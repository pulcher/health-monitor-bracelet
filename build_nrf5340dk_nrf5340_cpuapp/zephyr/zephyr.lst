
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_start>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_gc_clear_roots(void)
{
   0:	2002d1b0 	.word	0x2002d1b0
#define LV_CLEAR_ROOT(root_type, root_name) _lv_memset_00(&LV_GC_ROOT(root_name), sizeof(LV_GC_ROOT(root_name)));
    LV_ITERATE_ROOTS(LV_CLEAR_ROOT)
   4:	000029b1 	.word	0x000029b1
   8:	00012f5b 	.word	0x00012f5b
   c:	000029e1 	.word	0x000029e1
  10:	000029e1 	.word	0x000029e1
  14:	000029e1 	.word	0x000029e1
  18:	000029e1 	.word	0x000029e1
  1c:	000029e1 	.word	0x000029e1
	...
  2c:	0000290d 	.word	0x0000290d
  30:	000029e1 	.word	0x000029e1
  34:	00000000 	.word	0x00000000
  38:	000028b5 	.word	0x000028b5
  3c:	00012747 	.word	0x00012747

00000040 <_irq_vector_table>:
  40:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  50:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  60:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  70:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  80:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  90:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  a0:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  b0:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  c0:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  d0:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  e0:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
  f0:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
 100:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
 110:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
 120:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
 130:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
 140:	00002971 00002971 00002971 00002971     q)..q)..q)..q)..
 150:	00002971                                q)..

Disassembly of section text:

00000154 <__aeabi_uldivmod>:
     154:	b953      	cbnz	r3, 16c <__aeabi_uldivmod+0x18>
     156:	b94a      	cbnz	r2, 16c <__aeabi_uldivmod+0x18>
     158:	2900      	cmp	r1, #0
     15a:	bf08      	it	eq
     15c:	2800      	cmpeq	r0, #0
     15e:	bf1c      	itt	ne
     160:	f04f 31ff 	movne.w	r1, #4294967295
     164:	f04f 30ff 	movne.w	r0, #4294967295
     168:	f000 b970 	b.w	44c <__aeabi_idiv0>
     16c:	f1ad 0c08 	sub.w	ip, sp, #8
     170:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     174:	f000 f806 	bl	184 <__udivmoddi4>
     178:	f8dd e004 	ldr.w	lr, [sp, #4]
     17c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     180:	b004      	add	sp, #16
     182:	4770      	bx	lr

00000184 <__udivmoddi4>:
     184:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     188:	9e08      	ldr	r6, [sp, #32]
     18a:	460d      	mov	r5, r1
     18c:	4604      	mov	r4, r0
     18e:	468a      	mov	sl, r1
     190:	2b00      	cmp	r3, #0
     192:	d17f      	bne.n	294 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x14>
     194:	428a      	cmp	r2, r1
     196:	4617      	mov	r7, r2
     198:	d941      	bls.n	21e <CONFIG_SRAM_SIZE+0x5e>
     19a:	fab2 f282 	clz	r2, r2
     19e:	b14a      	cbz	r2, 1b4 <CONFIG_LVGL_INDEV_DEF_LONG_PRESS_TIME+0x24>
     1a0:	f1c2 0120 	rsb	r1, r2, #32
     1a4:	fa05 f302 	lsl.w	r3, r5, r2
     1a8:	4097      	lsls	r7, r2
     1aa:	4094      	lsls	r4, r2
     1ac:	fa20 f101 	lsr.w	r1, r0, r1
     1b0:	ea41 0a03 	orr.w	sl, r1, r3
     1b4:	ea4f 4817 	mov.w	r8, r7, lsr #16
     1b8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
     1bc:	fa1f f987 	uxth.w	r9, r7
     1c0:	fbba fef8 	udiv	lr, sl, r8
     1c4:	fb08 a31e 	mls	r3, r8, lr, sl
     1c8:	fb0e f109 	mul.w	r1, lr, r9
     1cc:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
     1d0:	4299      	cmp	r1, r3
     1d2:	d906      	bls.n	1e2 <CONFIG_SRAM_SIZE+0x22>
     1d4:	18fb      	adds	r3, r7, r3
     1d6:	d202      	bcs.n	1de <CONFIG_SRAM_SIZE+0x1e>
     1d8:	4299      	cmp	r1, r3
     1da:	f200 8124 	bhi.w	426 <CONFIG_BT_HCI_TX_STACK_SIZE+0x26>
     1de:	f10e 3eff 	add.w	lr, lr, #4294967295
     1e2:	1a59      	subs	r1, r3, r1
     1e4:	b2a3      	uxth	r3, r4
     1e6:	fbb1 f0f8 	udiv	r0, r1, r8
     1ea:	fb08 1110 	mls	r1, r8, r0, r1
     1ee:	fb00 f909 	mul.w	r9, r0, r9
     1f2:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
     1f6:	45a1      	cmp	r9, r4
     1f8:	d905      	bls.n	206 <CONFIG_SRAM_SIZE+0x46>
     1fa:	193c      	adds	r4, r7, r4
     1fc:	d202      	bcs.n	204 <CONFIG_SRAM_SIZE+0x44>
     1fe:	45a1      	cmp	r9, r4
     200:	f200 810e 	bhi.w	420 <CONFIG_BT_HCI_TX_STACK_SIZE+0x20>
     204:	3801      	subs	r0, #1
     206:	eba4 0409 	sub.w	r4, r4, r9
     20a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     20e:	2100      	movs	r1, #0
     210:	b11e      	cbz	r6, 21a <CONFIG_SRAM_SIZE+0x5a>
     212:	40d4      	lsrs	r4, r2
     214:	2300      	movs	r3, #0
     216:	e9c6 4300 	strd	r4, r3, [r6]
     21a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     21e:	b902      	cbnz	r2, 222 <CONFIG_SRAM_SIZE+0x62>
     220:	deff      	udf	#255	; 0xff
     222:	fab2 f282 	clz	r2, r2
     226:	2a00      	cmp	r2, #0
     228:	d14f      	bne.n	2ca <CONFIG_PM_PARTITION_SIZE_PROVISION+0x4a>
     22a:	1bcb      	subs	r3, r1, r7
     22c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     230:	fa1f f887 	uxth.w	r8, r7
     234:	2101      	movs	r1, #1
     236:	0c25      	lsrs	r5, r4, #16
     238:	fbb3 fcfe 	udiv	ip, r3, lr
     23c:	fb0e 301c 	mls	r0, lr, ip, r3
     240:	462b      	mov	r3, r5
     242:	fb08 f90c 	mul.w	r9, r8, ip
     246:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
     24a:	45a9      	cmp	r9, r5
     24c:	d90a      	bls.n	264 <CONFIG_SRAM_SIZE+0xa4>
     24e:	197d      	adds	r5, r7, r5
     250:	bf2c      	ite	cs
     252:	2301      	movcs	r3, #1
     254:	2300      	movcc	r3, #0
     256:	45a9      	cmp	r9, r5
     258:	d902      	bls.n	260 <CONFIG_SRAM_SIZE+0xa0>
     25a:	2b00      	cmp	r3, #0
     25c:	f000 80d9 	beq.w	412 <CONFIG_BT_HCI_TX_STACK_SIZE+0x12>
     260:	f10c 3cff 	add.w	ip, ip, #4294967295
     264:	eba5 0509 	sub.w	r5, r5, r9
     268:	b2a3      	uxth	r3, r4
     26a:	fbb5 f0fe 	udiv	r0, r5, lr
     26e:	fb0e 5510 	mls	r5, lr, r0, r5
     272:	fb08 f800 	mul.w	r8, r8, r0
     276:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
     27a:	45a0      	cmp	r8, r4
     27c:	d905      	bls.n	28a <CONFIG_PM_PARTITION_SIZE_PROVISION+0xa>
     27e:	193c      	adds	r4, r7, r4
     280:	d202      	bcs.n	288 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x8>
     282:	45a0      	cmp	r8, r4
     284:	f200 80c9 	bhi.w	41a <CONFIG_BT_HCI_TX_STACK_SIZE+0x1a>
     288:	3801      	subs	r0, #1
     28a:	eba4 0408 	sub.w	r4, r4, r8
     28e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     292:	e7bd      	b.n	210 <CONFIG_SRAM_SIZE+0x50>
     294:	428b      	cmp	r3, r1
     296:	d908      	bls.n	2aa <CONFIG_PM_PARTITION_SIZE_PROVISION+0x2a>
     298:	2e00      	cmp	r6, #0
     29a:	f000 80b1 	beq.w	400 <CONFIG_BT_HCI_TX_STACK_SIZE>
     29e:	2100      	movs	r1, #0
     2a0:	e9c6 0500 	strd	r0, r5, [r6]
     2a4:	4608      	mov	r0, r1
     2a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     2aa:	fab3 f183 	clz	r1, r3
     2ae:	2900      	cmp	r1, #0
     2b0:	d146      	bne.n	340 <CONFIG_PM_PARTITION_SIZE_PROVISION+0xc0>
     2b2:	42ab      	cmp	r3, r5
     2b4:	f0c0 80a7 	bcc.w	406 <CONFIG_BT_HCI_TX_STACK_SIZE+0x6>
     2b8:	4282      	cmp	r2, r0
     2ba:	f240 80a4 	bls.w	406 <CONFIG_BT_HCI_TX_STACK_SIZE+0x6>
     2be:	4608      	mov	r0, r1
     2c0:	2e00      	cmp	r6, #0
     2c2:	d0aa      	beq.n	21a <CONFIG_SRAM_SIZE+0x5a>
     2c4:	e9c6 4a00 	strd	r4, sl, [r6]
     2c8:	e7a7      	b.n	21a <CONFIG_SRAM_SIZE+0x5a>
     2ca:	f1c2 0020 	rsb	r0, r2, #32
     2ce:	4097      	lsls	r7, r2
     2d0:	fa01 f302 	lsl.w	r3, r1, r2
     2d4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     2d8:	40c1      	lsrs	r1, r0
     2da:	fa24 f500 	lsr.w	r5, r4, r0
     2de:	fa1f f887 	uxth.w	r8, r7
     2e2:	4094      	lsls	r4, r2
     2e4:	431d      	orrs	r5, r3
     2e6:	fbb1 f0fe 	udiv	r0, r1, lr
     2ea:	0c2b      	lsrs	r3, r5, #16
     2ec:	fb0e 1110 	mls	r1, lr, r0, r1
     2f0:	fb00 fc08 	mul.w	ip, r0, r8
     2f4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
     2f8:	459c      	cmp	ip, r3
     2fa:	d909      	bls.n	310 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x90>
     2fc:	18fb      	adds	r3, r7, r3
     2fe:	bf2c      	ite	cs
     300:	2101      	movcs	r1, #1
     302:	2100      	movcc	r1, #0
     304:	459c      	cmp	ip, r3
     306:	d902      	bls.n	30e <CONFIG_PM_PARTITION_SIZE_PROVISION+0x8e>
     308:	2900      	cmp	r1, #0
     30a:	f000 8095 	beq.w	438 <CONFIG_BT_HCI_TX_STACK_SIZE+0x38>
     30e:	3801      	subs	r0, #1
     310:	eba3 030c 	sub.w	r3, r3, ip
     314:	b2ad      	uxth	r5, r5
     316:	fbb3 f1fe 	udiv	r1, r3, lr
     31a:	fb0e 3311 	mls	r3, lr, r1, r3
     31e:	fb01 fc08 	mul.w	ip, r1, r8
     322:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
     326:	45ac      	cmp	ip, r5
     328:	d905      	bls.n	336 <CONFIG_PM_PARTITION_SIZE_PROVISION+0xb6>
     32a:	197d      	adds	r5, r7, r5
     32c:	d202      	bcs.n	334 <CONFIG_PM_PARTITION_SIZE_PROVISION+0xb4>
     32e:	45ac      	cmp	ip, r5
     330:	f200 8089 	bhi.w	446 <CONFIG_BT_HCI_TX_STACK_SIZE+0x46>
     334:	3901      	subs	r1, #1
     336:	eba5 030c 	sub.w	r3, r5, ip
     33a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
     33e:	e77a      	b.n	236 <CONFIG_SRAM_SIZE+0x76>
     340:	f1c1 0420 	rsb	r4, r1, #32
     344:	408b      	lsls	r3, r1
     346:	fa02 f701 	lsl.w	r7, r2, r1
     34a:	fa05 fc01 	lsl.w	ip, r5, r1
     34e:	40e2      	lsrs	r2, r4
     350:	fa20 f804 	lsr.w	r8, r0, r4
     354:	40e5      	lsrs	r5, r4
     356:	fa00 fe01 	lsl.w	lr, r0, r1
     35a:	4313      	orrs	r3, r2
     35c:	ea48 020c 	orr.w	r2, r8, ip
     360:	ea4f 4813 	mov.w	r8, r3, lsr #16
     364:	ea4f 4c12 	mov.w	ip, r2, lsr #16
     368:	fa1f f983 	uxth.w	r9, r3
     36c:	fbb5 faf8 	udiv	sl, r5, r8
     370:	fb08 551a 	mls	r5, r8, sl, r5
     374:	fb0a f009 	mul.w	r0, sl, r9
     378:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
     37c:	4560      	cmp	r0, ip
     37e:	d90a      	bls.n	396 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x116>
     380:	eb13 0c0c 	adds.w	ip, r3, ip
     384:	bf2c      	ite	cs
     386:	2501      	movcs	r5, #1
     388:	2500      	movcc	r5, #0
     38a:	4560      	cmp	r0, ip
     38c:	d901      	bls.n	392 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x112>
     38e:	2d00      	cmp	r5, #0
     390:	d055      	beq.n	43e <CONFIG_BT_HCI_TX_STACK_SIZE+0x3e>
     392:	f10a 3aff 	add.w	sl, sl, #4294967295
     396:	ebac 0c00 	sub.w	ip, ip, r0
     39a:	b292      	uxth	r2, r2
     39c:	fbbc f0f8 	udiv	r0, ip, r8
     3a0:	fb08 cc10 	mls	ip, r8, r0, ip
     3a4:	fb00 f909 	mul.w	r9, r0, r9
     3a8:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
     3ac:	45e1      	cmp	r9, ip
     3ae:	d905      	bls.n	3bc <CONFIG_PM_PARTITION_SIZE_PROVISION+0x13c>
     3b0:	eb13 0c0c 	adds.w	ip, r3, ip
     3b4:	d201      	bcs.n	3ba <CONFIG_PM_PARTITION_SIZE_PROVISION+0x13a>
     3b6:	45e1      	cmp	r9, ip
     3b8:	d83b      	bhi.n	432 <CONFIG_BT_HCI_TX_STACK_SIZE+0x32>
     3ba:	3801      	subs	r0, #1
     3bc:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
     3c0:	ebac 0c09 	sub.w	ip, ip, r9
     3c4:	fba0 8907 	umull	r8, r9, r0, r7
     3c8:	45cc      	cmp	ip, r9
     3ca:	4645      	mov	r5, r8
     3cc:	464a      	mov	r2, r9
     3ce:	d302      	bcc.n	3d6 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x156>
     3d0:	d106      	bne.n	3e0 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x160>
     3d2:	45c6      	cmp	lr, r8
     3d4:	d204      	bcs.n	3e0 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x160>
     3d6:	3801      	subs	r0, #1
     3d8:	ebb8 0507 	subs.w	r5, r8, r7
     3dc:	eb69 0203 	sbc.w	r2, r9, r3
     3e0:	b32e      	cbz	r6, 42e <CONFIG_BT_HCI_TX_STACK_SIZE+0x2e>
     3e2:	ebbe 0305 	subs.w	r3, lr, r5
     3e6:	eb6c 0c02 	sbc.w	ip, ip, r2
     3ea:	fa23 f201 	lsr.w	r2, r3, r1
     3ee:	fa0c f404 	lsl.w	r4, ip, r4
     3f2:	fa2c f301 	lsr.w	r3, ip, r1
     3f6:	2100      	movs	r1, #0
     3f8:	4314      	orrs	r4, r2
     3fa:	e9c6 4300 	strd	r4, r3, [r6]
     3fe:	e70c      	b.n	21a <CONFIG_SRAM_SIZE+0x5a>
     400:	4631      	mov	r1, r6
     402:	4630      	mov	r0, r6
     404:	e709      	b.n	21a <CONFIG_SRAM_SIZE+0x5a>
     406:	1a84      	subs	r4, r0, r2
     408:	eb65 0303 	sbc.w	r3, r5, r3
     40c:	2001      	movs	r0, #1
     40e:	469a      	mov	sl, r3
     410:	e756      	b.n	2c0 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x40>
     412:	f1ac 0c02 	sub.w	ip, ip, #2
     416:	443d      	add	r5, r7
     418:	e724      	b.n	264 <CONFIG_SRAM_SIZE+0xa4>
     41a:	3802      	subs	r0, #2
     41c:	443c      	add	r4, r7
     41e:	e734      	b.n	28a <CONFIG_PM_PARTITION_SIZE_PROVISION+0xa>
     420:	3802      	subs	r0, #2
     422:	443c      	add	r4, r7
     424:	e6ef      	b.n	206 <CONFIG_SRAM_SIZE+0x46>
     426:	f1ae 0e02 	sub.w	lr, lr, #2
     42a:	443b      	add	r3, r7
     42c:	e6d9      	b.n	1e2 <CONFIG_SRAM_SIZE+0x22>
     42e:	4631      	mov	r1, r6
     430:	e6f3      	b.n	21a <CONFIG_SRAM_SIZE+0x5a>
     432:	3802      	subs	r0, #2
     434:	449c      	add	ip, r3
     436:	e7c1      	b.n	3bc <CONFIG_PM_PARTITION_SIZE_PROVISION+0x13c>
     438:	3802      	subs	r0, #2
     43a:	443b      	add	r3, r7
     43c:	e768      	b.n	310 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x90>
     43e:	f1aa 0a02 	sub.w	sl, sl, #2
     442:	449c      	add	ip, r3
     444:	e7a7      	b.n	396 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x116>
     446:	3902      	subs	r1, #2
     448:	443d      	add	r5, r7
     44a:	e774      	b.n	336 <CONFIG_PM_PARTITION_SIZE_PROVISION+0xb6>

0000044c <__aeabi_idiv0>:
     44c:	4770      	bx	lr
     44e:	bf00      	nop

00000450 <strcmp>:
     450:	f810 2b01 	ldrb.w	r2, [r0], #1
     454:	f811 3b01 	ldrb.w	r3, [r1], #1
     458:	2a01      	cmp	r2, #1
     45a:	bf28      	it	cs
     45c:	429a      	cmpcs	r2, r3
     45e:	d0f7      	beq.n	450 <strcmp>
     460:	1ad0      	subs	r0, r2, r3
     462:	4770      	bx	lr

00000464 <strlen>:
     464:	4603      	mov	r3, r0
     466:	f813 2b01 	ldrb.w	r2, [r3], #1
     46a:	2a00      	cmp	r2, #0
     46c:	d1fb      	bne.n	466 <strlen+0x2>
     46e:	1a18      	subs	r0, r3, r0
     470:	3801      	subs	r0, #1
     472:	4770      	bx	lr

00000474 <trigger_event>:
	BT_DATA_BYTES(BT_DATA_UUID128_ALL, BT_UUID_LBS_VAL),
};

static void trigger_event(app_ble_event_type_t event_type)
{
	if(m_event_callback)
     474:	4a03      	ldr	r2, [pc, #12]	; (484 <trigger_event+0x10>)
{
     476:	4603      	mov	r3, r0
	if(m_event_callback)
     478:	6812      	ldr	r2, [r2, #0]
     47a:	b112      	cbz	r2, 482 <trigger_event+0xe>
	{
		m_event_data.type = event_type;
     47c:	4802      	ldr	r0, [pc, #8]	; (488 <trigger_event+0x14>)
     47e:	7003      	strb	r3, [r0, #0]
		m_event_callback(&m_event_data);
     480:	4710      	bx	r2
	}
}
     482:	4770      	bx	lr
     484:	20001210 	.word	0x20001210
     488:	20029f35 	.word	0x20029f35

0000048c <disconnected>:
	trigger_event(APP_BLE_CONNECTED);
}

static void disconnected(struct bt_conn *conn, uint8_t reason)
{
	app_bt_connected = false;
     48c:	2200      	movs	r2, #0
     48e:	4b02      	ldr	r3, [pc, #8]	; (498 <disconnected+0xc>)
	trigger_event(APP_BLE_DISCONNECTED);
     490:	2001      	movs	r0, #1
	app_bt_connected = false;
     492:	701a      	strb	r2, [r3, #0]
	trigger_event(APP_BLE_DISCONNECTED);
     494:	f7ff bfee 	b.w	474 <trigger_event>
     498:	20029f34 	.word	0x20029f34

0000049c <app_led_cb>:
static struct bt_conn_auth_cb conn_auth_callbacks;
#endif

static void app_led_cb(bool led_state)
{
	m_event_data.led_state = led_state;
     49c:	4b02      	ldr	r3, [pc, #8]	; (4a8 <app_led_cb+0xc>)
     49e:	7058      	strb	r0, [r3, #1]
	trigger_event(APP_BLE_ON_LED_WRITE);
     4a0:	2002      	movs	r0, #2
     4a2:	f7ff bfe7 	b.w	474 <trigger_event>
     4a6:	bf00      	nop
     4a8:	20029f35 	.word	0x20029f35

000004ac <connected>:
	if (err) {
     4ac:	4608      	mov	r0, r1
     4ae:	b111      	cbz	r1, 4b6 <connected+0xa>
		printk("Connection failed (err %u)\n", err);
     4b0:	4803      	ldr	r0, [pc, #12]	; (4c0 <connected+0x14>)
     4b2:	f011 ba45 	b.w	11940 <printk>
	app_bt_connected = true;
     4b6:	2201      	movs	r2, #1
     4b8:	4b02      	ldr	r3, [pc, #8]	; (4c4 <connected+0x18>)
     4ba:	701a      	strb	r2, [r3, #0]
	trigger_event(APP_BLE_CONNECTED);
     4bc:	f7ff bfda 	b.w	474 <trigger_event>
     4c0:	0001f524 	.word	0x0001f524
     4c4:	20029f34 	.word	0x20029f34

000004c8 <app_ble_start_advertising>:
	.led_cb    = app_led_cb,
	.button_cb = app_button_cb,
};

void app_ble_start_advertising(void)
{
     4c8:	b530      	push	{r4, r5, lr}
	int err = bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad),
     4ca:	4d0b      	ldr	r5, [pc, #44]	; (4f8 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x10>)
{
     4cc:	b089      	sub	sp, #36	; 0x24
	int err = bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad),
     4ce:	ac03      	add	r4, sp, #12
     4d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     4d2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
     4d4:	682b      	ldr	r3, [r5, #0]
     4d6:	4909      	ldr	r1, [pc, #36]	; (4fc <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x14>)
     4d8:	6023      	str	r3, [r4, #0]
     4da:	2301      	movs	r3, #1
     4dc:	2202      	movs	r2, #2
     4de:	9300      	str	r3, [sp, #0]
     4e0:	a803      	add	r0, sp, #12
     4e2:	4b07      	ldr	r3, [pc, #28]	; (500 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x18>)
     4e4:	f004 f990 	bl	4808 <bt_le_adv_start>
			      sd, ARRAY_SIZE(sd));
	if (err) {
     4e8:	4601      	mov	r1, r0
     4ea:	b110      	cbz	r0, 4f2 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xa>
		printk("Advertising failed to start (err %d)\n", err);
     4ec:	4805      	ldr	r0, [pc, #20]	; (504 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x1c>)
     4ee:	f011 fa27 	bl	11940 <printk>
		return;
	}
}
     4f2:	b009      	add	sp, #36	; 0x24
     4f4:	bd30      	pop	{r4, r5, pc}
     4f6:	bf00      	nop
     4f8:	0001dd30 	.word	0x0001dd30
     4fc:	0001dda8 	.word	0x0001dda8
     500:	0001ddb8 	.word	0x0001ddb8
     504:	0001f540 	.word	0x0001f540

00000508 <app_ble_send_button_state>:

void app_ble_send_button_state(bool btn_pressed)
{
	if(app_bt_connected) {
     508:	4b02      	ldr	r3, [pc, #8]	; (514 <app_ble_send_button_state+0xc>)
     50a:	781b      	ldrb	r3, [r3, #0]
     50c:	b10b      	cbz	r3, 512 <app_ble_send_button_state+0xa>
		bt_lbs_send_button_state(btn_pressed);
     50e:	f001 be5b 	b.w	21c8 <bt_lbs_send_button_state>
	}
}
     512:	4770      	bx	lr
     514:	20029f34 	.word	0x20029f34

00000518 <app_ble_init>:

void app_ble_init(app_ble_config_t * config)
{
     518:	b508      	push	{r3, lr}
	int err;

	m_event_callback = config->event_callback;
     51a:	6802      	ldr	r2, [r0, #0]
     51c:	4b0c      	ldr	r3, [pc, #48]	; (550 <app_ble_init+0x38>)

	bt_conn_cb_register(&conn_callbacks);
     51e:	480d      	ldr	r0, [pc, #52]	; (554 <app_ble_init+0x3c>)
	m_event_callback = config->event_callback;
     520:	601a      	str	r2, [r3, #0]
	bt_conn_cb_register(&conn_callbacks);
     522:	f004 fbc3 	bl	4cac <bt_conn_cb_register>
	if (IS_ENABLED(CONFIG_BT_LBS_SECURITY_ENABLED)) {
		bt_conn_auth_cb_register(&conn_auth_callbacks);
	}

	err = bt_enable(NULL);
     526:	2000      	movs	r0, #0
     528:	f003 ffd2 	bl	44d0 <bt_enable>
	if (err) {
     52c:	4601      	mov	r1, r0
     52e:	b120      	cbz	r0, 53a <app_ble_init+0x22>
		printk("Bluetooth init failed (err %d)\n", err);
     530:	4809      	ldr	r0, [pc, #36]	; (558 <app_ble_init+0x40>)
	err = bt_lbs_init(&lbs_callbacs);
	if (err) {
		printk("Failed to init LBS (err:%d)\n", err);
		return;
	}
}
     532:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		printk("Failed to init LBS (err:%d)\n", err);
     536:	f011 ba03 	b.w	11940 <printk>
	printk("Bluetooth initialized\n");
     53a:	4808      	ldr	r0, [pc, #32]	; (55c <app_ble_init+0x44>)
     53c:	f011 fa00 	bl	11940 <printk>
	err = bt_lbs_init(&lbs_callbacs);
     540:	4807      	ldr	r0, [pc, #28]	; (560 <app_ble_init+0x48>)
     542:	f001 fe37 	bl	21b4 <bt_lbs_init>
	if (err) {
     546:	4601      	mov	r1, r0
     548:	b108      	cbz	r0, 54e <app_ble_init+0x36>
		printk("Failed to init LBS (err:%d)\n", err);
     54a:	4806      	ldr	r0, [pc, #24]	; (564 <app_ble_init+0x4c>)
     54c:	e7f1      	b.n	532 <app_ble_init+0x1a>
}
     54e:	bd08      	pop	{r3, pc}
     550:	20001210 	.word	0x20001210
     554:	20000130 	.word	0x20000130
     558:	0001f566 	.word	0x0001f566
     55c:	0001f586 	.word	0x0001f586
     560:	20000144 	.word	0x20000144
     564:	0001f59d 	.word	0x0001f59d

00000568 <on_gui_blink_timer>:
}

static void on_gui_blink_timer(struct k_timer *dummy)
{
	static bool blink_state;
	blink_state = !blink_state;
     568:	4a06      	ldr	r2, [pc, #24]	; (584 <on_gui_blink_timer+0x1c>)
	lv_label_set_text(label_bt_state, blink_state ? "Advertising" : "");
     56a:	4907      	ldr	r1, [pc, #28]	; (588 <on_gui_blink_timer+0x20>)
	blink_state = !blink_state;
     56c:	7813      	ldrb	r3, [r2, #0]
     56e:	f083 0301 	eor.w	r3, r3, #1
     572:	7013      	strb	r3, [r2, #0]
	lv_label_set_text(label_bt_state, blink_state ? "Advertising" : "");
     574:	4a05      	ldr	r2, [pc, #20]	; (58c <on_gui_blink_timer+0x24>)
     576:	2b00      	cmp	r3, #0
     578:	bf08      	it	eq
     57a:	4611      	moveq	r1, r2
     57c:	4b04      	ldr	r3, [pc, #16]	; (590 <on_gui_blink_timer+0x28>)
     57e:	6818      	ldr	r0, [r3, #0]
     580:	f01c b93a 	b.w	1c7f8 <lv_label_set_text>
     584:	20029f37 	.word	0x20029f37
     588:	00026ca9 	.word	0x00026ca9
     58c:	0001f585 	.word	0x0001f585
     590:	20001258 	.word	0x20001258

00000594 <gui_show_connected_elements>:
	lv_obj_set_hidden(connected_background, !connected);
     594:	4b0e      	ldr	r3, [pc, #56]	; (5d0 <gui_show_connected_elements+0x3c>)
{
     596:	b510      	push	{r4, lr}
	lv_obj_set_hidden(connected_background, !connected);
     598:	f080 0401 	eor.w	r4, r0, #1
     59c:	4621      	mov	r1, r4
     59e:	6818      	ldr	r0, [r3, #0]
     5a0:	f015 f9df 	bl	15962 <lv_obj_set_hidden>
	lv_obj_set_hidden(btn1, !connected);
     5a4:	4b0b      	ldr	r3, [pc, #44]	; (5d4 <gui_show_connected_elements+0x40>)
     5a6:	4621      	mov	r1, r4
     5a8:	6818      	ldr	r0, [r3, #0]
     5aa:	f015 f9da 	bl	15962 <lv_obj_set_hidden>
	lv_obj_set_hidden(label_btn_state, !connected);
     5ae:	4b0a      	ldr	r3, [pc, #40]	; (5d8 <gui_show_connected_elements+0x44>)
     5b0:	4621      	mov	r1, r4
     5b2:	6818      	ldr	r0, [r3, #0]
     5b4:	f015 f9d5 	bl	15962 <lv_obj_set_hidden>
	lv_obj_set_hidden(image_led, !connected);
     5b8:	4b08      	ldr	r3, [pc, #32]	; (5dc <gui_show_connected_elements+0x48>)
     5ba:	4621      	mov	r1, r4
     5bc:	6818      	ldr	r0, [r3, #0]
     5be:	f015 f9d0 	bl	15962 <lv_obj_set_hidden>
	lv_obj_set_hidden(label_led_state, !connected);
     5c2:	4b07      	ldr	r3, [pc, #28]	; (5e0 <gui_show_connected_elements+0x4c>)
     5c4:	4621      	mov	r1, r4
}
     5c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lv_obj_set_hidden(label_led_state, !connected);
     5ca:	6818      	ldr	r0, [r3, #0]
     5cc:	f015 b9c9 	b.w	15962 <lv_obj_set_hidden>
     5d0:	2000121c 	.word	0x2000121c
     5d4:	20001214 	.word	0x20001214
     5d8:	2000125c 	.word	0x2000125c
     5dc:	20001254 	.word	0x20001254
     5e0:	20001260 	.word	0x20001260

000005e4 <on_button1>:
	if(btn == btn1){
     5e4:	4b12      	ldr	r3, [pc, #72]	; (630 <CONFIG_BT_COMPANY_ID+0x3f>)
{
     5e6:	b510      	push	{r4, lr}
	if(btn == btn1){
     5e8:	681b      	ldr	r3, [r3, #0]
{
     5ea:	460c      	mov	r4, r1
	if(btn == btn1){
     5ec:	4283      	cmp	r3, r0
     5ee:	d11d      	bne.n	62c <CONFIG_BT_COMPANY_ID+0x3b>
		if(event == LV_EVENT_PRESSED) {
     5f0:	b971      	cbnz	r1, 610 <CONFIG_BT_COMPANY_ID+0x1f>
			lv_label_set_text(label_btn_state, "Pressed");
     5f2:	4b10      	ldr	r3, [pc, #64]	; (634 <CONFIG_BT_COMPANY_ID+0x43>)
     5f4:	4910      	ldr	r1, [pc, #64]	; (638 <CONFIG_BT_COMPANY_ID+0x47>)
     5f6:	6818      	ldr	r0, [r3, #0]
     5f8:	f01c f8fe 	bl	1c7f8 <lv_label_set_text>
			if(m_gui_callback) { 
     5fc:	4b0f      	ldr	r3, [pc, #60]	; (63c <CONFIG_BT_COMPANY_ID+0x4b>)
     5fe:	681b      	ldr	r3, [r3, #0]
     600:	b1a3      	cbz	r3, 62c <CONFIG_BT_COMPANY_ID+0x3b>
				m_gui_event.button_checked = true;
     602:	2201      	movs	r2, #1
				m_gui_event.evt_type = GUI_EVT_BUTTON_PRESSED;
     604:	480e      	ldr	r0, [pc, #56]	; (640 <CONFIG_BT_COMPANY_ID+0x4f>)
     606:	7004      	strb	r4, [r0, #0]
				m_gui_event.button_checked = false;
     608:	7042      	strb	r2, [r0, #1]
}
     60a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				m_gui_callback(&m_gui_event);
     60e:	4718      	bx	r3
		else if(event == LV_EVENT_RELEASED) {
     610:	2907      	cmp	r1, #7
     612:	d10b      	bne.n	62c <CONFIG_BT_COMPANY_ID+0x3b>
			lv_label_set_text(label_btn_state, "Released");
     614:	4b07      	ldr	r3, [pc, #28]	; (634 <CONFIG_BT_COMPANY_ID+0x43>)
     616:	490b      	ldr	r1, [pc, #44]	; (644 <CONFIG_BT_COMPANY_ID+0x53>)
     618:	6818      	ldr	r0, [r3, #0]
     61a:	f01c f8ed 	bl	1c7f8 <lv_label_set_text>
			if(m_gui_callback) { 
     61e:	4b07      	ldr	r3, [pc, #28]	; (63c <CONFIG_BT_COMPANY_ID+0x4b>)
     620:	681b      	ldr	r3, [r3, #0]
     622:	b11b      	cbz	r3, 62c <CONFIG_BT_COMPANY_ID+0x3b>
				m_gui_event.evt_type = GUI_EVT_BUTTON_PRESSED;
     624:	2200      	movs	r2, #0
     626:	4806      	ldr	r0, [pc, #24]	; (640 <CONFIG_BT_COMPANY_ID+0x4f>)
     628:	7002      	strb	r2, [r0, #0]
     62a:	e7ed      	b.n	608 <CONFIG_BT_COMPANY_ID+0x17>
}
     62c:	bd10      	pop	{r4, pc}
     62e:	bf00      	nop
     630:	20001214 	.word	0x20001214
     634:	2000125c 	.word	0x2000125c
     638:	00026cb5 	.word	0x00026cb5
     63c:	20001264 	.word	0x20001264
     640:	20029f38 	.word	0x20029f38
     644:	00026cbd 	.word	0x00026cbd

00000648 <gui_run>:
		}
	}
}

void gui_run(void)
{
     648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     64c:	b089      	sub	sp, #36	; 0x24
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
     64e:	48b7      	ldr	r0, [pc, #732]	; (92c <CONFIG_ISR_STACK_SIZE+0x12c>)
     650:	f00f fccc 	bl	ffec <z_impl_device_get_binding>
	display_dev = device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
     654:	4eb6      	ldr	r6, [pc, #728]	; (930 <CONFIG_ISR_STACK_SIZE+0x130>)
     656:	6030      	str	r0, [r6, #0]

	if (display_dev == NULL) {
     658:	2800      	cmp	r0, #0
     65a:	f000 8313 	beq.w	c84 <CONFIG_ISR_STACK_SIZE+0x484>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_BLEND_MODE, bg_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_MAIN_STOP, bg_main_stop, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_STOP, bg_grad_stop, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
     65e:	2129      	movs	r1, #41	; 0x29
     660:	4ab4      	ldr	r2, [pc, #720]	; (934 <CONFIG_ISR_STACK_SIZE+0x134>)
     662:	48b5      	ldr	r0, [pc, #724]	; (938 <CONFIG_ISR_STACK_SIZE+0x138>)
     664:	f016 fc9a 	bl	16f9c <_lv_style_set_color>
	lv_obj_add_style(lv_scr_act(), LV_BTN_PART_MAIN, &style_screen);
     668:	f011 f92e 	bl	118c8 <lv_scr_act>
     66c:	2100      	movs	r1, #0
     66e:	4ab2      	ldr	r2, [pc, #712]	; (938 <CONFIG_ISR_STACK_SIZE+0x138>)
     670:	f015 fc6b 	bl	15f4a <lv_obj_add_style>
	lv_style_init(&style_header);
     674:	48b1      	ldr	r0, [pc, #708]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     676:	f016 fb62 	bl	16d3e <lv_style_init>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
     67a:	22ff      	movs	r2, #255	; 0xff
     67c:	212c      	movs	r1, #44	; 0x2c
     67e:	48af      	ldr	r0, [pc, #700]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     680:	f016 fcd0 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
     684:	2129      	movs	r1, #41	; 0x29
     686:	4aae      	ldr	r2, [pc, #696]	; (940 <CONFIG_ISR_STACK_SIZE+0x140>)
     688:	48ac      	ldr	r0, [pc, #688]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     68a:	f016 fc87 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
     68e:	2208      	movs	r2, #8
     690:	2101      	movs	r1, #1
     692:	48aa      	ldr	r0, [pc, #680]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     694:	f016 fc3e 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
     698:	2246      	movs	r2, #70	; 0x46
     69a:	2112      	movs	r1, #18
     69c:	48a7      	ldr	r0, [pc, #668]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     69e:	f016 fc39 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
     6a2:	221e      	movs	r2, #30
     6a4:	2110      	movs	r1, #16
     6a6:	48a5      	ldr	r0, [pc, #660]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6a8:	f016 fc34 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_COLOR, outline_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_OPA, outline_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_SPREAD, shadow_spread, lv_style_int_t, _int, scalar)
     6ac:	2201      	movs	r2, #1
     6ae:	2153      	movs	r1, #83	; 0x53
     6b0:	48a2      	ldr	r0, [pc, #648]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6b2:	f016 fc2f 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_BLEND_MODE, shadow_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_COLOR, shadow_color, lv_color_t, _color, nonscalar)
     6b6:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
     6ba:	2159      	movs	r1, #89	; 0x59
     6bc:	489f      	ldr	r0, [pc, #636]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6be:	f016 fc6d 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OPA, shadow_opa, lv_opa_t, _opa, scalar)
     6c2:	22ff      	movs	r2, #255	; 0xff
     6c4:	215c      	movs	r1, #92	; 0x5c
     6c6:	489d      	ldr	r0, [pc, #628]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6c8:	f016 fcac 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
     6cc:	2201      	movs	r2, #1
     6ce:	2150      	movs	r1, #80	; 0x50
     6d0:	489a      	ldr	r0, [pc, #616]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6d2:	f016 fc1f 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
     6d6:	2201      	movs	r2, #1
     6d8:	2151      	movs	r1, #81	; 0x51
     6da:	4898      	ldr	r0, [pc, #608]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6dc:	f016 fc1a 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
     6e0:	2202      	movs	r2, #2
     6e2:	2152      	movs	r1, #82	; 0x52
     6e4:	4895      	ldr	r0, [pc, #596]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6e6:	f016 fc15 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OPA, shadow_opa, lv_opa_t, _opa, scalar)
     6ea:	227f      	movs	r2, #127	; 0x7f
     6ec:	215c      	movs	r1, #92	; 0x5c
     6ee:	4893      	ldr	r0, [pc, #588]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6f0:	f016 fc98 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_BLEND_MODE, text_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
     6f4:	f248 0189 	movw	r1, #32905	; 0x8089
     6f8:	4a92      	ldr	r2, [pc, #584]	; (944 <CONFIG_ISR_STACK_SIZE+0x144>)
     6fa:	4890      	ldr	r0, [pc, #576]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     6fc:	f016 fc4e 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
     700:	4a91      	ldr	r2, [pc, #580]	; (948 <CONFIG_ISR_STACK_SIZE+0x148>)
     702:	f248 018e 	movw	r1, #32910	; 0x808e
     706:	488d      	ldr	r0, [pc, #564]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     708:	f016 fcd2 	bl	170b0 <_lv_style_set_ptr>
	lv_style_init(&style_con_bg);
     70c:	488f      	ldr	r0, [pc, #572]	; (94c <CONFIG_ISR_STACK_SIZE+0x14c>)
     70e:	f016 fb16 	bl	16d3e <lv_style_init>
	lv_style_copy(&style_con_bg, &style_header);
     712:	498a      	ldr	r1, [pc, #552]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     714:	488d      	ldr	r0, [pc, #564]	; (94c <CONFIG_ISR_STACK_SIZE+0x14c>)
     716:	f016 fbc1 	bl	16e9c <lv_style_copy>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
     71a:	2129      	movs	r1, #41	; 0x29
     71c:	4a8c      	ldr	r2, [pc, #560]	; (950 <CONFIG_ISR_STACK_SIZE+0x150>)
     71e:	488b      	ldr	r0, [pc, #556]	; (94c <CONFIG_ISR_STACK_SIZE+0x14c>)
     720:	f016 fc3c 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
     724:	227f      	movs	r2, #127	; 0x7f
     726:	212c      	movs	r1, #44	; 0x2c
     728:	4888      	ldr	r0, [pc, #544]	; (94c <CONFIG_ISR_STACK_SIZE+0x14c>)
     72a:	f016 fc7b 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
     72e:	2204      	movs	r2, #4
     730:	2101      	movs	r1, #1
     732:	4882      	ldr	r0, [pc, #520]	; (93c <CONFIG_ISR_STACK_SIZE+0x13c>)
     734:	f016 fbee 	bl	16f14 <_lv_style_set_int>
	lv_style_init(&style_label);
     738:	4886      	ldr	r0, [pc, #536]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     73a:	f016 fb00 	bl	16d3e <lv_style_init>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
     73e:	22ff      	movs	r2, #255	; 0xff
     740:	212c      	movs	r1, #44	; 0x2c
     742:	4884      	ldr	r0, [pc, #528]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     744:	f016 fc6e 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
     748:	2129      	movs	r1, #41	; 0x29
     74a:	4a83      	ldr	r2, [pc, #524]	; (958 <CONFIG_ISR_STACK_SIZE+0x158>)
     74c:	4881      	ldr	r0, [pc, #516]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     74e:	f016 fc25 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
     752:	212a      	movs	r1, #42	; 0x2a
     754:	4a81      	ldr	r2, [pc, #516]	; (95c <CONFIG_ISR_STACK_SIZE+0x15c>)
     756:	487f      	ldr	r0, [pc, #508]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     758:	f016 fc20 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
     75c:	2201      	movs	r2, #1
     75e:	2123      	movs	r1, #35	; 0x23
     760:	487c      	ldr	r0, [pc, #496]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     762:	f016 fbd7 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
     766:	2205      	movs	r2, #5
     768:	2112      	movs	r1, #18
     76a:	487a      	ldr	r0, [pc, #488]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     76c:	f016 fbd2 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
     770:	220a      	movs	r2, #10
     772:	2110      	movs	r1, #16
     774:	4877      	ldr	r0, [pc, #476]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     776:	f016 fbcd 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
     77a:	f04f 32ff 	mov.w	r2, #4294967295
     77e:	2139      	movs	r1, #57	; 0x39
     780:	4874      	ldr	r0, [pc, #464]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     782:	f016 fc0b 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_OPA, border_opa, lv_opa_t, _opa, scalar)
     786:	22b2      	movs	r2, #178	; 0xb2
     788:	213c      	movs	r1, #60	; 0x3c
     78a:	4872      	ldr	r0, [pc, #456]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     78c:	f016 fc4a 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
     790:	2203      	movs	r2, #3
     792:	2130      	movs	r1, #48	; 0x30
     794:	486f      	ldr	r0, [pc, #444]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     796:	f016 fbbd 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
     79a:	f248 0189 	movw	r1, #32905	; 0x8089
     79e:	4a70      	ldr	r2, [pc, #448]	; (960 <CONFIG_ISR_STACK_SIZE+0x160>)
     7a0:	486c      	ldr	r0, [pc, #432]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     7a2:	f016 fbfb 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
     7a6:	f248 018e 	movw	r1, #32910	; 0x808e
     7aa:	4a6e      	ldr	r2, [pc, #440]	; (964 <CONFIG_ISR_STACK_SIZE+0x164>)
     7ac:	4869      	ldr	r0, [pc, #420]	; (954 <CONFIG_ISR_STACK_SIZE+0x154>)
     7ae:	f016 fc7f 	bl	170b0 <_lv_style_set_ptr>
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void _lv_memset_00(void * dst, size_t len)
{
    memset(dst, 0x00, len);
     7b2:	2400      	movs	r4, #0
	lv_style_init(&style_label_value);
     7b4:	486c      	ldr	r0, [pc, #432]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     7b6:	f016 fac2 	bl	16d3e <lv_style_init>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
     7ba:	2233      	movs	r2, #51	; 0x33
     7bc:	212c      	movs	r1, #44	; 0x2c
     7be:	486a      	ldr	r0, [pc, #424]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     7c0:	f016 fc30 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
     7c4:	2129      	movs	r1, #41	; 0x29
     7c6:	4a64      	ldr	r2, [pc, #400]	; (958 <CONFIG_ISR_STACK_SIZE+0x158>)
     7c8:	4867      	ldr	r0, [pc, #412]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     7ca:	f016 fbe7 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
     7ce:	212a      	movs	r1, #42	; 0x2a
     7d0:	4a66      	ldr	r2, [pc, #408]	; (96c <CONFIG_ISR_STACK_SIZE+0x16c>)
     7d2:	4865      	ldr	r0, [pc, #404]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     7d4:	f016 fbe2 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
     7d8:	2201      	movs	r2, #1
     7da:	2123      	movs	r1, #35	; 0x23
     7dc:	4862      	ldr	r0, [pc, #392]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     7de:	f016 fb99 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
     7e2:	2200      	movs	r2, #0
     7e4:	2112      	movs	r1, #18
     7e6:	4860      	ldr	r0, [pc, #384]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     7e8:	f016 fb94 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
     7ec:	2203      	movs	r2, #3
     7ee:	2110      	movs	r1, #16
     7f0:	485d      	ldr	r0, [pc, #372]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     7f2:	f016 fb8f 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
     7f6:	f248 0189 	movw	r1, #32905	; 0x8089
     7fa:	4a59      	ldr	r2, [pc, #356]	; (960 <CONFIG_ISR_STACK_SIZE+0x160>)
     7fc:	485a      	ldr	r0, [pc, #360]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     7fe:	f016 fbcd 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
     802:	f248 018e 	movw	r1, #32910	; 0x808e
     806:	4a5a      	ldr	r2, [pc, #360]	; (970 <CONFIG_ISR_STACK_SIZE+0x170>)
     808:	4857      	ldr	r0, [pc, #348]	; (968 <CONFIG_ISR_STACK_SIZE+0x168>)
     80a:	f016 fc51 	bl	170b0 <_lv_style_set_ptr>
	lv_style_init(&style_btn);
     80e:	4859      	ldr	r0, [pc, #356]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     810:	f016 fa95 	bl	16d3e <lv_style_init>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
     814:	220a      	movs	r2, #10
     816:	2101      	movs	r1, #1
     818:	4856      	ldr	r0, [pc, #344]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     81a:	f016 fb7b 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
     81e:	22ff      	movs	r2, #255	; 0xff
     820:	212c      	movs	r1, #44	; 0x2c
     822:	4854      	ldr	r0, [pc, #336]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     824:	f016 fbfe 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
     828:	2129      	movs	r1, #41	; 0x29
     82a:	4a4b      	ldr	r2, [pc, #300]	; (958 <CONFIG_ISR_STACK_SIZE+0x158>)
     82c:	4851      	ldr	r0, [pc, #324]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     82e:	f016 fbb5 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
     832:	212a      	movs	r1, #42	; 0x2a
     834:	4a49      	ldr	r2, [pc, #292]	; (95c <CONFIG_ISR_STACK_SIZE+0x15c>)
     836:	484f      	ldr	r0, [pc, #316]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     838:	f016 fbb0 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
     83c:	2201      	movs	r2, #1
     83e:	2123      	movs	r1, #35	; 0x23
     840:	484c      	ldr	r0, [pc, #304]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     842:	f016 fb67 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_SPREAD, shadow_spread, lv_style_int_t, _int, scalar)
     846:	2201      	movs	r2, #1
     848:	2153      	movs	r1, #83	; 0x53
     84a:	484a      	ldr	r0, [pc, #296]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     84c:	f016 fb62 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_COLOR, shadow_color, lv_color_t, _color, nonscalar)
     850:	2159      	movs	r1, #89	; 0x59
     852:	4a42      	ldr	r2, [pc, #264]	; (95c <CONFIG_ISR_STACK_SIZE+0x15c>)
     854:	4847      	ldr	r0, [pc, #284]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     856:	f016 fba1 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OPA, shadow_opa, lv_opa_t, _opa, scalar)
     85a:	22ff      	movs	r2, #255	; 0xff
     85c:	215c      	movs	r1, #92	; 0x5c
     85e:	4845      	ldr	r0, [pc, #276]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     860:	f016 fbe0 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
     864:	2201      	movs	r2, #1
     866:	2150      	movs	r1, #80	; 0x50
     868:	4842      	ldr	r0, [pc, #264]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     86a:	f016 fb53 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
     86e:	f241 0129 	movw	r1, #4137	; 0x1029
     872:	4a3a      	ldr	r2, [pc, #232]	; (95c <CONFIG_ISR_STACK_SIZE+0x15c>)
     874:	483f      	ldr	r0, [pc, #252]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     876:	f016 fb91 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
     87a:	f241 012a 	movw	r1, #4138	; 0x102a
     87e:	4a36      	ldr	r2, [pc, #216]	; (958 <CONFIG_ISR_STACK_SIZE+0x158>)
     880:	483c      	ldr	r0, [pc, #240]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     882:	f016 fb8b 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
     886:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
     88a:	2139      	movs	r1, #57	; 0x39
     88c:	4839      	ldr	r0, [pc, #228]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     88e:	f016 fb85 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_OPA, border_opa, lv_opa_t, _opa, scalar)
     892:	22b2      	movs	r2, #178	; 0xb2
     894:	213c      	movs	r1, #60	; 0x3c
     896:	4837      	ldr	r0, [pc, #220]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     898:	f016 fbc4 	bl	17024 <_lv_style_set_opa>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
     89c:	2203      	movs	r2, #3
     89e:	2130      	movs	r1, #48	; 0x30
     8a0:	4834      	ldr	r0, [pc, #208]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     8a2:	f016 fb37 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
     8a6:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
     8aa:	f240 2139 	movw	r1, #569	; 0x239
     8ae:	4831      	ldr	r0, [pc, #196]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     8b0:	f016 fb74 	bl	16f9c <_lv_style_set_color>
     8b4:	f241 2139 	movw	r1, #4665	; 0x1239
     8b8:	4a2f      	ldr	r2, [pc, #188]	; (978 <CONFIG_ISR_STACK_SIZE+0x178>)
     8ba:	482e      	ldr	r0, [pc, #184]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     8bc:	f016 fb6e 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
     8c0:	f248 0189 	movw	r1, #32905	; 0x8089
     8c4:	4a29      	ldr	r2, [pc, #164]	; (96c <CONFIG_ISR_STACK_SIZE+0x16c>)
     8c6:	482b      	ldr	r0, [pc, #172]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     8c8:	f016 fb68 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
     8cc:	f248 018e 	movw	r1, #32910	; 0x808e
     8d0:	4a2a      	ldr	r2, [pc, #168]	; (97c <CONFIG_ISR_STACK_SIZE+0x17c>)
     8d2:	4828      	ldr	r0, [pc, #160]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     8d4:	f016 fbec 	bl	170b0 <_lv_style_set_ptr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
     8d8:	f06f 0203 	mvn.w	r2, #3
     8dc:	f241 0105 	movw	r1, #4101	; 0x1005
     8e0:	4824      	ldr	r0, [pc, #144]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     8e2:	f016 fb17 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
     8e6:	f06f 0207 	mvn.w	r2, #7
     8ea:	f241 0104 	movw	r1, #4100	; 0x1004
     8ee:	4821      	ldr	r0, [pc, #132]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     8f0:	f016 fb10 	bl	16f14 <_lv_style_set_int>
     8f4:	4d22      	ldr	r5, [pc, #136]	; (980 <CONFIG_ISR_STACK_SIZE+0x180>)
 * @param path pointer to an initialized path
 * @param cb the callback
 */
static inline void lv_anim_path_set_cb(lv_anim_path_t * path, lv_anim_path_cb_t cb)
{
    path->cb = cb;
     8f6:	4b23      	ldr	r3, [pc, #140]	; (984 <CONFIG_ISR_STACK_SIZE+0x184>)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_OPA, image_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_DELAY, transition_delay, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_1, transition_prop_1, lv_style_int_t, _int, scalar)
     8f8:	2205      	movs	r2, #5
     8fa:	602b      	str	r3, [r5, #0]
     8fc:	21b2      	movs	r1, #178	; 0xb2
     8fe:	481d      	ldr	r0, [pc, #116]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     900:	606c      	str	r4, [r5, #4]
     902:	f016 fb07 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_2, transition_prop_2, lv_style_int_t, _int, scalar)
     906:	2204      	movs	r2, #4
     908:	21b3      	movs	r1, #179	; 0xb3
     90a:	481a      	ldr	r0, [pc, #104]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     90c:	f016 fb02 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
     910:	f44f 7296 	mov.w	r2, #300	; 0x12c
     914:	21b0      	movs	r1, #176	; 0xb0
     916:	4817      	ldr	r0, [pc, #92]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     918:	f016 fafc 	bl	16f14 <_lv_style_set_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_3, transition_prop_3, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_4, transition_prop_4, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_5, transition_prop_5, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_6, transition_prop_6, lv_style_int_t, _int, scalar)
#if LV_USE_ANIMATION
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, lv_anim_path_t *, _ptr, scalar)
     91c:	462a      	mov	r2, r5
     91e:	21be      	movs	r1, #190	; 0xbe
     920:	4814      	ldr	r0, [pc, #80]	; (974 <CONFIG_ISR_STACK_SIZE+0x174>)
     922:	f016 fbc5 	bl	170b0 <_lv_style_set_ptr>
	for(int i = 0; i < 12; i++){
     926:	4d18      	ldr	r5, [pc, #96]	; (988 <CONFIG_ISR_STACK_SIZE+0x188>)
		lv_img_set_src(image_bg[i], &img_noise_background);		
     928:	4f18      	ldr	r7, [pc, #96]	; (98c <CONFIG_ISR_STACK_SIZE+0x18c>)
     92a:	e031      	b.n	990 <CONFIG_ISR_STACK_SIZE+0x190>
     92c:	00026ccd 	.word	0x00026ccd
     930:	20001220 	.word	0x20001220
     934:	ffcbcaff 	.word	0xffcbcaff
     938:	2000129c 	.word	0x2000129c
     93c:	20001290 	.word	0x20001290
     940:	ff1c11fd 	.word	0xff1c11fd
     944:	ff7dcefd 	.word	0xff7dcefd
     948:	200001f4 	.word	0x200001f4
     94c:	2000128c 	.word	0x2000128c
     950:	ff69b05a 	.word	0xff69b05a
     954:	20001294 	.word	0x20001294
     958:	ffc0c0c0 	.word	0xffc0c0c0
     95c:	ff808080 	.word	0xff808080
     960:	ff000030 	.word	0xff000030
     964:	20000184 	.word	0x20000184
     968:	20001298 	.word	0x20001298
     96c:	ff008080 	.word	0xff008080
     970:	2000014c 	.word	0x2000014c
     974:	20001288 	.word	0x20001288
     978:	ff000080 	.word	0xff000080
     97c:	200001bc 	.word	0x200001bc
     980:	20001268 	.word	0x20001268
     984:	0001abf7 	.word	0x0001abf7
     988:	20001224 	.word	0x20001224
     98c:	0001ea10 	.word	0x0001ea10
		image_bg[i] = lv_img_create(lv_scr_act(), NULL);
     990:	f010 ff9a 	bl	118c8 <lv_scr_act>
     994:	2100      	movs	r1, #0
     996:	f00e f993 	bl	ecc0 <lv_img_create>
		lv_obj_set_pos(image_bg[i], x_index*80, y_index*80);
     99a:	f024 0203 	bic.w	r2, r4, #3
     99e:	eb02 02a4 	add.w	r2, r2, r4, asr #2
		int x_index = i % 4;
     9a2:	f004 0103 	and.w	r1, r4, #3
		lv_obj_set_pos(image_bg[i], x_index*80, y_index*80);
     9a6:	0112      	lsls	r2, r2, #4
     9a8:	eb01 0181 	add.w	r1, r1, r1, lsl #2
		image_bg[i] = lv_img_create(lv_scr_act(), NULL);
     9ac:	6028      	str	r0, [r5, #0]
		lv_obj_set_pos(image_bg[i], x_index*80, y_index*80);
     9ae:	b212      	sxth	r2, r2
     9b0:	0109      	lsls	r1, r1, #4
     9b2:	f014 ff75 	bl	158a0 <lv_obj_set_pos>
		lv_obj_set_size(image_bg[i], 80, 80);
     9b6:	2250      	movs	r2, #80	; 0x50
     9b8:	f855 0b04 	ldr.w	r0, [r5], #4
     9bc:	4611      	mov	r1, r2
     9be:	f014 ffed 	bl	1599c <lv_obj_set_size>
	for(int i = 0; i < 12; i++){
     9c2:	3401      	adds	r4, #1
		lv_img_set_src(image_bg[i], &img_noise_background);		
     9c4:	4639      	mov	r1, r7
     9c6:	f855 0c04 	ldr.w	r0, [r5, #-4]
     9ca:	f01b fca7 	bl	1c31c <lv_img_set_src>
	for(int i = 0; i < 12; i++){
     9ce:	2c0c      	cmp	r4, #12
     9d0:	d1de      	bne.n	990 <CONFIG_ISR_STACK_SIZE+0x190>
	connected_background = lv_label_create(lv_scr_act(), NULL);
     9d2:	f010 ff79 	bl	118c8 <lv_scr_act>
     9d6:	2100      	movs	r1, #0
     9d8:	f00e ff1c 	bl	f814 <lv_label_create>
     9dc:	4cab      	ldr	r4, [pc, #684]	; (c8c <CONFIG_ISR_STACK_SIZE+0x48c>)
	lv_obj_add_style(connected_background, LV_LABEL_PART_MAIN, &style_con_bg);
     9de:	4aac      	ldr	r2, [pc, #688]	; (c90 <CONFIG_ISR_STACK_SIZE+0x490>)
     9e0:	2100      	movs	r1, #0
	connected_background = lv_label_create(lv_scr_act(), NULL);
     9e2:	6020      	str	r0, [r4, #0]
	lv_obj_add_style(connected_background, LV_LABEL_PART_MAIN, &style_con_bg);
     9e4:	f015 fab1 	bl	15f4a <lv_obj_add_style>
	lv_label_set_long_mode(connected_background, LV_LABEL_LONG_DOT);
     9e8:	6820      	ldr	r0, [r4, #0]
     9ea:	2102      	movs	r1, #2
     9ec:	f00e fed0 	bl	f790 <lv_label_set_long_mode>
	lv_obj_set_pos(connected_background, 6, 65);
     9f0:	6820      	ldr	r0, [r4, #0]
     9f2:	2241      	movs	r2, #65	; 0x41
     9f4:	2106      	movs	r1, #6
     9f6:	f014 ff53 	bl	158a0 <lv_obj_set_pos>
	lv_obj_set_size(connected_background, 308, 135);
     9fa:	2287      	movs	r2, #135	; 0x87
     9fc:	6820      	ldr	r0, [r4, #0]
     9fe:	f44f 719a 	mov.w	r1, #308	; 0x134
     a02:	f014 ffcb 	bl	1599c <lv_obj_set_size>
	lv_label_set_text(connected_background, "");
     a06:	49a3      	ldr	r1, [pc, #652]	; (c94 <CONFIG_ISR_STACK_SIZE+0x494>)
     a08:	6820      	ldr	r0, [r4, #0]
     a0a:	f01b fef5 	bl	1c7f8 <lv_label_set_text>
	top_header = lv_label_create(lv_scr_act(), NULL);
     a0e:	f010 ff5b 	bl	118c8 <lv_scr_act>
     a12:	2100      	movs	r1, #0
     a14:	f00e fefe 	bl	f814 <lv_label_create>
     a18:	4c9f      	ldr	r4, [pc, #636]	; (c98 <CONFIG_ISR_STACK_SIZE+0x498>)
	lv_obj_add_style(top_header, LV_LABEL_PART_MAIN, &style_header);
     a1a:	4aa0      	ldr	r2, [pc, #640]	; (c9c <CONFIG_ISR_STACK_SIZE+0x49c>)
     a1c:	2100      	movs	r1, #0
	top_header = lv_label_create(lv_scr_act(), NULL);
     a1e:	6020      	str	r0, [r4, #0]
	lv_obj_add_style(top_header, LV_LABEL_PART_MAIN, &style_header);
     a20:	f015 fa93 	bl	15f4a <lv_obj_add_style>
	lv_label_set_long_mode(top_header, LV_LABEL_LONG_DOT);
     a24:	6820      	ldr	r0, [r4, #0]
     a26:	2102      	movs	r1, #2
     a28:	f00e feb2 	bl	f790 <lv_label_set_long_mode>
	lv_obj_set_pos(top_header, 3, 3);
     a2c:	2203      	movs	r2, #3
     a2e:	6820      	ldr	r0, [r4, #0]
     a30:	4611      	mov	r1, r2
     a32:	f014 ff35 	bl	158a0 <lv_obj_set_pos>
	lv_obj_set_size(top_header, 314, 68);
     a36:	2244      	movs	r2, #68	; 0x44
     a38:	6820      	ldr	r0, [r4, #0]
     a3a:	f44f 719d 	mov.w	r1, #314	; 0x13a
     a3e:	f014 ffad 	bl	1599c <lv_obj_set_size>
	lv_label_set_text(top_header, "nRF Blinky");
     a42:	4997      	ldr	r1, [pc, #604]	; (ca0 <CONFIG_ISR_STACK_SIZE+0x4a0>)
     a44:	6820      	ldr	r0, [r4, #0]
     a46:	f01b fed7 	bl	1c7f8 <lv_label_set_text>
	top_header_logo = lv_img_create(lv_scr_act(), NULL);
     a4a:	f010 ff3d 	bl	118c8 <lv_scr_act>
     a4e:	2100      	movs	r1, #0
     a50:	f00e f936 	bl	ecc0 <lv_img_create>
	lv_obj_set_pos(top_header_logo, 0, 0);
     a54:	2200      	movs	r2, #0
	top_header_logo = lv_img_create(lv_scr_act(), NULL);
     a56:	4c93      	ldr	r4, [pc, #588]	; (ca4 <CONFIG_ISR_STACK_SIZE+0x4a4>)
	lv_obj_set_pos(top_header_logo, 0, 0);
     a58:	4611      	mov	r1, r2
	top_header_logo = lv_img_create(lv_scr_act(), NULL);
     a5a:	6020      	str	r0, [r4, #0]
	lv_obj_set_pos(top_header_logo, 0, 0);
     a5c:	f014 ff20 	bl	158a0 <lv_obj_set_pos>
	lv_obj_set_size(top_header_logo, 68, 68);
     a60:	2244      	movs	r2, #68	; 0x44
     a62:	6820      	ldr	r0, [r4, #0]
     a64:	4611      	mov	r1, r2
     a66:	f014 ff99 	bl	1599c <lv_obj_set_size>
	lv_img_set_src(top_header_logo, &nod_logo);
     a6a:	498f      	ldr	r1, [pc, #572]	; (ca8 <CONFIG_ISR_STACK_SIZE+0x4a8>)
     a6c:	6820      	ldr	r0, [r4, #0]
     a6e:	f01b fc55 	bl	1c31c <lv_img_set_src>
	label_bt_state = lv_label_create(lv_scr_act(), NULL);
     a72:	f010 ff29 	bl	118c8 <lv_scr_act>
     a76:	2100      	movs	r1, #0
     a78:	f00e fecc 	bl	f814 <lv_label_create>
     a7c:	4c8b      	ldr	r4, [pc, #556]	; (cac <CONFIG_ISR_STACK_SIZE+0x4ac>)
	lv_label_set_long_mode(label_bt_state, LV_LABEL_LONG_CROP);
     a7e:	2105      	movs	r1, #5
	label_bt_state = lv_label_create(lv_scr_act(), NULL);
     a80:	6020      	str	r0, [r4, #0]
	lv_label_set_long_mode(label_bt_state, LV_LABEL_LONG_CROP);
     a82:	f00e fe85 	bl	f790 <lv_label_set_long_mode>
	lv_label_set_align(label_bt_state, LV_LABEL_ALIGN_CENTER); 
     a86:	2101      	movs	r1, #1
     a88:	6820      	ldr	r0, [r4, #0]
     a8a:	f01b fd7f 	bl	1c58c <lv_label_set_align>
	lv_obj_set_pos(label_bt_state, 70, 210);
     a8e:	22d2      	movs	r2, #210	; 0xd2
     a90:	2146      	movs	r1, #70	; 0x46
     a92:	6820      	ldr	r0, [r4, #0]
     a94:	f014 ff04 	bl	158a0 <lv_obj_set_pos>
	lv_obj_set_size(label_bt_state, 180, 30);
     a98:	221e      	movs	r2, #30
     a9a:	21b4      	movs	r1, #180	; 0xb4
     a9c:	6820      	ldr	r0, [r4, #0]
     a9e:	f014 ff7d 	bl	1599c <lv_obj_set_size>
	lv_label_set_text(label_bt_state, "Idle");
     aa2:	4983      	ldr	r1, [pc, #524]	; (cb0 <CONFIG_ISR_STACK_SIZE+0x4b0>)
     aa4:	6820      	ldr	r0, [r4, #0]
     aa6:	f01b fea7 	bl	1c7f8 <lv_label_set_text>
	lv_obj_add_style(label_bt_state, LV_LABEL_PART_MAIN, &style_label_value);
     aaa:	4a82      	ldr	r2, [pc, #520]	; (cb4 <CONFIG_ISR_STACK_SIZE+0x4b4>)
     aac:	2100      	movs	r1, #0
     aae:	6820      	ldr	r0, [r4, #0]
     ab0:	f015 fa4b 	bl	15f4a <lv_obj_add_style>
	btn1 = lv_btn_create(lv_scr_act(), NULL);     /*Add a button the current screen*/
     ab4:	f010 ff08 	bl	118c8 <lv_scr_act>
     ab8:	2100      	movs	r1, #0
     aba:	f00d fe07 	bl	e6cc <lv_btn_create>
     abe:	4d7e      	ldr	r5, [pc, #504]	; (cb8 <CONFIG_ISR_STACK_SIZE+0x4b8>)
	lv_obj_set_pos(btn1, 10, 90);                            /*Set its position*/
     ac0:	225a      	movs	r2, #90	; 0x5a
     ac2:	210a      	movs	r1, #10
	btn1 = lv_btn_create(lv_scr_act(), NULL);     /*Add a button the current screen*/
     ac4:	6028      	str	r0, [r5, #0]
	lv_obj_set_pos(btn1, 10, 90);                            /*Set its position*/
     ac6:	f014 feeb 	bl	158a0 <lv_obj_set_pos>
	lv_obj_set_size(btn1, 120, 50);                          /*Set its size*/
     aca:	2232      	movs	r2, #50	; 0x32
     acc:	6828      	ldr	r0, [r5, #0]
     ace:	2178      	movs	r1, #120	; 0x78
     ad0:	f014 ff64 	bl	1599c <lv_obj_set_size>
	lv_obj_reset_style_list(btn1, LV_BTN_PART_MAIN);         /*Remove the styles coming from the theme*/
     ad4:	6828      	ldr	r0, [r5, #0]
     ad6:	2100      	movs	r1, #0
     ad8:	f015 fa50 	bl	15f7c <lv_obj_reset_style_list>
	lv_obj_add_style(btn1, LV_BTN_PART_MAIN, &style_btn);
     adc:	4a77      	ldr	r2, [pc, #476]	; (cbc <CONFIG_ISR_STACK_SIZE+0x4bc>)
     ade:	6828      	ldr	r0, [r5, #0]
     ae0:	2100      	movs	r1, #0
     ae2:	f015 fa32 	bl	15f4a <lv_obj_add_style>
	lv_btn_set_checkable(btn1, true);
     ae6:	6828      	ldr	r0, [r5, #0]
     ae8:	2101      	movs	r1, #1
     aea:	f01a fde7 	bl	1b6bc <lv_btn_set_checkable>
	btn1_label = lv_label_create(btn1, NULL);          /*Add a label to the button*/
     aee:	2100      	movs	r1, #0
     af0:	6828      	ldr	r0, [r5, #0]
     af2:	f00e fe8f 	bl	f814 <lv_label_create>
     af6:	4b72      	ldr	r3, [pc, #456]	; (cc0 <CONFIG_ISR_STACK_SIZE+0x4c0>)
	lv_label_set_text(btn1_label, "Button");                     /*Set the labels text*/
     af8:	4972      	ldr	r1, [pc, #456]	; (cc4 <CONFIG_ISR_STACK_SIZE+0x4c4>)
	btn1_label = lv_label_create(btn1, NULL);          /*Add a label to the button*/
     afa:	6018      	str	r0, [r3, #0]
	lv_label_set_text(btn1_label, "Button");                     /*Set the labels text*/
     afc:	f01b fe7c 	bl	1c7f8 <lv_label_set_text>
	lv_obj_set_event_cb(btn1, on_button1);
     b00:	4971      	ldr	r1, [pc, #452]	; (cc8 <CONFIG_ISR_STACK_SIZE+0x4c8>)
     b02:	6828      	ldr	r0, [r5, #0]
     b04:	f014 fdf9 	bl	156fa <lv_obj_set_event_cb>
	label_btn_state = lv_label_create(lv_scr_act(), NULL);
     b08:	f010 fede 	bl	118c8 <lv_scr_act>
     b0c:	2100      	movs	r1, #0
     b0e:	f00e fe81 	bl	f814 <lv_label_create>
     b12:	4d6e      	ldr	r5, [pc, #440]	; (ccc <CONFIG_ISR_STACK_SIZE+0x4cc>)
	lv_label_set_long_mode(label_btn_state, LV_LABEL_LONG_DOT);
     b14:	2102      	movs	r1, #2
	label_btn_state = lv_label_create(lv_scr_act(), NULL);
     b16:	6028      	str	r0, [r5, #0]
	lv_label_set_long_mode(label_btn_state, LV_LABEL_LONG_DOT);
     b18:	f00e fe3a 	bl	f790 <lv_label_set_long_mode>
	lv_obj_set_pos(label_btn_state, 10, 170);
     b1c:	6828      	ldr	r0, [r5, #0]
     b1e:	22aa      	movs	r2, #170	; 0xaa
     b20:	210a      	movs	r1, #10
     b22:	f014 febd 	bl	158a0 <lv_obj_set_pos>
	lv_obj_set_size(label_btn_state, 120, 25);
     b26:	2219      	movs	r2, #25
     b28:	6828      	ldr	r0, [r5, #0]
     b2a:	2178      	movs	r1, #120	; 0x78
     b2c:	f014 ff36 	bl	1599c <lv_obj_set_size>
	lv_label_set_text(label_btn_state, "Released");
     b30:	6828      	ldr	r0, [r5, #0]
     b32:	4967      	ldr	r1, [pc, #412]	; (cd0 <CONFIG_ISR_STACK_SIZE+0x4d0>)
     b34:	f01b fe60 	bl	1c7f8 <lv_label_set_text>
	lv_label_set_align(label_btn_state, LV_LABEL_ALIGN_CENTER);
     b38:	6828      	ldr	r0, [r5, #0]
     b3a:	2101      	movs	r1, #1
     b3c:	f01b fd26 	bl	1c58c <lv_label_set_align>
	lv_obj_add_style(label_btn_state, LV_LABEL_PART_MAIN, &style_label_value);	
     b40:	4a5c      	ldr	r2, [pc, #368]	; (cb4 <CONFIG_ISR_STACK_SIZE+0x4b4>)
     b42:	2100      	movs	r1, #0
     b44:	6828      	ldr	r0, [r5, #0]
     b46:	f015 fa00 	bl	15f4a <lv_obj_add_style>
	image_led = lv_img_create(lv_scr_act(), NULL);
     b4a:	f010 febd 	bl	118c8 <lv_scr_act>
     b4e:	2100      	movs	r1, #0
     b50:	f00e f8b6 	bl	ecc0 <lv_img_create>
     b54:	4f5f      	ldr	r7, [pc, #380]	; (cd4 <CONFIG_ISR_STACK_SIZE+0x4d4>)
	lv_obj_set_pos(image_led, 192, 68);
     b56:	2244      	movs	r2, #68	; 0x44
     b58:	21c0      	movs	r1, #192	; 0xc0
	image_led = lv_img_create(lv_scr_act(), NULL);
     b5a:	6038      	str	r0, [r7, #0]
	lv_obj_set_pos(image_led, 192, 68);
     b5c:	f014 fea0 	bl	158a0 <lv_obj_set_pos>
	lv_obj_set_size(image_led, 68, 68);
     b60:	2244      	movs	r2, #68	; 0x44
     b62:	6838      	ldr	r0, [r7, #0]
     b64:	4611      	mov	r1, r2
     b66:	f014 ff19 	bl	1599c <lv_obj_set_size>
	lv_img_set_src(image_led, &led_off);
     b6a:	495b      	ldr	r1, [pc, #364]	; (cd8 <CONFIG_ISR_STACK_SIZE+0x4d8>)
     b6c:	6838      	ldr	r0, [r7, #0]
     b6e:	f01b fbd5 	bl	1c31c <lv_img_set_src>
	label_led_state = lv_label_create(lv_scr_act(), NULL);
     b72:	f010 fea9 	bl	118c8 <lv_scr_act>
     b76:	2100      	movs	r1, #0
     b78:	f00e fe4c 	bl	f814 <lv_label_create>
     b7c:	4d57      	ldr	r5, [pc, #348]	; (cdc <CONFIG_ISR_STACK_SIZE+0x4dc>)
	lv_label_set_long_mode(label_led_state, LV_LABEL_LONG_DOT);
     b7e:	2102      	movs	r1, #2
	label_led_state = lv_label_create(lv_scr_act(), NULL);
     b80:	6028      	str	r0, [r5, #0]
	lv_label_set_long_mode(label_led_state, LV_LABEL_LONG_DOT);
     b82:	f00e fe05 	bl	f790 <lv_label_set_long_mode>
	lv_obj_set_pos(label_led_state, 170, 170);
     b86:	22aa      	movs	r2, #170	; 0xaa
     b88:	6828      	ldr	r0, [r5, #0]
     b8a:	4611      	mov	r1, r2
     b8c:	f014 fe88 	bl	158a0 <lv_obj_set_pos>
	lv_obj_set_size(label_led_state, 120, 25);
     b90:	2219      	movs	r2, #25
     b92:	2178      	movs	r1, #120	; 0x78
     b94:	6828      	ldr	r0, [r5, #0]
     b96:	f014 ff01 	bl	1599c <lv_obj_set_size>
	lv_label_set_text(label_led_state, "Off");
     b9a:	4951      	ldr	r1, [pc, #324]	; (ce0 <CONFIG_ISR_STACK_SIZE+0x4e0>)
     b9c:	6828      	ldr	r0, [r5, #0]
     b9e:	f01b fe2b 	bl	1c7f8 <lv_label_set_text>
	lv_label_set_align(label_led_state, LV_LABEL_ALIGN_CENTER);
     ba2:	2101      	movs	r1, #1
     ba4:	6828      	ldr	r0, [r5, #0]
     ba6:	f01b fcf1 	bl	1c58c <lv_label_set_align>
	lv_obj_add_style(label_led_state, LV_LABEL_PART_MAIN, &style_label_value);
     baa:	2100      	movs	r1, #0
     bac:	4a41      	ldr	r2, [pc, #260]	; (cb4 <CONFIG_ISR_STACK_SIZE+0x4b4>)
     bae:	6828      	ldr	r0, [r5, #0]
     bb0:	f015 f9cb 	bl	15f4a <lv_obj_add_style>
	gui_show_connected_elements(false);
     bb4:	2000      	movs	r0, #0
     bb6:	f7ff fced 	bl	594 <gui_show_connected_elements>

	init_styles();

	init_blinky_gui();

	display_blanking_off(display_dev);
     bba:	6830      	ldr	r0, [r6, #0]
static inline int display_blanking_off(const struct device *dev)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->api;

	return api->blanking_off(dev);
     bbc:	46b9      	mov	r9, r7
     bbe:	6883      	ldr	r3, [r0, #8]
     bc0:	f44f 4680 	mov.w	r6, #16384	; 0x4000
     bc4:	685b      	ldr	r3, [r3, #4]
     bc6:	4798      	blx	r3
     bc8:	2700      	movs	r7, #0
		parm0.val = timeout;
		return (int) arch_syscall_invoke4(*(uintptr_t *)&msgq, *(uintptr_t *)&data, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
     bca:	f8df a12c 	ldr.w	sl, [pc, #300]	; cf8 <CONFIG_ISR_STACK_SIZE+0x4f8>
     bce:	2200      	movs	r2, #0
     bd0:	2300      	movs	r3, #0
     bd2:	4650      	mov	r0, sl
     bd4:	a905      	add	r1, sp, #20
     bd6:	f00f fbeb 	bl	103b0 <z_impl_k_msgq_get>
	while(k_msgq_get(&m_gui_cmd_queue, &cmd_message, K_NO_WAIT) == 0){
     bda:	4683      	mov	fp, r0
     bdc:	b138      	cbz	r0, bee <CONFIG_ISR_STACK_SIZE+0x3ee>

	while(1){
		process_cmd_msg_queue();
		lv_task_handler();
     bde:	f00c f8d5 	bl	cd8c <lv_task_handler>
	return z_impl_k_sleep(timeout);
     be2:	2100      	movs	r1, #0
     be4:	f44f 7024 	mov.w	r0, #656	; 0x290
     be8:	f010 f8ac 	bl	10d44 <z_impl_k_sleep>
	while(1){
     bec:	e7ed      	b.n	bca <CONFIG_ISR_STACK_SIZE+0x3ca>
		switch(cmd_message.type){
     bee:	f89d 8014 	ldrb.w	r8, [sp, #20]
     bf2:	f1b8 0f01 	cmp.w	r8, #1
     bf6:	d01a      	beq.n	c2e <CONFIG_ISR_STACK_SIZE+0x42e>
     bf8:	f1b8 0f02 	cmp.w	r8, #2
     bfc:	d1e7      	bne.n	bce <CONFIG_ISR_STACK_SIZE+0x3ce>
				lv_img_set_src(image_led, cmd_message.params.led_state ? &led_on : &led_off);
     bfe:	f89d 101c 	ldrb.w	r1, [sp, #28]
     c02:	4a38      	ldr	r2, [pc, #224]	; (ce4 <CONFIG_ISR_STACK_SIZE+0x4e4>)
     c04:	4b34      	ldr	r3, [pc, #208]	; (cd8 <CONFIG_ISR_STACK_SIZE+0x4d8>)
     c06:	f8d9 0000 	ldr.w	r0, [r9]
     c0a:	2900      	cmp	r1, #0
     c0c:	bf14      	ite	ne
     c0e:	4611      	movne	r1, r2
     c10:	4619      	moveq	r1, r3
     c12:	f01b fb83 	bl	1c31c <lv_img_set_src>
				lv_label_set_text(label_led_state, cmd_message.params.led_state ? "On" : "Off");
     c16:	f89d 101c 	ldrb.w	r1, [sp, #28]
     c1a:	4a33      	ldr	r2, [pc, #204]	; (ce8 <CONFIG_ISR_STACK_SIZE+0x4e8>)
     c1c:	4b30      	ldr	r3, [pc, #192]	; (ce0 <CONFIG_ISR_STACK_SIZE+0x4e0>)
     c1e:	6828      	ldr	r0, [r5, #0]
     c20:	2900      	cmp	r1, #0
     c22:	bf14      	ite	ne
     c24:	4611      	movne	r1, r2
     c26:	4619      	moveq	r1, r3
     c28:	f01b fde6 	bl	1c7f8 <lv_label_set_text>
				break;
     c2c:	e7cf      	b.n	bce <CONFIG_ISR_STACK_SIZE+0x3ce>
				set_bt_state(cmd_message.params.bt_state);
     c2e:	f89d 301c 	ldrb.w	r3, [sp, #28]
	switch(state){
     c32:	2b01      	cmp	r3, #1
     c34:	d00f      	beq.n	c56 <CONFIG_ISR_STACK_SIZE+0x456>
     c36:	2b02      	cmp	r3, #2
     c38:	d01b      	beq.n	c72 <CONFIG_ISR_STACK_SIZE+0x472>
     c3a:	b9c3      	cbnz	r3, c6e <CONFIG_ISR_STACK_SIZE+0x46e>
     c3c:	9303      	str	r3, [sp, #12]
	z_impl_k_timer_stop(timer);
     c3e:	482b      	ldr	r0, [pc, #172]	; (cec <CONFIG_ISR_STACK_SIZE+0x4ec>)
     c40:	f01c fce8 	bl	1d614 <z_impl_k_timer_stop>
			lv_label_set_text(label_bt_state, "Idle");
     c44:	6820      	ldr	r0, [r4, #0]
     c46:	491a      	ldr	r1, [pc, #104]	; (cb0 <CONFIG_ISR_STACK_SIZE+0x4b0>)
     c48:	f01b fdd6 	bl	1c7f8 <lv_label_set_text>
	bool connected = false;
     c4c:	9b03      	ldr	r3, [sp, #12]
     c4e:	4618      	mov	r0, r3
	gui_show_connected_elements(connected);
     c50:	f7ff fca0 	bl	594 <gui_show_connected_elements>
}
     c54:	e7bb      	b.n	bce <CONFIG_ISR_STACK_SIZE+0x3ce>
	z_impl_k_timer_start(timer, duration, period);
     c56:	4825      	ldr	r0, [pc, #148]	; (cec <CONFIG_ISR_STACK_SIZE+0x4ec>)
     c58:	f44f 4280 	mov.w	r2, #16384	; 0x4000
     c5c:	2300      	movs	r3, #0
     c5e:	e9cd 6700 	strd	r6, r7, [sp]
     c62:	f010 fbe1 	bl	11428 <z_impl_k_timer_start>
			lv_label_set_text(label_bt_state, "Advertising");
     c66:	4922      	ldr	r1, [pc, #136]	; (cf0 <CONFIG_ISR_STACK_SIZE+0x4f0>)
     c68:	6820      	ldr	r0, [r4, #0]
     c6a:	f01b fdc5 	bl	1c7f8 <lv_label_set_text>
	switch(state){
     c6e:	4658      	mov	r0, fp
     c70:	e7ee      	b.n	c50 <CONFIG_ISR_STACK_SIZE+0x450>
	z_impl_k_timer_stop(timer);
     c72:	481e      	ldr	r0, [pc, #120]	; (cec <CONFIG_ISR_STACK_SIZE+0x4ec>)
     c74:	f01c fcce 	bl	1d614 <z_impl_k_timer_stop>
			lv_label_set_text(label_bt_state, "Connected");
     c78:	6820      	ldr	r0, [r4, #0]
     c7a:	491e      	ldr	r1, [pc, #120]	; (cf4 <CONFIG_ISR_STACK_SIZE+0x4f4>)
     c7c:	f01b fdbc 	bl	1c7f8 <lv_label_set_text>
			connected = true;
     c80:	4640      	mov	r0, r8
			break;
     c82:	e7e5      	b.n	c50 <CONFIG_ISR_STACK_SIZE+0x450>
		k_sleep(K_MSEC(20));
	}
}
     c84:	b009      	add	sp, #36	; 0x24
     c86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     c8a:	bf00      	nop
     c8c:	2000121c 	.word	0x2000121c
     c90:	2000128c 	.word	0x2000128c
     c94:	0001f585 	.word	0x0001f585
     c98:	200012a0 	.word	0x200012a0
     c9c:	20001290 	.word	0x20001290
     ca0:	00026cd5 	.word	0x00026cd5
     ca4:	200012a4 	.word	0x200012a4
     ca8:	0001ea34 	.word	0x0001ea34
     cac:	20001258 	.word	0x20001258
     cb0:	00026ce0 	.word	0x00026ce0
     cb4:	20001298 	.word	0x20001298
     cb8:	20001214 	.word	0x20001214
     cbc:	20001288 	.word	0x20001288
     cc0:	20001218 	.word	0x20001218
     cc4:	00026ce5 	.word	0x00026ce5
     cc8:	000005e5 	.word	0x000005e5
     ccc:	2000125c 	.word	0x2000125c
     cd0:	00026cbd 	.word	0x00026cbd
     cd4:	20001254 	.word	0x20001254
     cd8:	0001ea1c 	.word	0x0001ea1c
     cdc:	20001260 	.word	0x20001260
     ce0:	00026cc9 	.word	0x00026cc9
     ce4:	0001ea28 	.word	0x0001ea28
     ce8:	00026cc6 	.word	0x00026cc6
     cec:	20000740 	.word	0x20000740
     cf0:	00026ca9 	.word	0x00026ca9
     cf4:	00026cec 	.word	0x00026cec
     cf8:	20000858 	.word	0x20000858

00000cfc <gui_init>:
	m_gui_callback = config->event_callback;
     cfc:	6802      	ldr	r2, [r0, #0]
     cfe:	4b01      	ldr	r3, [pc, #4]	; (d04 <gui_init+0x8>)
     d00:	601a      	str	r2, [r3, #0]
}
     d02:	4770      	bx	lr
     d04:	20001264 	.word	0x20001264

00000d08 <gui_set_bt_state>:
	set_bt_state_msg.type = GUI_MSG_SET_BT_STATE;
     d08:	2301      	movs	r3, #1
     d0a:	4904      	ldr	r1, [pc, #16]	; (d1c <gui_set_bt_state+0x14>)
     d0c:	700b      	strb	r3, [r1, #0]
	set_bt_state_msg.params.bt_state = state;
     d0e:	7208      	strb	r0, [r1, #8]
	return z_impl_k_msgq_put(msgq, data, timeout);
     d10:	2200      	movs	r2, #0
     d12:	2300      	movs	r3, #0
     d14:	4802      	ldr	r0, [pc, #8]	; (d20 <gui_set_bt_state+0x18>)
     d16:	f00f baf7 	b.w	10308 <z_impl_k_msgq_put>
     d1a:	bf00      	nop
     d1c:	20001270 	.word	0x20001270
     d20:	20000858 	.word	0x20000858

00000d24 <gui_set_bt_led_state>:
	set_led_state_msg.type = GUI_MSG_SET_LED_STATE;
     d24:	2302      	movs	r3, #2
     d26:	4904      	ldr	r1, [pc, #16]	; (d38 <gui_set_bt_led_state+0x14>)
     d28:	700b      	strb	r3, [r1, #0]
	set_led_state_msg.params.led_state = led_is_on;
     d2a:	7208      	strb	r0, [r1, #8]
     d2c:	2200      	movs	r2, #0
     d2e:	2300      	movs	r3, #0
     d30:	4802      	ldr	r0, [pc, #8]	; (d3c <gui_set_bt_led_state+0x18>)
     d32:	f00f bae9 	b.w	10308 <z_impl_k_msgq_put>
     d36:	bf00      	nop
     d38:	2000127c 	.word	0x2000127c
     d3c:	20000858 	.word	0x20000858

00000d40 <on_app_ble_event>:
#define LOG_LEVEL CONFIG_LOG_DEFAULT_LEVEL
#include <logging/log.h>
LOG_MODULE_REGISTER(app);

static void on_app_ble_event(app_ble_event_data_t * evt_data)
{
     d40:	b538      	push	{r3, r4, r5, lr}
	switch(evt_data->type) {
     d42:	7805      	ldrb	r5, [r0, #0]
{
     d44:	4604      	mov	r4, r0
	switch(evt_data->type) {
     d46:	2d01      	cmp	r5, #1
     d48:	d00a      	beq.n	d60 <on_app_ble_event+0x20>
     d4a:	2d02      	cmp	r5, #2
     d4c:	d012      	beq.n	d74 <on_app_ble_event+0x34>
     d4e:	bb05      	cbnz	r5, d92 <on_app_ble_event+0x52>
		case APP_BLE_CONNECTED:
			printk("Connected\n");
     d50:	4810      	ldr	r0, [pc, #64]	; (d94 <on_app_ble_event+0x54>)
     d52:	f010 fdf5 	bl	11940 <printk>
		case APP_BLE_ON_LED_WRITE:
			printk("Led %s\n", evt_data->led_state ? "On" : "Off");
			gui_set_bt_led_state(evt_data->led_state);
			break;
	}
}
     d56:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gui_set_bt_state(GUI_BT_STATE_CONNECTED);
     d5a:	2002      	movs	r0, #2
     d5c:	f7ff bfd4 	b.w	d08 <gui_set_bt_state>
			printk("Disconnected\n");
     d60:	480d      	ldr	r0, [pc, #52]	; (d98 <on_app_ble_event+0x58>)
     d62:	f010 fded 	bl	11940 <printk>
			gui_set_bt_state(GUI_BT_STATE_ADVERTISING);
     d66:	4628      	mov	r0, r5
     d68:	f7ff ffce 	bl	d08 <gui_set_bt_state>
}
     d6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			app_ble_start_advertising();
     d70:	f7ff bbaa 	b.w	4c8 <app_ble_start_advertising>
			printk("Led %s\n", evt_data->led_state ? "On" : "Off");
     d74:	7841      	ldrb	r1, [r0, #1]
     d76:	4b09      	ldr	r3, [pc, #36]	; (d9c <on_app_ble_event+0x5c>)
     d78:	4a09      	ldr	r2, [pc, #36]	; (da0 <on_app_ble_event+0x60>)
     d7a:	480a      	ldr	r0, [pc, #40]	; (da4 <on_app_ble_event+0x64>)
     d7c:	2900      	cmp	r1, #0
     d7e:	bf14      	ite	ne
     d80:	4611      	movne	r1, r2
     d82:	4619      	moveq	r1, r3
     d84:	f010 fddc 	bl	11940 <printk>
			gui_set_bt_led_state(evt_data->led_state);
     d88:	7860      	ldrb	r0, [r4, #1]
}
     d8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gui_set_bt_led_state(evt_data->led_state);
     d8e:	f7ff bfc9 	b.w	d24 <gui_set_bt_led_state>
}
     d92:	bd38      	pop	{r3, r4, r5, pc}
     d94:	00043b69 	.word	0x00043b69
     d98:	00043b74 	.word	0x00043b74
     d9c:	00026cc9 	.word	0x00026cc9
     da0:	00026cc6 	.word	0x00026cc6
     da4:	00043b82 	.word	0x00043b82

00000da8 <main>:
			break;
	}
}

void main(void)
{
     da8:	b507      	push	{r0, r1, r2, lr}
	gui_config_t gui_config = {.event_callback = on_gui_event};
     daa:	4b0c      	ldr	r3, [pc, #48]	; (ddc <main+0x34>)
	gui_init(&gui_config);
     dac:	4668      	mov	r0, sp
	gui_config_t gui_config = {.event_callback = on_gui_event};
     dae:	9300      	str	r3, [sp, #0]
	gui_init(&gui_config);
     db0:	f7ff ffa4 	bl	cfc <gui_init>

	app_ble_config_t app_ble_config = {.event_callback = on_app_ble_event};
     db4:	4b0a      	ldr	r3, [pc, #40]	; (de0 <main+0x38>)
	app_ble_init(&app_ble_config);
     db6:	a801      	add	r0, sp, #4
	app_ble_config_t app_ble_config = {.event_callback = on_app_ble_event};
     db8:	9301      	str	r3, [sp, #4]
	app_ble_init(&app_ble_config);
     dba:	f7ff fbad 	bl	518 <app_ble_init>

	app_ble_start_advertising();
     dbe:	f7ff fb83 	bl	4c8 <app_ble_start_advertising>

	printk("Advertising started\n");
     dc2:	4808      	ldr	r0, [pc, #32]	; (de4 <main+0x3c>)
     dc4:	f010 fdbc 	bl	11940 <printk>

	gui_set_bt_state(GUI_BT_STATE_ADVERTISING);
     dc8:	2001      	movs	r0, #1
     dca:	f7ff ff9d 	bl	d08 <gui_set_bt_state>
	return z_impl_k_sleep(timeout);
     dce:	2100      	movs	r1, #0
     dd0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
     dd4:	f00f ffb6 	bl	10d44 <z_impl_k_sleep>

	while (1) {
     dd8:	e7f9      	b.n	dce <main+0x26>
     dda:	bf00      	nop
     ddc:	000118d7 	.word	0x000118d7
     de0:	00000d41 	.word	0x00000d41
     de4:	00043b8a 	.word	0x00043b8a

00000de8 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
     de8:	680b      	ldr	r3, [r1, #0]
     dea:	3301      	adds	r3, #1
     dec:	600b      	str	r3, [r1, #0]
	return _char_out(c);
     dee:	4b01      	ldr	r3, [pc, #4]	; (df4 <char_out+0xc>)
     df0:	681b      	ldr	r3, [r3, #0]
     df2:	4718      	bx	r3
     df4:	2000022c 	.word	0x2000022c

00000df8 <__printk_hook_install>:
	_char_out = fn;
     df8:	4b01      	ldr	r3, [pc, #4]	; (e00 <__printk_hook_install+0x8>)
     dfa:	6018      	str	r0, [r3, #0]
}
     dfc:	4770      	bx	lr
     dfe:	bf00      	nop
     e00:	2000022c 	.word	0x2000022c

00000e04 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
     e04:	b507      	push	{r0, r1, r2, lr}
     e06:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
     e08:	2100      	movs	r1, #0
{
     e0a:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
     e0c:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
     e0e:	4803      	ldr	r0, [pc, #12]	; (e1c <vprintk+0x18>)
     e10:	a901      	add	r1, sp, #4
     e12:	f000 f951 	bl	10b8 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
     e16:	b003      	add	sp, #12
     e18:	f85d fb04 	ldr.w	pc, [sp], #4
     e1c:	00000de9 	.word	0x00000de9

00000e20 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     e20:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     e24:	f8b0 9018 	ldrh.w	r9, [r0, #24]
{
     e28:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     e2a:	f019 0808 	ands.w	r8, r9, #8
{
     e2e:	4693      	mov	fp, r2
	if (processing) {
     e30:	d00d      	beq.n	e4e <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
     e32:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     e34:	bf0c      	ite	eq
     e36:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
     e3a:	f049 0920 	orrne.w	r9, r9, #32
     e3e:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     e42:	f38b 8811 	msr	BASEPRI, fp
     e46:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
     e4a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     e4e:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
     e52:	2902      	cmp	r1, #2
     e54:	d107      	bne.n	e66 <process_event+0x46>
			evt = process_recheck(mgr);
     e56:	4620      	mov	r0, r4
     e58:	f010 fd7f 	bl	1195a <process_recheck>
		if (evt == EVT_NOP) {
     e5c:	2800      	cmp	r0, #0
     e5e:	d0f0      	beq.n	e42 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
     e60:	2801      	cmp	r0, #1
     e62:	8b23      	ldrh	r3, [r4, #24]
     e64:	d150      	bne.n	f08 <process_event+0xe8>
			res = mgr->last_res;
     e66:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     e68:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
     e6a:	2f00      	cmp	r7, #0
     e6c:	da15      	bge.n	e9a <process_event+0x7a>
		*clients = mgr->clients;
     e6e:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     e70:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
     e74:	e9c4 8800 	strd	r8, r8, [r4]
     e78:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
     e7c:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
     e7e:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     e80:	8b21      	ldrh	r1, [r4, #24]
     e82:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
     e86:	45ca      	cmp	sl, r9
     e88:	d002      	beq.n	e90 <process_event+0x70>
		if (do_monitors
     e8a:	68a3      	ldr	r3, [r4, #8]
     e8c:	2b00      	cmp	r3, #0
     e8e:	d15c      	bne.n	f4a <process_event+0x12a>
		    || !sys_slist_is_empty(&clients)
     e90:	b90d      	cbnz	r5, e96 <process_event+0x76>
		    || (transit != NULL)) {
     e92:	2e00      	cmp	r6, #0
     e94:	d074      	beq.n	f80 <process_event+0x160>
     e96:	2300      	movs	r3, #0
     e98:	e058      	b.n	f4c <process_event+0x12c>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     e9a:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
     e9e:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
     ea0:	2a01      	cmp	r2, #1
     ea2:	d820      	bhi.n	ee6 <process_event+0xc6>
		*clients = mgr->clients;
     ea4:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
     ea8:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
     eaa:	6825      	ldr	r5, [r4, #0]
	list->head = NULL;
     eac:	b289      	uxth	r1, r1
	list->tail = NULL;
     eae:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
     eb2:	d10c      	bne.n	ece <process_event+0xae>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
     eb4:	2d00      	cmp	r5, #0
     eb6:	462b      	mov	r3, r5
     eb8:	bf38      	it	cc
     eba:	2300      	movcc	r3, #0
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
     ebc:	b12b      	cbz	r3, eca <process_event+0xaa>
				mgr->refs += 1U;
     ebe:	8b62      	ldrh	r2, [r4, #26]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
     ec0:	681b      	ldr	r3, [r3, #0]
     ec2:	3201      	adds	r2, #1
     ec4:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
     ec6:	2b00      	cmp	r3, #0
     ec8:	d1f8      	bne.n	ebc <process_event+0x9c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     eca:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
     ece:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
     ed0:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
     ed2:	f010 fd42 	bl	1195a <process_recheck>
     ed6:	4606      	mov	r6, r0
     ed8:	2800      	cmp	r0, #0
     eda:	d0d1      	beq.n	e80 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     edc:	8b23      	ldrh	r3, [r4, #24]
     ede:	f043 0320 	orr.w	r3, r3, #32
     ee2:	8323      	strh	r3, [r4, #24]
     ee4:	e7cb      	b.n	e7e <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
     ee6:	2b04      	cmp	r3, #4
     ee8:	d10c      	bne.n	f04 <process_event+0xe4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     eea:	f021 0107 	bic.w	r1, r1, #7
     eee:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
     ef0:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
     ef2:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
     ef4:	f010 fd31 	bl	1195a <process_recheck>
     ef8:	4605      	mov	r5, r0
     efa:	2800      	cmp	r0, #0
     efc:	d0bf      	beq.n	e7e <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     efe:	f041 0120 	orr.w	r1, r1, #32
     f02:	8321      	strh	r1, [r4, #24]
     f04:	2500      	movs	r5, #0
     f06:	e7ba      	b.n	e7e <process_event+0x5e>
		} else if (evt == EVT_START) {
     f08:	2803      	cmp	r0, #3
     f0a:	d109      	bne.n	f20 <process_event+0x100>
			transit = mgr->transitions->start;
     f0c:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     f0e:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
     f12:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     f14:	f043 0306 	orr.w	r3, r3, #6
}
     f18:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
     f1a:	8323      	strh	r3, [r4, #24]
		res = 0;
     f1c:	462f      	mov	r7, r5
     f1e:	e7af      	b.n	e80 <process_event+0x60>
		} else if (evt == EVT_STOP) {
     f20:	2804      	cmp	r0, #4
     f22:	d106      	bne.n	f32 <process_event+0x112>
			transit = mgr->transitions->stop;
     f24:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     f26:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
     f2a:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     f2c:	f043 0304 	orr.w	r3, r3, #4
     f30:	e7f2      	b.n	f18 <process_event+0xf8>
		} else if (evt == EVT_RESET) {
     f32:	2805      	cmp	r0, #5
     f34:	d106      	bne.n	f44 <process_event+0x124>
			transit = mgr->transitions->reset;
     f36:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     f38:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
     f3c:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     f3e:	f043 0305 	orr.w	r3, r3, #5
     f42:	e7e9      	b.n	f18 <process_event+0xf8>
     f44:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
     f46:	462e      	mov	r6, r5
     f48:	e7e8      	b.n	f1c <process_event+0xfc>
				   && !sys_slist_is_empty(&mgr->monitors);
     f4a:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     f4c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
     f50:	8321      	strh	r1, [r4, #24]
     f52:	f38b 8811 	msr	BASEPRI, fp
     f56:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
     f5a:	bb03      	cbnz	r3, f9e <process_event+0x17e>
	while (!sys_slist_is_empty(list)) {
     f5c:	2d00      	cmp	r5, #0
     f5e:	d133      	bne.n	fc8 <process_event+0x1a8>
			if (transit != NULL) {
     f60:	b116      	cbz	r6, f68 <process_event+0x148>
				transit(mgr, transition_complete);
     f62:	4620      	mov	r0, r4
     f64:	4920      	ldr	r1, [pc, #128]	; (fe8 <process_event+0x1c8>)
     f66:	47b0      	blx	r6
	__asm__ volatile(
     f68:	f04f 0320 	mov.w	r3, #32
     f6c:	f3ef 8b11 	mrs	fp, BASEPRI
     f70:	f383 8811 	msr	BASEPRI, r3
     f74:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
     f78:	8b23      	ldrh	r3, [r4, #24]
     f7a:	f023 0308 	bic.w	r3, r3, #8
     f7e:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
     f80:	8b23      	ldrh	r3, [r4, #24]
     f82:	06da      	lsls	r2, r3, #27
     f84:	d528      	bpl.n	fd8 <process_event+0x1b8>
			evt = EVT_COMPLETE;
     f86:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
     f88:	f023 0310 	bic.w	r3, r3, #16
     f8c:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
     f8e:	f8b4 9018 	ldrh.w	r9, [r4, #24]
     f92:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
     f96:	2900      	cmp	r1, #0
     f98:	f47f af5b 	bne.w	e52 <process_event+0x32>
out:
     f9c:	e751      	b.n	e42 <process_event+0x22>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
     f9e:	68a1      	ldr	r1, [r4, #8]
     fa0:	2900      	cmp	r1, #0
     fa2:	d0db      	beq.n	f5c <process_event+0x13c>
	return node->next;
     fa4:	680b      	ldr	r3, [r1, #0]
     fa6:	2b00      	cmp	r3, #0
     fa8:	bf38      	it	cc
     faa:	2300      	movcc	r3, #0
     fac:	4699      	mov	r9, r3
		mon->callback(mgr, mon, state, res);
     fae:	4652      	mov	r2, sl
     fb0:	463b      	mov	r3, r7
     fb2:	4620      	mov	r0, r4
     fb4:	f8d1 b004 	ldr.w	fp, [r1, #4]
     fb8:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
     fba:	f1b9 0f00 	cmp.w	r9, #0
     fbe:	d0cd      	beq.n	f5c <process_event+0x13c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
     fc0:	4649      	mov	r1, r9
     fc2:	f8d9 3000 	ldr.w	r3, [r9]
     fc6:	e7ee      	b.n	fa6 <process_event+0x186>
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
     fc8:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
     fca:	463b      	mov	r3, r7
     fcc:	4652      	mov	r2, sl
     fce:	4620      	mov	r0, r4
     fd0:	682d      	ldr	r5, [r5, #0]
     fd2:	f010 fcde 	bl	11992 <notify_one>
     fd6:	e7c1      	b.n	f5c <process_event+0x13c>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
     fd8:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     fdc:	bf1e      	ittt	ne
     fde:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
     fe2:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     fe4:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
     fe6:	e7d2      	b.n	f8e <process_event+0x16e>
     fe8:	000119bf 	.word	0x000119bf

00000fec <extract_decimal>:
 * the referenced text.
 *
 * @return the decoded integer value.
 */
static size_t extract_decimal(const char **str)
{
     fec:	b5f0      	push	{r4, r5, r6, r7, lr}
     fee:	4602      	mov	r2, r0
     ff0:	6801      	ldr	r1, [r0, #0]
	const char *sp = *str;
	size_t val = 0;

	while (isdigit((int)(unsigned char)*sp)) {
		val = 10U * val + *sp++ - '0';
     ff2:	270a      	movs	r7, #10
	size_t val = 0;
     ff4:	2000      	movs	r0, #0
	while (isdigit((int)(unsigned char)*sp)) {
     ff6:	4e07      	ldr	r6, [pc, #28]	; (1014 <CONFIG_MAIN_STACK_SIZE+0x14>)
     ff8:	460c      	mov	r4, r1
     ffa:	7823      	ldrb	r3, [r4, #0]
     ffc:	3101      	adds	r1, #1
     ffe:	5d9d      	ldrb	r5, [r3, r6]
    1000:	076d      	lsls	r5, r5, #29
    1002:	d401      	bmi.n	1008 <CONFIG_MAIN_STACK_SIZE+0x8>
	}
	*str = sp;
    1004:	6014      	str	r4, [r2, #0]
	return val;
}
    1006:	bdf0      	pop	{r4, r5, r6, r7, pc}
		val = 10U * val + *sp++ - '0';
    1008:	fb07 3300 	mla	r3, r7, r0, r3
    100c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    1010:	e7f2      	b.n	ff8 <extract_decimal+0xc>
    1012:	bf00      	nop
    1014:	0004433a 	.word	0x0004433a

00001018 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
    1018:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    101c:	4614      	mov	r4, r2
    101e:	4699      	mov	r9, r3
	bool upcase = isupper((int)conv->specifier);
    1020:	78d3      	ldrb	r3, [r2, #3]
    1022:	4a24      	ldr	r2, [pc, #144]	; (10b4 <encode_uint+0x9c>)
	switch (specifier) {
    1024:	2b6f      	cmp	r3, #111	; 0x6f
    1026:	f813 a002 	ldrb.w	sl, [r3, r2]
{
    102a:	4606      	mov	r6, r0
    102c:	f00a 0203 	and.w	r2, sl, #3
    1030:	460f      	mov	r7, r1
    1032:	9201      	str	r2, [sp, #4]
	switch (specifier) {
    1034:	d02d      	beq.n	1092 <encode_uint+0x7a>
    1036:	d828      	bhi.n	108a <encode_uint+0x72>
		return 16;
    1038:	2b58      	cmp	r3, #88	; 0x58
    103a:	bf14      	ite	ne
    103c:	250a      	movne	r5, #10
    103e:	2510      	moveq	r5, #16
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
    1040:	46aa      	mov	sl, r5
    1042:	f04f 0b00 	mov.w	fp, #0
	char *bp = bps + (bpe - bps);
    1046:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
		unsigned int lsv = (unsigned int)(value % radix);
    104a:	4652      	mov	r2, sl
    104c:	465b      	mov	r3, fp
    104e:	4630      	mov	r0, r6
    1050:	4639      	mov	r1, r7
    1052:	f7ff f87f 	bl	154 <__aeabi_uldivmod>

		*--bp = (lsv <= 9) ? ('0' + lsv)
    1056:	2a09      	cmp	r2, #9
    1058:	b2d3      	uxtb	r3, r2
    105a:	d81f      	bhi.n	109c <encode_uint+0x84>
    105c:	3330      	adds	r3, #48	; 0x30
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
	} while ((value != 0) && (bps < bp));
    105e:	455f      	cmp	r7, fp
		*--bp = (lsv <= 9) ? ('0' + lsv)
    1060:	b2db      	uxtb	r3, r3
	} while ((value != 0) && (bps < bp));
    1062:	bf08      	it	eq
    1064:	4556      	cmpeq	r6, sl
		*--bp = (lsv <= 9) ? ('0' + lsv)
    1066:	f808 3d01 	strb.w	r3, [r8, #-1]!
	} while ((value != 0) && (bps < bp));
    106a:	d301      	bcc.n	1070 <encode_uint+0x58>
    106c:	45c8      	cmp	r8, r9
    106e:	d812      	bhi.n	1096 <encode_uint+0x7e>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
    1070:	7823      	ldrb	r3, [r4, #0]
    1072:	069b      	lsls	r3, r3, #26
    1074:	d505      	bpl.n	1082 <encode_uint+0x6a>
		if (radix == 8) {
    1076:	2d08      	cmp	r5, #8
    1078:	d116      	bne.n	10a8 <encode_uint+0x90>
			conv->altform_0 = true;
    107a:	78a3      	ldrb	r3, [r4, #2]
    107c:	f043 0308 	orr.w	r3, r3, #8
		} else if (radix == 16) {
			conv->altform_0c = true;
    1080:	70a3      	strb	r3, [r4, #2]
		}
	}

	return bp;
}
    1082:	4640      	mov	r0, r8
    1084:	b003      	add	sp, #12
    1086:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
    108a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
    108e:	2b70      	cmp	r3, #112	; 0x70
    1090:	e7d3      	b.n	103a <encode_uint+0x22>
	switch (specifier) {
    1092:	2508      	movs	r5, #8
    1094:	e7d4      	b.n	1040 <encode_uint+0x28>
		value /= radix;
    1096:	4606      	mov	r6, r0
    1098:	460f      	mov	r7, r1
    109a:	e7d6      	b.n	104a <encode_uint+0x32>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    109c:	9a01      	ldr	r2, [sp, #4]
    109e:	2a01      	cmp	r2, #1
    10a0:	bf0c      	ite	eq
    10a2:	3337      	addeq	r3, #55	; 0x37
    10a4:	3357      	addne	r3, #87	; 0x57
    10a6:	e7da      	b.n	105e <encode_uint+0x46>
		} else if (radix == 16) {
    10a8:	2d10      	cmp	r5, #16
    10aa:	d1ea      	bne.n	1082 <encode_uint+0x6a>
			conv->altform_0c = true;
    10ac:	78a3      	ldrb	r3, [r4, #2]
    10ae:	f043 0310 	orr.w	r3, r3, #16
    10b2:	e7e5      	b.n	1080 <encode_uint+0x68>
    10b4:	0004433a 	.word	0x0004433a

000010b8 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    10b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    10bc:	4682      	mov	sl, r0
    10be:	468b      	mov	fp, r1
    10c0:	4691      	mov	r9, r2
    10c2:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    10c4:	2500      	movs	r5, #0
{
    10c6:	b093      	sub	sp, #76	; 0x4c
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    10c8:	f899 0000 	ldrb.w	r0, [r9]
    10cc:	b908      	cbnz	r0, 10d2 <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
    10ce:	4628      	mov	r0, r5
    10d0:	e33a      	b.n	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
		if (*fp != '%') {
    10d2:	f109 0301 	add.w	r3, r9, #1
    10d6:	2825      	cmp	r0, #37	; 0x25
    10d8:	9302      	str	r3, [sp, #8]
    10da:	d006      	beq.n	10ea <cbvprintf+0x32>
			OUTC('%');
    10dc:	4659      	mov	r1, fp
    10de:	47d0      	blx	sl
    10e0:	2800      	cmp	r0, #0
    10e2:	f2c0 8331 	blt.w	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
    10e6:	3501      	adds	r5, #1
			break;
    10e8:	e1f1      	b.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
		} state = {
    10ea:	2218      	movs	r2, #24
    10ec:	2100      	movs	r1, #0
    10ee:	a80c      	add	r0, sp, #48	; 0x30
    10f0:	f01c fc44 	bl	1d97c <memset>
	if (*sp == '%') {
    10f4:	f899 3001 	ldrb.w	r3, [r9, #1]
    10f8:	2b25      	cmp	r3, #37	; 0x25
    10fa:	d059      	beq.n	11b0 <cbvprintf+0xf8>
    10fc:	9a02      	ldr	r2, [sp, #8]
    10fe:	4616      	mov	r6, r2
		switch (*sp) {
    1100:	f812 3b01 	ldrb.w	r3, [r2], #1
    1104:	2b2b      	cmp	r3, #43	; 0x2b
    1106:	f000 808b 	beq.w	1220 <cbvprintf+0x168>
    110a:	d879      	bhi.n	1200 <cbvprintf+0x148>
    110c:	2b20      	cmp	r3, #32
    110e:	f000 808c 	beq.w	122a <cbvprintf+0x172>
    1112:	2b23      	cmp	r3, #35	; 0x23
    1114:	f000 808e 	beq.w	1234 <cbvprintf+0x17c>
	if (conv->flag_zero && conv->flag_dash) {
    1118:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    111c:	f003 0244 	and.w	r2, r3, #68	; 0x44
    1120:	2a44      	cmp	r2, #68	; 0x44
    1122:	d103      	bne.n	112c <cbvprintf+0x74>
		conv->flag_zero = false;
    1124:	f36f 1386 	bfc	r3, #6, #1
    1128:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
	conv->width_present = true;
    112c:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    1130:	9605      	str	r6, [sp, #20]
    1132:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1136:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
	if (*sp == '*') {
    113a:	7833      	ldrb	r3, [r6, #0]
    113c:	2b2a      	cmp	r3, #42	; 0x2a
    113e:	d17e      	bne.n	123e <cbvprintf+0x186>
		conv->width_star = true;
    1140:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
    1144:	f043 0301 	orr.w	r3, r3, #1
    1148:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
		return ++sp;
    114c:	1c73      	adds	r3, r6, #1
	sp = extract_prec(conv, sp);
    114e:	9305      	str	r3, [sp, #20]
	conv->prec_present = (*sp == '.');
    1150:	781a      	ldrb	r2, [r3, #0]
    1152:	2a2e      	cmp	r2, #46	; 0x2e
    1154:	bf0c      	ite	eq
    1156:	2101      	moveq	r1, #1
    1158:	2100      	movne	r1, #0
    115a:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
    115e:	f361 0241 	bfi	r2, r1, #1, #1
    1162:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
	if (!conv->prec_present) {
    1166:	d10b      	bne.n	1180 <cbvprintf+0xc8>
	++sp;
    1168:	1c5a      	adds	r2, r3, #1
    116a:	9205      	str	r2, [sp, #20]
	if (*sp == '*') {
    116c:	785a      	ldrb	r2, [r3, #1]
    116e:	2a2a      	cmp	r2, #42	; 0x2a
    1170:	d17b      	bne.n	126a <cbvprintf+0x1b2>
		conv->prec_star = true;
    1172:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
		return ++sp;
    1176:	3302      	adds	r3, #2
		conv->prec_star = true;
    1178:	f042 0204 	orr.w	r2, r2, #4
    117c:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
	switch (*sp) {
    1180:	4619      	mov	r1, r3
    1182:	f811 0b01 	ldrb.w	r0, [r1], #1
    1186:	286c      	cmp	r0, #108	; 0x6c
    1188:	f000 80b6 	beq.w	12f8 <cbvprintf+0x240>
    118c:	d87d      	bhi.n	128a <cbvprintf+0x1d2>
    118e:	2868      	cmp	r0, #104	; 0x68
    1190:	f000 8084 	beq.w	129c <cbvprintf+0x1e4>
    1194:	286a      	cmp	r0, #106	; 0x6a
    1196:	f000 80b9 	beq.w	130c <cbvprintf+0x254>
    119a:	284c      	cmp	r0, #76	; 0x4c
    119c:	f000 80bd 	beq.w	131a <cbvprintf+0x262>
		conv->length_mod = LENGTH_NONE;
    11a0:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
		break;
    11a4:	4619      	mov	r1, r3
		conv->length_mod = LENGTH_NONE;
    11a6:	f36f 02c6 	bfc	r2, #3, #4
    11aa:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
		break;
    11ae:	e080      	b.n	12b2 <cbvprintf+0x1fa>
		conv->specifier = *sp++;
    11b0:	f109 0202 	add.w	r2, r9, #2
    11b4:	9202      	str	r2, [sp, #8]
    11b6:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
		if (conv->width_star) {
    11ba:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
    11be:	07d9      	lsls	r1, r3, #31
    11c0:	f140 8149 	bpl.w	1456 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xce>
			width = va_arg(ap, int);
    11c4:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
    11c8:	f1b8 0f00 	cmp.w	r8, #0
    11cc:	da07      	bge.n	11de <cbvprintf+0x126>
				conv->flag_dash = true;
    11ce:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
				width = -width;
    11d2:	f1c8 0800 	rsb	r8, r8, #0
				conv->flag_dash = true;
    11d6:	f042 0204 	orr.w	r2, r2, #4
    11da:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
		if (conv->prec_star) {
    11de:	075a      	lsls	r2, r3, #29
    11e0:	f140 8142 	bpl.w	1468 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xe0>
			int arg = va_arg(ap, int);
    11e4:	f854 7b04 	ldr.w	r7, [r4], #4
			if (arg < 0) {
    11e8:	2f00      	cmp	r7, #0
    11ea:	f280 8141 	bge.w	1470 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xe8>
				conv->prec_present = false;
    11ee:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
    11f2:	f36f 0341 	bfc	r3, #1, #1
    11f6:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
		int precision = -1;
    11fa:	f04f 37ff 	mov.w	r7, #4294967295
    11fe:	e137      	b.n	1470 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xe8>
		switch (*sp) {
    1200:	2b2d      	cmp	r3, #45	; 0x2d
    1202:	d006      	beq.n	1212 <cbvprintf+0x15a>
    1204:	2b30      	cmp	r3, #48	; 0x30
    1206:	d187      	bne.n	1118 <cbvprintf+0x60>
			conv->flag_zero = true;
    1208:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    120c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1210:	e003      	b.n	121a <cbvprintf+0x162>
			conv->flag_dash = true;
    1212:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    1216:	f043 0304 	orr.w	r3, r3, #4
			conv->flag_zero = true;
    121a:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
			break;
    121e:	e76e      	b.n	10fe <cbvprintf+0x46>
			conv->flag_plus = true;
    1220:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    1224:	f043 0308 	orr.w	r3, r3, #8
    1228:	e7f7      	b.n	121a <cbvprintf+0x162>
			conv->flag_space = true;
    122a:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    122e:	f043 0310 	orr.w	r3, r3, #16
    1232:	e7f2      	b.n	121a <cbvprintf+0x162>
			conv->flag_hash = true;
    1234:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    1238:	f043 0320 	orr.w	r3, r3, #32
    123c:	e7ed      	b.n	121a <cbvprintf+0x162>
	size_t width = extract_decimal(&sp);
    123e:	a805      	add	r0, sp, #20
    1240:	f7ff fed4 	bl	fec <extract_decimal>
	if (sp != wp) {
    1244:	9b05      	ldr	r3, [sp, #20]
    1246:	42b3      	cmp	r3, r6
    1248:	d081      	beq.n	114e <cbvprintf+0x96>
		conv->unsupported |= ((conv->width_value < 0)
    124a:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
		conv->width_value = width;
    124e:	900f      	str	r0, [sp, #60]	; 0x3c
		conv->unsupported |= ((conv->width_value < 0)
    1250:	f3c1 0240 	ubfx	r2, r1, #1, #1
    1254:	ea42 72d0 	orr.w	r2, r2, r0, lsr #31
    1258:	0052      	lsls	r2, r2, #1
    125a:	f062 027f 	orn	r2, r2, #127	; 0x7f
    125e:	f001 017d 	and.w	r1, r1, #125	; 0x7d
    1262:	430a      	orrs	r2, r1
    1264:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
    1268:	e771      	b.n	114e <cbvprintf+0x96>
	size_t prec = extract_decimal(&sp);
    126a:	a805      	add	r0, sp, #20
    126c:	f7ff febe 	bl	fec <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
    1270:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
	conv->prec_value = prec;
    1274:	9010      	str	r0, [sp, #64]	; 0x40
	conv->unsupported |= ((conv->prec_value < 0)
    1276:	f3c3 0240 	ubfx	r2, r3, #1, #1
    127a:	ea42 70d0 	orr.w	r0, r2, r0, lsr #31
    127e:	f360 0341 	bfi	r3, r0, #1, #1
    1282:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
	return sp;
    1286:	9b05      	ldr	r3, [sp, #20]
    1288:	e77a      	b.n	1180 <cbvprintf+0xc8>
	switch (*sp) {
    128a:	2874      	cmp	r0, #116	; 0x74
    128c:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
    1290:	d040      	beq.n	1314 <cbvprintf+0x25c>
    1292:	287a      	cmp	r0, #122	; 0x7a
    1294:	d184      	bne.n	11a0 <cbvprintf+0xe8>
		conv->length_mod = LENGTH_Z;
    1296:	4613      	mov	r3, r2
    1298:	2206      	movs	r2, #6
    129a:	e028      	b.n	12ee <cbvprintf+0x236>
		if (*++sp == 'h') {
    129c:	785a      	ldrb	r2, [r3, #1]
    129e:	2a68      	cmp	r2, #104	; 0x68
    12a0:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
    12a4:	d121      	bne.n	12ea <cbvprintf+0x232>
			conv->length_mod = LENGTH_HH;
    12a6:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
    12a8:	f361 02c6 	bfi	r2, r1, #3, #4
    12ac:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
			++sp;
    12b0:	1c99      	adds	r1, r3, #2
	conv->specifier = *sp++;
    12b2:	460b      	mov	r3, r1
    12b4:	f813 2b01 	ldrb.w	r2, [r3], #1
	switch (conv->specifier) {
    12b8:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
    12ba:	9302      	str	r3, [sp, #8]
    12bc:	f88d 203b 	strb.w	r2, [sp, #59]	; 0x3b
	switch (conv->specifier) {
    12c0:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
    12c4:	f200 80bf 	bhi.w	1446 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xbe>
    12c8:	2a57      	cmp	r2, #87	; 0x57
    12ca:	d833      	bhi.n	1334 <cbvprintf+0x27c>
    12cc:	2a41      	cmp	r2, #65	; 0x41
    12ce:	d003      	beq.n	12d8 <cbvprintf+0x220>
    12d0:	3a45      	subs	r2, #69	; 0x45
    12d2:	2a02      	cmp	r2, #2
    12d4:	f200 80b7 	bhi.w	1446 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xbe>
		conv->specifier_cat = SPECIFIER_FP;
    12d8:	2204      	movs	r2, #4
    12da:	f89d 303a 	ldrb.w	r3, [sp, #58]	; 0x3a
    12de:	f362 0302 	bfi	r3, r2, #0, #3
    12e2:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
			unsupported = true;
    12e6:	2301      	movs	r3, #1
			break;
    12e8:	e084      	b.n	13f4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x6c>
			conv->length_mod = LENGTH_H;
    12ea:	4613      	mov	r3, r2
    12ec:	2202      	movs	r2, #2
			conv->length_mod = LENGTH_L;
    12ee:	f362 03c6 	bfi	r3, r2, #3, #4
    12f2:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    12f6:	e7dc      	b.n	12b2 <cbvprintf+0x1fa>
		if (*++sp == 'l') {
    12f8:	785a      	ldrb	r2, [r3, #1]
    12fa:	2a6c      	cmp	r2, #108	; 0x6c
    12fc:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
    1300:	d101      	bne.n	1306 <cbvprintf+0x24e>
			conv->length_mod = LENGTH_LL;
    1302:	2104      	movs	r1, #4
    1304:	e7d0      	b.n	12a8 <cbvprintf+0x1f0>
			conv->length_mod = LENGTH_L;
    1306:	4613      	mov	r3, r2
    1308:	2203      	movs	r2, #3
    130a:	e7f0      	b.n	12ee <cbvprintf+0x236>
		conv->length_mod = LENGTH_J;
    130c:	2205      	movs	r2, #5
    130e:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
    1312:	e7ec      	b.n	12ee <cbvprintf+0x236>
		conv->length_mod = LENGTH_T;
    1314:	4613      	mov	r3, r2
    1316:	2207      	movs	r2, #7
    1318:	e7e9      	b.n	12ee <cbvprintf+0x236>
		conv->unsupported = true;
    131a:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    131e:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    1322:	f023 0302 	bic.w	r3, r3, #2
    1326:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    132a:	f043 0302 	orr.w	r3, r3, #2
    132e:	f8ad 3038 	strh.w	r3, [sp, #56]	; 0x38
		break;
    1332:	e7be      	b.n	12b2 <cbvprintf+0x1fa>
    1334:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
    1338:	2920      	cmp	r1, #32
    133a:	f200 8084 	bhi.w	1446 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xbe>
    133e:	a001      	add	r0, pc, #4	; (adr r0, 1344 <cbvprintf+0x28c>)
    1340:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
    1344:	00001409 	.word	0x00001409
    1348:	00001447 	.word	0x00001447
    134c:	00001447 	.word	0x00001447
    1350:	00001447 	.word	0x00001447
    1354:	00001447 	.word	0x00001447
    1358:	00001447 	.word	0x00001447
    135c:	00001447 	.word	0x00001447
    1360:	00001447 	.word	0x00001447
    1364:	00001447 	.word	0x00001447
    1368:	000012d9 	.word	0x000012d9
    136c:	00001447 	.word	0x00001447
    1370:	00001409 	.word	0x00001409
    1374:	000013c9 	.word	0x000013c9
    1378:	000012d9 	.word	0x000012d9
    137c:	000012d9 	.word	0x000012d9
    1380:	000012d9 	.word	0x000012d9
    1384:	00001447 	.word	0x00001447
    1388:	000013c9 	.word	0x000013c9
    138c:	00001447 	.word	0x00001447
    1390:	00001447 	.word	0x00001447
    1394:	00001447 	.word	0x00001447
    1398:	00001447 	.word	0x00001447
    139c:	00001411 	.word	0x00001411
    13a0:	00001409 	.word	0x00001409
    13a4:	0000142d 	.word	0x0000142d
    13a8:	00001447 	.word	0x00001447
    13ac:	00001447 	.word	0x00001447
    13b0:	0000142d 	.word	0x0000142d
    13b4:	00001447 	.word	0x00001447
    13b8:	00001409 	.word	0x00001409
    13bc:	00001447 	.word	0x00001447
    13c0:	00001447 	.word	0x00001447
    13c4:	00001409 	.word	0x00001409
		conv->specifier_cat = SPECIFIER_SINT;
    13c8:	2001      	movs	r0, #1
    13ca:	f89d 103a 	ldrb.w	r1, [sp, #58]	; 0x3a
		if (conv->length_mod == LENGTH_UPPER_L) {
    13ce:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
    13d2:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    13d6:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
    13d8:	f88d 103a 	strb.w	r1, [sp, #58]	; 0x3a
			conv->invalid = true;
    13dc:	bf02      	ittt	eq
    13de:	f89d 1038 	ldrbeq.w	r1, [sp, #56]	; 0x38
    13e2:	f041 0101 	orreq.w	r1, r1, #1
    13e6:	f88d 1038 	strbeq.w	r1, [sp, #56]	; 0x38
		if (conv->specifier == 'c') {
    13ea:	2a63      	cmp	r2, #99	; 0x63
    13ec:	d131      	bne.n	1452 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0xca>
			unsupported = (conv->length_mod != LENGTH_NONE);
    13ee:	3b00      	subs	r3, #0
    13f0:	bf18      	it	ne
    13f2:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
    13f4:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
    13f8:	f3c2 0140 	ubfx	r1, r2, #1, #1
    13fc:	430b      	orrs	r3, r1
    13fe:	f363 0241 	bfi	r2, r3, #1, #1
    1402:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
	return sp;
    1406:	e6d8      	b.n	11ba <cbvprintf+0x102>
		conv->specifier_cat = SPECIFIER_UINT;
    1408:	2002      	movs	r0, #2
    140a:	f89d 103a 	ldrb.w	r1, [sp, #58]	; 0x3a
    140e:	e7de      	b.n	13ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x46>
		conv->specifier_cat = SPECIFIER_PTR;
    1410:	2103      	movs	r1, #3
    1412:	f89d 203a 	ldrb.w	r2, [sp, #58]	; 0x3a
		if (conv->length_mod == LENGTH_UPPER_L) {
    1416:	f003 0378 	and.w	r3, r3, #120	; 0x78
    141a:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
    141e:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    1422:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
    1424:	f88d 203a 	strb.w	r2, [sp, #58]	; 0x3a
		if (conv->length_mod == LENGTH_UPPER_L) {
    1428:	4143      	adcs	r3, r0
    142a:	e7e3      	b.n	13f4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x6c>
		conv->specifier_cat = SPECIFIER_PTR;
    142c:	2103      	movs	r1, #3
    142e:	f89d 203a 	ldrb.w	r2, [sp, #58]	; 0x3a
		if (conv->length_mod != LENGTH_NONE) {
    1432:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
    1436:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
    143a:	bf14      	ite	ne
    143c:	2301      	movne	r3, #1
    143e:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
    1440:	f88d 203a 	strb.w	r2, [sp, #58]	; 0x3a
		if (conv->length_mod != LENGTH_NONE) {
    1444:	e7d6      	b.n	13f4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x6c>
		conv->invalid = true;
    1446:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    144a:	f043 0301 	orr.w	r3, r3, #1
    144e:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
	bool unsupported = false;
    1452:	2300      	movs	r3, #0
    1454:	e7ce      	b.n	13f4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x6c>
		} else if (conv->width_present) {
    1456:	f99d 2038 	ldrsb.w	r2, [sp, #56]	; 0x38
    145a:	2a00      	cmp	r2, #0
		int width = -1;
    145c:	bfac      	ite	ge
    145e:	f04f 38ff 	movge.w	r8, #4294967295
			width = conv->width_value;
    1462:	f8dd 803c 	ldrlt.w	r8, [sp, #60]	; 0x3c
    1466:	e6ba      	b.n	11de <cbvprintf+0x126>
		} else if (conv->prec_present) {
    1468:	079f      	lsls	r7, r3, #30
    146a:	f57f aec6 	bpl.w	11fa <cbvprintf+0x142>
			precision = conv->prec_value;
    146e:	9f10      	ldr	r7, [sp, #64]	; 0x40
		conv->pad0_value = 0;
    1470:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
    1472:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
			= (enum specifier_cat_enum)conv->specifier_cat;
    1476:	f89d 303a 	ldrb.w	r3, [sp, #58]	; 0x3a
			= (enum length_mod_enum)conv->length_mod;
    147a:	f89d 1039 	ldrb.w	r1, [sp, #57]	; 0x39
		enum specifier_cat_enum specifier_cat
    147e:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
    1482:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
    1484:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
    1488:	d137      	bne.n	14fa <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x172>
			switch (length_mod) {
    148a:	1ecb      	subs	r3, r1, #3
    148c:	2b04      	cmp	r3, #4
    148e:	d821      	bhi.n	14d4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x14c>
    1490:	e8df f003 	tbb	[pc, r3]
    1494:	20070703 	.word	0x20070703
    1498:	20          	.byte	0x20
    1499:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
    149a:	f854 2b04 	ldr.w	r2, [r4], #4
				value->sint = (short)value->sint;
    149e:	17d3      	asrs	r3, r2, #31
    14a0:	e004      	b.n	14ac <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x124>
					(sint_value_type)va_arg(ap, intmax_t);
    14a2:	3407      	adds	r4, #7
    14a4:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
    14a8:	e8f4 2302 	ldrd	r2, r3, [r4], #8
				value->sint = (short)value->sint;
    14ac:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
		if (conv->invalid || conv->unsupported) {
    14b0:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    14b4:	f013 0603 	ands.w	r6, r3, #3
    14b8:	d055      	beq.n	1566 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x1de>
			OUTS(sp, fp);
    14ba:	464a      	mov	r2, r9
    14bc:	4659      	mov	r1, fp
    14be:	4650      	mov	r0, sl
    14c0:	9b02      	ldr	r3, [sp, #8]
    14c2:	f010 fdb0 	bl	12026 <outs>
    14c6:	2800      	cmp	r0, #0
    14c8:	f2c0 813e 	blt.w	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
    14cc:	4405      	add	r5, r0
			OUTS(bps, bpe);
    14ce:	f8dd 9008 	ldr.w	r9, [sp, #8]
    14d2:	e5f9      	b.n	10c8 <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    14d4:	f854 2b04 	ldr.w	r2, [r4], #4
			if (length_mod == LENGTH_HH) {
    14d8:	2901      	cmp	r1, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
    14da:	ea4f 73e2 	mov.w	r3, r2, asr #31
    14de:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
			if (length_mod == LENGTH_HH) {
    14e2:	d105      	bne.n	14f0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x168>
				value->uint = (unsigned char)value->uint;
    14e4:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
				value->uint = (unsigned short)value->uint;
    14e8:	930c      	str	r3, [sp, #48]	; 0x30
    14ea:	2300      	movs	r3, #0
    14ec:	930d      	str	r3, [sp, #52]	; 0x34
    14ee:	e7df      	b.n	14b0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x128>
			} else if (length_mod == LENGTH_H) {
    14f0:	2902      	cmp	r1, #2
    14f2:	d1dd      	bne.n	14b0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x128>
				value->sint = (short)value->sint;
    14f4:	f9bd 2030 	ldrsh.w	r2, [sp, #48]	; 0x30
    14f8:	e7d1      	b.n	149e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x116>
		} else if (specifier_cat == SPECIFIER_UINT) {
    14fa:	2b02      	cmp	r3, #2
    14fc:	d123      	bne.n	1546 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x1be>
			switch (length_mod) {
    14fe:	1ecb      	subs	r3, r1, #3
    1500:	2b04      	cmp	r3, #4
    1502:	d813      	bhi.n	152c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x1a4>
    1504:	e8df f003 	tbb	[pc, r3]
    1508:	120a0a03 	.word	0x120a0a03
    150c:	12          	.byte	0x12
    150d:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
    150e:	2300      	movs	r3, #0
					value->uint = (wchar_t)va_arg(ap,
    1510:	6822      	ldr	r2, [r4, #0]
    1512:	1d20      	adds	r0, r4, #4
    1514:	920c      	str	r2, [sp, #48]	; 0x30
    1516:	930d      	str	r3, [sp, #52]	; 0x34
					(uint_value_type)va_arg(ap, size_t);
    1518:	4604      	mov	r4, r0
    151a:	e7c9      	b.n	14b0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x128>
					(uint_value_type)va_arg(ap,
    151c:	3407      	adds	r4, #7
    151e:	f024 0007 	bic.w	r0, r4, #7
				value->uint =
    1522:	e8f0 2302 	ldrd	r2, r3, [r0], #8
    1526:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
				break;
    152a:	e7f5      	b.n	1518 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x190>
					(uint_value_type)va_arg(ap, size_t);
    152c:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
    1530:	2901      	cmp	r1, #1
					(uint_value_type)va_arg(ap, size_t);
    1532:	930c      	str	r3, [sp, #48]	; 0x30
    1534:	f04f 0300 	mov.w	r3, #0
    1538:	930d      	str	r3, [sp, #52]	; 0x34
			if (length_mod == LENGTH_HH) {
    153a:	d0d3      	beq.n	14e4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x15c>
			} else if (length_mod == LENGTH_H) {
    153c:	2902      	cmp	r1, #2
    153e:	d1b7      	bne.n	14b0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x128>
				value->uint = (unsigned short)value->uint;
    1540:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    1544:	e7d0      	b.n	14e8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x160>
		} else if (specifier_cat == SPECIFIER_FP) {
    1546:	2b04      	cmp	r3, #4
    1548:	d107      	bne.n	155a <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x1d2>
			if (length_mod == LENGTH_UPPER_L) {
    154a:	3407      	adds	r4, #7
    154c:	f024 0407 	bic.w	r4, r4, #7
    1550:	e8f4 2302 	ldrd	r2, r3, [r4], #8
				value->ldbl = va_arg(ap, long double);
    1554:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    1558:	e7aa      	b.n	14b0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x128>
		} else if (specifier_cat == SPECIFIER_PTR) {
    155a:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
    155c:	bf04      	itt	eq
    155e:	f854 3b04 	ldreq.w	r3, [r4], #4
    1562:	930c      	streq	r3, [sp, #48]	; 0x30
    1564:	e7a4      	b.n	14b0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x128>
		switch (conv->specifier) {
    1566:	f89d 003b 	ldrb.w	r0, [sp, #59]	; 0x3b
    156a:	2878      	cmp	r0, #120	; 0x78
    156c:	d8af      	bhi.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
    156e:	2862      	cmp	r0, #98	; 0x62
    1570:	d820      	bhi.n	15b4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x22c>
    1572:	2825      	cmp	r0, #37	; 0x25
    1574:	f43f adb2 	beq.w	10dc <cbvprintf+0x24>
    1578:	2858      	cmp	r0, #88	; 0x58
    157a:	d1a8      	bne.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
			bps = encode_uint(value->uint, conv, buf, bpe);
    157c:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    1580:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
    1584:	9300      	str	r3, [sp, #0]
    1586:	aa0e      	add	r2, sp, #56	; 0x38
    1588:	ab06      	add	r3, sp, #24
    158a:	f7ff fd45 	bl	1018 <encode_uint>
    158e:	4681      	mov	r9, r0
			if (precision >= 0) {
    1590:	2f00      	cmp	r7, #0
    1592:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
    1596:	db0b      	blt.n	15b0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x228>
				conv->flag_zero = false;
    1598:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
				size_t len = bpe - bps;
    159c:	eba0 0309 	sub.w	r3, r0, r9
				conv->flag_zero = false;
    15a0:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
    15a4:	429f      	cmp	r7, r3
				conv->flag_zero = false;
    15a6:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
				if (len < (size_t)precision) {
    15aa:	d901      	bls.n	15b0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x228>
					conv->pad0_value = precision - (int)len;
    15ac:	1aff      	subs	r7, r7, r3
    15ae:	970f      	str	r7, [sp, #60]	; 0x3c
		const char *bpe = buf + sizeof(buf);
    15b0:	4607      	mov	r7, r0
    15b2:	e03c      	b.n	162e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2a6>
    15b4:	3863      	subs	r0, #99	; 0x63
    15b6:	2815      	cmp	r0, #21
    15b8:	d889      	bhi.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
    15ba:	a201      	add	r2, pc, #4	; (adr r2, 15c0 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x238>)
    15bc:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
    15c0:	0000163f 	.word	0x0000163f
    15c4:	000016a1 	.word	0x000016a1
    15c8:	000014cf 	.word	0x000014cf
    15cc:	000014cf 	.word	0x000014cf
    15d0:	000014cf 	.word	0x000014cf
    15d4:	000014cf 	.word	0x000014cf
    15d8:	000016a1 	.word	0x000016a1
    15dc:	000014cf 	.word	0x000014cf
    15e0:	000014cf 	.word	0x000014cf
    15e4:	000014cf 	.word	0x000014cf
    15e8:	000014cf 	.word	0x000014cf
    15ec:	000016ff 	.word	0x000016ff
    15f0:	000016cd 	.word	0x000016cd
    15f4:	000016d1 	.word	0x000016d1
    15f8:	000014cf 	.word	0x000014cf
    15fc:	000014cf 	.word	0x000014cf
    1600:	00001619 	.word	0x00001619
    1604:	000014cf 	.word	0x000014cf
    1608:	000016cd 	.word	0x000016cd
    160c:	000014cf 	.word	0x000014cf
    1610:	000014cf 	.word	0x000014cf
    1614:	000016cd 	.word	0x000016cd
			if (precision >= 0) {
    1618:	2f00      	cmp	r7, #0
			bps = (const char *)value->ptr;
    161a:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
			if (precision >= 0) {
    161e:	db0a      	blt.n	1636 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2ae>
				len = strnlen(bps, precision);
    1620:	4639      	mov	r1, r7
    1622:	4648      	mov	r0, r9
    1624:	f01c f9df 	bl	1d9e6 <strnlen>
		char sign = 0;
    1628:	2600      	movs	r6, #0
			bpe = bps + len;
    162a:	eb09 0700 	add.w	r7, r9, r0
		if (bps == NULL) {
    162e:	f1b9 0f00 	cmp.w	r9, #0
    1632:	d10c      	bne.n	164e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2c6>
    1634:	e74b      	b.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
				len = strlen(bps);
    1636:	4648      	mov	r0, r9
    1638:	f7fe ff14 	bl	464 <strlen>
    163c:	e7f4      	b.n	1628 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2a0>
			break;
    163e:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    1640:	9b0c      	ldr	r3, [sp, #48]	; 0x30
			bpe = buf + 1;
    1642:	f10d 0719 	add.w	r7, sp, #25
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    1646:	f88d 3018 	strb.w	r3, [sp, #24]
			bps = buf;
    164a:	f10d 0918 	add.w	r9, sp, #24
		size_t nj_len = (bpe - bps);
    164e:	eba7 0309 	sub.w	r3, r7, r9
		if (sign != 0) {
    1652:	b106      	cbz	r6, 1656 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2ce>
			nj_len += 1U;
    1654:	3301      	adds	r3, #1
		if (conv->altform_0c) {
    1656:	f89d 203a 	ldrb.w	r2, [sp, #58]	; 0x3a
    165a:	06d0      	lsls	r0, r2, #27
    165c:	d569      	bpl.n	1732 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3aa>
			nj_len += 2U;
    165e:	3302      	adds	r3, #2
		if (conv->pad_fp) {
    1660:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
    1662:	990f      	ldr	r1, [sp, #60]	; 0x3c
			nj_len += conv->pad0_pre_exp;
    1664:	bf48      	it	mi
    1666:	9a10      	ldrmi	r2, [sp, #64]	; 0x40
		nj_len += conv->pad0_value;
    1668:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
    166a:	bf48      	it	mi
    166c:	189b      	addmi	r3, r3, r2
		if (width > 0) {
    166e:	f1b8 0f00 	cmp.w	r8, #0
    1672:	dd76      	ble.n	1762 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3da>
			if (!conv->flag_dash) {
    1674:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
			width -= (int)nj_len;
    1678:	eba8 0803 	sub.w	r8, r8, r3
			if (!conv->flag_dash) {
    167c:	f3c2 0380 	ubfx	r3, r2, #2, #1
    1680:	9303      	str	r3, [sp, #12]
    1682:	0753      	lsls	r3, r2, #29
    1684:	d46d      	bmi.n	1762 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3da>
				if (conv->flag_zero) {
    1686:	0650      	lsls	r0, r2, #25
    1688:	d561      	bpl.n	174e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c6>
					if (sign != 0) {
    168a:	b13e      	cbz	r6, 169c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x314>
						OUTC(sign);
    168c:	4659      	mov	r1, fp
    168e:	4630      	mov	r0, r6
    1690:	47d0      	blx	sl
    1692:	2800      	cmp	r0, #0
    1694:	db58      	blt.n	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
						sign = 0;
    1696:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
    1698:	3501      	adds	r5, #1
						sign = 0;
    169a:	461e      	mov	r6, r3
					pad = '0';
    169c:	2330      	movs	r3, #48	; 0x30
    169e:	e057      	b.n	1750 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c8>
			if (conv->flag_plus) {
    16a0:	071e      	lsls	r6, r3, #28
    16a2:	d411      	bmi.n	16c8 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x340>
				sign = ' ';
    16a4:	f013 0610 	ands.w	r6, r3, #16
    16a8:	bf18      	it	ne
    16aa:	2620      	movne	r6, #32
			if (value->sint < 0) {
    16ac:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
    16b0:	2a00      	cmp	r2, #0
    16b2:	f173 0100 	sbcs.w	r1, r3, #0
    16b6:	f6bf af61 	bge.w	157c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x1f4>
				value->uint = (uint_value_type)-value->sint;
    16ba:	4252      	negs	r2, r2
    16bc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
    16c0:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-value->sint;
    16c2:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    16c6:	e759      	b.n	157c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x1f4>
				sign = '+';
    16c8:	262b      	movs	r6, #43	; 0x2b
    16ca:	e7ef      	b.n	16ac <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x324>
		switch (conv->specifier) {
    16cc:	2600      	movs	r6, #0
    16ce:	e755      	b.n	157c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x1f4>
			if (value->ptr != NULL) {
    16d0:	980c      	ldr	r0, [sp, #48]	; 0x30
    16d2:	b348      	cbz	r0, 1728 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3a0>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    16d4:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
    16d8:	9300      	str	r3, [sp, #0]
    16da:	2100      	movs	r1, #0
    16dc:	ab06      	add	r3, sp, #24
    16de:	aa0e      	add	r2, sp, #56	; 0x38
    16e0:	f7ff fc9a 	bl	1018 <encode_uint>
				conv->altform_0c = true;
    16e4:	f8bd 303a 	ldrh.w	r3, [sp, #58]	; 0x3a
				bps = encode_uint((uintptr_t)value->ptr, conv,
    16e8:	4681      	mov	r9, r0
				conv->altform_0c = true;
    16ea:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    16ee:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
    16f2:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
    16f6:	2600      	movs	r6, #0
				conv->altform_0c = true;
    16f8:	f8ad 303a 	strh.w	r3, [sp, #58]	; 0x3a
				goto prec_int_pad0;
    16fc:	e748      	b.n	1590 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x208>
				store_count(conv, value->ptr, count);
    16fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	switch ((enum length_mod_enum)conv->length_mod) {
    1700:	2907      	cmp	r1, #7
    1702:	f63f aee4 	bhi.w	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
    1706:	e8df f001 	tbb	[pc, r1]
    170a:	040d      	.short	0x040d
    170c:	08080d06 	.word	0x08080d06
    1710:	0d0d      	.short	0x0d0d
		*(signed char *)dp = (signed char)count;
    1712:	701d      	strb	r5, [r3, #0]
		break;
    1714:	e6db      	b.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
		*(short *)dp = (short)count;
    1716:	801d      	strh	r5, [r3, #0]
		break;
    1718:	e6d9      	b.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
		*(intmax_t *)dp = (intmax_t)count;
    171a:	4628      	mov	r0, r5
    171c:	17e9      	asrs	r1, r5, #31
    171e:	e9c3 0100 	strd	r0, r1, [r3]
		break;
    1722:	e6d4      	b.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    1724:	601d      	str	r5, [r3, #0]
		break;
    1726:	e6d2      	b.n	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
			bpe = bps + 5;
    1728:	4f2e      	ldr	r7, [pc, #184]	; (17e4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x45c>)
    172a:	4606      	mov	r6, r0
			bps = "(nil)";
    172c:	f1a7 0905 	sub.w	r9, r7, #5
    1730:	e78d      	b.n	164e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2c6>
		} else if (conv->altform_0) {
    1732:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
    1734:	bf48      	it	mi
    1736:	3301      	addmi	r3, #1
    1738:	e792      	b.n	1660 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x2d8>
					OUTC(pad);
    173a:	4618      	mov	r0, r3
    173c:	4659      	mov	r1, fp
    173e:	9303      	str	r3, [sp, #12]
    1740:	47d0      	blx	sl
    1742:	2800      	cmp	r0, #0
    1744:	9b03      	ldr	r3, [sp, #12]
    1746:	da04      	bge.n	1752 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3ca>
#undef OUTS
#undef OUTC
}
    1748:	b013      	add	sp, #76	; 0x4c
    174a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
    174e:	2320      	movs	r3, #32
    1750:	4445      	add	r5, r8
    1752:	4642      	mov	r2, r8
				while (width-- > 0) {
    1754:	2a00      	cmp	r2, #0
    1756:	eba5 0108 	sub.w	r1, r5, r8
    175a:	f108 38ff 	add.w	r8, r8, #4294967295
    175e:	dcec      	bgt.n	173a <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3b2>
    1760:	460d      	mov	r5, r1
		if (sign != 0) {
    1762:	b12e      	cbz	r6, 1770 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3e8>
			OUTC(sign);
    1764:	4659      	mov	r1, fp
    1766:	4630      	mov	r0, r6
    1768:	47d0      	blx	sl
    176a:	2800      	cmp	r0, #0
    176c:	dbec      	blt.n	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
    176e:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
    1770:	f89d 303a 	ldrb.w	r3, [sp, #58]	; 0x3a
    1774:	06d9      	lsls	r1, r3, #27
    1776:	d401      	bmi.n	177c <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3f4>
    1778:	071a      	lsls	r2, r3, #28
    177a:	d505      	bpl.n	1788 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x400>
				OUTC('0');
    177c:	4659      	mov	r1, fp
    177e:	2030      	movs	r0, #48	; 0x30
    1780:	47d0      	blx	sl
    1782:	2800      	cmp	r0, #0
    1784:	dbe0      	blt.n	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
    1786:	3501      	adds	r5, #1
			if (conv->altform_0c) {
    1788:	f89d 303a 	ldrb.w	r3, [sp, #58]	; 0x3a
    178c:	06db      	lsls	r3, r3, #27
    178e:	d506      	bpl.n	179e <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x416>
				OUTC(conv->specifier);
    1790:	4659      	mov	r1, fp
    1792:	f89d 003b 	ldrb.w	r0, [sp, #59]	; 0x3b
    1796:	47d0      	blx	sl
    1798:	2800      	cmp	r0, #0
    179a:	dbd5      	blt.n	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
    179c:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
    179e:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    17a0:	442e      	add	r6, r5
    17a2:	1b73      	subs	r3, r6, r5
    17a4:	2b00      	cmp	r3, #0
    17a6:	dc15      	bgt.n	17d4 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x44c>
			OUTS(bps, bpe);
    17a8:	463b      	mov	r3, r7
    17aa:	464a      	mov	r2, r9
    17ac:	4659      	mov	r1, fp
    17ae:	4650      	mov	r0, sl
    17b0:	f010 fc39 	bl	12026 <outs>
    17b4:	2800      	cmp	r0, #0
    17b6:	dbc7      	blt.n	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
    17b8:	4405      	add	r5, r0
		while (width > 0) {
    17ba:	44a8      	add	r8, r5
    17bc:	eba8 0305 	sub.w	r3, r8, r5
    17c0:	2b00      	cmp	r3, #0
    17c2:	f77f ae84 	ble.w	14ce <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x146>
			OUTC(' ');
    17c6:	4659      	mov	r1, fp
    17c8:	2020      	movs	r0, #32
    17ca:	47d0      	blx	sl
    17cc:	2800      	cmp	r0, #0
    17ce:	dbbb      	blt.n	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
    17d0:	3501      	adds	r5, #1
			--width;
    17d2:	e7f3      	b.n	17bc <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x434>
				OUTC('0');
    17d4:	4659      	mov	r1, fp
    17d6:	2030      	movs	r0, #48	; 0x30
    17d8:	47d0      	blx	sl
    17da:	2800      	cmp	r0, #0
    17dc:	dbb4      	blt.n	1748 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3c0>
    17de:	3501      	adds	r5, #1
    17e0:	e7df      	b.n	17a2 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x41a>
    17e2:	bf00      	nop
    17e4:	00043ba4 	.word	0x00043ba4

000017e8 <check_erratum19>:
    #ifndef NRF53_SERIES
        return false;
    #else
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined(NRF_APPLICATION)
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    17e8:	4b09      	ldr	r3, [pc, #36]	; (1810 <check_erratum19+0x28>)
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    17ea:	681b      	ldr	r3, [r3, #0]
    17ec:	2b07      	cmp	r3, #7
    17ee:	d10d      	bne.n	180c <check_erratum19+0x24>
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    17f0:	4b08      	ldr	r3, [pc, #32]	; (1814 <check_erratum19+0x2c>)
    17f2:	681b      	ldr	r3, [r3, #0]
    17f4:	3b02      	subs	r3, #2
    17f6:	2b03      	cmp	r3, #3
    17f8:	d808      	bhi.n	180c <check_erratum19+0x24>
	!defined(CONFIG_NRF5340_CPUAPP_ERRATUM19)

static int check_erratum19(const struct device *arg)
{
	ARG_UNUSED(arg);
	if (nrf53_errata_19()) {
    17fa:	4a07      	ldr	r2, [pc, #28]	; (1818 <check_erratum19+0x30>)
    17fc:	5cd3      	ldrb	r3, [r2, r3]
    17fe:	b12b      	cbz	r3, 180c <check_erratum19+0x24>
		LOG_ERR("This device is affected by nRF53 Erratum 19,");
		LOG_ERR("but workarounds have not been enabled.");
		LOG_ERR("See CONFIG_NRF5340_CPUAPP_ERRATUM19.");
		k_panic();
    1800:	4040      	eors	r0, r0
    1802:	f380 8811 	msr	BASEPRI, r0
    1806:	f04f 0004 	mov.w	r0, #4
    180a:	df02      	svc	2
	}

	return 0;
}
    180c:	2000      	movs	r0, #0
    180e:	4770      	bx	lr
    1810:	00ff0130 	.word	0x00ff0130
    1814:	00ff0134 	.word	0x00ff0134
    1818:	00043ba5 	.word	0x00043ba5

0000181c <nrf_gpio_pin_mcu_select.constprop.0>:
        /* FALLTHROUGH */
        case 0: return NRF_P0;
#endif
#if defined(P1_FEATURE_PINS_PRESENT)
        /* FALLTHROUGH */
        case 1: return NRF_P1;
    181c:	4b09      	ldr	r3, [pc, #36]	; (1844 <nrf_gpio_pin_mcu_select.constprop.0+0x28>)
    181e:	490a      	ldr	r1, [pc, #40]	; (1848 <nrf_gpio_pin_mcu_select.constprop.0+0x2c>)
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    1820:	f000 021f 	and.w	r2, r0, #31

    return pin_number >> 5;
    1824:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    1826:	2801      	cmp	r0, #1
    1828:	bf08      	it	eq
    182a:	460b      	moveq	r3, r1
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_MCUSEL_Msk;
    182c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    1830:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    1834:	f022 42e0 	bic.w	r2, r2, #1879048192	; 0x70000000
    reg->PIN_CNF[pin_number] = cnf | (mcu << GPIO_PIN_CNF_MCUSEL_Pos);
    1838:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
    183c:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
    1840:	4770      	bx	lr
    1842:	bf00      	nop
    1844:	50842500 	.word	0x50842500
    1848:	50842800 	.word	0x50842800

0000184c <nordicsemi_nrf53_init>:
{
    184c:	b570      	push	{r4, r5, r6, lr}
    184e:	f04f 0320 	mov.w	r3, #32
    1852:	f3ef 8611 	mrs	r6, BASEPRI
    1856:	f383 8811 	msr	BASEPRI, r3
    185a:	f3bf 8f6f 	isb	sy

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_cache_enable(NRF_CACHE_Type * p_reg)
{
    p_reg->ENABLE = CACHE_ENABLE_ENABLE_Enabled;
    185e:	2401      	movs	r4, #1
}

NRF_STATIC_INLINE void nrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS_Type *     p_reg,
                                                    nrf_oscillators_lfxo_cap_t cap)
{
    p_reg->XOSC32KI.INTCAP = (uint32_t)cap;
    1860:	4d0b      	ldr	r5, [pc, #44]	; (1890 <nordicsemi_nrf53_init+0x44>)
    1862:	4b0c      	ldr	r3, [pc, #48]	; (1894 <nordicsemi_nrf53_init+0x48>)
	nrf_gpio_pin_mcu_select(PIN_XL1, NRF_GPIO_PIN_MCUSEL_PERIPHERAL);
    1864:	2000      	movs	r0, #0
    1866:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
    186a:	f8c5 46d0 	str.w	r4, [r5, #1744]	; 0x6d0
    186e:	f7ff ffd5 	bl	181c <nrf_gpio_pin_mcu_select.constprop.0>
	nrf_gpio_pin_mcu_select(PIN_XL2, NRF_GPIO_PIN_MCUSEL_PERIPHERAL);
    1872:	4620      	mov	r0, r4
    1874:	f7ff ffd2 	bl	181c <nrf_gpio_pin_mcu_select.constprop.0>
NRF_STATIC_INLINE void nrf_regulators_dcdcen_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
#if defined(REGULATORS_DCDCEN_DCDCEN_Msk)
    p_reg->DCDCEN = (enable ? REGULATORS_DCDCEN_DCDCEN_Msk : 0);
#else
    p_reg->VREGMAIN.DCDCEN = (enable ? REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Msk : 0);
    1878:	f8c5 4704 	str.w	r4, [r5, #1796]	; 0x704
#endif

#if NRF_REGULATORS_HAS_DCDCEN_RADIO
NRF_STATIC_INLINE void nrf_regulators_dcdcen_radio_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGRADIO.DCDCEN = (enable) ? REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Enabled :
    187c:	f8c5 4904 	str.w	r4, [r5, #2308]	; 0x904
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
    1880:	f8c5 4b00 	str.w	r4, [r5, #2816]	; 0xb00
	__asm__ volatile(
    1884:	f386 8811 	msr	BASEPRI, r6
    1888:	f3bf 8f6f 	isb	sy
}
    188c:	2000      	movs	r0, #0
    188e:	bd70      	pop	{r4, r5, r6, pc}
    1890:	50004000 	.word	0x50004000
    1894:	50001000 	.word	0x50001000

00001898 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    1898:	b148      	cbz	r0, 18ae <arch_busy_wait+0x16>

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    189a:	4b05      	ldr	r3, [pc, #20]	; (18b0 <arch_busy_wait+0x18>)
    189c:	681a      	ldr	r2, [r3, #0]
    189e:	4b05      	ldr	r3, [pc, #20]	; (18b4 <arch_busy_wait+0x1c>)
    18a0:	fbb2 f2f3 	udiv	r2, r2, r3
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    18a4:	4b04      	ldr	r3, [pc, #16]	; (18b8 <arch_busy_wait+0x20>)
    delay_cycles(cycles);
    18a6:	4350      	muls	r0, r2
    18a8:	f043 0301 	orr.w	r3, r3, #1
    18ac:	4718      	bx	r3
}
    18ae:	4770      	bx	lr
    18b0:	2000047c 	.word	0x2000047c
    18b4:	000f4240 	.word	0x000f4240
    18b8:	0001dda0 	.word	0x0001dda0

000018bc <virtio_set_status>:
	return *(volatile uint8_t *)addr;
}

static ALWAYS_INLINE void sys_write8(uint8_t data, mem_addr_t addr)
{
	*(volatile uint8_t *)addr = data;
    18bc:	4b01      	ldr	r3, [pc, #4]	; (18c4 <virtio_set_status+0x8>)
    18be:	7019      	strb	r1, [r3, #0]
}

static void virtio_set_status(struct virtio_device *vdev, unsigned char status)
{
	sys_write8(status, VDEV_STATUS_ADDR);
}
    18c0:	4770      	bx	lr
    18c2:	bf00      	nop
    18c4:	20070000 	.word	0x20070000

000018c8 <init_status_flag>:
    18c8:	2000      	movs	r0, #0
    18ca:	4b01      	ldr	r3, [pc, #4]	; (18d0 <init_status_flag+0x8>)
    18cc:	7018      	strb	r0, [r3, #0]
int init_status_flag(const struct device *arg)
{
	virtio_set_status(NULL, 0);

	return 0;
}
    18ce:	4770      	bx	lr
    18d0:	20070000 	.word	0x20070000

000018d4 <ipm_callback_process>:
	virtqueue_notification(vq[VIRTQUEUE_ID]);
    18d4:	4b01      	ldr	r3, [pc, #4]	; (18dc <ipm_callback_process+0x8>)
    18d6:	6818      	ldr	r0, [r3, #0]
    18d8:	f01b b9a6 	b.w	1cc28 <virtqueue_notification>
    18dc:	200012b8 	.word	0x200012b8

000018e0 <virtio_notify>:
	status = ipm_send(ipm_tx_handle, 0, 0, NULL, 0);
    18e0:	4b05      	ldr	r3, [pc, #20]	; (18f8 <virtio_notify+0x18>)
{
    18e2:	b513      	push	{r0, r1, r4, lr}
	status = ipm_send(ipm_tx_handle, 0, 0, NULL, 0);
    18e4:	6818      	ldr	r0, [r3, #0]
				  const void *data, int size)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->api;

	return api->send(ipmdev, wait, id, data, size);
    18e6:	2300      	movs	r3, #0
    18e8:	6882      	ldr	r2, [r0, #8]
    18ea:	9300      	str	r3, [sp, #0]
    18ec:	6814      	ldr	r4, [r2, #0]
    18ee:	4619      	mov	r1, r3
    18f0:	461a      	mov	r2, r3
    18f2:	47a0      	blx	r4
}
    18f4:	b002      	add	sp, #8
    18f6:	bd10      	pop	{r4, pc}
    18f8:	200012a8 	.word	0x200012a8

000018fc <ipm_callback>:
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    18fc:	4907      	ldr	r1, [pc, #28]	; (191c <ipm_callback+0x20>)
    18fe:	e8d1 3fef 	ldaex	r3, [r1]
    1902:	f043 0201 	orr.w	r2, r3, #1
    1906:	e8c1 2fe0 	stlex	r0, r2, [r1]
    190a:	2800      	cmp	r0, #0
    190c:	d1f7      	bne.n	18fe <ipm_callback+0x2>
 * @return N/A
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    190e:	07db      	lsls	r3, r3, #31
    1910:	d403      	bmi.n	191a <ipm_callback+0x1e>
		k_queue_append(&work_q->queue, work);
    1912:	4803      	ldr	r0, [pc, #12]	; (1920 <ipm_callback+0x24>)
    1914:	3908      	subs	r1, #8
    1916:	f01b bc2b 	b.w	1d170 <k_queue_append>
}
    191a:	4770      	bx	lr
    191c:	200012b4 	.word	0x200012b4
    1920:	20000a38 	.word	0x20000a38

00001924 <rpmsg_backend_init>:
{
    1924:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
    1926:	4b39      	ldr	r3, [pc, #228]	; (1a0c <rpmsg_backend_init+0xe8>)
{
    1928:	b085      	sub	sp, #20
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
    192a:	ac02      	add	r4, sp, #8
{
    192c:	4606      	mov	r6, r0
    192e:	460d      	mov	r5, r1
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
    1930:	e893 0003 	ldmia.w	r3, {r0, r1}
	k_work_q_start(&ipm_work_q, ipm_stack_area,
    1934:	f44f 6200 	mov.w	r2, #2048	; 0x800
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
    1938:	e884 0003 	stmia.w	r4, {r0, r1}
	k_work_q_start(&ipm_work_q, ipm_stack_area,
    193c:	f04f 33ff 	mov.w	r3, #4294967295
    1940:	4933      	ldr	r1, [pc, #204]	; (1a10 <rpmsg_backend_init+0xec>)
    1942:	4834      	ldr	r0, [pc, #208]	; (1a14 <rpmsg_backend_init+0xf0>)
    1944:	f00f fb5c 	bl	11000 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
    1948:	4933      	ldr	r1, [pc, #204]	; (1a18 <rpmsg_backend_init+0xf4>)
    194a:	4834      	ldr	r0, [pc, #208]	; (1a1c <rpmsg_backend_init+0xf8>)
    194c:	f01b fd76 	bl	1d43c <z_impl_k_thread_name_set>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    1950:	2200      	movs	r2, #0
    1952:	4b33      	ldr	r3, [pc, #204]	; (1a20 <rpmsg_backend_init+0xfc>)
    1954:	4933      	ldr	r1, [pc, #204]	; (1a24 <rpmsg_backend_init+0x100>)
	err = metal_init(&metal_params);
    1956:	4620      	mov	r0, r4
    1958:	e9c3 1201 	strd	r1, r2, [r3, #4]
    195c:	601a      	str	r2, [r3, #0]
    195e:	f006 fe17 	bl	8590 <metal_init>
	if (err) {
    1962:	4604      	mov	r4, r0
    1964:	b978      	cbnz	r0, 1986 <rpmsg_backend_init+0x62>
	err = metal_register_generic_device(&shm_device);
    1966:	4830      	ldr	r0, [pc, #192]	; (1a28 <rpmsg_backend_init+0x104>)
    1968:	f006 fdf2 	bl	8550 <metal_register_generic_device>
	if (err) {
    196c:	4604      	mov	r4, r0
    196e:	b950      	cbnz	r0, 1986 <rpmsg_backend_init+0x62>
	err = metal_device_open("generic", SHM_DEVICE_NAME, &device);
    1970:	492e      	ldr	r1, [pc, #184]	; (1a2c <rpmsg_backend_init+0x108>)
    1972:	482f      	ldr	r0, [pc, #188]	; (1a30 <rpmsg_backend_init+0x10c>)
    1974:	aa01      	add	r2, sp, #4
    1976:	f013 fd37 	bl	153e8 <metal_device_open>
	if (err) {
    197a:	4604      	mov	r4, r0
    197c:	b918      	cbnz	r0, 1986 <rpmsg_backend_init+0x62>
	*io = metal_device_io_region(device, 0);
    197e:	9b01      	ldr	r3, [sp, #4]
static inline struct metal_io_region *
metal_device_io_region(struct metal_device *device, unsigned int index)
{
	return (index < device->num_regions
		? &device->regions[index]
		: NULL);
    1980:	689a      	ldr	r2, [r3, #8]
    1982:	b91a      	cbnz	r2, 198c <rpmsg_backend_init+0x68>
    1984:	6030      	str	r0, [r6, #0]
}
    1986:	4620      	mov	r0, r4
    1988:	b005      	add	sp, #20
    198a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    198c:	330c      	adds	r3, #12
	*io = metal_device_io_region(device, 0);
    198e:	6033      	str	r3, [r6, #0]
	if (!*io) {
    1990:	2b00      	cmp	r3, #0
    1992:	d0f8      	beq.n	1986 <rpmsg_backend_init+0x62>
    1994:	4827      	ldr	r0, [pc, #156]	; (1a34 <rpmsg_backend_init+0x110>)
    1996:	f00e fb29 	bl	ffec <z_impl_device_get_binding>
	ipm_tx_handle = device_get_binding(CONFIG_RPMSG_SERVICE_IPM_TX_NAME);
    199a:	4f27      	ldr	r7, [pc, #156]	; (1a38 <rpmsg_backend_init+0x114>)
    199c:	6038      	str	r0, [r7, #0]
    199e:	4827      	ldr	r0, [pc, #156]	; (1a3c <rpmsg_backend_init+0x118>)
    19a0:	f00e fb24 	bl	ffec <z_impl_device_get_binding>
	if (!ipm_tx_handle) {
    19a4:	683a      	ldr	r2, [r7, #0]
    19a6:	2a00      	cmp	r2, #0
    19a8:	d02c      	beq.n	1a04 <rpmsg_backend_init+0xe0>
	if (!ipm_rx_handle) {
    19aa:	2800      	cmp	r0, #0
    19ac:	d02a      	beq.n	1a04 <rpmsg_backend_init+0xe0>
					 ipm_callback_t cb, void *user_data)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->api;

	api->register_callback(ipmdev, cb, user_data);
    19ae:	6883      	ldr	r3, [r0, #8]
    19b0:	4622      	mov	r2, r4
    19b2:	685b      	ldr	r3, [r3, #4]
    19b4:	4922      	ldr	r1, [pc, #136]	; (1a40 <rpmsg_backend_init+0x11c>)
    19b6:	4798      	blx	r3
	vq[0] = virtqueue_allocate(VRING_SIZE);
    19b8:	f010 fb53 	bl	12062 <virtqueue_allocate.constprop.0>
    19bc:	4f21      	ldr	r7, [pc, #132]	; (1a44 <rpmsg_backend_init+0x120>)
    19be:	6038      	str	r0, [r7, #0]
	if (!vq[0]) {
    19c0:	b910      	cbnz	r0, 19c8 <rpmsg_backend_init+0xa4>
		return -ENOMEM;
    19c2:	f06f 040b 	mvn.w	r4, #11
    19c6:	e7de      	b.n	1986 <rpmsg_backend_init+0x62>
	vq[1] = virtqueue_allocate(VRING_SIZE);
    19c8:	f010 fb4b 	bl	12062 <virtqueue_allocate.constprop.0>
    19cc:	6078      	str	r0, [r7, #4]
	if (!vq[1]) {
    19ce:	2800      	cmp	r0, #0
    19d0:	d0f7      	beq.n	19c2 <rpmsg_backend_init+0x9e>
	rvrings[0].io = *io;
    19d2:	6832      	ldr	r2, [r6, #0]
    19d4:	4b1c      	ldr	r3, [pc, #112]	; (1a48 <rpmsg_backend_init+0x124>)
	rvrings[0].info.num_descs = VRING_SIZE;
    19d6:	2110      	movs	r1, #16
	rvrings[0].io = *io;
    19d8:	615a      	str	r2, [r3, #20]
	rvrings[0].info.vaddr = (void *)VRING_TX_ADDRESS;
    19da:	4a1c      	ldr	r2, [pc, #112]	; (1a4c <rpmsg_backend_init+0x128>)
	rvrings[0].vq = vq[0];
    19dc:	683f      	ldr	r7, [r7, #0]
	rvrings[0].info.vaddr = (void *)VRING_TX_ADDRESS;
    19de:	605a      	str	r2, [r3, #4]
	rvrings[0].info.align = VRING_ALIGNMENT;
    19e0:	2204      	movs	r2, #4
	rvrings[1].io = *io;
    19e2:	6836      	ldr	r6, [r6, #0]
	rvrings[0].info.align = VRING_ALIGNMENT;
    19e4:	609a      	str	r2, [r3, #8]
	rvrings[1].info.align = VRING_ALIGNMENT;
    19e6:	621a      	str	r2, [r3, #32]
	vdev->vrings_num = VRING_COUNT;
    19e8:	2202      	movs	r2, #2
	rvrings[1].io = *io;
    19ea:	62de      	str	r6, [r3, #44]	; 0x2c
	rvrings[1].info.vaddr = (void *)VRING_RX_ADDRESS;
    19ec:	4e18      	ldr	r6, [pc, #96]	; (1a50 <rpmsg_backend_init+0x12c>)
	vdev->vrings_num = VRING_COUNT;
    19ee:	62aa      	str	r2, [r5, #40]	; 0x28
	vdev->func = &dispatch;
    19f0:	4a18      	ldr	r2, [pc, #96]	; (1a54 <rpmsg_backend_init+0x130>)
	rvrings[1].info.num_descs = VRING_SIZE;
    19f2:	8499      	strh	r1, [r3, #36]	; 0x24
	rvrings[1].info.vaddr = (void *)VRING_RX_ADDRESS;
    19f4:	61de      	str	r6, [r3, #28]
	rvrings[1].vq = vq[1];
    19f6:	6198      	str	r0, [r3, #24]
	rvrings[0].info.num_descs = VRING_SIZE;
    19f8:	8199      	strh	r1, [r3, #12]
	rvrings[0].vq = vq[0];
    19fa:	601f      	str	r7, [r3, #0]
	vdev->role = RPMSG_ROLE;
    19fc:	61ac      	str	r4, [r5, #24]
	vdev->func = &dispatch;
    19fe:	622a      	str	r2, [r5, #32]
	vdev->vrings_info = &rvrings[0];
    1a00:	62eb      	str	r3, [r5, #44]	; 0x2c
	return 0;
    1a02:	e7c0      	b.n	1986 <rpmsg_backend_init+0x62>
		return -ENODEV;
    1a04:	f06f 0412 	mvn.w	r4, #18
    1a08:	e7bd      	b.n	1986 <rpmsg_backend_init+0x62>
    1a0a:	bf00      	nop
    1a0c:	0001dd44 	.word	0x0001dd44
    1a10:	2002b080 	.word	0x2002b080
    1a14:	20000a38 	.word	0x20000a38
    1a18:	00043ba9 	.word	0x00043ba9
    1a1c:	20000a50 	.word	0x20000a50
    1a20:	200012ac 	.word	0x200012ac
    1a24:	000018d5 	.word	0x000018d5
    1a28:	20000260 	.word	0x20000260
    1a2c:	00043bb4 	.word	0x00043bb4
    1a30:	00043bbe 	.word	0x00043bbe
    1a34:	00043bc6 	.word	0x00043bc6
    1a38:	200012a8 	.word	0x200012a8
    1a3c:	00043bcc 	.word	0x00043bcc
    1a40:	000018fd 	.word	0x000018fd
    1a44:	200012b8 	.word	0x200012b8
    1a48:	20000230 	.word	0x20000230
    1a4c:	2007fc00 	.word	0x2007fc00
    1a50:	2007f800 	.word	0x2007f800
    1a54:	0001ea40 	.word	0x0001ea40

00001a58 <ns_bind_cb>:
#if MASTER

static void ns_bind_cb(struct rpmsg_device *rdev,
					const char *name,
					uint32_t dest)
{
    1a58:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    1a5c:	460d      	mov	r5, r1
	int err;

	for (int i = 0; i < CONFIG_RPMSG_SERVICE_NUM_ENDPOINTS; ++i) {
		if (strcmp(name, endpoints[i].name) == 0) {
    1a5e:	4c13      	ldr	r4, [pc, #76]	; (1aac <ns_bind_cb+0x54>)
{
    1a60:	4606      	mov	r6, r0
		if (strcmp(name, endpoints[i].name) == 0) {
    1a62:	6821      	ldr	r1, [r4, #0]
    1a64:	4628      	mov	r0, r5
{
    1a66:	4617      	mov	r7, r2
		if (strcmp(name, endpoints[i].name) == 0) {
    1a68:	f7fe fcf2 	bl	450 <strcmp>
    1a6c:	46a0      	mov	r8, r4
    1a6e:	b128      	cbz	r0, 1a7c <ns_bind_cb+0x24>
    1a70:	4628      	mov	r0, r5
    1a72:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
    1a74:	f7fe fcec 	bl	450 <strcmp>
    1a78:	b9a8      	cbnz	r0, 1aa6 <ns_bind_cb+0x4e>
	for (int i = 0; i < CONFIG_RPMSG_SERVICE_NUM_ENDPOINTS; ++i) {
    1a7a:	2001      	movs	r0, #1
			err = rpmsg_create_ept(&endpoints[i].ep,
    1a7c:	244c      	movs	r4, #76	; 0x4c
    1a7e:	4344      	muls	r4, r0
    1a80:	4b0b      	ldr	r3, [pc, #44]	; (1ab0 <ns_bind_cb+0x58>)
    1a82:	f104 0008 	add.w	r0, r4, #8
    1a86:	9302      	str	r3, [sp, #8]
    1a88:	4444      	add	r4, r8
    1a8a:	6863      	ldr	r3, [r4, #4]
    1a8c:	462a      	mov	r2, r5
    1a8e:	e9cd 7300 	strd	r7, r3, [sp]
    1a92:	4631      	mov	r1, r6
    1a94:	f04f 33ff 	mov.w	r3, #4294967295
    1a98:	4440      	add	r0, r8
    1a9a:	f00e f84d 	bl	fb38 <rpmsg_create_ept>
						   RPMSG_ADDR_ANY,
						   dest,
						   endpoints[i].cb,
						   rpmsg_service_unbind);

			if (err != 0) {
    1a9e:	b910      	cbnz	r0, 1aa6 <ns_bind_cb+0x4e>
				LOG_ERR("Creating remote endpoint %s"
					" failed wirh error %d", name, err);
			} else {
				endpoints[i].bound = true;
    1aa0:	2301      	movs	r3, #1
    1aa2:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
			return;
		}
	}

	LOG_ERR("Remote endpoint %s not registered locally", name);
}
    1aa6:	b004      	add	sp, #16
    1aa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1aac:	200012c0 	.word	0x200012c0
    1ab0:	0001207d 	.word	0x0001207d

00001ab4 <rpmsg_service_init>:

#endif

static int rpmsg_service_init(const struct device *dev)
{
    1ab4:	b537      	push	{r0, r1, r2, r4, r5, lr}

	(void)dev;

	LOG_DBG("RPMsg service initialization start");

	err = rpmsg_backend_init(&io, &vdev);
    1ab6:	4c0d      	ldr	r4, [pc, #52]	; (1aec <rpmsg_service_init+0x38>)
    1ab8:	490d      	ldr	r1, [pc, #52]	; (1af0 <rpmsg_service_init+0x3c>)
    1aba:	4620      	mov	r0, r4
    1abc:	f7ff ff32 	bl	1924 <rpmsg_backend_init>
	if (err) {
    1ac0:	b988      	cbnz	r0, 1ae6 <rpmsg_service_init+0x32>
		LOG_ERR("RPMsg backend init failed with error %d", err);
		return err;
	}

#if MASTER
	rpmsg_virtio_init_shm_pool(&shpool, (void *)SHM_START_ADDR, SHM_SIZE);
    1ac2:	4d0c      	ldr	r5, [pc, #48]	; (1af4 <rpmsg_service_init+0x40>)
    1ac4:	f44f 427c 	mov.w	r2, #64512	; 0xfc00
    1ac8:	4628      	mov	r0, r5
    1aca:	490b      	ldr	r1, [pc, #44]	; (1af8 <rpmsg_service_init+0x44>)
    1acc:	f01b fa23 	bl	1cf16 <rpmsg_virtio_init_shm_pool>
	err = rpmsg_init_vdev(&rvdev, &vdev, ns_bind_cb, io, &shpool);
    1ad0:	6823      	ldr	r3, [r4, #0]
    1ad2:	4a0a      	ldr	r2, [pc, #40]	; (1afc <rpmsg_service_init+0x48>)
    1ad4:	4906      	ldr	r1, [pc, #24]	; (1af0 <rpmsg_service_init+0x3c>)
    1ad6:	480a      	ldr	r0, [pc, #40]	; (1b00 <rpmsg_service_init+0x4c>)
    1ad8:	9500      	str	r5, [sp, #0]
    1ada:	f00e f967 	bl	fdac <rpmsg_init_vdev>
#else
	err = rpmsg_init_vdev(&rvdev, &vdev, NULL, io, NULL);
#endif

	if (err) {
    1ade:	b910      	cbnz	r0, 1ae6 <rpmsg_service_init+0x32>
		LOG_ERR("rpmsg_init_vdev failed %d", err);
		return err;
	}

	ep_crt_started = true;
    1ae0:	2201      	movs	r2, #1
    1ae2:	4b08      	ldr	r3, [pc, #32]	; (1b04 <rpmsg_service_init+0x50>)
    1ae4:	701a      	strb	r2, [r3, #0]
#endif

	LOG_DBG("RPMsg service initialized");

	return 0;
}
    1ae6:	b003      	add	sp, #12
    1ae8:	bd30      	pop	{r4, r5, pc}
    1aea:	bf00      	nop
    1aec:	20001358 	.word	0x20001358
    1af0:	20000ad8 	.word	0x20000ad8
    1af4:	200013ec 	.word	0x200013ec
    1af8:	20070400 	.word	0x20070400
    1afc:	00001a59 	.word	0x00001a59
    1b00:	2000135c 	.word	0x2000135c
    1b04:	20029f3a 	.word	0x20029f3a

00001b08 <rpmsg_service_register_endpoint>:

int rpmsg_service_register_endpoint(const char *name, rpmsg_ept_cb cb)
{
	if (ep_crt_started) {
    1b08:	4b0b      	ldr	r3, [pc, #44]	; (1b38 <rpmsg_service_register_endpoint+0x30>)
{
    1b0a:	b530      	push	{r4, r5, lr}
	if (ep_crt_started) {
    1b0c:	781b      	ldrb	r3, [r3, #0]
{
    1b0e:	4604      	mov	r4, r0
	if (ep_crt_started) {
    1b10:	b95b      	cbnz	r3, 1b2a <rpmsg_service_register_endpoint+0x22>
		return -EINPROGRESS;
	}

	for (int i = 0; i < CONFIG_RPMSG_SERVICE_NUM_ENDPOINTS; ++i) {
		if (!endpoints[i].name) {
    1b12:	4b0a      	ldr	r3, [pc, #40]	; (1b3c <rpmsg_service_register_endpoint+0x34>)
    1b14:	6818      	ldr	r0, [r3, #0]
    1b16:	b110      	cbz	r0, 1b1e <rpmsg_service_register_endpoint+0x16>
    1b18:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    1b1a:	b94a      	cbnz	r2, 1b30 <rpmsg_service_register_endpoint+0x28>
	for (int i = 0; i < CONFIG_RPMSG_SERVICE_NUM_ENDPOINTS; ++i) {
    1b1c:	2001      	movs	r0, #1
			endpoints[i].name = name;
    1b1e:	224c      	movs	r2, #76	; 0x4c
    1b20:	4342      	muls	r2, r0
    1b22:	189d      	adds	r5, r3, r2
    1b24:	509c      	str	r4, [r3, r2]
			endpoints[i].cb = cb;
    1b26:	6069      	str	r1, [r5, #4]
	}

	LOG_ERR("No free slots to register endpoint %s", name);

	return -ENOMEM;
}
    1b28:	bd30      	pop	{r4, r5, pc}
		return -EINPROGRESS;
    1b2a:	f06f 0076 	mvn.w	r0, #118	; 0x76
    1b2e:	e7fb      	b.n	1b28 <rpmsg_service_register_endpoint+0x20>
	return -ENOMEM;
    1b30:	f06f 000b 	mvn.w	r0, #11
    1b34:	e7f8      	b.n	1b28 <rpmsg_service_register_endpoint+0x20>
    1b36:	bf00      	nop
    1b38:	20029f3a 	.word	0x20029f3a
    1b3c:	200012c0 	.word	0x200012c0

00001b40 <rpmsg_service_endpoint_is_bound>:

bool rpmsg_service_endpoint_is_bound(int endpoint_id)
{
	return endpoints[endpoint_id].bound;
    1b40:	224c      	movs	r2, #76	; 0x4c
    1b42:	4b03      	ldr	r3, [pc, #12]	; (1b50 <rpmsg_service_endpoint_is_bound+0x10>)
    1b44:	fb02 3000 	mla	r0, r2, r0, r3
    1b48:	f890 0048 	ldrb.w	r0, [r0, #72]	; 0x48
}
    1b4c:	4770      	bx	lr
    1b4e:	bf00      	nop
    1b50:	200012c0 	.word	0x200012c0

00001b54 <rpmsg_service_send>:

int rpmsg_service_send(int endpoint_id, const void *data, size_t len)
{
    1b54:	b537      	push	{r0, r1, r2, r4, r5, lr}
 * Returns number of bytes it has sent or negative error value on failure.
 */
static inline int rpmsg_send(struct rpmsg_endpoint *ept, const void *data,
			     int len)
{
	return rpmsg_send_offchannel_raw(ept, ept->addr, ept->dest_addr, data,
    1b56:	244c      	movs	r4, #76	; 0x4c
    1b58:	460b      	mov	r3, r1
    1b5a:	2101      	movs	r1, #1
    1b5c:	4344      	muls	r4, r0
    1b5e:	e9cd 2100 	strd	r2, r1, [sp]
    1b62:	4d05      	ldr	r5, [pc, #20]	; (1b78 <rpmsg_service_send+0x24>)
    1b64:	1928      	adds	r0, r5, r4
	return rpmsg_send(&endpoints[endpoint_id].ep, data, len);
    1b66:	3408      	adds	r4, #8
    1b68:	e9d0 120b 	ldrd	r1, r2, [r0, #44]	; 0x2c
    1b6c:	1928      	adds	r0, r5, r4
    1b6e:	f00d ffd1 	bl	fb14 <rpmsg_send_offchannel_raw>
}
    1b72:	b003      	add	sp, #12
    1b74:	bd30      	pop	{r4, r5, pc}
    1b76:	bf00      	nop
    1b78:	200012c0 	.word	0x200012c0

00001b7c <sys_reboot>:

extern void sys_arch_reboot(int type);
extern void sys_clock_disable(void);

void sys_reboot(int type)
{
    1b7c:	4604      	mov	r4, r0
    1b7e:	b508      	push	{r3, lr}
	__asm__ volatile(
    1b80:	f04f 0220 	mov.w	r2, #32
    1b84:	f3ef 8311 	mrs	r3, BASEPRI
    1b88:	f382 8811 	msr	BASEPRI, r2
    1b8c:	f3bf 8f6f 	isb	sy
	(void)irq_lock();
#ifdef CONFIG_SYS_CLOCK_EXISTS
	sys_clock_disable();
    1b90:	f010 fddb 	bl	1274a <sys_clock_disable>
#endif

	sys_arch_reboot(type);
    1b94:	4620      	mov	r0, r4
    1b96:	f001 f817 	bl	2bc8 <sys_arch_reboot>

	/* should never get here */
	printk("Failed to reboot: spinning endlessly...\n");
    1b9a:	4803      	ldr	r0, [pc, #12]	; (1ba8 <sys_reboot+0x2c>)
    1b9c:	f00f fed0 	bl	11940 <printk>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    1ba0:	f000 feca 	bl	2938 <arch_cpu_idle>
    1ba4:	e7fc      	b.n	1ba0 <sys_reboot+0x24>
    1ba6:	bf00      	nop
    1ba8:	00043bd2 	.word	0x00043bd2

00001bac <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    1bac:	b510      	push	{r4, lr}
    1bae:	4807      	ldr	r0, [pc, #28]	; (1bcc <uart_console_init+0x20>)
    1bb0:	f00e fa1c 	bl	ffec <z_impl_device_get_binding>
	__stdout_hook_install(console_out);
    1bb4:	4c06      	ldr	r4, [pc, #24]	; (1bd0 <uart_console_init+0x24>)

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    1bb6:	4b07      	ldr	r3, [pc, #28]	; (1bd4 <uart_console_init+0x28>)
    1bb8:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
    1bba:	4620      	mov	r0, r4
    1bbc:	f001 f9ae 	bl	2f1c <__stdout_hook_install>
	__printk_hook_install(console_out);
    1bc0:	4620      	mov	r0, r4
    1bc2:	f7ff f919 	bl	df8 <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
    1bc6:	2000      	movs	r0, #0
    1bc8:	bd10      	pop	{r4, pc}
    1bca:	bf00      	nop
    1bcc:	00043bfb 	.word	0x00043bfb
    1bd0:	00001bd9 	.word	0x00001bd9
    1bd4:	200013f8 	.word	0x200013f8

00001bd8 <console_out>:
	if ('\n' == c) {
    1bd8:	280a      	cmp	r0, #10
{
    1bda:	b538      	push	{r3, r4, r5, lr}
    1bdc:	4604      	mov	r4, r0
    1bde:	4d07      	ldr	r5, [pc, #28]	; (1bfc <console_out+0x24>)
	if ('\n' == c) {
    1be0:	d104      	bne.n	1bec <console_out+0x14>
    1be2:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    1be4:	6883      	ldr	r3, [r0, #8]
    1be6:	210d      	movs	r1, #13
    1be8:	685b      	ldr	r3, [r3, #4]
    1bea:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
    1bec:	6828      	ldr	r0, [r5, #0]
    1bee:	6883      	ldr	r3, [r0, #8]
    1bf0:	b2e1      	uxtb	r1, r4
    1bf2:	685b      	ldr	r3, [r3, #4]
    1bf4:	4798      	blx	r3
}
    1bf6:	4620      	mov	r0, r4
    1bf8:	bd38      	pop	{r3, r4, r5, pc}
    1bfa:	bf00      	nop
    1bfc:	200013f8 	.word	0x200013f8

00001c00 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    1c00:	4a0e      	ldr	r2, [pc, #56]	; (1c3c <onoff_stop+0x3c>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    1c02:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    1c04:	1a84      	subs	r4, r0, r2
{
    1c06:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
    1c08:	200c      	movs	r0, #12
	size_t offset = (size_t)(mgr - data->mgr);
    1c0a:	10a3      	asrs	r3, r4, #2
    1c0c:	4c0c      	ldr	r4, [pc, #48]	; (1c40 <onoff_stop+0x40>)
{
    1c0e:	460e      	mov	r6, r1
	size_t offset = (size_t)(mgr - data->mgr);
    1c10:	435c      	muls	r4, r3
    1c12:	b2e4      	uxtb	r4, r4
	err = set_off_state(&subdata->flags, ctx);
    1c14:	fb00 2004 	mla	r0, r0, r4, r2
    1c18:	2140      	movs	r1, #64	; 0x40
    1c1a:	3078      	adds	r0, #120	; 0x78
    1c1c:	f010 fa39 	bl	12092 <set_off_state>
	if (err < 0) {
    1c20:	1e01      	subs	r1, r0, #0
    1c22:	db05      	blt.n	1c30 <onoff_stop+0x30>
	get_sub_config(dev, type)->stop();
    1c24:	4b07      	ldr	r3, [pc, #28]	; (1c44 <onoff_stop+0x44>)
    1c26:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
    1c2a:	6863      	ldr	r3, [r4, #4]
    1c2c:	4798      	blx	r3
	return 0;
    1c2e:	2100      	movs	r1, #0
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
	notify(mgr, res);
    1c30:	4628      	mov	r0, r5
    1c32:	4633      	mov	r3, r6
}
    1c34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
    1c38:	4718      	bx	r3
    1c3a:	bf00      	nop
    1c3c:	2000140c 	.word	0x2000140c
    1c40:	b6db6db7 	.word	0xb6db6db7
    1c44:	0001ea78 	.word	0x0001ea78

00001c48 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    1c48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	err = set_starting_state(&subdata->flags, ctx);
    1c4c:	250c      	movs	r5, #12
	size_t offset = (size_t)(mgr - data->mgr);
    1c4e:	4e10      	ldr	r6, [pc, #64]	; (1c90 <onoff_start+0x48>)
{
    1c50:	4680      	mov	r8, r0
	size_t offset = (size_t)(mgr - data->mgr);
    1c52:	1b84      	subs	r4, r0, r6
    1c54:	10a3      	asrs	r3, r4, #2
    1c56:	4c0f      	ldr	r4, [pc, #60]	; (1c94 <onoff_start+0x4c>)
{
    1c58:	460f      	mov	r7, r1
	size_t offset = (size_t)(mgr - data->mgr);
    1c5a:	435c      	muls	r4, r3
    1c5c:	b2e4      	uxtb	r4, r4
	err = set_starting_state(&subdata->flags, ctx);
    1c5e:	4365      	muls	r5, r4
    1c60:	f105 0078 	add.w	r0, r5, #120	; 0x78
    1c64:	2140      	movs	r1, #64	; 0x40
    1c66:	4430      	add	r0, r6
    1c68:	f010 fa2c 	bl	120c4 <set_starting_state>
	if (err < 0) {
    1c6c:	1e01      	subs	r1, r0, #0
    1c6e:	db09      	blt.n	1c84 <onoff_start+0x3c>
	subdata->cb = cb;
    1c70:	4a09      	ldr	r2, [pc, #36]	; (1c98 <onoff_start+0x50>)
    1c72:	1973      	adds	r3, r6, r5
	subdata->user_data = user_data;
    1c74:	e9c3 271c 	strd	r2, r7, [r3, #112]	; 0x70
	 get_sub_config(dev, type)->start();
    1c78:	4b08      	ldr	r3, [pc, #32]	; (1c9c <onoff_start+0x54>)
    1c7a:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
		notify(mgr, err);
	}
}
    1c7e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	 get_sub_config(dev, type)->start();
    1c82:	4718      	bx	r3
		notify(mgr, err);
    1c84:	4640      	mov	r0, r8
    1c86:	463b      	mov	r3, r7
}
    1c88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		notify(mgr, err);
    1c8c:	4718      	bx	r3
    1c8e:	bf00      	nop
    1c90:	2000140c 	.word	0x2000140c
    1c94:	b6db6db7 	.word	0xb6db6db7
    1c98:	00012127 	.word	0x00012127
    1c9c:	0001ea78 	.word	0x0001ea78

00001ca0 <clk_init>:
		break;
	}
}

static int clk_init(const struct device *dev)
{
    1ca0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    1ca4:	2200      	movs	r2, #0
    1ca6:	2101      	movs	r1, #1
{
    1ca8:	4606      	mov	r6, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    1caa:	2005      	movs	r0, #5
    1cac:	f000 fd94 	bl	27d8 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    1cb0:	2005      	movs	r0, #5
    1cb2:	f000 fd73 	bl	279c <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    1cb6:	4811      	ldr	r0, [pc, #68]	; (1cfc <clk_init+0x5c>)
    1cb8:	f005 fd94 	bl	77e4 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    1cbc:	4b10      	ldr	r3, [pc, #64]	; (1d00 <clk_init+0x60>)
    1cbe:	4298      	cmp	r0, r3
    1cc0:	d119      	bne.n	1cf6 <clk_init+0x56>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    1cc2:	f013 fb2c 	bl	1531e <nrfx_clock_enable>
    1cc6:	2400      	movs	r4, #0
	return &data->mgr[type];
    1cc8:	f04f 081c 	mov.w	r8, #28
					 &transitions);
		if (err < 0) {
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    1ccc:	270c      	movs	r7, #12
		err = onoff_manager_init(get_onoff_manager(dev, i),
    1cce:	f8df 9034 	ldr.w	r9, [pc, #52]	; 1d04 <clk_init+0x64>
						get_sub_data(dev, i);
    1cd2:	68f5      	ldr	r5, [r6, #12]
		err = onoff_manager_init(get_onoff_manager(dev, i),
    1cd4:	4649      	mov	r1, r9
    1cd6:	fb08 5004 	mla	r0, r8, r4, r5
    1cda:	f00f fe8d 	bl	119f8 <onoff_manager_init>
		if (err < 0) {
    1cde:	2800      	cmp	r0, #0
    1ce0:	db07      	blt.n	1cf2 <clk_init+0x52>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    1ce2:	2301      	movs	r3, #1
    1ce4:	fb07 5504 	mla	r5, r7, r4, r5
    1ce8:	441c      	add	r4, r3
	for (enum clock_control_nrf_type i = 0;
    1cea:	2c04      	cmp	r4, #4
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    1cec:	67ab      	str	r3, [r5, #120]	; 0x78
	for (enum clock_control_nrf_type i = 0;
    1cee:	d1f0      	bne.n	1cd2 <clk_init+0x32>
	}

	return 0;
    1cf0:	2000      	movs	r0, #0
}
    1cf2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EIO;
    1cf6:	f06f 0004 	mvn.w	r0, #4
    1cfa:	e7fa      	b.n	1cf2 <clk_init+0x52>
    1cfc:	00001d3d 	.word	0x00001d3d
    1d00:	0bad0000 	.word	0x0bad0000
    1d04:	0001ea98 	.word	0x0001ea98

00001d08 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
    1d08:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
    1d0a:	230c      	movs	r3, #12
	sub_data->cb = NULL;
    1d0c:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
    1d0e:	434b      	muls	r3, r1
    1d10:	4808      	ldr	r0, [pc, #32]	; (1d34 <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
    1d12:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
    1d14:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
    1d16:	3378      	adds	r3, #120	; 0x78
	void *user_data = sub_data->user_data;
    1d18:	e9d4 561c 	ldrd	r5, r6, [r4, #112]	; 0x70
	set_on_state(&sub_data->flags);
    1d1c:	4418      	add	r0, r3
	sub_data->cb = NULL;
    1d1e:	6722      	str	r2, [r4, #112]	; 0x70
	set_on_state(&sub_data->flags);
    1d20:	f010 f9ee 	bl	12100 <set_on_state>
	if (callback) {
    1d24:	b12d      	cbz	r5, 1d32 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
    1d26:	4632      	mov	r2, r6
    1d28:	462b      	mov	r3, r5
}
    1d2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
    1d2e:	4802      	ldr	r0, [pc, #8]	; (1d38 <clkstarted_handle.constprop.0+0x30>)
    1d30:	4718      	bx	r3
}
    1d32:	bd70      	pop	{r4, r5, r6, pc}
    1d34:	2000140c 	.word	0x2000140c
    1d38:	20000648 	.word	0x20000648

00001d3c <clock_event_handler>:
	switch (event) {
    1d3c:	2805      	cmp	r0, #5
    1d3e:	d811      	bhi.n	1d64 <clock_event_handler+0x28>
    1d40:	e8df f000 	tbb	[pc, r0]
    1d44:	10100e03 	.word	0x10100e03
    1d48:	0a0c      	.short	0x0a0c
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    1d4a:	4b07      	ldr	r3, [pc, #28]	; (1d68 <clock_event_handler+0x2c>)
    1d4c:	6f98      	ldr	r0, [r3, #120]	; 0x78
    1d4e:	f010 0007 	ands.w	r0, r0, #7
    1d52:	d107      	bne.n	1d64 <clock_event_handler+0x28>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    1d54:	f7ff bfd8 	b.w	1d08 <clkstarted_handle.constprop.0>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK192M);
    1d58:	2002      	movs	r0, #2
    1d5a:	e7fb      	b.n	1d54 <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLKAUDIO);
    1d5c:	2003      	movs	r0, #3
    1d5e:	e7f9      	b.n	1d54 <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    1d60:	2001      	movs	r0, #1
    1d62:	e7f7      	b.n	1d54 <clock_event_handler+0x18>
}
    1d64:	4770      	bx	lr
    1d66:	bf00      	nop
    1d68:	2000140c 	.word	0x2000140c

00001d6c <generic_hfclk_start>:
{
    1d6c:	b508      	push	{r3, lr}
    1d6e:	f04f 0320 	mov.w	r3, #32
    1d72:	f3ef 8111 	mrs	r1, BASEPRI
    1d76:	f383 8811 	msr	BASEPRI, r3
    1d7a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    1d7e:	4a12      	ldr	r2, [pc, #72]	; (1dc8 <generic_hfclk_start+0x5c>)
    1d80:	6813      	ldr	r3, [r2, #0]
    1d82:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
    1d86:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
    1d8a:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    1d8c:	d00c      	beq.n	1da8 <generic_hfclk_start+0x3c>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    1d8e:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    1d92:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    1d96:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    1d9a:	f013 0301 	ands.w	r3, r3, #1
    1d9e:	d003      	beq.n	1da8 <generic_hfclk_start+0x3c>
			set_on_state(get_hf_flags());
    1da0:	480a      	ldr	r0, [pc, #40]	; (1dcc <generic_hfclk_start+0x60>)
    1da2:	f010 f9ad 	bl	12100 <set_on_state>
			already_started = true;
    1da6:	2301      	movs	r3, #1
	__asm__ volatile(
    1da8:	f381 8811 	msr	BASEPRI, r1
    1dac:	f3bf 8f6f 	isb	sy
	if (already_started) {
    1db0:	b123      	cbz	r3, 1dbc <generic_hfclk_start+0x50>
}
    1db2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
    1db6:	2000      	movs	r0, #0
    1db8:	f7ff bfa6 	b.w	1d08 <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    1dbc:	2001      	movs	r0, #1
}
    1dbe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    1dc2:	f005 bd1f 	b.w	7804 <nrfx_clock_start>
    1dc6:	bf00      	nop
    1dc8:	200014ac 	.word	0x200014ac
    1dcc:	20001484 	.word	0x20001484

00001dd0 <generic_hfclk_stop>:
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    1dd0:	4b07      	ldr	r3, [pc, #28]	; (1df0 <generic_hfclk_stop+0x20>)
    1dd2:	e8d3 2fef 	ldaex	r2, [r3]
    1dd6:	f022 0102 	bic.w	r1, r2, #2
    1dda:	e8c3 1fe0 	stlex	r0, r1, [r3]
    1dde:	2800      	cmp	r0, #0
    1de0:	d1f7      	bne.n	1dd2 <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    1de2:	07d3      	lsls	r3, r2, #31
    1de4:	d402      	bmi.n	1dec <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    1de6:	2001      	movs	r0, #1
    1de8:	f005 bd60 	b.w	78ac <nrfx_clock_stop>
}
    1dec:	4770      	bx	lr
    1dee:	bf00      	nop
    1df0:	200014ac 	.word	0x200014ac

00001df4 <api_blocking_start>:
{
    1df4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    1df6:	2200      	movs	r2, #0
    1df8:	2301      	movs	r3, #1
    1dfa:	e9cd 2302 	strd	r2, r3, [sp, #8]
    1dfe:	ab04      	add	r3, sp, #16
    1e00:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    1e04:	4a09      	ldr	r2, [pc, #36]	; (1e2c <api_blocking_start+0x38>)
    1e06:	466b      	mov	r3, sp
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    1e08:	f8cd d000 	str.w	sp, [sp]
    1e0c:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    1e10:	f010 f9bb 	bl	1218a <api_start>
	if (err < 0) {
    1e14:	2800      	cmp	r0, #0
    1e16:	db05      	blt.n	1e24 <api_blocking_start+0x30>
	return z_impl_k_sem_take(sem, timeout);
    1e18:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    1e1c:	2300      	movs	r3, #0
    1e1e:	4668      	mov	r0, sp
    1e20:	f00e ffde 	bl	10de0 <z_impl_k_sem_take>
}
    1e24:	b007      	add	sp, #28
    1e26:	f85d fb04 	ldr.w	pc, [sp], #4
    1e2a:	bf00      	nop
    1e2c:	0001215d 	.word	0x0001215d

00001e30 <z_nrf_clock_control_lf_on>:
{
    1e30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    1e34:	2201      	movs	r2, #1
    1e36:	4606      	mov	r6, r0
    1e38:	4939      	ldr	r1, [pc, #228]	; (1f20 <z_nrf_clock_control_lf_on+0xf0>)
    1e3a:	e8d1 3fef 	ldaex	r3, [r1]
    1e3e:	e8c1 2fe0 	stlex	r0, r2, [r1]
    1e42:	2800      	cmp	r0, #0
    1e44:	d1f9      	bne.n	1e3a <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
    1e46:	b933      	cbnz	r3, 1e56 <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    1e48:	4936      	ldr	r1, [pc, #216]	; (1f24 <z_nrf_clock_control_lf_on+0xf4>)
		err = onoff_request(mgr, &cli);
    1e4a:	4837      	ldr	r0, [pc, #220]	; (1f28 <z_nrf_clock_control_lf_on+0xf8>)
    1e4c:	604b      	str	r3, [r1, #4]
    1e4e:	60cb      	str	r3, [r1, #12]
    1e50:	608a      	str	r2, [r1, #8]
    1e52:	f00f fde4 	bl	11a1e <onoff_request>
	switch (start_mode) {
    1e56:	1e73      	subs	r3, r6, #1
    1e58:	2b01      	cmp	r3, #1
    1e5a:	d832      	bhi.n	1ec2 <z_nrf_clock_control_lf_on+0x92>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    1e5c:	2e01      	cmp	r6, #1
    1e5e:	d107      	bne.n	1e70 <z_nrf_clock_control_lf_on+0x40>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    1e60:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    1e64:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    1e68:	f003 0303 	and.w	r3, r3, #3
    1e6c:	2b02      	cmp	r3, #2
    1e6e:	d028      	beq.n	1ec2 <z_nrf_clock_control_lf_on+0x92>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    1e70:	f01b fada 	bl	1d428 <k_is_in_isr>
    1e74:	4604      	mov	r4, r0
    1e76:	b918      	cbnz	r0, 1e80 <z_nrf_clock_control_lf_on+0x50>
	return !z_sys_post_kernel;
    1e78:	4b2c      	ldr	r3, [pc, #176]	; (1f2c <z_nrf_clock_control_lf_on+0xfc>)
	int key = isr_mode ? irq_lock() : 0;
    1e7a:	781b      	ldrb	r3, [r3, #0]
    1e7c:	2b00      	cmp	r3, #0
    1e7e:	d147      	bne.n	1f10 <z_nrf_clock_control_lf_on+0xe0>
	__asm__ volatile(
    1e80:	f04f 0320 	mov.w	r3, #32
    1e84:	f3ef 8511 	mrs	r5, BASEPRI
    1e88:	f383 8811 	msr	BASEPRI, r3
    1e8c:	f3bf 8f6f 	isb	sy
    1e90:	2401      	movs	r4, #1
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    1e92:	4f27      	ldr	r7, [pc, #156]	; (1f30 <z_nrf_clock_control_lf_on+0x100>)
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1e94:	f8df 809c 	ldr.w	r8, [pc, #156]	; 1f34 <z_nrf_clock_control_lf_on+0x104>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    1e98:	f8df 909c 	ldr.w	r9, [pc, #156]	; 1f38 <z_nrf_clock_control_lf_on+0x108>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    1e9c:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    1ea0:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    1ea4:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
    1ea8:	03d2      	lsls	r2, r2, #15
    1eaa:	d50c      	bpl.n	1ec6 <z_nrf_clock_control_lf_on+0x96>
	while (!(nrfx_clock_is_running(d, (void *)&type)
    1eac:	f003 0303 	and.w	r3, r3, #3
    1eb0:	2b02      	cmp	r3, #2
    1eb2:	d001      	beq.n	1eb8 <z_nrf_clock_control_lf_on+0x88>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    1eb4:	2e01      	cmp	r6, #1
    1eb6:	d106      	bne.n	1ec6 <z_nrf_clock_control_lf_on+0x96>
	if (isr_mode) {
    1eb8:	b324      	cbz	r4, 1f04 <z_nrf_clock_control_lf_on+0xd4>
	__asm__ volatile(
    1eba:	f385 8811 	msr	BASEPRI, r5
    1ebe:	f3bf 8f6f 	isb	sy
}
    1ec2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (isr_mode) {
    1ec6:	b1c4      	cbz	r4, 1efa <z_nrf_clock_control_lf_on+0xca>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    1ec8:	4628      	mov	r0, r5
    1eca:	f000 fd43 	bl	2954 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    1ece:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    1ed2:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    1ed6:	b2db      	uxtb	r3, r3
    1ed8:	2b01      	cmp	r3, #1
    1eda:	d1df      	bne.n	1e9c <z_nrf_clock_control_lf_on+0x6c>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    1edc:	6839      	ldr	r1, [r7, #0]
		    && nrf_clock_event_check(NRF_CLOCK,
    1ede:	2900      	cmp	r1, #0
    1ee0:	d0dc      	beq.n	1e9c <z_nrf_clock_control_lf_on+0x6c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    1ee2:	2100      	movs	r1, #0
    1ee4:	6039      	str	r1, [r7, #0]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    1ee6:	6839      	ldr	r1, [r7, #0]
    p_reg->LFCLKSRC = (uint32_t)(source);
    1ee8:	2102      	movs	r1, #2
    1eea:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
    1eee:	2220      	movs	r2, #32
    1ef0:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    1ef4:	f8c9 3000 	str.w	r3, [r9]
}
    1ef8:	e7d0      	b.n	1e9c <z_nrf_clock_control_lf_on+0x6c>
	return z_impl_k_sleep(timeout);
    1efa:	2100      	movs	r1, #0
    1efc:	2021      	movs	r0, #33	; 0x21
    1efe:	f00e ff21 	bl	10d44 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    1f02:	e7e4      	b.n	1ece <z_nrf_clock_control_lf_on+0x9e>
    p_reg->INTENSET = mask;
    1f04:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    1f08:	2202      	movs	r2, #2
    1f0a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    1f0e:	e7d8      	b.n	1ec2 <z_nrf_clock_control_lf_on+0x92>
    p_reg->INTENCLR = mask;
    1f10:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    1f14:	2202      	movs	r2, #2
	int key = isr_mode ? irq_lock() : 0;
    1f16:	4605      	mov	r5, r0
    1f18:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    1f1c:	e7b9      	b.n	1e92 <z_nrf_clock_control_lf_on+0x62>
    1f1e:	bf00      	nop
    1f20:	200014b0 	.word	0x200014b0
    1f24:	200013fc 	.word	0x200013fc
    1f28:	20001428 	.word	0x20001428
    1f2c:	2002a079 	.word	0x2002a079
    1f30:	50005104 	.word	0x50005104
    1f34:	e000e100 	.word	0xe000e100
    1f38:	50005008 	.word	0x50005008

00001f3c <bt_rpmsg_init>:
	.quirks         = BT_QUIRK_NO_AUTO_DLE,
#endif
};

static int bt_rpmsg_init(const struct device *unused)
{
    1f3c:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	int err;

	err = bt_rpmsg_platform_init();
    1f3e:	f000 f80b 	bl	1f58 <bt_rpmsg_platform_init>
	if (err < 0) {
    1f42:	2800      	cmp	r0, #0
    1f44:	db04      	blt.n	1f50 <bt_rpmsg_init+0x14>
	if (err < 0) {
		BT_ERR("Failed to register BT HIC driver (err %d)", err);
	}

	return err;
}
    1f46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = bt_hci_driver_register(&drv);
    1f4a:	4802      	ldr	r0, [pc, #8]	; (1f54 <bt_rpmsg_init+0x18>)
    1f4c:	f001 bfc4 	b.w	3ed8 <bt_hci_driver_register>
}
    1f50:	bd08      	pop	{r3, pc}
    1f52:	bf00      	nop
    1f54:	0001eb00 	.word	0x0001eb00

00001f58 <bt_rpmsg_platform_init>:

	return RPMSG_SUCCESS;
}

int bt_rpmsg_platform_init(void)
{
    1f58:	b508      	push	{r3, lr}
	int err;

	err = rpmsg_service_register_endpoint("nrf_bt_hci", endpoint_cb);
    1f5a:	4905      	ldr	r1, [pc, #20]	; (1f70 <bt_rpmsg_platform_init+0x18>)
    1f5c:	4805      	ldr	r0, [pc, #20]	; (1f74 <bt_rpmsg_platform_init+0x1c>)
    1f5e:	f7ff fdd3 	bl	1b08 <rpmsg_service_register_endpoint>

	if (err < 0) {
    1f62:	2800      	cmp	r0, #0
		LOG_ERR("Registering endpoint failed with %d", err);
		return RPMSG_ERR_INIT;
	}

	endpoint_id = err;
    1f64:	bfa9      	itett	ge
    1f66:	4b04      	ldrge	r3, [pc, #16]	; (1f78 <bt_rpmsg_platform_init+0x20>)
		return RPMSG_ERR_INIT;
    1f68:	4804      	ldrlt	r0, [pc, #16]	; (1f7c <bt_rpmsg_platform_init+0x24>)
	endpoint_id = err;
    1f6a:	6018      	strge	r0, [r3, #0]

	return RPMSG_SUCCESS;
    1f6c:	2000      	movge	r0, #0
}
    1f6e:	bd08      	pop	{r3, pc}
    1f70:	00012739 	.word	0x00012739
    1f74:	00043c45 	.word	0x00043c45
    1f78:	200014dc 	.word	0x200014dc
    1f7c:	fffff82a 	.word	0xfffff82a

00001f80 <bt_rpmsg_platform_send>:

int bt_rpmsg_platform_send(struct net_buf *buf)
{
	return rpmsg_service_send(endpoint_id, buf->data, buf->len);
    1f80:	4b02      	ldr	r3, [pc, #8]	; (1f8c <bt_rpmsg_platform_send+0xc>)
    1f82:	8982      	ldrh	r2, [r0, #12]
    1f84:	6881      	ldr	r1, [r0, #8]
    1f86:	6818      	ldr	r0, [r3, #0]
    1f88:	f7ff bde4 	b.w	1b54 <rpmsg_service_send>
    1f8c:	200014dc 	.word	0x200014dc

00001f90 <bt_rpmsg_platform_endpoint_is_bound>:
}

int bt_rpmsg_platform_endpoint_is_bound(void)
{
    1f90:	b508      	push	{r3, lr}
	return rpmsg_service_endpoint_is_bound(endpoint_id);
    1f92:	4b02      	ldr	r3, [pc, #8]	; (1f9c <bt_rpmsg_platform_endpoint_is_bound+0xc>)
    1f94:	6818      	ldr	r0, [r3, #0]
    1f96:	f7ff fdd3 	bl	1b40 <rpmsg_service_endpoint_is_bound>
}
    1f9a:	bd08      	pop	{r3, pc}
    1f9c:	200014dc 	.word	0x200014dc

00001fa0 <sys_clock_timeout_handler>:

static void sys_clock_timeout_handler(uint32_t chan,
				      uint32_t cc_value,
				      void *user_data)
{
	uint32_t dticks = counter_sub(cc_value, last_count) / CYC_PER_TICK;
    1fa0:	4a04      	ldr	r2, [pc, #16]	; (1fb4 <sys_clock_timeout_handler+0x14>)
    1fa2:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    1fa4:	1ac8      	subs	r0, r1, r3
    1fa6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    1faa:	4403      	add	r3, r0
    1fac:	6013      	str	r3, [r2, #0]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    1fae:	f00f b991 	b.w	112d4 <z_clock_announce>
    1fb2:	bf00      	nop
    1fb4:	200014ec 	.word	0x200014ec

00001fb8 <set_absolute_alarm>:
{
    1fb8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    1fbc:	f44f 3780 	mov.w	r7, #65536	; 0x10000
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type * p_reg, nrf_rtc_event_t event)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    1fc0:	f04f 0900 	mov.w	r9, #0
    1fc4:	0086      	lsls	r6, r0, #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    1fc6:	f100 0450 	add.w	r4, r0, #80	; 0x50
    1fca:	f106 2650 	add.w	r6, r6, #1342197760	; 0x50005000
    1fce:	00a4      	lsls	r4, r4, #2
    1fd0:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
    1fd4:	b2a4      	uxth	r4, r4
    1fd6:	f104 2450 	add.w	r4, r4, #1342197760	; 0x50005000
    return p_reg->CC[ch];
    1fda:	f8d6 3540 	ldr.w	r3, [r6, #1344]	; 0x540
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
    1fde:	f8df 806c 	ldr.w	r8, [pc, #108]	; 204c <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x4c>
	uint32_t cc_val = abs_val & COUNTER_MAX;
    1fe2:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    1fe6:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    1fea:	4087      	lsls	r7, r0
     return p_reg->COUNTER;
    1fec:	f8d8 a504 	ldr.w	sl, [r8, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    1ff0:	eba3 030a 	sub.w	r3, r3, sl
    1ff4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    1ff8:	f02a 427f 	bic.w	r2, sl, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
    1ffc:	2b01      	cmp	r3, #1
    p_reg->CC[ch] = cc_val;
    1ffe:	f8c6 2540 	str.w	r2, [r6, #1344]	; 0x540
    2002:	d102      	bne.n	200a <CONFIG_NRF_SPU_RAM_REGION_SIZE+0xa>
	z_impl_k_busy_wait(usec_to_wait);
    2004:	2013      	movs	r0, #19
    2006:	f01b fa15 	bl	1d434 <z_impl_k_busy_wait>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    200a:	f10a 0202 	add.w	r2, sl, #2
	return (a - b) & COUNTER_MAX;
    200e:	1aab      	subs	r3, r5, r2
    2010:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
			cc_val = now + 2;
    2014:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    2018:	bf88      	it	hi
    201a:	4615      	movhi	r5, r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    201c:	f8c4 9000 	str.w	r9, [r4]
    2020:	6823      	ldr	r3, [r4, #0]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    2022:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    2026:	f8c8 7344 	str.w	r7, [r8, #836]	; 0x344
    p_reg->CC[ch] = cc_val;
    202a:	f8c6 3540 	str.w	r3, [r6, #1344]	; 0x540
     return p_reg->COUNTER;
    202e:	f8d8 3504 	ldr.w	r3, [r8, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    2032:	459a      	cmp	sl, r3
    2034:	d006      	beq.n	2044 <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x44>
	return (a - b) & COUNTER_MAX;
    2036:	1aeb      	subs	r3, r5, r3
    2038:	3b02      	subs	r3, #2
    203a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	} while ((now2 != now) &&
    203e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    2042:	d801      	bhi.n	2048 <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x48>
}
    2044:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		prev_cc = cc_val;
    2048:	462b      	mov	r3, r5
    204a:	e7cf      	b.n	1fec <set_absolute_alarm+0x34>
    204c:	50015000 	.word	0x50015000

00002050 <rtc_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc_nrf_isr(const void *arg)
{
    2050:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ARG_UNUSED(arg);

	for (uint32_t chan = 0; chan < CHAN_COUNT; chan++) {
    2052:	2400      	movs	r4, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    2054:	4627      	mov	r7, r4
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2056:	4e0f      	ldr	r6, [pc, #60]	; (2094 <rtc_nrf_isr+0x44>)
    2058:	4b0f      	ldr	r3, [pc, #60]	; (2098 <rtc_nrf_isr+0x48>)
    return p_reg->INTENSET & mask;
    205a:	4a10      	ldr	r2, [pc, #64]	; (209c <rtc_nrf_isr+0x4c>)
    205c:	4618      	mov	r0, r3
    205e:	681d      	ldr	r5, [r3, #0]
    2060:	b104      	cbz	r4, 2064 <rtc_nrf_isr+0x14>
				handler(chan, cc_val,
					cc_data[chan].user_context);
			}
		}
	}
}
    2062:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2064:	f8d2 1304 	ldr.w	r1, [r2, #772]	; 0x304
		if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan)) &&
    2068:	03c9      	lsls	r1, r1, #15
    206a:	d5fa      	bpl.n	2062 <rtc_nrf_isr+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    206c:	6831      	ldr	r1, [r6, #0]
    206e:	2900      	cmp	r1, #0
    2070:	d0f7      	beq.n	2062 <rtc_nrf_isr+0x12>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    2072:	6034      	str	r4, [r6, #0]
    2074:	6831      	ldr	r1, [r6, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    2076:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    207a:	f8c2 1348 	str.w	r1, [r2, #840]	; 0x348
	for (uint32_t chan = 0; chan < CHAN_COUNT; chan++) {
    207e:	2401      	movs	r4, #1
    return p_reg->CC[ch];
    2080:	f8d2 1540 	ldr.w	r1, [r2, #1344]	; 0x540
			if (handler) {
    2084:	b125      	cbz	r5, 2090 <rtc_nrf_isr+0x40>
				handler(chan, cc_val,
    2086:	2000      	movs	r0, #0
    2088:	685a      	ldr	r2, [r3, #4]
    208a:	601f      	str	r7, [r3, #0]
    208c:	47a8      	blx	r5
    208e:	e7e3      	b.n	2058 <rtc_nrf_isr+0x8>
    2090:	6005      	str	r5, [r0, #0]
}
    2092:	e7e6      	b.n	2062 <rtc_nrf_isr+0x12>
    2094:	50015140 	.word	0x50015140
    2098:	200014e0 	.word	0x200014e0
    209c:	50015000 	.word	0x50015000

000020a0 <z_clock_driver_init>:

	atomic_or(&alloc_mask, BIT(chan));
}

int z_clock_driver_init(const struct device *device)
{
    20a0:	b538      	push	{r3, r4, r5, lr}
    p_reg->PRESCALER = val;
    20a2:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
    20a4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    20a8:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->PRESCALER = val;
    20ac:	4d0d      	ldr	r5, [pc, #52]	; (20e4 <z_clock_driver_init+0x44>)
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
	}

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    20ae:	2101      	movs	r1, #1
    20b0:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->INTENSET = mask;
    20b4:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    20b8:	4b0b      	ldr	r3, [pc, #44]	; (20e8 <z_clock_driver_init+0x48>)
    20ba:	2015      	movs	r0, #21
    20bc:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    20c0:	4622      	mov	r2, r4
    20c2:	f000 fb89 	bl	27d8 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    20c6:	2015      	movs	r0, #21
    20c8:	f000 fb68 	bl	279c <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    20cc:	2301      	movs	r3, #1
    20ce:	4a07      	ldr	r2, [pc, #28]	; (20ec <z_clock_driver_init+0x4c>)
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		compare_set(0, counter() + CYC_PER_TICK,
			    sys_clock_timeout_handler, NULL);
	}

	z_nrf_clock_control_lf_on(mode);
    20d0:	2002      	movs	r0, #2
    20d2:	6013      	str	r3, [r2, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
    20d4:	4a06      	ldr	r2, [pc, #24]	; (20f0 <z_clock_driver_init+0x50>)
    20d6:	602b      	str	r3, [r5, #0]
    20d8:	6013      	str	r3, [r2, #0]
	z_nrf_clock_control_lf_on(mode);
    20da:	f7ff fea9 	bl	1e30 <z_nrf_clock_control_lf_on>

	return 0;
}
    20de:	4620      	mov	r0, r4
    20e0:	bd38      	pop	{r3, r4, r5, pc}
    20e2:	bf00      	nop
    20e4:	50015000 	.word	0x50015000
    20e8:	e000e100 	.word	0xe000e100
    20ec:	50015008 	.word	0x50015008
    20f0:	200014e8 	.word	0x200014e8

000020f4 <z_clock_set_timeout>:

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    20f4:	4b13      	ldr	r3, [pc, #76]	; (2144 <z_clock_set_timeout+0x50>)
    20f6:	f1b0 3fff 	cmp.w	r0, #4294967295
    20fa:	bf08      	it	eq
    20fc:	4618      	moveq	r0, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    20fe:	3801      	subs	r0, #1
    2100:	2800      	cmp	r0, #0
    2102:	dd1c      	ble.n	213e <z_clock_set_timeout+0x4a>
    2104:	4298      	cmp	r0, r3
    2106:	bfa8      	it	ge
    2108:	4618      	movge	r0, r3
     return p_reg->COUNTER;
    210a:	4b0f      	ldr	r3, [pc, #60]	; (2148 <z_clock_set_timeout+0x54>)
    210c:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504

	uint32_t unannounced = counter_sub(counter(), last_count);
    2110:	4b0e      	ldr	r3, [pc, #56]	; (214c <z_clock_set_timeout+0x58>)
    2112:	6819      	ldr	r1, [r3, #0]
	return (a - b) & COUNTER_MAX;
    2114:	1a52      	subs	r2, r2, r1
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
		ticks = 0;
    2116:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
    211a:	bf18      	it	ne
    211c:	2000      	movne	r0, #0
	return (a - b) & COUNTER_MAX;
    211e:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    2122:	3301      	adds	r3, #1
	cc_data[chan].callback = handler;
    2124:	4a0a      	ldr	r2, [pc, #40]	; (2150 <z_clock_set_timeout+0x5c>)
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    2126:	4403      	add	r3, r0
	cc_data[chan].callback = handler;
    2128:	480a      	ldr	r0, [pc, #40]	; (2154 <z_clock_set_timeout+0x60>)
    212a:	6010      	str	r0, [r2, #0]
	cc_data[chan].user_context = user_data;
    212c:	2000      	movs	r0, #0
    212e:	6050      	str	r0, [r2, #4]
	set_absolute_alarm(chan, cc_value);
    2130:	4a04      	ldr	r2, [pc, #16]	; (2144 <z_clock_set_timeout+0x50>)
    2132:	4293      	cmp	r3, r2
    2134:	bf94      	ite	ls
    2136:	18c9      	addls	r1, r1, r3
    2138:	1889      	addhi	r1, r1, r2
    213a:	f7ff bf3d 	b.w	1fb8 <set_absolute_alarm>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    213e:	2000      	movs	r0, #0
    2140:	e7e3      	b.n	210a <z_clock_set_timeout+0x16>
    2142:	bf00      	nop
    2144:	007fffff 	.word	0x007fffff
    2148:	50015000 	.word	0x50015000
    214c:	200014ec 	.word	0x200014ec
    2150:	200014e0 	.word	0x200014e0
    2154:	00001fa1 	.word	0x00001fa1

00002158 <z_clock_elapsed>:
	__asm__ volatile(
    2158:	f04f 0220 	mov.w	r2, #32
    215c:	f3ef 8311 	mrs	r3, BASEPRI
    2160:	f382 8811 	msr	BASEPRI, r2
    2164:	f3bf 8f6f 	isb	sy
    2168:	4a06      	ldr	r2, [pc, #24]	; (2184 <z_clock_elapsed+0x2c>)
    216a:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    216e:	4a06      	ldr	r2, [pc, #24]	; (2188 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    2170:	6812      	ldr	r2, [r2, #0]
    2172:	1a80      	subs	r0, r0, r2
    2174:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    2178:	f383 8811 	msr	BASEPRI, r3
    217c:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    2180:	4770      	bx	lr
    2182:	bf00      	nop
    2184:	50015000 	.word	0x50015000
    2188:	200014ec 	.word	0x200014ec

0000218c <lbslc_ccc_cfg_changed>:
static struct bt_lbs_cb       lbs_cb;

static void lbslc_ccc_cfg_changed(const struct bt_gatt_attr *attr,
				  uint16_t value)
{
	notify_enabled = (value == BT_GATT_CCC_NOTIFY);
    218c:	1e4b      	subs	r3, r1, #1
    218e:	4259      	negs	r1, r3
    2190:	4159      	adcs	r1, r3
    2192:	4b01      	ldr	r3, [pc, #4]	; (2198 <lbslc_ccc_cfg_changed+0xc>)
    2194:	7019      	strb	r1, [r3, #0]
}
    2196:	4770      	bx	lr
    2198:	20029f3b 	.word	0x20029f3b

0000219c <write_led>:

static ssize_t write_led(struct bt_conn *conn,
			 const struct bt_gatt_attr *attr,
			 const void *buf,
			 uint16_t len, uint16_t offset, uint8_t flags)
{
    219c:	b510      	push	{r4, lr}
    219e:	461c      	mov	r4, r3
	LOG_DBG("Attribute write, handle: %u, conn: %p", attr->handle, conn);

	if (lbs_cb.led_cb) {
    21a0:	4b03      	ldr	r3, [pc, #12]	; (21b0 <write_led+0x14>)
    21a2:	681b      	ldr	r3, [r3, #0]
    21a4:	b10b      	cbz	r3, 21aa <write_led+0xe>
		lbs_cb.led_cb(*(bool *)buf);
    21a6:	7810      	ldrb	r0, [r2, #0]
    21a8:	4798      	blx	r3
	}

	return len;
}
    21aa:	4620      	mov	r0, r4
    21ac:	bd10      	pop	{r4, pc}
    21ae:	bf00      	nop
    21b0:	200014f0 	.word	0x200014f0

000021b4 <bt_lbs_init>:
			       NULL, write_led, NULL),
);

int bt_lbs_init(struct bt_lbs_cb *callbacks)
{
	if (callbacks) {
    21b4:	b120      	cbz	r0, 21c0 <bt_lbs_init+0xc>
		lbs_cb.led_cb    = callbacks->led_cb;
    21b6:	4b03      	ldr	r3, [pc, #12]	; (21c4 <bt_lbs_init+0x10>)
    21b8:	6802      	ldr	r2, [r0, #0]
    21ba:	601a      	str	r2, [r3, #0]
		lbs_cb.button_cb = callbacks->button_cb;
    21bc:	6842      	ldr	r2, [r0, #4]
    21be:	605a      	str	r2, [r3, #4]
	}

	return 0;
}
    21c0:	2000      	movs	r0, #0
    21c2:	4770      	bx	lr
    21c4:	200014f0 	.word	0x200014f0

000021c8 <bt_lbs_send_button_state>:

int bt_lbs_send_button_state(bool button_state)
{
    21c8:	b500      	push	{lr}
	if (!notify_enabled) {
    21ca:	4b0e      	ldr	r3, [pc, #56]	; (2204 <bt_lbs_send_button_state+0x3c>)
{
    21cc:	b089      	sub	sp, #36	; 0x24
	if (!notify_enabled) {
    21ce:	781b      	ldrb	r3, [r3, #0]
{
    21d0:	f88d 0007 	strb.w	r0, [sp, #7]
	if (!notify_enabled) {
    21d4:	b19b      	cbz	r3, 21fe <bt_lbs_send_button_state+0x36>
				 const struct bt_gatt_attr *attr,
				 const void *data, uint16_t len)
{
	struct bt_gatt_notify_params params;

	memset(&params, 0, sizeof(params));
    21d6:	2100      	movs	r1, #0
    21d8:	2218      	movs	r2, #24
    21da:	a802      	add	r0, sp, #8
    21dc:	f01b fbce 	bl	1d97c <memset>

	params.attr = attr;
    21e0:	4b09      	ldr	r3, [pc, #36]	; (2208 <bt_lbs_send_button_state+0x40>)
	params.data = data;
	params.len = len;

	return bt_gatt_notify_cb(conn, &params);
    21e2:	2000      	movs	r0, #0
	params.attr = attr;
    21e4:	9303      	str	r3, [sp, #12]
	params.data = data;
    21e6:	f10d 0307 	add.w	r3, sp, #7
    21ea:	9304      	str	r3, [sp, #16]
	params.len = len;
    21ec:	2301      	movs	r3, #1
	return bt_gatt_notify_cb(conn, &params);
    21ee:	a902      	add	r1, sp, #8
	params.len = len;
    21f0:	f8ad 3014 	strh.w	r3, [sp, #20]
	return bt_gatt_notify_cb(conn, &params);
    21f4:	f004 f914 	bl	6420 <bt_gatt_notify_cb>
	}

	return bt_gatt_notify(NULL, &lbs_svc.attrs[2],
			      &button_state,
			      sizeof(button_state));
}
    21f8:	b009      	add	sp, #36	; 0x24
    21fa:	f85d fb04 	ldr.w	pc, [sp], #4
		return -EACCES;
    21fe:	f06f 000c 	mvn.w	r0, #12
    2202:	e7f9      	b.n	21f8 <bt_lbs_send_button_state+0x30>
    2204:	20029f3b 	.word	0x20029f3b
    2208:	0001eb3c 	.word	0x0001eb3c

0000220c <nrf_cc3xx_platform_abort_init>:

/** @brief Function to initialize the nrf_cc3xx_platform abort APIs.
 */
void nrf_cc3xx_platform_abort_init(void)
{
	nrf_cc3xx_platform_set_abort(&apis);
    220c:	4801      	ldr	r0, [pc, #4]	; (2214 <nrf_cc3xx_platform_abort_init+0x8>)
    220e:	f00f ba59 	b.w	116c4 <nrf_cc3xx_platform_set_abort>
    2212:	bf00      	nop
    2214:	0001eb8c 	.word	0x0001eb8c

00002218 <mutex_unlock_platform>:
    }
}

/** @brief Static function to unlock a mutex
 */
static int32_t mutex_unlock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    2218:	b508      	push	{r3, lr}
    struct k_mutex * p_mutex;

    /* Ensure that the mutex param is valid (not NULL) */
    if(mutex == NULL) {
    221a:	b308      	cbz	r0, 2260 <mutex_unlock_platform+0x48>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    }

    switch (mutex->flags)
    221c:	6843      	ldr	r3, [r0, #4]
    221e:	2b04      	cmp	r3, #4
    2220:	d007      	beq.n	2232 <mutex_unlock_platform+0x1a>
    2222:	2b08      	cmp	r3, #8
    2224:	d013      	beq.n	224e <mutex_unlock_platform+0x36>

#endif /* defined(NRF5340_XXAA_APPLICATION) */

    default:
        /* Ensure that the mutex has been initialized */
        if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    2226:	b1f3      	cbz	r3, 2266 <mutex_unlock_platform+0x4e>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
        }

        p_mutex = (struct k_mutex *)mutex->mutex;
    2228:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_unlock(mutex);
    222a:	f00e f999 	bl	10560 <z_impl_k_mutex_unlock>

        k_mutex_unlock(p_mutex);
        return NRF_CC3XX_PLATFORM_SUCCESS;
    222e:	2000      	movs	r0, #0
    2230:	e00c      	b.n	224c <mutex_unlock_platform+0x34>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    2232:	2200      	movs	r2, #0
    2234:	6803      	ldr	r3, [r0, #0]
    2236:	e8d3 1fef 	ldaex	r1, [r3]
    223a:	2901      	cmp	r1, #1
    223c:	d103      	bne.n	2246 <mutex_unlock_platform+0x2e>
    223e:	e8c3 2fe0 	stlex	r0, r2, [r3]
    2242:	2800      	cmp	r0, #0
    2244:	d1f7      	bne.n	2236 <mutex_unlock_platform+0x1e>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    2246:	4809      	ldr	r0, [pc, #36]	; (226c <mutex_unlock_platform+0x54>)
    2248:	bf08      	it	eq
    224a:	4610      	moveq	r0, r2
    }
}
    224c:	bd08      	pop	{r3, pc}
        nrf_mutex_unlock(NRF_MUTEX, *((uint8_t *)mutex->mutex));
    224e:	6803      	ldr	r3, [r0, #0]
    return (p_reg->MUTEX[mutex] == MUTEX_MUTEX_MUTEX_Unlocked);
}

NRF_STATIC_INLINE void nrf_mutex_unlock(NRF_MUTEX_Type * p_reg, uint8_t mutex)
{
    p_reg->MUTEX[mutex] = MUTEX_MUTEX_MUTEX_Unlocked;
    2250:	2000      	movs	r0, #0
    2252:	781b      	ldrb	r3, [r3, #0]
    2254:	4a06      	ldr	r2, [pc, #24]	; (2270 <mutex_unlock_platform+0x58>)
    2256:	f503 7380 	add.w	r3, r3, #256	; 0x100
    225a:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
        return NRF_CC3XX_PLATFORM_SUCCESS;
    225e:	e7f5      	b.n	224c <mutex_unlock_platform+0x34>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    2260:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    2264:	e7f2      	b.n	224c <mutex_unlock_platform+0x34>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    2266:	4803      	ldr	r0, [pc, #12]	; (2274 <mutex_unlock_platform+0x5c>)
    2268:	e7f0      	b.n	224c <mutex_unlock_platform+0x34>
    226a:	bf00      	nop
    226c:	ffff8fe9 	.word	0xffff8fe9
    2270:	50030000 	.word	0x50030000
    2274:	ffff8fea 	.word	0xffff8fea

00002278 <mutex_free_platform>:
static void mutex_free_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    2278:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    227a:	4604      	mov	r4, r0
    227c:	b918      	cbnz	r0, 2286 <mutex_free_platform+0xe>
        platform_abort_apis.abort_fn(
    227e:	4b0d      	ldr	r3, [pc, #52]	; (22b4 <mutex_free_platform+0x3c>)
    2280:	480d      	ldr	r0, [pc, #52]	; (22b8 <mutex_free_platform+0x40>)
    2282:	685b      	ldr	r3, [r3, #4]
    2284:	4798      	blx	r3
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC ||
    2286:	6861      	ldr	r1, [r4, #4]
    2288:	2908      	cmp	r1, #8
    228a:	d00d      	beq.n	22a8 <mutex_free_platform+0x30>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    228c:	f031 0304 	bics.w	r3, r1, #4
    2290:	d00a      	beq.n	22a8 <mutex_free_platform+0x30>
    if ((mutex->flags & NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED) != 0) {
    2292:	f011 0102 	ands.w	r1, r1, #2
    2296:	d008      	beq.n	22aa <mutex_free_platform+0x32>
        k_mem_slab_free(&mutex_slab, &mutex->mutex);
    2298:	4621      	mov	r1, r4
    229a:	4808      	ldr	r0, [pc, #32]	; (22bc <mutex_free_platform+0x44>)
    229c:	f00e f808 	bl	102b0 <k_mem_slab_free>
        mutex->mutex = NULL;
    22a0:	2300      	movs	r3, #0
    22a2:	6023      	str	r3, [r4, #0]
    mutex->flags = NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID;
    22a4:	2300      	movs	r3, #0
    22a6:	6063      	str	r3, [r4, #4]
}
    22a8:	bd10      	pop	{r4, pc}

__BEGIN_DECLS
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
__ssp_bos_icheck3(memmove, void *, const void *)
__ssp_bos_icheck3_restrict(mempcpy, void *, const void *)
__ssp_bos_icheck3(memset, void *, int)
    22aa:	2214      	movs	r2, #20
    22ac:	6820      	ldr	r0, [r4, #0]
    22ae:	f01b fb65 	bl	1d97c <memset>
    22b2:	e7f7      	b.n	22a4 <mutex_free_platform+0x2c>
    22b4:	20000514 	.word	0x20000514
    22b8:	00043c5a 	.word	0x00043c5a
    22bc:	200014f8 	.word	0x200014f8

000022c0 <mutex_init_platform>:
static void mutex_init_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    22c0:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    22c2:	4604      	mov	r4, r0
    22c4:	b918      	cbnz	r0, 22ce <mutex_init_platform+0xe>
        platform_abort_apis.abort_fn(
    22c6:	4b16      	ldr	r3, [pc, #88]	; (2320 <mutex_init_platform+0x60>)
    22c8:	4816      	ldr	r0, [pc, #88]	; (2324 <mutex_init_platform+0x64>)
    22ca:	685b      	ldr	r3, [r3, #4]
    22cc:	4798      	blx	r3
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC ||
    22ce:	6863      	ldr	r3, [r4, #4]
    22d0:	2b04      	cmp	r3, #4
    22d2:	d023      	beq.n	231c <mutex_init_platform+0x5c>
    22d4:	2b08      	cmp	r3, #8
    22d6:	d021      	beq.n	231c <mutex_init_platform+0x5c>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID &&
    22d8:	b9cb      	cbnz	r3, 230e <mutex_init_platform+0x4e>
    22da:	6823      	ldr	r3, [r4, #0]
    22dc:	b9bb      	cbnz	r3, 230e <mutex_init_platform+0x4e>
        ret = k_mem_slab_alloc(&mutex_slab, &mutex->mutex, K_FOREVER);
    22de:	f04f 32ff 	mov.w	r2, #4294967295
    22e2:	f04f 33ff 	mov.w	r3, #4294967295
    22e6:	4621      	mov	r1, r4
    22e8:	480f      	ldr	r0, [pc, #60]	; (2328 <mutex_init_platform+0x68>)
    22ea:	f00d ffaf 	bl	1024c <k_mem_slab_alloc>
        if(ret != 0 || mutex->mutex == NULL)
    22ee:	b908      	cbnz	r0, 22f4 <mutex_init_platform+0x34>
    22f0:	6823      	ldr	r3, [r4, #0]
    22f2:	b91b      	cbnz	r3, 22fc <mutex_init_platform+0x3c>
            platform_abort_apis.abort_fn(
    22f4:	4b0a      	ldr	r3, [pc, #40]	; (2320 <mutex_init_platform+0x60>)
    22f6:	480d      	ldr	r0, [pc, #52]	; (232c <mutex_init_platform+0x6c>)
    22f8:	685b      	ldr	r3, [r3, #4]
    22fa:	4798      	blx	r3
    22fc:	2214      	movs	r2, #20
    22fe:	2100      	movs	r1, #0
    2300:	6820      	ldr	r0, [r4, #0]
    2302:	f01b fb3b 	bl	1d97c <memset>
        mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED;
    2306:	6863      	ldr	r3, [r4, #4]
    2308:	f043 0302 	orr.w	r3, r3, #2
    230c:	6063      	str	r3, [r4, #4]
    p_mutex = (struct k_mutex *)mutex->mutex;
    230e:	6820      	ldr	r0, [r4, #0]
	return z_impl_k_mutex_init(mutex);
    2310:	f01a feaa 	bl	1d068 <z_impl_k_mutex_init>
    mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_VALID;
    2314:	6863      	ldr	r3, [r4, #4]
    2316:	f043 0301 	orr.w	r3, r3, #1
    231a:	6063      	str	r3, [r4, #4]
}
    231c:	bd10      	pop	{r4, pc}
    231e:	bf00      	nop
    2320:	20000514 	.word	0x20000514
    2324:	00043c5a 	.word	0x00043c5a
    2328:	200014f8 	.word	0x200014f8
    232c:	00043c80 	.word	0x00043c80

00002330 <mutex_lock_platform>:
static int32_t mutex_lock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    2330:	b508      	push	{r3, lr}
    if(mutex == NULL) {
    2332:	b340      	cbz	r0, 2386 <mutex_lock_platform+0x56>
    switch (mutex->flags) {
    2334:	6843      	ldr	r3, [r0, #4]
    2336:	2b04      	cmp	r3, #4
    2338:	d00b      	beq.n	2352 <mutex_lock_platform+0x22>
    233a:	2b08      	cmp	r3, #8
    233c:	d016      	beq.n	236c <mutex_lock_platform+0x3c>
        if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    233e:	b303      	cbz	r3, 2382 <mutex_lock_platform+0x52>
        p_mutex = (struct k_mutex *)mutex->mutex;
    2340:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    2342:	f04f 32ff 	mov.w	r2, #4294967295
    2346:	f04f 33ff 	mov.w	r3, #4294967295
    234a:	f00e f891 	bl	10470 <z_impl_k_mutex_lock>
        if (ret == 0) {
    234e:	b158      	cbz	r0, 2368 <mutex_lock_platform+0x38>
    2350:	e015      	b.n	237e <mutex_lock_platform+0x4e>
    2352:	2201      	movs	r2, #1
    2354:	6803      	ldr	r3, [r0, #0]
    2356:	e8d3 1fef 	ldaex	r1, [r3]
    235a:	2900      	cmp	r1, #0
    235c:	d103      	bne.n	2366 <mutex_lock_platform+0x36>
    235e:	e8c3 2fe0 	stlex	r0, r2, [r3]
    2362:	2800      	cmp	r0, #0
    2364:	d1f7      	bne.n	2356 <mutex_lock_platform+0x26>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    2366:	d10a      	bne.n	237e <mutex_lock_platform+0x4e>
    2368:	2000      	movs	r0, #0
}
    236a:	bd08      	pop	{r3, pc}
        return nrf_mutex_lock(NRF_MUTEX, *((uint8_t *)mutex->mutex)) ?
    236c:	6803      	ldr	r3, [r0, #0]
    return (p_reg->MUTEX[mutex] == MUTEX_MUTEX_MUTEX_Unlocked);
    236e:	4a07      	ldr	r2, [pc, #28]	; (238c <mutex_lock_platform+0x5c>)
    2370:	781b      	ldrb	r3, [r3, #0]
    2372:	f503 7380 	add.w	r3, r3, #256	; 0x100
    2376:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
                       NRF_CC3XX_PLATFORM_SUCCESS :
    237a:	2b00      	cmp	r3, #0
    237c:	d0f4      	beq.n	2368 <mutex_lock_platform+0x38>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    237e:	4804      	ldr	r0, [pc, #16]	; (2390 <mutex_lock_platform+0x60>)
    2380:	e7f3      	b.n	236a <mutex_lock_platform+0x3a>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    2382:	4804      	ldr	r0, [pc, #16]	; (2394 <mutex_lock_platform+0x64>)
    2384:	e7f1      	b.n	236a <mutex_lock_platform+0x3a>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    2386:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    238a:	e7ee      	b.n	236a <mutex_lock_platform+0x3a>
    238c:	50030000 	.word	0x50030000
    2390:	ffff8fe9 	.word	0xffff8fe9
    2394:	ffff8fea 	.word	0xffff8fea

00002398 <nrf_cc3xx_platform_mutex_init>:
};

/** @brief Function to initialize the nrf_cc3xx_platform mutex APIs
 */
void nrf_cc3xx_platform_mutex_init(void)
{
    2398:	b508      	push	{r3, lr}
    k_mem_slab_init(&mutex_slab,
    239a:	4906      	ldr	r1, [pc, #24]	; (23b4 <nrf_cc3xx_platform_mutex_init+0x1c>)
    239c:	2340      	movs	r3, #64	; 0x40
    239e:	2214      	movs	r2, #20
    23a0:	4805      	ldr	r0, [pc, #20]	; (23b8 <nrf_cc3xx_platform_mutex_init+0x20>)
    23a2:	f01a fe46 	bl	1d032 <k_mem_slab_init>
                mutex_slab_buffer,
                sizeof(struct k_mutex),
                NUM_MUTEXES);

    nrf_cc3xx_platform_set_mutexes(&mutex_apis, &mutexes);
}
    23a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrf_cc3xx_platform_set_mutexes(&mutex_apis, &mutexes);
    23aa:	4904      	ldr	r1, [pc, #16]	; (23bc <nrf_cc3xx_platform_mutex_init+0x24>)
    23ac:	4804      	ldr	r0, [pc, #16]	; (23c0 <nrf_cc3xx_platform_mutex_init+0x28>)
    23ae:	f00f b9db 	b.w	11768 <nrf_cc3xx_platform_set_mutexes>
    23b2:	bf00      	nop
    23b4:	20001514 	.word	0x20001514
    23b8:	200014f8 	.word	0x200014f8
    23bc:	0001eba4 	.word	0x0001eba4
    23c0:	0001eb94 	.word	0x0001eb94

000023c4 <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
    23c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    23c6:	4607      	mov	r7, r0
	const unsigned int rconst[11] = {
    23c8:	4e26      	ldr	r6, [pc, #152]	; (2464 <tc_aes128_set_encrypt_key+0xa0>)
{
    23ca:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
    23cc:	ad01      	add	r5, sp, #4
{
    23ce:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
    23d0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    23d2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    23d4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    23d6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    23d8:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    23dc:	e885 0007 	stmia.w	r5, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
    23e0:	4638      	mov	r0, r7
    23e2:	2f00      	cmp	r7, #0
    23e4:	d039      	beq.n	245a <tc_aes128_set_encrypt_key+0x96>
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
    23e6:	2c00      	cmp	r4, #0
    23e8:	d039      	beq.n	245e <tc_aes128_set_encrypt_key+0x9a>
    23ea:	1f38      	subs	r0, r7, #4
    23ec:	4602      	mov	r2, r0
    23ee:	4621      	mov	r1, r4
    23f0:	3410      	adds	r4, #16
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    23f2:	784b      	ldrb	r3, [r1, #1]
    23f4:	780d      	ldrb	r5, [r1, #0]
    23f6:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    23f8:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    23fc:	78cd      	ldrb	r5, [r1, #3]
    23fe:	3104      	adds	r1, #4
    2400:	432b      	orrs	r3, r5
    2402:	f811 5c02 	ldrb.w	r5, [r1, #-2]
	for (i = 0; i < Nk; ++i) {
    2406:	428c      	cmp	r4, r1
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    2408:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    240c:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
    2410:	d1ef      	bne.n	23f2 <tc_aes128_set_encrypt_key+0x2e>
    2412:	2104      	movs	r1, #4
	}

	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
    2414:	4c14      	ldr	r4, [pc, #80]	; (2468 <tc_aes128_set_encrypt_key+0xa4>)
		if ((i % Nk) == 0) {
    2416:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
    2418:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
    241a:	d116      	bne.n	244a <tc_aes128_set_encrypt_key+0x86>
			t = subword(rotword(t)) ^ rconst[i/Nk];
    241c:	f3c3 4207 	ubfx	r2, r3, #16, #8
    2420:	5ca5      	ldrb	r5, [r4, r2]
    2422:	0e1a      	lsrs	r2, r3, #24
    2424:	5ca2      	ldrb	r2, [r4, r2]
    2426:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    242a:	f3c3 2507 	ubfx	r5, r3, #8, #8
    242e:	5d65      	ldrb	r5, [r4, r5]
    2430:	b2db      	uxtb	r3, r3
    2432:	5ce3      	ldrb	r3, [r4, r3]
    2434:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
    2438:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
    243c:	ad0c      	add	r5, sp, #48	; 0x30
    243e:	f021 0303 	bic.w	r3, r1, #3
    2442:	442b      	add	r3, r5
    2444:	f853 3c2c 	ldr.w	r3, [r3, #-44]
    2448:	4053      	eors	r3, r2
		}
		s->words[i] = s->words[i-Nk] ^ t;
    244a:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
    244e:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
    2450:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
    2452:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
    2454:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
    2456:	d1de      	bne.n	2416 <tc_aes128_set_encrypt_key+0x52>
	}

	return TC_CRYPTO_SUCCESS;
    2458:	2001      	movs	r0, #1
}
    245a:	b00d      	add	sp, #52	; 0x34
    245c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
    245e:	4620      	mov	r0, r4
    2460:	e7fb      	b.n	245a <tc_aes128_set_encrypt_key+0x96>
    2462:	bf00      	nop
    2464:	0001dd4c 	.word	0x0001dd4c
    2468:	00043cad 	.word	0x00043cad

0000246c <tc_aes_encrypt>:
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
}

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
    246c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2470:	4615      	mov	r5, r2
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
    2472:	4606      	mov	r6, r0
{
    2474:	b089      	sub	sp, #36	; 0x24
	if (out == (uint8_t *) 0) {
    2476:	2800      	cmp	r0, #0
    2478:	d058      	beq.n	252c <tc_aes_encrypt+0xc0>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
    247a:	2900      	cmp	r1, #0
    247c:	d059      	beq.n	2532 <tc_aes_encrypt+0xc6>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    247e:	2a00      	cmp	r2, #0
    2480:	d059      	beq.n	2536 <tc_aes_encrypt+0xca>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    2482:	2310      	movs	r3, #16
    2484:	460a      	mov	r2, r1
    2486:	4668      	mov	r0, sp
    2488:	4619      	mov	r1, r3
		s[i] = sbox[s[i]];
    248a:	4c2c      	ldr	r4, [pc, #176]	; (253c <tc_aes_encrypt+0xd0>)
	(void)_copy(state, sizeof(state), in, sizeof(state));
    248c:	f010 f961 	bl	12752 <_copy>
	add_round_key(state, s->words);
    2490:	4629      	mov	r1, r5
    2492:	4668      	mov	r0, sp
    2494:	f010 f975 	bl	12782 <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
    2498:	46a1      	mov	r9, r4
    249a:	f105 0710 	add.w	r7, r5, #16
    249e:	35a0      	adds	r5, #160	; 0xa0
	for (i = 0; i < (Nb * Nk); ++i) {
    24a0:	46e8      	mov	r8, sp
{
    24a2:	466a      	mov	r2, sp
    24a4:	2310      	movs	r3, #16
		s[i] = sbox[s[i]];
    24a6:	7811      	ldrb	r1, [r2, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
    24a8:	3b01      	subs	r3, #1
		s[i] = sbox[s[i]];
    24aa:	5c61      	ldrb	r1, [r4, r1]
    24ac:	f802 1b01 	strb.w	r1, [r2], #1
	for (i = 0; i < (Nb * Nk); ++i) {
    24b0:	d1f9      	bne.n	24a6 <tc_aes_encrypt+0x3a>
		sub_bytes(state);
		shift_rows(state);
    24b2:	4668      	mov	r0, sp
    24b4:	f010 f9aa 	bl	1280c <shift_rows>
	mult_row_column(t, s);
    24b8:	4669      	mov	r1, sp
    24ba:	a804      	add	r0, sp, #16
    24bc:	f010 f9df 	bl	1287e <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
    24c0:	a901      	add	r1, sp, #4
    24c2:	a805      	add	r0, sp, #20
    24c4:	f010 f9db 	bl	1287e <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
    24c8:	a902      	add	r1, sp, #8
    24ca:	a806      	add	r0, sp, #24
    24cc:	f010 f9d7 	bl	1287e <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
    24d0:	a903      	add	r1, sp, #12
    24d2:	a807      	add	r0, sp, #28
    24d4:	f010 f9d3 	bl	1287e <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
    24d8:	2310      	movs	r3, #16
    24da:	4668      	mov	r0, sp
    24dc:	4619      	mov	r1, r3
    24de:	eb0d 0203 	add.w	r2, sp, r3
    24e2:	f010 f936 	bl	12752 <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
    24e6:	4639      	mov	r1, r7
    24e8:	4668      	mov	r0, sp
    24ea:	3710      	adds	r7, #16
    24ec:	f010 f949 	bl	12782 <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
    24f0:	42af      	cmp	r7, r5
    24f2:	d1d5      	bne.n	24a0 <tc_aes_encrypt+0x34>
    24f4:	2410      	movs	r4, #16
		s[i] = sbox[s[i]];
    24f6:	f898 3000 	ldrb.w	r3, [r8]
	for (i = 0; i < (Nb * Nk); ++i) {
    24fa:	3c01      	subs	r4, #1
		s[i] = sbox[s[i]];
    24fc:	f819 3003 	ldrb.w	r3, [r9, r3]
    2500:	f808 3b01 	strb.w	r3, [r8], #1
	for (i = 0; i < (Nb * Nk); ++i) {
    2504:	d1f7      	bne.n	24f6 <tc_aes_encrypt+0x8a>
	}

	sub_bytes(state);
	shift_rows(state);
    2506:	4668      	mov	r0, sp
    2508:	f010 f980 	bl	1280c <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
    250c:	4629      	mov	r1, r5
    250e:	4668      	mov	r0, sp
    2510:	f010 f937 	bl	12782 <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
    2514:	2310      	movs	r3, #16
    2516:	466a      	mov	r2, sp
    2518:	4619      	mov	r1, r3
    251a:	4630      	mov	r0, r6
    251c:	f010 f919 	bl	12752 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    2520:	4668      	mov	r0, sp
    2522:	2210      	movs	r2, #16
    2524:	4621      	mov	r1, r4
    2526:	f010 f921 	bl	1276c <_set>

	return TC_CRYPTO_SUCCESS;
    252a:	2001      	movs	r0, #1
}
    252c:	b009      	add	sp, #36	; 0x24
    252e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return TC_CRYPTO_FAIL;
    2532:	4608      	mov	r0, r1
    2534:	e7fa      	b.n	252c <tc_aes_encrypt+0xc0>
    2536:	4610      	mov	r0, r2
    2538:	e7f8      	b.n	252c <tc_aes_encrypt+0xc0>
    253a:	bf00      	nop
    253c:	00043cad 	.word	0x00043cad

00002540 <compress>:
	n |= ((unsigned int)(*((*c)++)));
	return n;
}

static void compress(unsigned int *iv, const uint8_t *data)
{
    2540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	unsigned int work_space[16];
	unsigned int n;
	unsigned int i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
    2544:	2700      	movs	r7, #0
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
    2546:	6803      	ldr	r3, [r0, #0]
{
    2548:	b09d      	sub	sp, #116	; 0x74
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
    254a:	9303      	str	r3, [sp, #12]
    254c:	6843      	ldr	r3, [r0, #4]
    254e:	f8df a1b8 	ldr.w	sl, [pc, #440]	; 2708 <compress+0x1c8>
    2552:	9304      	str	r3, [sp, #16]
    2554:	6883      	ldr	r3, [r0, #8]
    2556:	9c03      	ldr	r4, [sp, #12]
    2558:	9305      	str	r3, [sp, #20]
    255a:	68c3      	ldr	r3, [r0, #12]
{
    255c:	9102      	str	r1, [sp, #8]
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
    255e:	9306      	str	r3, [sp, #24]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
    2560:	6903      	ldr	r3, [r0, #16]
    2562:	9307      	str	r3, [sp, #28]
    2564:	6943      	ldr	r3, [r0, #20]
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
    2566:	e9dd e206 	ldrd	lr, r2, [sp, #24]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
    256a:	9308      	str	r3, [sp, #32]
    256c:	6983      	ldr	r3, [r0, #24]
    256e:	9309      	str	r3, [sp, #36]	; 0x24
    2570:	69c3      	ldr	r3, [r0, #28]
    2572:	e9dd cb08 	ldrd	ip, fp, [sp, #32]
    2576:	4698      	mov	r8, r3
    2578:	930a      	str	r3, [sp, #40]	; 0x28
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
    257a:	9b05      	ldr	r3, [sp, #20]
    257c:	9301      	str	r3, [sp, #4]
    257e:	9b04      	ldr	r3, [sp, #16]
    2580:	9300      	str	r3, [sp, #0]
	n = (((unsigned int)(*((*c)++))) << 24);
    2582:	9b02      	ldr	r3, [sp, #8]

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
		t2 = Sigma0(a) + Maj(a, b, c);
    2584:	9e01      	ldr	r6, [sp, #4]
    2586:	59dd      	ldr	r5, [r3, r7]
		t1 = work_space[i] = n;
    2588:	ab0c      	add	r3, sp, #48	; 0x30
    258a:	ba2d      	rev	r5, r5
    258c:	51dd      	str	r5, [r3, r7]
	return (((a) >> n) | ((a) << (32 - n)));
    258e:	f85a 3b04 	ldr.w	r3, [sl], #4
    2592:	3704      	adds	r7, #4
    2594:	eb05 0903 	add.w	r9, r5, r3
    2598:	ea4f 25f2 	mov.w	r5, r2, ror #11
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    259c:	ea85 15b2 	eor.w	r5, r5, r2, ror #6
    25a0:	ea85 6572 	eor.w	r5, r5, r2, ror #25
    25a4:	444d      	add	r5, r9
    25a6:	ea2b 0302 	bic.w	r3, fp, r2
    25aa:	ea02 090c 	and.w	r9, r2, ip
    25ae:	ea83 0309 	eor.w	r3, r3, r9
    25b2:	442b      	add	r3, r5
    25b4:	4443      	add	r3, r8
		t2 = Sigma0(a) + Maj(a, b, c);
    25b6:	e9dd 1500 	ldrd	r1, r5, [sp]
	return (((a) >> n) | ((a) << (32 - n)));
    25ba:	ea4f 3874 	mov.w	r8, r4, ror #13
		t2 = Sigma0(a) + Maj(a, b, c);
    25be:	404d      	eors	r5, r1
    25c0:	ea88 08b4 	eor.w	r8, r8, r4, ror #2
    25c4:	4025      	ands	r5, r4
    25c6:	ea01 0906 	and.w	r9, r1, r6
    25ca:	ea85 0509 	eor.w	r5, r5, r9
    25ce:	ea88 58b4 	eor.w	r8, r8, r4, ror #22
    25d2:	44a8      	add	r8, r5
	for (i = 0; i < 16; ++i) {
    25d4:	2f40      	cmp	r7, #64	; 0x40
		h = g; g = f; f = e; e = d + t1;
    25d6:	eb03 050e 	add.w	r5, r3, lr
		d = c; c = b; b = a; a = t1 + t2;
    25da:	4443      	add	r3, r8
	for (i = 0; i < 16; ++i) {
    25dc:	46b6      	mov	lr, r6
    25de:	46d8      	mov	r8, fp
    25e0:	f040 8081 	bne.w	26e6 <compress+0x1a6>
    25e4:	f04f 0a10 	mov.w	sl, #16
    25e8:	4946      	ldr	r1, [pc, #280]	; (2704 <compress+0x1c4>)
    25ea:	910b      	str	r1, [sp, #44]	; 0x2c
	}

	for ( ; i < 64; ++i) {
		s0 = work_space[(i+1)&0x0f];
    25ec:	4651      	mov	r1, sl
    25ee:	f10a 0a01 	add.w	sl, sl, #1
    25f2:	ae1c      	add	r6, sp, #112	; 0x70
    25f4:	f00a 070f 	and.w	r7, sl, #15
    25f8:	eb06 0787 	add.w	r7, r6, r7, lsl #2
    25fc:	f857 6c40 	ldr.w	r6, [r7, #-64]
		s0 = sigma0(s0);
		s1 = work_space[(i+14)&0x0f];
		s1 = sigma1(s1);

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    2600:	f001 090f 	and.w	r9, r1, #15
	return (((a) >> n) | ((a) << (32 - n)));
    2604:	ea4f 48b6 	mov.w	r8, r6, ror #18
		s1 = work_space[(i+14)&0x0f];
    2608:	f101 070e 	add.w	r7, r1, #14
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    260c:	3109      	adds	r1, #9
		s0 = work_space[(i+1)&0x0f];
    260e:	9602      	str	r6, [sp, #8]
		s0 = sigma0(s0);
    2610:	ea88 18f6 	eor.w	r8, r8, r6, ror #7
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    2614:	f001 010f 	and.w	r1, r1, #15
		s1 = work_space[(i+14)&0x0f];
    2618:	ae1c      	add	r6, sp, #112	; 0x70
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    261a:	eb06 0989 	add.w	r9, r6, r9, lsl #2
    261e:	eb06 0181 	add.w	r1, r6, r1, lsl #2
		s1 = work_space[(i+14)&0x0f];
    2622:	f007 070f 	and.w	r7, r7, #15
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    2626:	f851 1c40 	ldr.w	r1, [r1, #-64]
		s1 = work_space[(i+14)&0x0f];
    262a:	eb06 0787 	add.w	r7, r6, r7, lsl #2
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    262e:	f859 6c40 	ldr.w	r6, [r9, #-64]
		s1 = work_space[(i+14)&0x0f];
    2632:	f857 7c40 	ldr.w	r7, [r7, #-64]
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    2636:	4431      	add	r1, r6
		s0 = sigma0(s0);
    2638:	9e02      	ldr	r6, [sp, #8]
	return (((a) >> n) | ((a) << (32 - n)));
    263a:	ea4f 4ef7 	mov.w	lr, r7, ror #19
		s0 = sigma0(s0);
    263e:	ea88 08d6 	eor.w	r8, r8, r6, lsr #3
		s1 = sigma1(s1);
    2642:	ea8e 4e77 	eor.w	lr, lr, r7, ror #17
    2646:	ea8e 2e97 	eor.w	lr, lr, r7, lsr #10
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    264a:	4441      	add	r1, r8
    264c:	4471      	add	r1, lr
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    264e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    2650:	f849 1c40 	str.w	r1, [r9, #-64]
	return (((a) >> n) | ((a) << (32 - n)));
    2654:	ea4f 29f5 	mov.w	r9, r5, ror #11
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    2658:	ea05 0802 	and.w	r8, r5, r2
    265c:	ea89 19b5 	eor.w	r9, r9, r5, ror #6
    2660:	ea2c 0705 	bic.w	r7, ip, r5
    2664:	f856 eb04 	ldr.w	lr, [r6], #4
    2668:	ea87 0708 	eor.w	r7, r7, r8
    266c:	ea89 6975 	eor.w	r9, r9, r5, ror #25
    2670:	444f      	add	r7, r9
    2672:	4477      	add	r7, lr
    2674:	960b      	str	r6, [sp, #44]	; 0x2c
		t2 = Sigma0(a) + Maj(a, b, c);
    2676:	9e00      	ldr	r6, [sp, #0]
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    2678:	4439      	add	r1, r7
    267a:	4459      	add	r1, fp
		t2 = Sigma0(a) + Maj(a, b, c);
    267c:	ea04 0e06 	and.w	lr, r4, r6
    2680:	ea84 0b06 	eor.w	fp, r4, r6
		h = g; g = f; f = e; e = d + t1;
    2684:	9e01      	ldr	r6, [sp, #4]
	return (((a) >> n) | ((a) << (32 - n)));
    2686:	ea4f 3773 	mov.w	r7, r3, ror #13
		h = g; g = f; f = e; e = d + t1;
    268a:	440e      	add	r6, r1
		t2 = Sigma0(a) + Maj(a, b, c);
    268c:	ea87 07b3 	eor.w	r7, r7, r3, ror #2
    2690:	ea0b 0b03 	and.w	fp, fp, r3
    2694:	ea8b 0b0e 	eor.w	fp, fp, lr
		h = g; g = f; f = e; e = d + t1;
    2698:	46b0      	mov	r8, r6
		t2 = Sigma0(a) + Maj(a, b, c);
    269a:	ea87 57b3 	eor.w	r7, r7, r3, ror #22
    269e:	9e00      	ldr	r6, [sp, #0]
    26a0:	445f      	add	r7, fp
	for ( ; i < 64; ++i) {
    26a2:	f1ba 0f40 	cmp.w	sl, #64	; 0x40
    26a6:	46e3      	mov	fp, ip
		d = c; c = b; b = a; a = t1 + t2;
    26a8:	4439      	add	r1, r7
	for ( ; i < 64; ++i) {
    26aa:	9601      	str	r6, [sp, #4]
    26ac:	d123      	bne.n	26f6 <compress+0x1b6>
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
    26ae:	9e03      	ldr	r6, [sp, #12]
    26b0:	440e      	add	r6, r1
    26b2:	9904      	ldr	r1, [sp, #16]
    26b4:	6006      	str	r6, [r0, #0]
    26b6:	4419      	add	r1, r3
    26b8:	9b05      	ldr	r3, [sp, #20]
    26ba:	6041      	str	r1, [r0, #4]
    26bc:	4423      	add	r3, r4
    26be:	9900      	ldr	r1, [sp, #0]
    26c0:	6083      	str	r3, [r0, #8]
    26c2:	9b06      	ldr	r3, [sp, #24]
    26c4:	440b      	add	r3, r1
    26c6:	60c3      	str	r3, [r0, #12]
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
    26c8:	9b07      	ldr	r3, [sp, #28]
    26ca:	4443      	add	r3, r8
    26cc:	6103      	str	r3, [r0, #16]
    26ce:	9b08      	ldr	r3, [sp, #32]
    26d0:	442b      	add	r3, r5
    26d2:	6143      	str	r3, [r0, #20]
    26d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    26d6:	4413      	add	r3, r2
    26d8:	6183      	str	r3, [r0, #24]
    26da:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    26dc:	4463      	add	r3, ip
    26de:	61c3      	str	r3, [r0, #28]
}
    26e0:	b01d      	add	sp, #116	; 0x74
    26e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    26e6:	9900      	ldr	r1, [sp, #0]
    26e8:	46e3      	mov	fp, ip
    26ea:	e9cd 4100 	strd	r4, r1, [sp]
    26ee:	4694      	mov	ip, r2
		d = c; c = b; b = a; a = t1 + t2;
    26f0:	461c      	mov	r4, r3
		h = g; g = f; f = e; e = d + t1;
    26f2:	462a      	mov	r2, r5
    26f4:	e745      	b.n	2582 <compress+0x42>
    26f6:	4694      	mov	ip, r2
    26f8:	9400      	str	r4, [sp, #0]
    26fa:	462a      	mov	r2, r5
    26fc:	461c      	mov	r4, r3
		h = g; g = f; f = e; e = d + t1;
    26fe:	4645      	mov	r5, r8
		d = c; c = b; b = a; a = t1 + t2;
    2700:	460b      	mov	r3, r1
    2702:	e773      	b.n	25ec <compress+0xac>
    2704:	0001ebf8 	.word	0x0001ebf8
    2708:	0001ebb8 	.word	0x0001ebb8

0000270c <tc_sha256_init>:
{
    270c:	b510      	push	{r4, lr}
	if (s == (TCSha256State_t) 0) {
    270e:	4604      	mov	r4, r0
    2710:	b1c8      	cbz	r0, 2746 <tc_sha256_init+0x3a>
	_set((uint8_t *) s, 0x00, sizeof(*s));
    2712:	2270      	movs	r2, #112	; 0x70
    2714:	2100      	movs	r1, #0
    2716:	f010 f829 	bl	1276c <_set>
	s->iv[1] = 0xbb67ae85;
    271a:	4b0b      	ldr	r3, [pc, #44]	; (2748 <tc_sha256_init+0x3c>)
    271c:	4a0b      	ldr	r2, [pc, #44]	; (274c <tc_sha256_init+0x40>)
	s->iv[3] = 0xa54ff53a;
    271e:	490c      	ldr	r1, [pc, #48]	; (2750 <tc_sha256_init+0x44>)
	s->iv[1] = 0xbb67ae85;
    2720:	e9c4 2300 	strd	r2, r3, [r4]
	s->iv[3] = 0xa54ff53a;
    2724:	4b0b      	ldr	r3, [pc, #44]	; (2754 <tc_sha256_init+0x48>)
	s->iv[5] = 0x9b05688c;
    2726:	480c      	ldr	r0, [pc, #48]	; (2758 <tc_sha256_init+0x4c>)
	s->iv[3] = 0xa54ff53a;
    2728:	e9c4 1302 	strd	r1, r3, [r4, #8]
	s->iv[5] = 0x9b05688c;
    272c:	4b0b      	ldr	r3, [pc, #44]	; (275c <tc_sha256_init+0x50>)
    272e:	e9c4 0304 	strd	r0, r3, [r4, #16]
	return TC_CRYPTO_SUCCESS;
    2732:	2001      	movs	r0, #1
	s->iv[6] = 0x1f83d9ab;
    2734:	4b0a      	ldr	r3, [pc, #40]	; (2760 <tc_sha256_init+0x54>)
    2736:	61a3      	str	r3, [r4, #24]
	s->iv[7] = 0x5be0cd19;
    2738:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
    273c:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
    2740:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
    2744:	61e3      	str	r3, [r4, #28]
}
    2746:	bd10      	pop	{r4, pc}
    2748:	bb67ae85 	.word	0xbb67ae85
    274c:	6a09e667 	.word	0x6a09e667
    2750:	3c6ef372 	.word	0x3c6ef372
    2754:	a54ff53a 	.word	0xa54ff53a
    2758:	510e527f 	.word	0x510e527f
    275c:	9b05688c 	.word	0x9b05688c
    2760:	1f83d9ab 	.word	0x1f83d9ab

00002764 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    2764:	4a0a      	ldr	r2, [pc, #40]	; (2790 <arch_swap+0x2c>)
	_current->arch.swap_return_value = _k_neg_eagain;
    2766:	490b      	ldr	r1, [pc, #44]	; (2794 <arch_swap+0x30>)
	_current->arch.basepri = key;
    2768:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    276a:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
    276c:	67d8      	str	r0, [r3, #124]	; 0x7c
	_current->arch.swap_return_value = _k_neg_eagain;
    276e:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    2772:	4909      	ldr	r1, [pc, #36]	; (2798 <arch_swap+0x34>)
    2774:	684b      	ldr	r3, [r1, #4]
    2776:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    277a:	604b      	str	r3, [r1, #4]
    277c:	2300      	movs	r3, #0
    277e:	f383 8811 	msr	BASEPRI, r3
    2782:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    2786:	6893      	ldr	r3, [r2, #8]
}
    2788:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
    278c:	4770      	bx	lr
    278e:	bf00      	nop
    2790:	20025ec8 	.word	0x20025ec8
    2794:	0001f494 	.word	0x0001f494
    2798:	e000ed00 	.word	0xe000ed00

0000279c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    279c:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    279e:	2b00      	cmp	r3, #0
    27a0:	db08      	blt.n	27b4 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    27a2:	2201      	movs	r2, #1
    27a4:	f000 001f 	and.w	r0, r0, #31
    27a8:	fa02 f000 	lsl.w	r0, r2, r0
    27ac:	4a02      	ldr	r2, [pc, #8]	; (27b8 <arch_irq_enable+0x1c>)
    27ae:	095b      	lsrs	r3, r3, #5
    27b0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    27b4:	4770      	bx	lr
    27b6:	bf00      	nop
    27b8:	e000e100 	.word	0xe000e100

000027bc <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    27bc:	4b05      	ldr	r3, [pc, #20]	; (27d4 <arch_irq_is_enabled+0x18>)
    27be:	0942      	lsrs	r2, r0, #5
    27c0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    27c4:	2301      	movs	r3, #1
    27c6:	f000 001f 	and.w	r0, r0, #31
    27ca:	fa03 f000 	lsl.w	r0, r3, r0
}
    27ce:	4010      	ands	r0, r2
    27d0:	4770      	bx	lr
    27d2:	bf00      	nop
    27d4:	e000e100 	.word	0xe000e100

000027d8 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    27d8:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    27da:	2b00      	cmp	r3, #0
	prio += _IRQ_PRIO_OFFSET;
    27dc:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    27e0:	bfac      	ite	ge
    27e2:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    27e6:	4b06      	ldrlt	r3, [pc, #24]	; (2800 <z_arm_irq_priority_set+0x28>)
    27e8:	ea4f 1141 	mov.w	r1, r1, lsl #5
    27ec:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    27ee:	bfab      	itete	ge
    27f0:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    27f4:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    27f8:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    27fc:	5419      	strblt	r1, [r3, r0]
}
    27fe:	4770      	bx	lr
    2800:	e000ed14 	.word	0xe000ed14

00002804 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
    2804:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    2808:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
    280a:	490b      	ldr	r1, [pc, #44]	; (2838 <arch_new_thread+0x34>)
	iframe->a2 = (uint32_t)p1;
    280c:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
    2810:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
    2812:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
    2816:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    281a:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
    281c:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
    2820:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    2824:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    2828:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
    282c:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    282e:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
    2830:	6582      	str	r2, [r0, #88]	; 0x58
	thread->arch.basepri = 0;
    2832:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    2834:	4770      	bx	lr
    2836:	bf00      	nop
    2838:	00011ab1 	.word	0x00011ab1

0000283c <arch_switch_to_main_thread>:
#endif
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    283c:	4604      	mov	r4, r0
    283e:	b508      	push	{r3, lr}
    2840:	460e      	mov	r6, r1
    2842:	4615      	mov	r5, r2
	z_arm_configure_static_mpu_regions();
    2844:	f000 fa00 	bl	2c48 <z_arm_configure_static_mpu_regions>
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    2848:	4b08      	ldr	r3, [pc, #32]	; (286c <arch_switch_to_main_thread+0x30>)
    284a:	609c      	str	r4, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
    284c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    284e:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    2852:	4628      	mov	r0, r5
    2854:	f386 8809 	msr	PSP, r6
    2858:	2100      	movs	r1, #0
    285a:	b663      	cpsie	if
    285c:	f381 8811 	msr	BASEPRI, r1
    2860:	f3bf 8f6f 	isb	sy
    2864:	2200      	movs	r2, #0
    2866:	2300      	movs	r3, #0
    2868:	f00f f922 	bl	11ab0 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    286c:	20025ec8 	.word	0x20025ec8

00002870 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    2870:	4a0e      	ldr	r2, [pc, #56]	; (28ac <z_arm_prep_c+0x3c>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    2872:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    2874:	4b0e      	ldr	r3, [pc, #56]	; (28b0 <z_arm_prep_c+0x40>)
    2876:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    287a:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    287c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2880:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    2884:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    2888:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    288c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    2890:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    2894:	f023 0304 	bic.w	r3, r3, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    2898:	f383 8814 	msr	CONTROL, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    289c:	f00d fbfe 	bl	1009c <z_bss_zero>
	z_data_copy();
    28a0:	f00e fc20 	bl	110e4 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    28a4:	f000 f9a2 	bl	2bec <z_arm_interrupt_init>
	z_cstart();
    28a8:	f00d fc1c 	bl	100e4 <z_cstart>
    28ac:	00000000 	.word	0x00000000
    28b0:	e000ed00 	.word	0xe000ed00

000028b4 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    28b4:	4913      	ldr	r1, [pc, #76]	; (2904 <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
    28b6:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    28b8:	f04f 0038 	mov.w	r0, #56	; 0x38
    add r0, r2
    28bc:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    28be:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    28c2:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    28c6:	2020      	movs	r0, #32
    msr BASEPRI, r0
    28c8:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    28cc:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    28d0:	4f0d      	ldr	r7, [pc, #52]	; (2908 <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    28d2:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    28d6:	6a8a      	ldr	r2, [r1, #40]	; 0x28

    str r2, [r1, #_kernel_offset_to_current]
    28d8:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    28da:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    28dc:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
    movs r3, #0
    28de:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    28e0:	67d3      	str	r3, [r2, #124]	; 0x7c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    28e2:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    28e6:	f102 0038 	add.w	r0, r2, #56	; 0x38
    ldmia r0, {v1-v8, ip}
    28ea:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    28ee:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
    28f2:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
    28f6:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
    28f8:	f010 fb25 	bl	12f46 <configure_builtin_stack_guard>
    pop {r2, lr}
    28fc:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    2900:	4770      	bx	lr
    2902:	0000      	.short	0x0000
    ldr r1, =_kernel
    2904:	20025ec8 	.word	0x20025ec8
    ldr v4, =_SCS_ICSR
    2908:	e000ed04 	.word	0xe000ed04

0000290c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    290c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    2910:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    2912:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    2916:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    291a:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    291c:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    2920:	2902      	cmp	r1, #2
    beq _oops
    2922:	d0ff      	beq.n	2924 <_oops>

00002924 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    2924:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    2926:	f010 fb14 	bl	12f52 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    292a:	bd01      	pop	{r0, pc}

0000292c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    292c:	4901      	ldr	r1, [pc, #4]	; (2934 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    292e:	2210      	movs	r2, #16
	str	r2, [r1]
    2930:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    2932:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    2934:	e000ed10 	.word	0xe000ed10

00002938 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    2938:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    293a:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    293c:	f380 8811 	msr	BASEPRI, r0
	isb
    2940:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    2944:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    2948:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    294a:	b662      	cpsie	i
	isb
    294c:	f3bf 8f6f 	isb	sy

	bx	lr
    2950:	4770      	bx	lr
    2952:	bf00      	nop

00002954 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    2954:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    2956:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    2958:	f381 8811 	msr	BASEPRI, r1

	wfe
    295c:	bf20      	wfe

	msr	BASEPRI, r0
    295e:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    2962:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    2964:	4770      	bx	lr
    2966:	bf00      	nop

00002968 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    2968:	bf30      	wfi
    b z_SysNmiOnReset
    296a:	f7ff bffd 	b.w	2968 <z_SysNmiOnReset>
    296e:	bf00      	nop

00002970 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    2970:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    2972:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    2974:	4a0b      	ldr	r2, [pc, #44]	; (29a4 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    2976:	6a50      	ldr	r0, [r2, #36]	; 0x24
	cmp r0, #0
    2978:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    297a:	bf1e      	ittt	ne
	movne	r1, #0
    297c:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    297e:	6251      	strne	r1, [r2, #36]	; 0x24
		blne	z_pm_save_idle_exit
    2980:	f01a fae9 	blne	1cf56 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    2984:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    2986:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    298a:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    298e:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    2992:	4905      	ldr	r1, [pc, #20]	; (29a8 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    2994:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    2996:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    2998:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    299a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    299e:	4903      	ldr	r1, [pc, #12]	; (29ac <_isr_wrapper+0x3c>)
	bx r1
    29a0:	4708      	bx	r1
    29a2:	0000      	.short	0x0000
	ldr r2, =_kernel
    29a4:	20025ec8 	.word	0x20025ec8
	ldr r1, =_sw_isr_table
    29a8:	0001dac8 	.word	0x0001dac8
	ldr r1, =z_arm_int_exit
    29ac:	000029f5 	.word	0x000029f5

000029b0 <__start>:
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    29b0:	f00f fb50 	bl	12054 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    29b4:	2020      	movs	r0, #32
    msr BASEPRI, r0
    29b6:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    29ba:	4808      	ldr	r0, [pc, #32]	; (29dc <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    29bc:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    29c0:	1840      	adds	r0, r0, r1
    msr PSP, r0
    29c2:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    29c6:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    29ca:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    29cc:	4308      	orrs	r0, r1
    msr CONTROL, r0
    29ce:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    29d2:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    29d6:	f7ff ff4b 	bl	2870 <z_arm_prep_c>
    29da:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    29dc:	2002d2f0 	.word	0x2002d2f0

000029e0 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    29e0:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    29e4:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    29e8:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    29ea:	4672      	mov	r2, lr
	bl z_arm_fault
    29ec:	f000 f864 	bl	2ab8 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    29f0:	bd01      	pop	{r0, pc}
    29f2:	bf00      	nop

000029f4 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    29f4:	4b04      	ldr	r3, [pc, #16]	; (2a08 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    29f6:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    29f8:	6a98      	ldr	r0, [r3, #40]	; 0x28
	cmp r0, r1
    29fa:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    29fc:	d003      	beq.n	2a06 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    29fe:	4903      	ldr	r1, [pc, #12]	; (2a0c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    2a00:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    2a04:	600a      	str	r2, [r1, #0]

00002a06 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    2a06:	4770      	bx	lr
	ldr r3, =_kernel
    2a08:	20025ec8 	.word	0x20025ec8
	ldr r1, =_SCS_ICSR
    2a0c:	e000ed04 	.word	0xe000ed04

00002a10 <mem_manage_fault.isra.0>:
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    2a10:	4b0e      	ldr	r3, [pc, #56]	; (2a4c <mem_manage_fault.isra.0+0x3c>)
    2a12:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    2a14:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    2a16:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a18:	0792      	lsls	r2, r2, #30
    2a1a:	d508      	bpl.n	2a2e <mem_manage_fault.isra.0+0x1e>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
    2a1c:	6b5a      	ldr	r2, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    2a1e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a20:	0612      	lsls	r2, r2, #24
    2a22:	d504      	bpl.n	2a2e <mem_manage_fault.isra.0+0x1e>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault) {
    2a24:	b118      	cbz	r0, 2a2e <mem_manage_fault.isra.0+0x1e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    2a26:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a28:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    2a2c:	629a      	str	r2, [r3, #40]	; 0x28

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
    2a2e:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    2a30:	4b06      	ldr	r3, [pc, #24]	; (2a4c <mem_manage_fault.isra.0+0x3c>)
    2a32:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    2a34:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    2a36:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a38:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    2a3a:	bf58      	it	pl
    2a3c:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    2a3e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a40:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    2a44:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    2a46:	7008      	strb	r0, [r1, #0]

	return reason;
}
    2a48:	4770      	bx	lr
    2a4a:	bf00      	nop
    2a4c:	e000ed00 	.word	0xe000ed00

00002a50 <bus_fault.isra.0>:
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    2a50:	4b0d      	ldr	r3, [pc, #52]	; (2a88 <bus_fault.isra.0+0x38>)
    2a52:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    2a54:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    2a56:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a58:	0592      	lsls	r2, r2, #22
    2a5a:	d508      	bpl.n	2a6e <bus_fault.isra.0+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    2a5c:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    2a5e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a60:	0412      	lsls	r2, r2, #16
    2a62:	d504      	bpl.n	2a6e <bus_fault.isra.0+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault) {
    2a64:	b118      	cbz	r0, 2a6e <bus_fault.isra.0+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    2a66:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a68:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    2a6c:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
    2a6e:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    2a70:	4b05      	ldr	r3, [pc, #20]	; (2a88 <bus_fault.isra.0+0x38>)
    2a72:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    2a74:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a76:	05d2      	lsls	r2, r2, #23
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    2a78:	bf58      	it	pl
    2a7a:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    2a7c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2a7e:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
    2a82:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    2a84:	7008      	strb	r0, [r1, #0]

	return reason;
}
    2a86:	4770      	bx	lr
    2a88:	e000ed00 	.word	0xe000ed00

00002a8c <usage_fault.isra.0>:
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    2a8c:	4b09      	ldr	r3, [pc, #36]	; (2ab4 <usage_fault.isra.0+0x28>)
    2a8e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    2a90:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unaligned memory access");
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    2a92:	6a98      	ldr	r0, [r3, #40]	; 0x28
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    2a94:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    2a96:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    2a98:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    2a9a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    2a9c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    2a9e:	f410 1080 	ands.w	r0, r0, #1048576	; 0x100000
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    2aa2:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    2aa6:	ea6f 4212 	mvn.w	r2, r2, lsr #16

	return reason;
}
    2aaa:	bf18      	it	ne
    2aac:	2002      	movne	r0, #2
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    2aae:	629a      	str	r2, [r3, #40]	; 0x28
}
    2ab0:	4770      	bx	lr
    2ab2:	bf00      	nop
    2ab4:	e000ed00 	.word	0xe000ed00

00002ab8 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    2ab8:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    2aba:	4b39      	ldr	r3, [pc, #228]	; (2ba0 <z_arm_fault+0xe8>)
{
    2abc:	460c      	mov	r4, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    2abe:	685b      	ldr	r3, [r3, #4]
    2ac0:	2500      	movs	r5, #0
{
    2ac2:	b08b      	sub	sp, #44	; 0x2c
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    2ac4:	f3c3 0308 	ubfx	r3, r3, #0, #9
    2ac8:	f385 8811 	msr	BASEPRI, r5
    2acc:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    2ad0:	f002 417f 	and.w	r1, r2, #4278190080	; 0xff000000
    2ad4:	f1b1 4f7f 	cmp.w	r1, #4278190080	; 0xff000000
    2ad8:	d111      	bne.n	2afe <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    2ada:	f002 010c 	and.w	r1, r2, #12
    2ade:	2908      	cmp	r1, #8
    2ae0:	d00d      	beq.n	2afe <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    2ae2:	0711      	lsls	r1, r2, #28
    2ae4:	d401      	bmi.n	2aea <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
    2ae6:	4604      	mov	r4, r0
			*nested_exc = true;
    2ae8:	2501      	movs	r5, #1
	*recoverable = false;
    2aea:	2200      	movs	r2, #0
    2aec:	3b03      	subs	r3, #3
    2aee:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    2af2:	2b03      	cmp	r3, #3
    2af4:	d84d      	bhi.n	2b92 <z_arm_fault+0xda>
    2af6:	e8df f003 	tbb	[pc, r3]
    2afa:	4404      	.short	0x4404
    2afc:	4148      	.short	0x4148
		return NULL;
    2afe:	462c      	mov	r4, r5
    2b00:	e7f3      	b.n	2aea <z_arm_fault+0x32>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    2b02:	4b27      	ldr	r3, [pc, #156]	; (2ba0 <z_arm_fault+0xe8>)
    2b04:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2b06:	0792      	lsls	r2, r2, #30
    2b08:	d443      	bmi.n	2b92 <z_arm_fault+0xda>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    2b0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2b0c:	f013 4380 	ands.w	r3, r3, #1073741824	; 0x40000000
    2b10:	d008      	beq.n	2b24 <z_arm_fault+0x6c>
		if (SCB_MMFSR != 0) {
    2b12:	4b24      	ldr	r3, [pc, #144]	; (2ba4 <z_arm_fault+0xec>)
    2b14:	781b      	ldrb	r3, [r3, #0]
    2b16:	b31b      	cbz	r3, 2b60 <z_arm_fault+0xa8>
			reason = mem_manage_fault(esf, 1, recoverable);
    2b18:	2001      	movs	r0, #1
    2b1a:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
    2b1e:	f7ff ff77 	bl	2a10 <mem_manage_fault.isra.0>
		reason = usage_fault(esf);
    2b22:	4603      	mov	r3, r0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    2b24:	f89d 2007 	ldrb.w	r2, [sp, #7]
    2b28:	b9c2      	cbnz	r2, 2b5c <z_arm_fault+0xa4>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    2b2a:	ae02      	add	r6, sp, #8
    2b2c:	f104 0720 	add.w	r7, r4, #32
    2b30:	4632      	mov	r2, r6
    2b32:	6820      	ldr	r0, [r4, #0]
    2b34:	6861      	ldr	r1, [r4, #4]
    2b36:	3408      	adds	r4, #8
    2b38:	c203      	stmia	r2!, {r0, r1}
    2b3a:	42bc      	cmp	r4, r7
    2b3c:	4616      	mov	r6, r2
    2b3e:	d1f7      	bne.n	2b30 <z_arm_fault+0x78>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    2b40:	9a09      	ldr	r2, [sp, #36]	; 0x24
    2b42:	b345      	cbz	r5, 2b96 <z_arm_fault+0xde>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    2b44:	f3c2 0108 	ubfx	r1, r2, #0, #9
    2b48:	b921      	cbnz	r1, 2b54 <z_arm_fault+0x9c>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    2b4a:	ea6f 2252 	mvn.w	r2, r2, lsr #9
    2b4e:	ea6f 2242 	mvn.w	r2, r2, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    2b52:	9209      	str	r2, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    2b54:	4618      	mov	r0, r3
    2b56:	a902      	add	r1, sp, #8
    2b58:	f010 f9f9 	bl	12f4e <z_arm_fatal_error>
}
    2b5c:	b00b      	add	sp, #44	; 0x2c
    2b5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		} else if (SCB_BFSR != 0) {
    2b60:	4b11      	ldr	r3, [pc, #68]	; (2ba8 <z_arm_fault+0xf0>)
    2b62:	781b      	ldrb	r3, [r3, #0]
    2b64:	b12b      	cbz	r3, 2b72 <z_arm_fault+0xba>
			reason = bus_fault(esf, 1, recoverable);
    2b66:	2001      	movs	r0, #1
    2b68:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
    2b6c:	f7ff ff70 	bl	2a50 <bus_fault.isra.0>
    2b70:	e7d7      	b.n	2b22 <z_arm_fault+0x6a>
		} else if (SCB_UFSR != 0) {
    2b72:	4b0e      	ldr	r3, [pc, #56]	; (2bac <z_arm_fault+0xf4>)
    2b74:	8818      	ldrh	r0, [r3, #0]
    2b76:	b283      	uxth	r3, r0
    2b78:	2b00      	cmp	r3, #0
    2b7a:	d0d3      	beq.n	2b24 <z_arm_fault+0x6c>
		reason = usage_fault(esf);
    2b7c:	f7ff ff86 	bl	2a8c <usage_fault.isra.0>
    2b80:	e7cf      	b.n	2b22 <z_arm_fault+0x6a>
		reason = mem_manage_fault(esf, 0, recoverable);
    2b82:	2000      	movs	r0, #0
    2b84:	f10d 0107 	add.w	r1, sp, #7
    2b88:	e7c9      	b.n	2b1e <z_arm_fault+0x66>
		reason = bus_fault(esf, 0, recoverable);
    2b8a:	2000      	movs	r0, #0
    2b8c:	f10d 0107 	add.w	r1, sp, #7
    2b90:	e7ec      	b.n	2b6c <z_arm_fault+0xb4>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    2b92:	2300      	movs	r3, #0
    2b94:	e7c6      	b.n	2b24 <z_arm_fault+0x6c>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    2b96:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
    2b9a:	f022 0201 	bic.w	r2, r2, #1
    2b9e:	e7d8      	b.n	2b52 <z_arm_fault+0x9a>
    2ba0:	e000ed00 	.word	0xe000ed00
    2ba4:	e000ed28 	.word	0xe000ed28
    2ba8:	e000ed29 	.word	0xe000ed29
    2bac:	e000ed2a 	.word	0xe000ed2a

00002bb0 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    2bb0:	4b04      	ldr	r3, [pc, #16]	; (2bc4 <z_arm_fault_init+0x14>)
    2bb2:	695a      	ldr	r2, [r3, #20]
    2bb4:	f042 0210 	orr.w	r2, r2, #16
    2bb8:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
    2bba:	695a      	ldr	r2, [r3, #20]
    2bbc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    2bc0:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    2bc2:	4770      	bx	lr
    2bc4:	e000ed00 	.word	0xe000ed00

00002bc8 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
    2bc8:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    2bcc:	4905      	ldr	r1, [pc, #20]	; (2be4 <sys_arch_reboot+0x1c>)
    2bce:	4b06      	ldr	r3, [pc, #24]	; (2be8 <sys_arch_reboot+0x20>)
    2bd0:	68ca      	ldr	r2, [r1, #12]
    2bd2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    2bd6:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    2bd8:	60cb      	str	r3, [r1, #12]
    2bda:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    2bde:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    2be0:	e7fd      	b.n	2bde <sys_arch_reboot+0x16>
    2be2:	bf00      	nop
    2be4:	e000ed00 	.word	0xe000ed00
    2be8:	05fa0004 	.word	0x05fa0004

00002bec <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    2bec:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2bee:	2120      	movs	r1, #32
    2bf0:	4803      	ldr	r0, [pc, #12]	; (2c00 <z_arm_interrupt_init+0x14>)
    2bf2:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    2bf4:	3301      	adds	r3, #1
    2bf6:	2b45      	cmp	r3, #69	; 0x45
    2bf8:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    2bfc:	d1f9      	bne.n	2bf2 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    2bfe:	4770      	bx	lr
    2c00:	e000e100 	.word	0xe000e100

00002c04 <z_impl_k_thread_abort>:
#include <kswap.h>
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    2c04:	b508      	push	{r3, lr}
	if (_current == thread) {
    2c06:	4b0e      	ldr	r3, [pc, #56]	; (2c40 <z_impl_k_thread_abort+0x3c>)
    2c08:	689b      	ldr	r3, [r3, #8]
    2c0a:	4283      	cmp	r3, r0
    2c0c:	d107      	bne.n	2c1e <z_impl_k_thread_abort+0x1a>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    2c0e:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    2c12:	b193      	cbz	r3, 2c3a <z_impl_k_thread_abort+0x36>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    2c14:	4a0b      	ldr	r2, [pc, #44]	; (2c44 <z_impl_k_thread_abort+0x40>)
    2c16:	6853      	ldr	r3, [r2, #4]
    2c18:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    2c1c:	6053      	str	r3, [r2, #4]
		} else {
			z_self_abort(); /* Never returns */
		}
	}

	z_thread_single_abort(thread);
    2c1e:	f00d fee3 	bl	109e8 <z_thread_single_abort>
	__asm__ volatile(
    2c22:	f04f 0320 	mov.w	r3, #32
    2c26:	f3ef 8011 	mrs	r0, BASEPRI
    2c2a:	f383 8811 	msr	BASEPRI, r3
    2c2e:	f3bf 8f6f 	isb	sy

	/* The abort handler might have altered the ready queue. */
	z_reschedule_unlocked();
}
    2c32:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
}

static inline void z_reschedule_unlocked(void)
{
	(void) z_reschedule_irqlock(arch_irq_lock());
    2c36:	f01a bb15 	b.w	1d264 <z_reschedule_irqlock>
			z_self_abort(); /* Never returns */
    2c3a:	f00e f9cd 	bl	10fd8 <z_self_abort>
    2c3e:	bf00      	nop
    2c40:	20025ec8 	.word	0x20025ec8
    2c44:	e000ed00 	.word	0xe000ed00

00002c48 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    2c48:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    2c4a:	4c09      	ldr	r4, [pc, #36]	; (2c70 <z_arm_configure_static_mpu_regions+0x28>)
    2c4c:	4a09      	ldr	r2, [pc, #36]	; (2c74 <z_arm_configure_static_mpu_regions+0x2c>)
    2c4e:	4623      	mov	r3, r4
    2c50:	2101      	movs	r1, #1
    2c52:	4809      	ldr	r0, [pc, #36]	; (2c78 <z_arm_configure_static_mpu_regions+0x30>)
    2c54:	f000 f902 	bl	2e5c <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    2c58:	2300      	movs	r3, #0
    2c5a:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    2c5c:	4b07      	ldr	r3, [pc, #28]	; (2c7c <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    2c5e:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    2c60:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    2c62:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    2c64:	9301      	str	r3, [sp, #4]
    2c66:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    2c68:	f000 f902 	bl	2e70 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    2c6c:	b004      	add	sp, #16
    2c6e:	bd10      	pop	{r4, pc}
    2c70:	20070000 	.word	0x20070000
    2c74:	20000000 	.word	0x20000000
    2c78:	0001ecb8 	.word	0x0001ecb8
    2c7c:	200009b0 	.word	0x200009b0

00002c80 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
    2c80:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
    2c82:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
    2c84:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
    2c86:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
    2c8a:	f004 031f 	and.w	r3, r4, #31
    2c8e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    2c90:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    2c92:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    2c94:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
    2c98:	4904      	ldr	r1, [pc, #16]	; (2cac <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    2c9a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
    2c9e:	f043 0301 	orr.w	r3, r3, #1
    2ca2:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
    2ca4:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
    2ca6:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
    2ca8:	bd10      	pop	{r4, pc}
    2caa:	bf00      	nop
    2cac:	e000ed90 	.word	0xe000ed90

00002cb0 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
    2cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2cb4:	4688      	mov	r8, r1
    2cb6:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    2cb8:	4606      	mov	r6, r0
    2cba:	f04f 0900 	mov.w	r9, #0
	MPU->RNR = index;
    2cbe:	4d4a      	ldr	r5, [pc, #296]	; (2de8 <mpu_configure_regions_and_partition.constprop.0+0x138>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
    2cc0:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
    2cc2:	45c1      	cmp	r9, r8
    2cc4:	da05      	bge.n	2cd2 <mpu_configure_regions_and_partition.constprop.0+0x22>
		if (regions[i].size == 0U) {
    2cc6:	6877      	ldr	r7, [r6, #4]
    2cc8:	b3bf      	cbz	r7, 2d3a <mpu_configure_regions_and_partition.constprop.0+0x8a>
		&&
    2cca:	2f1f      	cmp	r7, #31
    2ccc:	d805      	bhi.n	2cda <mpu_configure_regions_and_partition.constprop.0+0x2a>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
    2cce:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
    2cd2:	4620      	mov	r0, r4
    2cd4:	b005      	add	sp, #20
    2cd6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		&&
    2cda:	06fb      	lsls	r3, r7, #27
    2cdc:	d1f7      	bne.n	2cce <mpu_configure_regions_and_partition.constprop.0+0x1e>
		((part->start &
    2cde:	f8d6 a000 	ldr.w	sl, [r6]
		&&
    2ce2:	f01a 0f1f 	tst.w	sl, #31
    2ce6:	d1f2      	bne.n	2cce <mpu_configure_regions_and_partition.constprop.0+0x1e>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    2ce8:	4650      	mov	r0, sl
    2cea:	f010 f95a 	bl	12fa2 <arm_cmse_mpu_region_get>
    2cee:	4683      	mov	fp, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    2cf0:	eb07 000a 	add.w	r0, r7, sl
    2cf4:	3801      	subs	r0, #1
    2cf6:	f010 f954 	bl	12fa2 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    2cfa:	4583      	cmp	fp, r0
    2cfc:	d1e7      	bne.n	2cce <mpu_configure_regions_and_partition.constprop.0+0x1e>
		if ((u_reg_index == -EINVAL) ||
    2cfe:	f11b 0f16 	cmn.w	fp, #22
    2d02:	d0e4      	beq.n	2cce <mpu_configure_regions_and_partition.constprop.0+0x1e>
			(u_reg_index > (reg_index - 1))) {
    2d04:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
    2d06:	455b      	cmp	r3, fp
    2d08:	dbe1      	blt.n	2cce <mpu_configure_regions_and_partition.constprop.0+0x1e>
	MPU->RNR = index;
    2d0a:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    2d0e:	68e9      	ldr	r1, [r5, #12]
	MPU->RNR = index;
    2d10:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    2d14:	692f      	ldr	r7, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    2d16:	f021 011f 	bic.w	r1, r1, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
    2d1a:	e9d6 3200 	ldrd	r3, r2, [r6]
    2d1e:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
    2d20:	4299      	cmp	r1, r3
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    2d22:	f047 071f 	orr.w	r7, r7, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
    2d26:	f102 3aff 	add.w	sl, r2, #4294967295
		if ((regions[i].start == u_reg_base) &&
    2d2a:	d11c      	bne.n	2d66 <mpu_configure_regions_and_partition.constprop.0+0xb6>
    2d2c:	4557      	cmp	r7, sl
    2d2e:	d108      	bne.n	2d42 <mpu_configure_regions_and_partition.constprop.0+0x92>
			mpu_configure_region(u_reg_index, &regions[i]);
    2d30:	4631      	mov	r1, r6
    2d32:	fa5f f08b 	uxtb.w	r0, fp
    2d36:	f010 f917 	bl	12f68 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
    2d3a:	f109 0901 	add.w	r9, r9, #1
    2d3e:	360c      	adds	r6, #12
    2d40:	e7bf      	b.n	2cc2 <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
    2d42:	4631      	mov	r1, r6
	MPU->RNR = index;
    2d44:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    2d48:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
    2d4a:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    2d4e:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
    2d52:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    2d54:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, &regions[i]);
    2d56:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
    2d58:	f010 f906 	bl	12f68 <mpu_configure_region>
			if (reg_index == -EINVAL) {
    2d5c:	f110 0f16 	cmn.w	r0, #22
    2d60:	d0b5      	beq.n	2cce <mpu_configure_regions_and_partition.constprop.0+0x1e>
			reg_index++;
    2d62:	1c44      	adds	r4, r0, #1
    2d64:	e7e9      	b.n	2d3a <mpu_configure_regions_and_partition.constprop.0+0x8a>
		} else if (reg_last == u_reg_last) {
    2d66:	3b01      	subs	r3, #1
    2d68:	4557      	cmp	r7, sl
    2d6a:	b2e0      	uxtb	r0, r4
    2d6c:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
    2d70:	f8c5 b008 	str.w	fp, [r5, #8]
		} else if (reg_last == u_reg_last) {
    2d74:	d106      	bne.n	2d84 <mpu_configure_regions_and_partition.constprop.0+0xd4>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    2d76:	692a      	ldr	r2, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
    2d78:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    2d7a:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    2d7e:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    2d80:	612b      	str	r3, [r5, #16]
			reg_index =
    2d82:	e7e9      	b.n	2d58 <mpu_configure_regions_and_partition.constprop.0+0xa8>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    2d84:	6929      	ldr	r1, [r5, #16]
    2d86:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    2d8a:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    2d8c:	612b      	str	r3, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
    2d8e:	4631      	mov	r1, r6
    2d90:	f010 f8ea 	bl	12f68 <mpu_configure_region>
			if (reg_index == -EINVAL) {
    2d94:	f110 0f16 	cmn.w	r0, #22
    2d98:	d099      	beq.n	2cce <mpu_configure_regions_and_partition.constprop.0+0x1e>
	MPU->RNR = index;
    2d9a:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
    2d9e:	68ea      	ldr	r2, [r5, #12]
    2da0:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
    2da4:	3f01      	subs	r7, #1
	attr->rbar = MPU->RBAR &
    2da6:	f362 0304 	bfi	r3, r2, #0, #5
    2daa:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    2dae:	692b      	ldr	r3, [r5, #16]
    2db0:	f89d 2008 	ldrb.w	r2, [sp, #8]
    2db4:	085b      	lsrs	r3, r3, #1
    2db6:	f363 1247 	bfi	r2, r3, #5, #3
    2dba:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
    2dbe:	e9d6 3200 	ldrd	r3, r2, [r6]
    2dc2:	4413      	add	r3, r2
    2dc4:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
    2dc6:	f023 031f 	bic.w	r3, r3, #31
    2dca:	443b      	add	r3, r7
			reg_index++;
    2dcc:	1c44      	adds	r4, r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
    2dce:	eba3 0a0a 	sub.w	sl, r3, sl
    2dd2:	b2e0      	uxtb	r0, r4
    2dd4:	f02a 031f 	bic.w	r3, sl, #31

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
    2dd8:	2807      	cmp	r0, #7
			fill_region.attr.r_limit =
    2dda:	9303      	str	r3, [sp, #12]
    2ddc:	f63f af77 	bhi.w	2cce <mpu_configure_regions_and_partition.constprop.0+0x1e>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    2de0:	4669      	mov	r1, sp
    2de2:	f7ff ff4d 	bl	2c80 <region_init>
    2de6:	e7bc      	b.n	2d62 <mpu_configure_regions_and_partition.constprop.0+0xb2>
    2de8:	e000ed90 	.word	0xe000ed90

00002dec <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    2dec:	2205      	movs	r2, #5
    2dee:	4b03      	ldr	r3, [pc, #12]	; (2dfc <arm_core_mpu_enable+0x10>)
    2df0:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    2df2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2df6:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    2dfa:	4770      	bx	lr
    2dfc:	e000ed90 	.word	0xe000ed90

00002e00 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    2e00:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    2e04:	2200      	movs	r2, #0
    2e06:	4b01      	ldr	r3, [pc, #4]	; (2e0c <arm_core_mpu_disable+0xc>)
    2e08:	605a      	str	r2, [r3, #4]
}
    2e0a:	4770      	bx	lr
    2e0c:	e000ed90 	.word	0xe000ed90

00002e10 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(const struct device *arg)
{
    2e10:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    2e12:	4c0e      	ldr	r4, [pc, #56]	; (2e4c <arm_mpu_init+0x3c>)
    2e14:	6825      	ldr	r5, [r4, #0]
    2e16:	2d08      	cmp	r5, #8
    2e18:	d814      	bhi.n	2e44 <arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    2e1a:	f7ff fff1 	bl	2e00 <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    2e1e:	2000      	movs	r0, #0
	MPU->MAIR0 =
    2e20:	4b0b      	ldr	r3, [pc, #44]	; (2e50 <arm_mpu_init+0x40>)
    2e22:	4a0c      	ldr	r2, [pc, #48]	; (2e54 <arm_mpu_init+0x44>)
    2e24:	631a      	str	r2, [r3, #48]	; 0x30
    2e26:	4285      	cmp	r5, r0
    2e28:	d105      	bne.n	2e36 <arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    2e2a:	4b0b      	ldr	r3, [pc, #44]	; (2e58 <arm_mpu_init+0x48>)
    2e2c:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
    2e2e:	f7ff ffdd 	bl	2dec <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    2e32:	2000      	movs	r0, #0
}
    2e34:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    2e36:	6861      	ldr	r1, [r4, #4]
    2e38:	eb01 1100 	add.w	r1, r1, r0, lsl #4
    2e3c:	f7ff ff20 	bl	2c80 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    2e40:	3001      	adds	r0, #1
    2e42:	e7f0      	b.n	2e26 <arm_mpu_init+0x16>
		return -1;
    2e44:	f04f 30ff 	mov.w	r0, #4294967295
    2e48:	e7f4      	b.n	2e34 <arm_mpu_init+0x24>
    2e4a:	bf00      	nop
    2e4c:	0001ecc4 	.word	0x0001ecc4
    2e50:	e000ed90 	.word	0xe000ed90
    2e54:	0044ffaa 	.word	0x0044ffaa
    2e58:	20029f3c 	.word	0x20029f3c

00002e5c <arm_core_mpu_configure_static_mpu_regions>:
{
    2e5c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    2e5e:	4c03      	ldr	r4, [pc, #12]	; (2e6c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
    2e60:	7822      	ldrb	r2, [r4, #0]
    2e62:	f7ff ff25 	bl	2cb0 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    2e66:	7020      	strb	r0, [r4, #0]
}
    2e68:	bd10      	pop	{r4, pc}
    2e6a:	bf00      	nop
    2e6c:	20029f3c 	.word	0x20029f3c

00002e70 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
    2e70:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e74:	4d26      	ldr	r5, [pc, #152]	; (2f10 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
    2e76:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    2e78:	4606      	mov	r6, r0
    2e7a:	f04f 0800 	mov.w	r8, #0
    2e7e:	46ab      	mov	fp, r5
	MPU->RNR = index;
    2e80:	4f24      	ldr	r7, [pc, #144]	; (2f14 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
    2e82:	45d0      	cmp	r8, sl
    2e84:	da1b      	bge.n	2ebe <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
    2e86:	f8d6 9004 	ldr.w	r9, [r6, #4]
    2e8a:	f1b9 0f00 	cmp.w	r9, #0
    2e8e:	d039      	beq.n	2f04 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
    2e90:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    2e92:	4608      	mov	r0, r1
    2e94:	9101      	str	r1, [sp, #4]
    2e96:	f010 f884 	bl	12fa2 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    2e9a:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    2e9c:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    2e9e:	eb09 0001 	add.w	r0, r9, r1
    2ea2:	3801      	subs	r0, #1
    2ea4:	f010 f87d 	bl	12fa2 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    2ea8:	4284      	cmp	r4, r0
    2eaa:	f04f 0214 	mov.w	r2, #20
    2eae:	4b1a      	ldr	r3, [pc, #104]	; (2f18 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
    2eb0:	d008      	beq.n	2ec4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
    2eb2:	f06f 0315 	mvn.w	r3, #21
    2eb6:	fb02 f808 	mul.w	r8, r2, r8
    2eba:	f84b 3008 	str.w	r3, [fp, r8]
}
    2ebe:	b003      	add	sp, #12
    2ec0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
    2ec4:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
    2ec8:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
    2eca:	d0f8      	beq.n	2ebe <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    2ecc:	7819      	ldrb	r1, [r3, #0]
    2ece:	42a1      	cmp	r1, r4
    2ed0:	ddf5      	ble.n	2ebe <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
    2ed2:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
    2ed6:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
    2ed8:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
    2eda:	68fc      	ldr	r4, [r7, #12]
    2edc:	f100 0108 	add.w	r1, r0, #8
    2ee0:	7b00      	ldrb	r0, [r0, #12]
    2ee2:	f364 0004 	bfi	r0, r4, #0, #5
    2ee6:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    2ee8:	6938      	ldr	r0, [r7, #16]
    2eea:	790c      	ldrb	r4, [r1, #4]
    2eec:	0840      	lsrs	r0, r0, #1
    2eee:	f360 1447 	bfi	r4, r0, #5, #3
    2ef2:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
    2ef4:	68f9      	ldr	r1, [r7, #12]
    2ef6:	f021 011f 	bic.w	r1, r1, #31
    2efa:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
    2efc:	6939      	ldr	r1, [r7, #16]
    2efe:	f021 011f 	bic.w	r1, r1, #31
    2f02:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
    2f04:	f108 0801 	add.w	r8, r8, #1
    2f08:	3514      	adds	r5, #20
    2f0a:	360c      	adds	r6, #12
    2f0c:	e7b9      	b.n	2e82 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
    2f0e:	bf00      	nop
    2f10:	20001a14 	.word	0x20001a14
    2f14:	e000ed90 	.word	0xe000ed90
    2f18:	20029f3c 	.word	0x20029f3c

00002f1c <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    2f1c:	4b01      	ldr	r3, [pc, #4]	; (2f24 <__stdout_hook_install+0x8>)
    2f1e:	6018      	str	r0, [r3, #0]
}
    2f20:	4770      	bx	lr
    2f22:	bf00      	nop
    2f24:	20000300 	.word	0x20000300

00002f28 <lvgl_pointer_kscan_read>:
		LOG_ERR("Could put input data into queue");
	}
}

static bool lvgl_pointer_kscan_read(lv_indev_drv_t *drv, lv_indev_data_t *data)
{
    2f28:	b570      	push	{r4, r5, r6, lr}
    2f2a:	460d      	mov	r5, r1
    2f2c:	b088      	sub	sp, #32
	return z_impl_k_msgq_get(msgq, data, timeout);
    2f2e:	ae04      	add	r6, sp, #16
    2f30:	2200      	movs	r2, #0
    2f32:	2300      	movs	r3, #0
    2f34:	4631      	mov	r1, r6
    2f36:	4824      	ldr	r0, [pc, #144]	; (2fc8 <lvgl_pointer_kscan_read+0xa0>)
    2f38:	f00d fa3a 	bl	103b0 <z_impl_k_msgq_get>
    2f3c:	4c23      	ldr	r4, [pc, #140]	; (2fcc <lvgl_pointer_kscan_read+0xa4>)
		.point.x = 0,
		.point.y = 0,
		.state = LV_INDEV_STATE_REL,
	};

	if (k_msgq_get(&kscan_msgq, &curr, K_NO_WAIT) != 0) {
    2f3e:	2800      	cmp	r0, #0
    2f40:	d12f      	bne.n	2fa2 <lvgl_pointer_kscan_read+0x7a>
		goto set_and_release;
	}

	prev = curr;
    2f42:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
    2f46:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	disp = lv_disp_get_default();
    2f4a:	f009 fb0d 	bl	c568 <lv_disp_get_default>
	disp_dev = disp->driver.user_data;
    2f4e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
					    capabilities)
{
	struct display_driver_api *api =
		(struct display_driver_api *)dev->api;

	api->get_capabilities(dev, capabilities);
    2f50:	4669      	mov	r1, sp
    2f52:	6883      	ldr	r3, [r0, #8]
    2f54:	69db      	ldr	r3, [r3, #28]
    2f56:	4798      	blx	r3
		prev.point.x = prev.point.y;
		prev.point.y = x;
	}

	if (IS_ENABLED(CONFIG_LVGL_POINTER_KSCAN_INVERT_X)) {
		if (cap.current_orientation == DISPLAY_ORIENTATION_NORMAL ||
    2f58:	f89d 600d 	ldrb.w	r6, [sp, #13]
		x = prev.point.x;
    2f5c:	f9b4 3000 	ldrsh.w	r3, [r4]
		prev.point.x = prev.point.y;
    2f60:	f9b4 0002 	ldrsh.w	r0, [r4, #2]
		if (cap.current_orientation == DISPLAY_ORIENTATION_NORMAL ||
    2f64:	f8bd 2000 	ldrh.w	r2, [sp]
    2f68:	f8bd 1002 	ldrh.w	r1, [sp, #2]
    2f6c:	f016 0ffd 	tst.w	r6, #253	; 0xfd
		    cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_180) {
			prev.point.x = cap.x_resolution - prev.point.x;
    2f70:	bf07      	ittee	eq
    2f72:	1a10      	subeq	r0, r2, r0
	}

	if (IS_ENABLED(CONFIG_LVGL_POINTER_KSCAN_INVERT_Y)) {
		if (cap.current_orientation == DISPLAY_ORIENTATION_NORMAL ||
		    cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_180) {
			prev.point.y = cap.y_resolution - prev.point.y;
    2f74:	1acb      	subeq	r3, r1, r3
			prev.point.x = cap.y_resolution - prev.point.x;
    2f76:	1a08      	subne	r0, r1, r0
		} else {
			prev.point.y = cap.x_resolution - prev.point.y;
    2f78:	1ad3      	subne	r3, r2, r3
			prev.point.x = cap.x_resolution - prev.point.x;
    2f7a:	bf0c      	ite	eq
    2f7c:	8020      	strheq	r0, [r4, #0]
			prev.point.x = cap.y_resolution - prev.point.x;
    2f7e:	8020      	strhne	r0, [r4, #0]
			prev.point.y = cap.x_resolution - prev.point.y;
    2f80:	b21b      	sxth	r3, r3
		}
	}

	/* rotate touch point to match display rotation */
	if (cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_90) {
    2f82:	2e01      	cmp	r6, #1
    2f84:	8063      	strh	r3, [r4, #2]
    2f86:	d105      	bne.n	2f94 <lvgl_pointer_kscan_read+0x6c>
		lv_coord_t x;

		x = prev.point.x;
    2f88:	f9b4 2000 	ldrsh.w	r2, [r4]
		prev.point.x = prev.point.y;
    2f8c:	8023      	strh	r3, [r4, #0]
		prev.point.y = cap.y_resolution - x;
    2f8e:	1a89      	subs	r1, r1, r2
	} else if (cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_270) {
		lv_coord_t x;

		x = prev.point.x;
		prev.point.x = cap.x_resolution - prev.point.y;
		prev.point.y = x;
    2f90:	8061      	strh	r1, [r4, #2]
    2f92:	e006      	b.n	2fa2 <lvgl_pointer_kscan_read+0x7a>
	} else if (cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_180) {
    2f94:	2e02      	cmp	r6, #2
    2f96:	d10f      	bne.n	2fb8 <lvgl_pointer_kscan_read+0x90>
		prev.point.x = cap.x_resolution - prev.point.x;
    2f98:	8820      	ldrh	r0, [r4, #0]
		prev.point.y = cap.y_resolution - prev.point.y;
    2f9a:	1acb      	subs	r3, r1, r3
		prev.point.x = cap.x_resolution - prev.point.x;
    2f9c:	1a12      	subs	r2, r2, r0
    2f9e:	8022      	strh	r2, [r4, #0]
		prev.point.y = cap.y_resolution - prev.point.y;
    2fa0:	8063      	strh	r3, [r4, #2]
	}

set_and_release:
	*data = prev;
    2fa2:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
    2fa6:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	if (z_syscall_trap()) {
		return (uint32_t) arch_syscall_invoke1(*(uintptr_t *)&msgq, K_SYSCALL_K_MSGQ_NUM_USED_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_num_used_get(msgq);
    2faa:	4b07      	ldr	r3, [pc, #28]	; (2fc8 <lvgl_pointer_kscan_read+0xa0>)

	return k_msgq_num_used_get(&kscan_msgq) > 0;
    2fac:	6a18      	ldr	r0, [r3, #32]
}
    2fae:	3800      	subs	r0, #0
    2fb0:	bf18      	it	ne
    2fb2:	2001      	movne	r0, #1
    2fb4:	b008      	add	sp, #32
    2fb6:	bd70      	pop	{r4, r5, r6, pc}
	} else if (cap.current_orientation == DISPLAY_ORIENTATION_ROTATED_270) {
    2fb8:	2e03      	cmp	r6, #3
    2fba:	d1f2      	bne.n	2fa2 <lvgl_pointer_kscan_read+0x7a>
		prev.point.x = cap.x_resolution - prev.point.y;
    2fbc:	1ad3      	subs	r3, r2, r3
		x = prev.point.x;
    2fbe:	f9b4 1000 	ldrsh.w	r1, [r4]
		prev.point.x = cap.x_resolution - prev.point.y;
    2fc2:	8023      	strh	r3, [r4, #0]
    2fc4:	e7e4      	b.n	2f90 <lvgl_pointer_kscan_read+0x68>
    2fc6:	bf00      	nop
    2fc8:	20000830 	.word	0x20000830
    2fcc:	20025a4c 	.word	0x20025a4c

00002fd0 <lvgl_pointer_kscan_callback>:
{
    2fd0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	lv_indev_data_t data = {
    2fd2:	2000      	movs	r0, #0
    2fd4:	f8ad 2000 	strh.w	r2, [sp]
    2fd8:	9003      	str	r0, [sp, #12]
    2fda:	e9cd 0001 	strd	r0, r0, [sp, #4]
    2fde:	f8ad 1002 	strh.w	r1, [sp, #2]
    2fe2:	f88d 300e 	strb.w	r3, [sp, #14]
	return z_impl_k_msgq_put(msgq, data, timeout);
    2fe6:	2200      	movs	r2, #0
    2fe8:	2300      	movs	r3, #0
    2fea:	4669      	mov	r1, sp
    2fec:	4802      	ldr	r0, [pc, #8]	; (2ff8 <lvgl_pointer_kscan_callback+0x28>)
    2fee:	f00d f98b 	bl	10308 <z_impl_k_msgq_put>
}
    2ff2:	b005      	add	sp, #20
    2ff4:	f85d fb04 	ldr.w	pc, [sp], #4
    2ff8:	20000830 	.word	0x20000830

00002ffc <lvgl_init>:
	return 0;
}
#endif /* CONFIG_LVGL_POINTER_KSCAN */

static int lvgl_init(const struct device *dev)
{
    2ffc:	b530      	push	{r4, r5, lr}
    2ffe:	b095      	sub	sp, #84	; 0x54
    3000:	482e      	ldr	r0, [pc, #184]	; (30bc <lvgl_init+0xc0>)
    3002:	f00c fff3 	bl	ffec <z_impl_device_get_binding>
	const struct device *display_dev =
		device_get_binding(CONFIG_LVGL_DISPLAY_DEV_NAME);
	int err = 0;
	lv_disp_drv_t disp_drv;

	if (display_dev == NULL) {
    3006:	4604      	mov	r4, r0
    3008:	2800      	cmp	r0, #0
    300a:	d04e      	beq.n	30aa <lvgl_init+0xae>

#if CONFIG_LVGL_LOG_LEVEL != 0
	lv_log_register_print_cb(lvgl_log);
#endif

	lv_init();
    300c:	f006 f938 	bl	9280 <lv_init>

#ifdef CONFIG_LVGL_USE_FILESYSTEM
	lvgl_fs_init();
#endif

	lv_disp_drv_init(&disp_drv);
    3010:	a808      	add	r0, sp, #32
    3012:	f009 fa8d 	bl	c530 <lv_disp_drv_init>
    3016:	68a3      	ldr	r3, [r4, #8]
    3018:	4620      	mov	r0, r4
	disp_drv.user_data = (void *) display_dev;
    301a:	9413      	str	r4, [sp, #76]	; 0x4c
    301c:	4669      	mov	r1, sp
    301e:	69db      	ldr	r3, [r3, #28]
    3020:	4798      	blx	r3
	if (cap.x_resolution <= CONFIG_LVGL_HOR_RES_MAX) {
    3022:	f8bd 3000 	ldrh.w	r3, [sp]
	disp_drv->buffer = &disp_buf;
    3026:	4826      	ldr	r0, [pc, #152]	; (30c0 <lvgl_init+0xc4>)
	if (cap.x_resolution <= CONFIG_LVGL_HOR_RES_MAX) {
    3028:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
		disp_drv->hor_res = cap.x_resolution;
    302c:	bf98      	it	ls
    302e:	f8ad 3020 	strhls.w	r3, [sp, #32]
	if (cap.y_resolution <= CONFIG_LVGL_VER_RES_MAX) {
    3032:	f8bd 3002 	ldrh.w	r3, [sp, #2]
		err = -ENOTSUP;
    3036:	bf8c      	ite	hi
    3038:	f06f 0485 	mvnhi.w	r4, #133	; 0x85
	int err = 0;
    303c:	2400      	movls	r4, #0
	if (cap.y_resolution <= CONFIG_LVGL_VER_RES_MAX) {
    303e:	2bf0      	cmp	r3, #240	; 0xf0
		err = -ENOTSUP;
    3040:	bf8c      	ite	hi
    3042:	f06f 0485 	mvnhi.w	r4, #133	; 0x85
		disp_drv->ver_res = cap.y_resolution;
    3046:	f8ad 3022 	strhls.w	r3, [sp, #34]	; 0x22
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    304a:	2200      	movs	r2, #0
    304c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    3050:	491c      	ldr	r1, [pc, #112]	; (30c4 <lvgl_init+0xc8>)
	disp_drv->buffer = &disp_buf;
    3052:	9009      	str	r0, [sp, #36]	; 0x24
	lv_disp_buf_init(disp_drv->buffer, &buf0, NULL, NBR_PIXELS_IN_BUFFER);
    3054:	f017 fd24 	bl	1aaa0 <lv_disp_buf_init>

	err = lvgl_allocate_rendering_buffers(&disp_drv);
	if (err != 0) {
    3058:	bb24      	cbnz	r4, 30a4 <lvgl_init+0xa8>
		return err;
	}

	if (set_lvgl_rendering_cb(&disp_drv) != 0) {
    305a:	a808      	add	r0, sp, #32
    305c:	f000 f83a 	bl	30d4 <set_lvgl_rendering_cb>
    3060:	4604      	mov	r4, r0
    3062:	bb28      	cbnz	r0, 30b0 <lvgl_init+0xb4>
		LOG_ERR("Display not supported.");
		return -ENOTSUP;
	}

	if (lv_disp_drv_register(&disp_drv) == NULL) {
    3064:	a808      	add	r0, sp, #32
    3066:	f009 fae1 	bl	c62c <lv_disp_drv_register>
    306a:	b320      	cbz	r0, 30b6 <lvgl_init+0xba>
    306c:	4816      	ldr	r0, [pc, #88]	; (30c8 <lvgl_init+0xcc>)
    306e:	f00c ffbd 	bl	ffec <z_impl_device_get_binding>
	if (kscan_dev == NULL) {
    3072:	4605      	mov	r5, r0
    3074:	b1b0      	cbz	r0, 30a4 <lvgl_init+0xa8>
					kscan_callback_t callback)
{
	const struct kscan_driver_api *api =
				(struct kscan_driver_api *)dev->api;

	return api->config(dev, callback);
    3076:	6883      	ldr	r3, [r0, #8]
    3078:	4914      	ldr	r1, [pc, #80]	; (30cc <lvgl_init+0xd0>)
    307a:	681b      	ldr	r3, [r3, #0]
    307c:	4798      	blx	r3
	if (kscan_config(kscan_dev, lvgl_pointer_kscan_callback) < 0) {
    307e:	2800      	cmp	r0, #0
    3080:	db10      	blt.n	30a4 <lvgl_init+0xa8>
	lv_indev_drv_init(&indev_drv);
    3082:	4668      	mov	r0, sp
    3084:	f009 fb3e 	bl	c704 <lv_indev_drv_init>
	indev_drv.type = LV_INDEV_TYPE_POINTER;
    3088:	2301      	movs	r3, #1
    308a:	f88d 3000 	strb.w	r3, [sp]
	indev_drv.read_cb = lvgl_pointer_kscan_read;
    308e:	4b10      	ldr	r3, [pc, #64]	; (30d0 <lvgl_init+0xd4>)
	if (lv_indev_drv_register(&indev_drv) == NULL) {
    3090:	4668      	mov	r0, sp
	indev_drv.read_cb = lvgl_pointer_kscan_read;
    3092:	9301      	str	r3, [sp, #4]
	if (lv_indev_drv_register(&indev_drv) == NULL) {
    3094:	f009 fb46 	bl	c724 <lv_indev_drv_register>
    3098:	b120      	cbz	r0, 30a4 <lvgl_init+0xa8>
static inline int z_impl_kscan_enable_callback(const struct device *dev)
{
	const struct kscan_driver_api *api =
			(const struct kscan_driver_api *)dev->api;

	if (api->enable_callback == NULL) {
    309a:	68ab      	ldr	r3, [r5, #8]
    309c:	689b      	ldr	r3, [r3, #8]
    309e:	b10b      	cbz	r3, 30a4 <lvgl_init+0xa8>
		return -ENOTSUP;
	}

	return api->enable_callback(dev);
    30a0:	4628      	mov	r0, r5
    30a2:	4798      	blx	r3
#ifdef CONFIG_LVGL_POINTER_KSCAN
	lvgl_pointer_kscan_init();
#endif /* CONFIG_LVGL_POINTER_KSCAN */

	return 0;
}
    30a4:	4620      	mov	r0, r4
    30a6:	b015      	add	sp, #84	; 0x54
    30a8:	bd30      	pop	{r4, r5, pc}
		return -ENODEV;
    30aa:	f06f 0412 	mvn.w	r4, #18
    30ae:	e7f9      	b.n	30a4 <lvgl_init+0xa8>
		return -ENOTSUP;
    30b0:	f06f 0485 	mvn.w	r4, #133	; 0x85
    30b4:	e7f6      	b.n	30a4 <lvgl_init+0xa8>
		return -EPERM;
    30b6:	f04f 34ff 	mov.w	r4, #4294967295
    30ba:	e7f3      	b.n	30a4 <lvgl_init+0xa8>
    30bc:	00026ccd 	.word	0x00026ccd
    30c0:	20025a28 	.word	0x20025a28
    30c4:	20001a28 	.word	0x20001a28
    30c8:	00043dad 	.word	0x00043dad
    30cc:	00002fd1 	.word	0x00002fd1
    30d0:	00002f29 	.word	0x00002f29

000030d4 <set_lvgl_rendering_cb>:
 */

#include "lvgl_display.h"

int set_lvgl_rendering_cb(lv_disp_drv_t *disp_drv)
{
    30d4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    30d6:	4604      	mov	r4, r0
	int err = 0;
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
    30d8:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    30da:	4669      	mov	r1, sp
    30dc:	6883      	ldr	r3, [r0, #8]
    30de:	69db      	ldr	r3, [r3, #28]
    30e0:	4798      	blx	r3
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);

	switch (cap.current_pixel_format) {
    30e2:	f89d 300c 	ldrb.w	r3, [sp, #12]
    30e6:	2b08      	cmp	r3, #8
    30e8:	d80a      	bhi.n	3100 <set_lvgl_rendering_cb+0x2c>
    30ea:	b16b      	cbz	r3, 3108 <set_lvgl_rendering_cb+0x34>
    30ec:	3b01      	subs	r3, #1
    30ee:	2200      	movs	r2, #0
    30f0:	2b07      	cmp	r3, #7
    30f2:	d809      	bhi.n	3108 <set_lvgl_rendering_cb+0x34>
    30f4:	e8df f003 	tbb	[pc, r3]
    30f8:	23082316 	.word	0x23082316
    30fc:	0f080808 	.word	0x0f080808
    3100:	2b10      	cmp	r3, #16
    3102:	d015      	beq.n	3130 <set_lvgl_rendering_cb+0x5c>
    3104:	2b20      	cmp	r3, #32
    3106:	d013      	beq.n	3130 <set_lvgl_rendering_cb+0x5c>
		disp_drv->flush_cb = lvgl_flush_cb_mono;
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
		break;
	default:
		disp_drv->flush_cb = NULL;
    3108:	2300      	movs	r3, #0
		disp_drv->rounder_cb = NULL;
		disp_drv->set_px_cb = NULL;
		err = -ENOTSUP;
    310a:	f06f 0085 	mvn.w	r0, #133	; 0x85
		disp_drv->rounder_cb = NULL;
    310e:	e9c4 3303 	strd	r3, r3, [r4, #12]
		disp_drv->set_px_cb = NULL;
    3112:	6163      	str	r3, [r4, #20]
		break;

	}

	return err;
    3114:	e004      	b.n	3120 <set_lvgl_rendering_cb+0x4c>
		disp_drv->flush_cb = lvgl_flush_cb_32bit;
    3116:	4b0d      	ldr	r3, [pc, #52]	; (314c <set_lvgl_rendering_cb+0x78>)
		disp_drv->set_px_cb = NULL;
    3118:	6162      	str	r2, [r4, #20]
		disp_drv->rounder_cb = NULL;
    311a:	e9c4 3203 	strd	r3, r2, [r4, #12]
	int err = 0;
    311e:	2000      	movs	r0, #0
}
    3120:	b004      	add	sp, #16
    3122:	bd10      	pop	{r4, pc}
		disp_drv->flush_cb = lvgl_flush_cb_24bit;
    3124:	4b0a      	ldr	r3, [pc, #40]	; (3150 <set_lvgl_rendering_cb+0x7c>)
		disp_drv->rounder_cb = NULL;
    3126:	e9c4 3203 	strd	r3, r2, [r4, #12]
		disp_drv->set_px_cb = lvgl_set_px_cb_24bit;
    312a:	4b0a      	ldr	r3, [pc, #40]	; (3154 <set_lvgl_rendering_cb+0x80>)
    312c:	6163      	str	r3, [r4, #20]
    312e:	e7f6      	b.n	311e <set_lvgl_rendering_cb+0x4a>
		disp_drv->rounder_cb = NULL;
    3130:	2000      	movs	r0, #0
		disp_drv->flush_cb = lvgl_flush_cb_16bit;
    3132:	4b09      	ldr	r3, [pc, #36]	; (3158 <set_lvgl_rendering_cb+0x84>)
		disp_drv->rounder_cb = NULL;
    3134:	6120      	str	r0, [r4, #16]
		disp_drv->flush_cb = lvgl_flush_cb_16bit;
    3136:	60e3      	str	r3, [r4, #12]
		disp_drv->set_px_cb = lvgl_set_px_cb_16bit;
    3138:	4b08      	ldr	r3, [pc, #32]	; (315c <set_lvgl_rendering_cb+0x88>)
    313a:	6163      	str	r3, [r4, #20]
		break;
    313c:	e7f0      	b.n	3120 <set_lvgl_rendering_cb+0x4c>
		disp_drv->flush_cb = lvgl_flush_cb_mono;
    313e:	4b08      	ldr	r3, [pc, #32]	; (3160 <set_lvgl_rendering_cb+0x8c>)
    3140:	60e3      	str	r3, [r4, #12]
		disp_drv->rounder_cb = lvgl_rounder_cb_mono;
    3142:	4b08      	ldr	r3, [pc, #32]	; (3164 <set_lvgl_rendering_cb+0x90>)
    3144:	6123      	str	r3, [r4, #16]
		disp_drv->set_px_cb = lvgl_set_px_cb_mono;
    3146:	4b08      	ldr	r3, [pc, #32]	; (3168 <set_lvgl_rendering_cb+0x94>)
    3148:	e7f0      	b.n	312c <set_lvgl_rendering_cb+0x58>
    314a:	bf00      	nop
    314c:	0001324f 	.word	0x0001324f
    3150:	0001317b 	.word	0x0001317b
    3154:	000131c9 	.word	0x000131c9
    3158:	00013109 	.word	0x00013109
    315c:	00013155 	.word	0x00013155
    3160:	00012fc1 	.word	0x00012fc1
    3164:	000130d1 	.word	0x000130d1
    3168:	0001303b 	.word	0x0001303b

0000316c <remoteproc_mgr_boot>:
{
	/* UARTE */
	/* Assign specific GPIOs that will be used to get UARTE from
	 * nRF5340 Network MCU.
	 */
	CPUNET_UARTE_PORT_TRX->PIN_CNF[CPUNET_UARTE_PIN_TX] =
    316c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    3170:	4a09      	ldr	r2, [pc, #36]	; (3198 <remoteproc_mgr_boot+0x2c>)
	 * this case do the remainder of actions to properly configure and
	 * boot the Network MCU.
	 */

	/* Release the Network MCU, 'Release force off signal' */
	NRF_RESET->NETWORK.FORCEOFF = RESET_NETWORK_FORCEOFF_FORCEOFF_Release;
    3172:	2000      	movs	r0, #0
	CPUNET_UARTE_PORT_TRX->PIN_CNF[CPUNET_UARTE_PIN_TX] =
    3174:	f8c2 3204 	str.w	r3, [r2, #516]	; 0x204
	CPUNET_UARTE_PORT_TRX->PIN_CNF[CPUNET_UARTE_PIN_RX] =
    3178:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	NRF_P0->PIN_CNF[CPUNET_UARTE_PIN_RTS] =
    317c:	f842 3cd4 	str.w	r3, [r2, #-212]
	NRF_P0->PIN_CNF[CPUNET_UARTE_PIN_CTS] =
    3180:	f842 3cd8 	str.w	r3, [r2, #-216]
	NRF_SPU->EXTDOMAIN[0].PERM = 1 << 4;
    3184:	2210      	movs	r2, #16
    3186:	4b05      	ldr	r3, [pc, #20]	; (319c <remoteproc_mgr_boot+0x30>)
    3188:	f8c3 2440 	str.w	r2, [r3, #1088]	; 0x440
	NRF_RESET->NETWORK.FORCEOFF = RESET_NETWORK_FORCEOFF_FORCEOFF_Release;
    318c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    3190:	f8c3 0614 	str.w	r0, [r3, #1556]	; 0x614

	LOG_DBG("Network MCU released.");
#endif /* !CONFIG_TRUSTED_EXECUTION_SECURE */

	return 0;
}
    3194:	4770      	bx	lr
    3196:	bf00      	nop
    3198:	50842800 	.word	0x50842800
    319c:	50003000 	.word	0x50003000

000031a0 <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
    31a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    31a2:	460b      	mov	r3, r1
	switch (src->type) {
    31a4:	7801      	ldrb	r1, [r0, #0]
{
    31a6:	4602      	mov	r2, r0
	switch (src->type) {
    31a8:	2901      	cmp	r1, #1
    31aa:	d015      	beq.n	31d8 <uuid_to_uuid128+0x38>
    31ac:	2902      	cmp	r1, #2
    31ae:	d02b      	beq.n	3208 <uuid_to_uuid128+0x68>
    31b0:	b989      	cbnz	r1, 31d6 <uuid_to_uuid128+0x36>
	case BT_UUID_TYPE_16:
		*dst = uuid128_base;
    31b2:	461d      	mov	r5, r3
    31b4:	4c1b      	ldr	r4, [pc, #108]	; (3224 <uuid_to_uuid128+0x84>)
    31b6:	f104 0710 	add.w	r7, r4, #16
    31ba:	462e      	mov	r6, r5
    31bc:	6820      	ldr	r0, [r4, #0]
    31be:	6861      	ldr	r1, [r4, #4]
    31c0:	3408      	adds	r4, #8
    31c2:	c603      	stmia	r6!, {r0, r1}
    31c4:	42bc      	cmp	r4, r7
    31c6:	4635      	mov	r5, r6
    31c8:	d1f7      	bne.n	31ba <uuid_to_uuid128+0x1a>
		sys_put_le16(BT_UUID_16(src)->val,
    31ca:	8852      	ldrh	r2, [r2, #2]
		*dst = uuid128_base;
    31cc:	7821      	ldrb	r1, [r4, #0]
    31ce:	7031      	strb	r1, [r6, #0]
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
    31d0:	735a      	strb	r2, [r3, #13]
	dst[1] = val >> 8;
    31d2:	0a12      	lsrs	r2, r2, #8
    31d4:	739a      	strb	r2, [r3, #14]
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
    31d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst = uuid128_base;
    31d8:	461d      	mov	r5, r3
    31da:	4c12      	ldr	r4, [pc, #72]	; (3224 <uuid_to_uuid128+0x84>)
    31dc:	f104 0710 	add.w	r7, r4, #16
    31e0:	462e      	mov	r6, r5
    31e2:	6820      	ldr	r0, [r4, #0]
    31e4:	6861      	ldr	r1, [r4, #4]
    31e6:	3408      	adds	r4, #8
    31e8:	c603      	stmia	r6!, {r0, r1}
    31ea:	42bc      	cmp	r4, r7
    31ec:	4635      	mov	r5, r6
    31ee:	d1f7      	bne.n	31e0 <uuid_to_uuid128+0x40>
		sys_put_le32(BT_UUID_32(src)->val,
    31f0:	6852      	ldr	r2, [r2, #4]
		*dst = uuid128_base;
    31f2:	7821      	ldrb	r1, [r4, #0]
    31f4:	7031      	strb	r1, [r6, #0]
    31f6:	f3c2 2107 	ubfx	r1, r2, #8, #8
	dst[0] = val;
    31fa:	735a      	strb	r2, [r3, #13]
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le32(uint32_t val, uint8_t dst[4])
{
	sys_put_le16(val, dst);
	sys_put_le16(val >> 16, &dst[2]);
    31fc:	0c12      	lsrs	r2, r2, #16
	dst[0] = val;
    31fe:	73da      	strb	r2, [r3, #15]
	dst[1] = val >> 8;
    3200:	0a12      	lsrs	r2, r2, #8
    3202:	7399      	strb	r1, [r3, #14]
    3204:	741a      	strb	r2, [r3, #16]
}
    3206:	e7e6      	b.n	31d6 <uuid_to_uuid128+0x36>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    3208:	f100 0510 	add.w	r5, r0, #16
    320c:	461c      	mov	r4, r3
    320e:	6810      	ldr	r0, [r2, #0]
    3210:	6851      	ldr	r1, [r2, #4]
    3212:	3208      	adds	r2, #8
    3214:	c403      	stmia	r4!, {r0, r1}
    3216:	42aa      	cmp	r2, r5
    3218:	4623      	mov	r3, r4
    321a:	d1f7      	bne.n	320c <uuid_to_uuid128+0x6c>
    321c:	7812      	ldrb	r2, [r2, #0]
    321e:	7022      	strb	r2, [r4, #0]
    3220:	e7d9      	b.n	31d6 <uuid_to_uuid128+0x36>
    3222:	bf00      	nop
    3224:	00043dc3 	.word	0x00043dc3

00003228 <bt_buf_get_rx>:
	if (IS_ENABLED(CONFIG_BT_ISO) && type == BT_BUF_ISO_IN) {
		return bt_iso_get_rx(timeout);
	}

#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	if (type == BT_BUF_EVT) {
    3228:	2801      	cmp	r0, #1
{
    322a:	b538      	push	{r3, r4, r5, lr}
    322c:	4605      	mov	r5, r0
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf *net_buf_alloc(struct net_buf_pool *pool,
					    k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
    322e:	bf0c      	ite	eq
    3230:	4806      	ldreq	r0, [pc, #24]	; (324c <bt_buf_get_rx+0x24>)
    3232:	4807      	ldrne	r0, [pc, #28]	; (3250 <bt_buf_get_rx+0x28>)
    3234:	f011 fd7c 	bl	14d30 <net_buf_alloc_fixed>
    3238:	4604      	mov	r4, r0
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
    323a:	b120      	cbz	r0, 3246 <bt_buf_get_rx+0x1e>
 * @param buf Buffer to initialize.
 * @param reserve How much headroom to reserve.
 */
static inline void net_buf_reserve(struct net_buf *buf, size_t reserve)
{
	net_buf_simple_reserve(&buf->b, reserve);
    323c:	2101      	movs	r1, #1
    323e:	3008      	adds	r0, #8
    3240:	f011 fd95 	bl	14d6e <net_buf_simple_reserve>
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    3244:	7525      	strb	r5, [r4, #20]
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    3246:	4620      	mov	r0, r4
    3248:	bd38      	pop	{r3, r4, r5, pc}
    324a:	bf00      	nop
    324c:	20000960 	.word	0x20000960
    3250:	20000898 	.word	0x20000898

00003254 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
    3254:	4602      	mov	r2, r0
    3256:	460b      	mov	r3, r1
    3258:	b570      	push	{r4, r5, r6, lr}
    325a:	f04f 0120 	mov.w	r1, #32
    325e:	f3ef 8511 	mrs	r5, BASEPRI
    3262:	f381 8811 	msr	BASEPRI, r1
    3266:	f3bf 8f6f 	isb	sy
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
	bt_dev.sent_cmd = NULL;
    326a:	2000      	movs	r0, #0
	buf = bt_dev.sent_cmd;
    326c:	490b      	ldr	r1, [pc, #44]	; (329c <bt_buf_get_cmd_complete+0x48>)
    326e:	f8d1 40f8 	ldr.w	r4, [r1, #248]	; 0xf8
	bt_dev.sent_cmd = NULL;
    3272:	f8c1 00f8 	str.w	r0, [r1, #248]	; 0xf8
	__asm__ volatile(
    3276:	f385 8811 	msr	BASEPRI, r5
    327a:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
    327e:	b924      	cbnz	r4, 328a <bt_buf_get_cmd_complete+0x36>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
    3280:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    3284:	2001      	movs	r0, #1
    3286:	f7ff bfcf 	b.w	3228 <bt_buf_get_rx>
    328a:	2101      	movs	r1, #1
		buf->len = 0U;
    328c:	81a0      	strh	r0, [r4, #12]
    328e:	7521      	strb	r1, [r4, #20]
    3290:	f104 0008 	add.w	r0, r4, #8
    3294:	f011 fd6b 	bl	14d6e <net_buf_simple_reserve>
}
    3298:	4620      	mov	r0, r4
    329a:	bd70      	pop	{r4, r5, r6, pc}
    329c:	20000000 	.word	0x20000000

000032a0 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
    32a0:	b570      	push	{r4, r5, r6, lr}
    32a2:	4604      	mov	r4, r0
	switch (evt) {
    32a4:	2c0f      	cmp	r4, #15
{
    32a6:	460d      	mov	r5, r1
    32a8:	4610      	mov	r0, r2
    32aa:	4619      	mov	r1, r3
	switch (evt) {
    32ac:	d805      	bhi.n	32ba <bt_buf_get_evt+0x1a>
    32ae:	2c0d      	cmp	r4, #13
    32b0:	d912      	bls.n	32d8 <bt_buf_get_evt+0x38>
		}
#endif /* CONFIG_BT_DISCARDABLE_BUF_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
    32b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_cmd_complete(timeout);
    32b6:	f7ff bfcd 	b.w	3254 <bt_buf_get_cmd_complete>
	switch (evt) {
    32ba:	2c13      	cmp	r4, #19
    32bc:	d10c      	bne.n	32d8 <bt_buf_get_evt+0x38>
	return net_buf_alloc_fixed(pool, timeout);
    32be:	480b      	ldr	r0, [pc, #44]	; (32ec <bt_buf_get_evt+0x4c>)
    32c0:	f011 fd36 	bl	14d30 <net_buf_alloc_fixed>
			if (buf) {
    32c4:	4604      	mov	r4, r0
    32c6:	b128      	cbz	r0, 32d4 <bt_buf_get_evt+0x34>
	net_buf_simple_reserve(&buf->b, reserve);
    32c8:	2101      	movs	r1, #1
    32ca:	3008      	adds	r0, #8
    32cc:	f011 fd4f 	bl	14d6e <net_buf_simple_reserve>
    32d0:	2301      	movs	r3, #1
    32d2:	7523      	strb	r3, [r4, #20]
}
    32d4:	4620      	mov	r0, r4
    32d6:	bd70      	pop	{r4, r5, r6, pc}
	return net_buf_alloc_fixed(pool, timeout);
    32d8:	4602      	mov	r2, r0
    32da:	460b      	mov	r3, r1
		if (discardable) {
    32dc:	b10d      	cbz	r5, 32e2 <bt_buf_get_evt+0x42>
    32de:	4804      	ldr	r0, [pc, #16]	; (32f0 <bt_buf_get_evt+0x50>)
    32e0:	e7ee      	b.n	32c0 <bt_buf_get_evt+0x20>
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    32e2:	2001      	movs	r0, #1
}
    32e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    32e8:	f7ff bf9e 	b.w	3228 <bt_buf_get_rx>
    32ec:	20000988 	.word	0x20000988
    32f0:	200008e8 	.word	0x200008e8

000032f4 <id_find>:
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
	*count = to_copy;
}

static int id_find(const bt_addr_le_t *addr)
{
    32f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    32f6:	4606      	mov	r6, r0
	uint8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    32f8:	2500      	movs	r5, #0
    32fa:	4f09      	ldr	r7, [pc, #36]	; (3320 <id_find+0x2c>)
    32fc:	79fb      	ldrb	r3, [r7, #7]
    32fe:	b2ec      	uxtb	r4, r5
    3300:	42a3      	cmp	r3, r4
    3302:	d802      	bhi.n	330a <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
    3304:	f06f 0401 	mvn.w	r4, #1
    3308:	e008      	b.n	331c <id_find+0x28>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    330a:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
    330e:	4630      	mov	r0, r6
    3310:	4439      	add	r1, r7
    3312:	f010 f860 	bl	133d6 <bt_addr_le_cmp>
    3316:	3501      	adds	r5, #1
    3318:	2800      	cmp	r0, #0
    331a:	d1ef      	bne.n	32fc <id_find+0x8>
}
    331c:	4620      	mov	r0, r4
    331e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3320:	20000000 	.word	0x20000000

00003324 <valid_adv_param>:
	return true;
}

static bool valid_adv_param(const struct bt_le_adv_param *param)
{
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    3324:	6843      	ldr	r3, [r0, #4]
{
    3326:	b537      	push	{r0, r1, r2, r4, r5, lr}
    3328:	4604      	mov	r4, r0
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
    332a:	0558      	lsls	r0, r3, #21
    332c:	d502      	bpl.n	3334 <valid_adv_param+0x10>
		return false;
    332e:	2000      	movs	r0, #0
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
		return false;
	}

	return valid_adv_ext_param(param);
}
    3330:	b003      	add	sp, #12
    3332:	bd30      	pop	{r4, r5, pc}
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    3334:	6922      	ldr	r2, [r4, #16]
    3336:	b10a      	cbz	r2, 333c <valid_adv_param+0x18>
    3338:	07d9      	lsls	r1, r3, #31
    333a:	d5f8      	bpl.n	332e <valid_adv_param+0xa>
	if (param->id >= bt_dev.id_count ||
    333c:	4d1a      	ldr	r5, [pc, #104]	; (33a8 <valid_adv_param+0x84>)
    333e:	7820      	ldrb	r0, [r4, #0]
    3340:	79eb      	ldrb	r3, [r5, #7]
    3342:	4283      	cmp	r3, r0
    3344:	d9f3      	bls.n	332e <valid_adv_param+0xa>
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    3346:	2300      	movs	r3, #0
    3348:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    334c:	4669      	mov	r1, sp
    334e:	4428      	add	r0, r5
    3350:	9300      	str	r3, [sp, #0]
    3352:	f8cd 3003 	str.w	r3, [sp, #3]
    3356:	f010 f83e 	bl	133d6 <bt_addr_le_cmp>
	if (param->id >= bt_dev.id_count ||
    335a:	2800      	cmp	r0, #0
    335c:	d0e7      	beq.n	332e <valid_adv_param+0xa>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    335e:	6860      	ldr	r0, [r4, #4]
    3360:	07c2      	lsls	r2, r0, #31
    3362:	d406      	bmi.n	3372 <valid_adv_param+0x4e>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    3364:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
    3368:	2b08      	cmp	r3, #8
    336a:	d802      	bhi.n	3372 <valid_adv_param+0x4e>
    336c:	68a3      	ldr	r3, [r4, #8]
    336e:	2b9f      	cmp	r3, #159	; 0x9f
    3370:	d9dd      	bls.n	332e <valid_adv_param+0xa>
	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
    3372:	f010 0f30 	tst.w	r0, #48	; 0x30
    3376:	d002      	beq.n	337e <valid_adv_param+0x5a>
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
    3378:	6923      	ldr	r3, [r4, #16]
    337a:	2b00      	cmp	r3, #0
    337c:	d0d7      	beq.n	332e <valid_adv_param+0xa>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
    337e:	06c3      	lsls	r3, r0, #27
    3380:	d401      	bmi.n	3386 <valid_adv_param+0x62>
    3382:	6923      	ldr	r3, [r4, #16]
    3384:	b943      	cbnz	r3, 3398 <valid_adv_param+0x74>
		if (param->interval_min > param->interval_max ||
    3386:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    338a:	429a      	cmp	r2, r3
    338c:	d8cf      	bhi.n	332e <valid_adv_param+0xa>
    338e:	2a1f      	cmp	r2, #31
    3390:	d9cd      	bls.n	332e <valid_adv_param+0xa>
		    param->interval_min < 0x0020 ||
    3392:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    3396:	d8ca      	bhi.n	332e <valid_adv_param+0xa>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
    3398:	f400 3060 	and.w	r0, r0, #229376	; 0x38000
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
    339c:	f5b0 3060 	subs.w	r0, r0, #229376	; 0x38000
    33a0:	bf18      	it	ne
    33a2:	2001      	movne	r0, #1
    33a4:	e7c4      	b.n	3330 <valid_adv_param+0xc>
    33a6:	bf00      	nop
    33a8:	20000000 	.word	0x20000000

000033ac <hci_le_meta_event>:
{
    33ac:	b510      	push	{r4, lr}
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
    33ae:	2101      	movs	r1, #1
    33b0:	4604      	mov	r4, r0
    33b2:	3008      	adds	r0, #8
    33b4:	f011 fd43 	bl	14e3e <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    33b8:	4621      	mov	r1, r4
}
    33ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    33be:	2307      	movs	r3, #7
    33c0:	4a01      	ldr	r2, [pc, #4]	; (33c8 <hci_le_meta_event+0x1c>)
    33c2:	7800      	ldrb	r0, [r0, #0]
    33c4:	f00f bfe0 	b.w	13388 <handle_event>
    33c8:	0001ed2c 	.word	0x0001ed2c

000033cc <find_pending_connect.part.0>:
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
    33cc:	b513      	push	{r0, r1, r4, lr}
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
    33ce:	4c0c      	ldr	r4, [pc, #48]	; (3400 <find_pending_connect.part.0+0x34>)
static struct bt_conn *find_pending_connect(uint8_t role, bt_addr_le_t *peer_addr)
    33d0:	4601      	mov	r1, r0
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
    33d2:	2205      	movs	r2, #5
    33d4:	f894 0033 	ldrb.w	r0, [r4, #51]	; 0x33
    33d8:	f001 fe10 	bl	4ffc <bt_conn_lookup_state_le>
		if (!conn) {
    33dc:	b970      	cbnz	r0, 33fc <find_pending_connect.part.0+0x30>
						       BT_ADDR_LE_NONE,
    33de:	4b09      	ldr	r3, [pc, #36]	; (3404 <find_pending_connect.part.0+0x38>)
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    33e0:	4669      	mov	r1, sp
						       BT_ADDR_LE_NONE,
    33e2:	6818      	ldr	r0, [r3, #0]
    33e4:	889a      	ldrh	r2, [r3, #4]
    33e6:	799b      	ldrb	r3, [r3, #6]
    33e8:	9000      	str	r0, [sp, #0]
    33ea:	f8ad 2004 	strh.w	r2, [sp, #4]
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    33ee:	f894 0033 	ldrb.w	r0, [r4, #51]	; 0x33
    33f2:	2204      	movs	r2, #4
						       BT_ADDR_LE_NONE,
    33f4:	f88d 3006 	strb.w	r3, [sp, #6]
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    33f8:	f001 fe00 	bl	4ffc <bt_conn_lookup_state_le>
}
    33fc:	b002      	add	sp, #8
    33fe:	bd10      	pop	{r4, pc}
    3400:	20000000 	.word	0x20000000
    3404:	0001dd80 	.word	0x0001dd80

00003408 <id_create.isra.0>:
static void id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
    3408:	b530      	push	{r4, r5, lr}
    340a:	4d13      	ldr	r5, [pc, #76]	; (3458 <id_create.isra.0+0x50>)
    340c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    3410:	460c      	mov	r4, r1
static void id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
    3412:	b085      	sub	sp, #20
    3414:	4405      	add	r5, r0
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    3416:	b171      	cbz	r1, 3436 <id_create.isra.0+0x2e>
    3418:	2300      	movs	r3, #0
    341a:	4669      	mov	r1, sp
    341c:	4620      	mov	r0, r4
    341e:	9300      	str	r3, [sp, #0]
    3420:	f8cd 3003 	str.w	r3, [sp, #3]
    3424:	f00f ffd7 	bl	133d6 <bt_addr_le_cmp>
    3428:	b128      	cbz	r0, 3436 <id_create.isra.0+0x2e>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    342a:	4621      	mov	r1, r4
    342c:	4628      	mov	r0, r5
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    342e:	f010 f873 	bl	13518 <bt_addr_le_copy>
}
    3432:	b005      	add	sp, #20
    3434:	bd30      	pop	{r4, r5, pc}
			bt_addr_le_create_static(&new_addr);
    3436:	a802      	add	r0, sp, #8
    3438:	f00f ff86 	bl	13348 <bt_addr_le_create_static>
		} while (id_find(&new_addr) >= 0);
    343c:	a802      	add	r0, sp, #8
    343e:	f7ff ff59 	bl	32f4 <id_find>
    3442:	2800      	cmp	r0, #0
    3444:	daf7      	bge.n	3436 <id_create.isra.0+0x2e>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    3446:	4628      	mov	r0, r5
    3448:	a902      	add	r1, sp, #8
    344a:	f010 f865 	bl	13518 <bt_addr_le_copy>
		if (addr) {
    344e:	2c00      	cmp	r4, #0
    3450:	d0ef      	beq.n	3432 <id_create.isra.0+0x2a>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
    3452:	4629      	mov	r1, r5
    3454:	4620      	mov	r0, r4
    3456:	e7ea      	b.n	342e <id_create.isra.0+0x26>
    3458:	20000000 	.word	0x20000000

0000345c <hci_rx_thread>:
{
    345c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		buf = net_buf_get(&bt_dev.rx_queue, K_FOREVER);
    3460:	4f3b      	ldr	r7, [pc, #236]	; (3550 <hci_rx_thread+0xf4>)
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    3462:	f8df 8100 	ldr.w	r8, [pc, #256]	; 3564 <hci_rx_thread+0x108>
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    3466:	4e3b      	ldr	r6, [pc, #236]	; (3554 <hci_rx_thread+0xf8>)
		buf = net_buf_get(&bt_dev.rx_queue, K_FOREVER);
    3468:	f04f 33ff 	mov.w	r3, #4294967295
    346c:	f04f 32ff 	mov.w	r2, #4294967295
    3470:	4638      	mov	r0, r7
    3472:	f011 fc62 	bl	14d3a <net_buf_get>
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
    3476:	7d03      	ldrb	r3, [r0, #20]
    3478:	4604      	mov	r4, r0
		switch (bt_buf_get_type(buf)) {
    347a:	2b01      	cmp	r3, #1
    347c:	d039      	beq.n	34f2 <hci_rx_thread+0x96>
    347e:	2b03      	cmp	r3, #3
    3480:	d120      	bne.n	34c4 <hci_rx_thread+0x68>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    3482:	8983      	ldrh	r3, [r0, #12]
    3484:	2b03      	cmp	r3, #3
    3486:	d80c      	bhi.n	34a2 <hci_rx_thread+0x46>
    3488:	f240 43ac 	movw	r3, #1196	; 0x4ac
    348c:	4632      	mov	r2, r6
    348e:	4932      	ldr	r1, [pc, #200]	; (3558 <hci_rx_thread+0xfc>)
    3490:	4832      	ldr	r0, [pc, #200]	; (355c <hci_rx_thread+0x100>)
    3492:	f00e fa55 	bl	11940 <printk>
    3496:	4040      	eors	r0, r0
    3498:	f380 8811 	msr	BASEPRI, r0
    349c:	f04f 0003 	mov.w	r0, #3
    34a0:	df02      	svc	2
    34a2:	2104      	movs	r1, #4
    34a4:	f104 0008 	add.w	r0, r4, #8
    34a8:	f011 fcc9 	bl	14e3e <net_buf_simple_pull_mem>
	acl(buf)->index = BT_CONN_INDEX_INVALID;
    34ac:	22ff      	movs	r2, #255	; 0xff
	len = sys_le16_to_cpu(hdr->len);
    34ae:	8843      	ldrh	r3, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
    34b0:	f8b0 9000 	ldrh.w	r9, [r0]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
    34b4:	7562      	strb	r2, [r4, #21]
	if (buf->len != len) {
    34b6:	89a2      	ldrh	r2, [r4, #12]
	acl(buf)->handle = bt_acl_handle(handle);
    34b8:	f3c9 000b 	ubfx	r0, r9, #0, #12
	if (buf->len != len) {
    34bc:	429a      	cmp	r2, r3
	acl(buf)->handle = bt_acl_handle(handle);
    34be:	82e0      	strh	r0, [r4, #22]
	if (buf->len != len) {
    34c0:	d003      	beq.n	34ca <hci_rx_thread+0x6e>
	net_buf_unref(buf);
    34c2:	4620      	mov	r0, r4
			net_buf_unref(buf);
    34c4:	f003 fa44 	bl	6950 <net_buf_unref>
			break;
    34c8:	e010      	b.n	34ec <hci_rx_thread+0x90>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
    34ca:	f001 fcc3 	bl	4e54 <bt_conn_lookup_handle>
	if (!conn) {
    34ce:	4605      	mov	r5, r0
    34d0:	2800      	cmp	r0, #0
    34d2:	d0f6      	beq.n	34c2 <hci_rx_thread+0x66>
	acl(buf)->index = bt_conn_index(conn);
    34d4:	f001 fedc 	bl	5290 <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
    34d8:	4621      	mov	r1, r4
	acl(buf)->index = bt_conn_index(conn);
    34da:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
    34dc:	ea4f 3219 	mov.w	r2, r9, lsr #12
    34e0:	4628      	mov	r0, r5
    34e2:	f010 fa55 	bl	13990 <bt_conn_recv>
	bt_conn_unref(conn);
    34e6:	4628      	mov	r0, r5
    34e8:	f010 facd 	bl	13a86 <bt_conn_unref>
	z_impl_k_yield();
    34ec:	f00d fbdc 	bl	10ca8 <z_impl_k_yield>
	while (1) {
    34f0:	e7ba      	b.n	3468 <hci_rx_thread+0xc>
	BT_ASSERT(buf->len >= sizeof(*hdr));
    34f2:	8983      	ldrh	r3, [r0, #12]
    34f4:	2b01      	cmp	r3, #1
    34f6:	d80c      	bhi.n	3512 <hci_rx_thread+0xb6>
    34f8:	f241 33fb 	movw	r3, #5115	; 0x13fb
    34fc:	4632      	mov	r2, r6
    34fe:	4916      	ldr	r1, [pc, #88]	; (3558 <hci_rx_thread+0xfc>)
    3500:	4816      	ldr	r0, [pc, #88]	; (355c <hci_rx_thread+0x100>)
    3502:	f00e fa1d 	bl	11940 <printk>
    3506:	4040      	eors	r0, r0
    3508:	f380 8811 	msr	BASEPRI, r0
    350c:	f04f 0003 	mov.w	r0, #3
    3510:	df02      	svc	2
    3512:	2102      	movs	r1, #2
    3514:	f104 0008 	add.w	r0, r4, #8
    3518:	f011 fc91 	bl	14e3e <net_buf_simple_pull_mem>
    351c:	4605      	mov	r5, r0
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    351e:	7800      	ldrb	r0, [r0, #0]
    3520:	f00f ff20 	bl	13364 <bt_hci_evt_get_flags>
    3524:	0783      	lsls	r3, r0, #30
    3526:	d40c      	bmi.n	3542 <hci_rx_thread+0xe6>
    3528:	f241 33ff 	movw	r3, #5119	; 0x13ff
    352c:	4632      	mov	r2, r6
    352e:	490c      	ldr	r1, [pc, #48]	; (3560 <hci_rx_thread+0x104>)
    3530:	480a      	ldr	r0, [pc, #40]	; (355c <hci_rx_thread+0x100>)
    3532:	f00e fa05 	bl	11940 <printk>
    3536:	4040      	eors	r0, r0
    3538:	f380 8811 	msr	BASEPRI, r0
    353c:	f04f 0003 	mov.w	r0, #3
    3540:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    3542:	2304      	movs	r3, #4
    3544:	4642      	mov	r2, r8
    3546:	4621      	mov	r1, r4
    3548:	7828      	ldrb	r0, [r5, #0]
    354a:	f00f ff1d 	bl	13388 <handle_event>
    354e:	e7b8      	b.n	34c2 <hci_rx_thread+0x66>
    3550:	200000fc 	.word	0x200000fc
    3554:	00043dd4 	.word	0x00043dd4
    3558:	00043e08 	.word	0x00043e08
    355c:	00043e21 	.word	0x00043e21
    3560:	00043e3e 	.word	0x00043e3e
    3564:	0001ed74 	.word	0x0001ed74

00003568 <hci_num_completed_packets>:
{
    3568:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	for (i = 0; i < evt->num_handles; i++) {
    356c:	2500      	movs	r5, #0
			tx->pending_no_cb = 0U;
    356e:	46a8      	mov	r8, r5
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
    3570:	6887      	ldr	r7, [r0, #8]
		k_queue_append(&work_q->queue, work);
    3572:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 3638 <hci_num_completed_packets+0xd0>
	for (i = 0; i < evt->num_handles; i++) {
    3576:	783b      	ldrb	r3, [r7, #0]
    3578:	429d      	cmp	r5, r3
    357a:	db01      	blt.n	3580 <hci_num_completed_packets+0x18>
}
    357c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		handle = sys_le16_to_cpu(evt->h[i].handle);
    3580:	eb07 0385 	add.w	r3, r7, r5, lsl #2
		conn = bt_conn_lookup_handle(handle);
    3584:	f8b3 0001 	ldrh.w	r0, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
    3588:	f8b3 6003 	ldrh.w	r6, [r3, #3]
		conn = bt_conn_lookup_handle(handle);
    358c:	f001 fc62 	bl	4e54 <bt_conn_lookup_handle>
		if (!conn) {
    3590:	4604      	mov	r4, r0
    3592:	b350      	cbz	r0, 35ea <hci_num_completed_packets+0x82>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    3594:	f100 0a28 	add.w	sl, r0, #40	; 0x28
		while (count--) {
    3598:	b326      	cbz	r6, 35e4 <hci_num_completed_packets+0x7c>
	__asm__ volatile(
    359a:	f04f 0320 	mov.w	r3, #32
    359e:	f3ef 8211 	mrs	r2, BASEPRI
    35a2:	f383 8811 	msr	BASEPRI, r3
    35a6:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
    35aa:	69e3      	ldr	r3, [r4, #28]
    35ac:	b16b      	cbz	r3, 35ca <hci_num_completed_packets+0x62>
				conn->pending_no_cb--;
    35ae:	3b01      	subs	r3, #1
    35b0:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
    35b2:	f382 8811 	msr	BASEPRI, r2
    35b6:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
    35ba:	4620      	mov	r0, r4
    35bc:	f001 fb22 	bl	4c04 <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
    35c0:	3e01      	subs	r6, #1
    35c2:	f00d fbe7 	bl	10d94 <z_impl_k_sem_give>
    35c6:	b2b6      	uxth	r6, r6
    35c8:	e7e6      	b.n	3598 <hci_num_completed_packets+0x30>
Z_GENLIST_IS_EMPTY(slist)
    35ca:	6963      	ldr	r3, [r4, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    35cc:	b12b      	cbz	r3, 35da <hci_num_completed_packets+0x72>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    35ce:	69a1      	ldr	r1, [r4, #24]
    35d0:	6818      	ldr	r0, [r3, #0]
    35d2:	428b      	cmp	r3, r1
	list->head = node;
    35d4:	6160      	str	r0, [r4, #20]
	list->tail = node;
    35d6:	bf08      	it	eq
    35d8:	61a0      	streq	r0, [r4, #24]
    35da:	f382 8811 	msr	BASEPRI, r2
    35de:	f3bf 8f6f 	isb	sy
			if (!node) {
    35e2:	b923      	cbnz	r3, 35ee <hci_num_completed_packets+0x86>
		bt_conn_unref(conn);
    35e4:	4620      	mov	r0, r4
    35e6:	f010 fa4e 	bl	13a86 <bt_conn_unref>
	for (i = 0; i < evt->num_handles; i++) {
    35ea:	3501      	adds	r5, #1
    35ec:	e7c3      	b.n	3576 <hci_num_completed_packets+0xe>
	__asm__ volatile(
    35ee:	f04f 0220 	mov.w	r2, #32
    35f2:	f3ef 8111 	mrs	r1, BASEPRI
    35f6:	f382 8811 	msr	BASEPRI, r2
    35fa:	f3bf 8f6f 	isb	sy
			conn->pending_no_cb = tx->pending_no_cb;
    35fe:	68da      	ldr	r2, [r3, #12]
    3600:	61e2      	str	r2, [r4, #28]
	parent->next = child;
    3602:	f8c3 8000 	str.w	r8, [r3]
Z_GENLIST_APPEND(slist, snode)
    3606:	6a62      	ldr	r2, [r4, #36]	; 0x24
			tx->pending_no_cb = 0U;
    3608:	f8c3 800c 	str.w	r8, [r3, #12]
    360c:	b98a      	cbnz	r2, 3632 <hci_num_completed_packets+0xca>
	list->head = node;
    360e:	e9c4 3308 	strd	r3, r3, [r4, #32]
	__asm__ volatile(
    3612:	f381 8811 	msr	BASEPRI, r1
    3616:	f3bf 8f6f 	isb	sy
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    361a:	2101      	movs	r1, #1
    361c:	f104 0030 	add.w	r0, r4, #48	; 0x30
    3620:	f00f ff10 	bl	13444 <atomic_or>
    3624:	07c3      	lsls	r3, r0, #31
    3626:	d4c8      	bmi.n	35ba <hci_num_completed_packets+0x52>
		k_queue_append(&work_q->queue, work);
    3628:	4651      	mov	r1, sl
    362a:	4648      	mov	r0, r9
    362c:	f019 fda0 	bl	1d170 <k_queue_append>
    3630:	e7c3      	b.n	35ba <hci_num_completed_packets+0x52>
	parent->next = child;
    3632:	6013      	str	r3, [r2, #0]
	list->tail = node;
    3634:	6263      	str	r3, [r4, #36]	; 0x24
}
    3636:	e7ec      	b.n	3612 <hci_num_completed_packets+0xaa>
    3638:	20001168 	.word	0x20001168

0000363c <hci_cmd_done.isra.0>:
static void hci_cmd_done(uint16_t opcode, uint8_t status, struct net_buf *buf)
    363c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    363e:	4606      	mov	r6, r0
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    3640:	7988      	ldrb	r0, [r1, #6]
static void hci_cmd_done(uint16_t opcode, uint8_t status, struct net_buf *buf)
    3642:	460c      	mov	r4, r1
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    3644:	f003 f8c8 	bl	67d8 <net_buf_pool_get>
    3648:	4b19      	ldr	r3, [pc, #100]	; (36b0 <hci_cmd_done.isra.0+0x74>)
    364a:	4283      	cmp	r3, r0
    364c:	d12e      	bne.n	36ac <hci_cmd_done.isra.0+0x70>
	if (cmd(buf)->opcode != opcode) {
    364e:	4620      	mov	r0, r4
    3650:	f003 f8ca 	bl	67e8 <net_buf_id>
	if (cmd(buf)->state && !status) {
    3654:	4620      	mov	r0, r4
    3656:	f003 f8c7 	bl	67e8 <net_buf_id>
    365a:	270c      	movs	r7, #12
    365c:	4d15      	ldr	r5, [pc, #84]	; (36b4 <hci_cmd_done.isra.0+0x78>)
    365e:	fb07 5300 	mla	r3, r7, r0, r5
    3662:	685b      	ldr	r3, [r3, #4]
    3664:	b15b      	cbz	r3, 367e <hci_cmd_done.isra.0+0x42>
    3666:	b956      	cbnz	r6, 367e <hci_cmd_done.isra.0+0x42>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
    3668:	4620      	mov	r0, r4
    366a:	f003 f8bd 	bl	67e8 <net_buf_id>
    366e:	fb07 5000 	mla	r0, r7, r0, r5
    3672:	6843      	ldr	r3, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
    3674:	7a1a      	ldrb	r2, [r3, #8]
    3676:	e9d3 0100 	ldrd	r0, r1, [r3]
    367a:	f00f fef9 	bl	13470 <atomic_set_bit_to>
	if (cmd(buf)->sync) {
    367e:	4620      	mov	r0, r4
    3680:	f003 f8b2 	bl	67e8 <net_buf_id>
    3684:	270c      	movs	r7, #12
    3686:	fb07 5000 	mla	r0, r7, r0, r5
    368a:	6883      	ldr	r3, [r0, #8]
    368c:	b173      	cbz	r3, 36ac <hci_cmd_done.isra.0+0x70>
		cmd(buf)->status = status;
    368e:	4620      	mov	r0, r4
    3690:	f003 f8aa 	bl	67e8 <net_buf_id>
    3694:	4378      	muls	r0, r7
    3696:	542e      	strb	r6, [r5, r0]
		k_sem_give(cmd(buf)->sync);
    3698:	4620      	mov	r0, r4
    369a:	f003 f8a5 	bl	67e8 <net_buf_id>
    369e:	fb07 5500 	mla	r5, r7, r0, r5
    36a2:	68a8      	ldr	r0, [r5, #8]
}
    36a4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    36a8:	f00d bb74 	b.w	10d94 <z_impl_k_sem_give>
    36ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    36ae:	bf00      	nop
    36b0:	20000938 	.word	0x20000938
    36b4:	20025a5c 	.word	0x20025a5c

000036b8 <hci_cmd_complete>:
{
    36b8:	b538      	push	{r3, r4, r5, lr}
    36ba:	2103      	movs	r1, #3
    36bc:	4604      	mov	r4, r0
    36be:	3008      	adds	r0, #8
    36c0:	f011 fbbd 	bl	14e3e <net_buf_simple_pull_mem>
	status = buf->data[0];
    36c4:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
    36c6:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
    36c8:	4621      	mov	r1, r4
    36ca:	7818      	ldrb	r0, [r3, #0]
    36cc:	f7ff ffb6 	bl	363c <hci_cmd_done.isra.0>
	if (ncmd) {
    36d0:	b125      	cbz	r5, 36dc <hci_cmd_complete+0x24>
}
    36d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    36d6:	4802      	ldr	r0, [pc, #8]	; (36e0 <hci_cmd_complete+0x28>)
    36d8:	f00d bb5c 	b.w	10d94 <z_impl_k_sem_give>
    36dc:	bd38      	pop	{r3, r4, r5, pc}
    36de:	bf00      	nop
    36e0:	200000e0 	.word	0x200000e0

000036e4 <le_adv_start_add_conn>:
	return 0;
}

static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv,
				 struct bt_conn **out_conn)
{
    36e4:	b5f0      	push	{r4, r5, r6, r7, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    36e6:	4b28      	ldr	r3, [pc, #160]	; (3788 <le_adv_start_add_conn+0xa4>)
    36e8:	4605      	mov	r5, r0
    36ea:	460f      	mov	r7, r1
    36ec:	b085      	sub	sp, #20
	struct adv_id_check_data check_data = {
		.id = adv->id,
    36ee:	7801      	ldrb	r1, [r0, #0]
    36f0:	f103 0028 	add.w	r0, r3, #40	; 0x28
    36f4:	f00f fe6c 	bl	133d0 <atomic_get>
	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED) &&
    36f8:	f010 0f40 	tst.w	r0, #64	; 0x40
    36fc:	461a      	mov	r2, r3
    36fe:	d008      	beq.n	3712 <le_adv_start_add_conn+0x2e>
    3700:	f103 0028 	add.w	r0, r3, #40	; 0x28
    3704:	f00f fe64 	bl	133d0 <atomic_get>
    3708:	05c0      	lsls	r0, r0, #23
    370a:	d502      	bpl.n	3712 <le_adv_start_add_conn+0x2e>
	    atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE) &&
    370c:	7e1b      	ldrb	r3, [r3, #24]
    370e:	428b      	cmp	r3, r1
    3710:	d131      	bne.n	3776 <le_adv_start_add_conn+0x92>
	bt_adv_foreach(adv_id_check_connectable_func, &check_data);
	if (check_data.adv_enabled) {
		return -ENOTSUP;
	}

	bt_dev.adv_conn_id = adv->id;
    3712:	462e      	mov	r6, r5
    3714:	f816 3b09 	ldrb.w	r3, [r6], #9

	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    3718:	4669      	mov	r1, sp
	bt_dev.adv_conn_id = adv->id;
    371a:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    371e:	2300      	movs	r3, #0
    3720:	4630      	mov	r0, r6
    3722:	9300      	str	r3, [sp, #0]
    3724:	f8cd 3003 	str.w	r3, [sp, #3]
    3728:	f00f fe55 	bl	133d6 <bt_addr_le_cmp>
    372c:	4604      	mov	r4, r0
    372e:	7828      	ldrb	r0, [r5, #0]
    3730:	b164      	cbz	r4, 374c <le_adv_start_add_conn+0x68>
		bt_conn_set_state(conn, BT_CONN_CONNECT_ADV);
		*out_conn = conn;
		return 0;
	}

	if (bt_conn_exists_le(adv->id, &adv->target_addr)) {
    3732:	4631      	mov	r1, r6
    3734:	f010 f9d7 	bl	13ae6 <bt_conn_exists_le>
    3738:	4604      	mov	r4, r0
    373a:	b9f8      	cbnz	r0, 377c <le_adv_start_add_conn+0x98>
		return -EINVAL;
	}

	conn = bt_conn_add_le(adv->id, &adv->target_addr);
    373c:	7828      	ldrb	r0, [r5, #0]
    373e:	4631      	mov	r1, r6
    3740:	f001 fb5a 	bl	4df8 <bt_conn_add_le>
	if (!conn) {
    3744:	4605      	mov	r5, r0
    3746:	b1e0      	cbz	r0, 3782 <le_adv_start_add_conn+0x9e>
		return -ENOMEM;
	}

	bt_conn_set_state(conn, BT_CONN_CONNECT_DIR_ADV);
    3748:	2105      	movs	r1, #5
    374a:	e00e      	b.n	376a <le_adv_start_add_conn+0x86>
		conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
    374c:	f06f 03ff 	mvn.w	r3, #255	; 0xff
    3750:	9302      	str	r3, [sp, #8]
    3752:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3756:	a902      	add	r1, sp, #8
    3758:	f8ad 300c 	strh.w	r3, [sp, #12]
    375c:	f88d 300e 	strb.w	r3, [sp, #14]
    3760:	f001 fb4a 	bl	4df8 <bt_conn_add_le>
		if (!conn) {
    3764:	4605      	mov	r5, r0
    3766:	b160      	cbz	r0, 3782 <le_adv_start_add_conn+0x9e>
		bt_conn_set_state(conn, BT_CONN_CONNECT_ADV);
    3768:	2104      	movs	r1, #4
	bt_conn_set_state(conn, BT_CONN_CONNECT_DIR_ADV);
    376a:	f001 fb7f 	bl	4e6c <bt_conn_set_state>
	*out_conn = conn;
    376e:	603d      	str	r5, [r7, #0]
	return 0;
}
    3770:	4620      	mov	r0, r4
    3772:	b005      	add	sp, #20
    3774:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENOTSUP;
    3776:	f06f 0485 	mvn.w	r4, #133	; 0x85
    377a:	e7f9      	b.n	3770 <le_adv_start_add_conn+0x8c>
		return -EINVAL;
    377c:	f06f 0415 	mvn.w	r4, #21
    3780:	e7f6      	b.n	3770 <le_adv_start_add_conn+0x8c>
		return -ENOMEM;
    3782:	f06f 040b 	mvn.w	r4, #11
    3786:	e7f3      	b.n	3770 <le_adv_start_add_conn+0x8c>
    3788:	20000000 	.word	0x20000000

0000378c <hci_cmd_status>:
{
    378c:	b538      	push	{r3, r4, r5, lr}
    378e:	2104      	movs	r1, #4
    3790:	4604      	mov	r4, r0
    3792:	3008      	adds	r0, #8
    3794:	f011 fb53 	bl	14e3e <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    3798:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    379a:	4621      	mov	r1, r4
    379c:	7800      	ldrb	r0, [r0, #0]
    379e:	f7ff ff4d 	bl	363c <hci_cmd_done.isra.0>
	if (ncmd) {
    37a2:	b125      	cbz	r5, 37ae <hci_cmd_status+0x22>
}
    37a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    37a8:	4801      	ldr	r0, [pc, #4]	; (37b0 <hci_cmd_status+0x24>)
    37aa:	f00d baf3 	b.w	10d94 <z_impl_k_sem_give>
    37ae:	bd38      	pop	{r3, r4, r5, pc}
    37b0:	200000e0 	.word	0x200000e0

000037b4 <bt_hci_cmd_create>:
{
    37b4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return net_buf_alloc_fixed(pool, timeout);
    37b8:	f04f 32ff 	mov.w	r2, #4294967295
    37bc:	f04f 33ff 	mov.w	r3, #4294967295
    37c0:	4605      	mov	r5, r0
    37c2:	4816      	ldr	r0, [pc, #88]	; (381c <bt_hci_cmd_create+0x68>)
    37c4:	460e      	mov	r6, r1
    37c6:	f011 fab3 	bl	14d30 <net_buf_alloc_fixed>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    37ca:	2700      	movs	r7, #0
    37cc:	4604      	mov	r4, r0
	net_buf_simple_reserve(&buf->b, reserve);
    37ce:	f100 0b08 	add.w	fp, r0, #8
    37d2:	2101      	movs	r1, #1
    37d4:	4658      	mov	r0, fp
    37d6:	f011 faca 	bl	14d6e <net_buf_simple_reserve>
	cmd(buf)->opcode = opcode;
    37da:	4620      	mov	r0, r4
    37dc:	7527      	strb	r7, [r4, #20]
    37de:	f003 f803 	bl	67e8 <net_buf_id>
    37e2:	f04f 0a0c 	mov.w	sl, #12
    37e6:	f8df 8038 	ldr.w	r8, [pc, #56]	; 3820 <bt_hci_cmd_create+0x6c>
    37ea:	fb0a 8000 	mla	r0, sl, r0, r8
    37ee:	8045      	strh	r5, [r0, #2]
	cmd(buf)->sync = NULL;
    37f0:	4620      	mov	r0, r4
    37f2:	f002 fff9 	bl	67e8 <net_buf_id>
    37f6:	fb0a 8000 	mla	r0, sl, r0, r8
    37fa:	6087      	str	r7, [r0, #8]
	cmd(buf)->state = NULL;
    37fc:	4620      	mov	r0, r4
    37fe:	f002 fff3 	bl	67e8 <net_buf_id>
    3802:	fb0a 8000 	mla	r0, sl, r0, r8
	return net_buf_simple_add(&buf->b, len);
    3806:	2103      	movs	r1, #3
    3808:	6047      	str	r7, [r0, #4]
    380a:	4658      	mov	r0, fp
    380c:	f011 fae6 	bl	14ddc <net_buf_simple_add>
	hdr->param_len = param_len;
    3810:	7086      	strb	r6, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
    3812:	8005      	strh	r5, [r0, #0]
}
    3814:	4620      	mov	r0, r4
    3816:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    381a:	bf00      	nop
    381c:	20000938 	.word	0x20000938
    3820:	20025a5c 	.word	0x20025a5c

00003824 <bt_hci_cmd_send_sync>:
{
    3824:	b5f0      	push	{r4, r5, r6, r7, lr}
    3826:	4615      	mov	r5, r2
	if (!buf) {
    3828:	460c      	mov	r4, r1
{
    382a:	b087      	sub	sp, #28
	if (!buf) {
    382c:	b921      	cbnz	r1, 3838 <bt_hci_cmd_send_sync+0x14>
		buf = bt_hci_cmd_create(opcode, 0);
    382e:	f7ff ffc1 	bl	37b4 <bt_hci_cmd_create>
		if (!buf) {
    3832:	4604      	mov	r4, r0
    3834:	2800      	cmp	r0, #0
    3836:	d048      	beq.n	38ca <bt_hci_cmd_send_sync+0xa6>
	return z_impl_k_sem_init(sem, initial_count, limit);
    3838:	2201      	movs	r2, #1
    383a:	2100      	movs	r1, #0
    383c:	4668      	mov	r0, sp
    383e:	f019 fde3 	bl	1d408 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    3842:	4620      	mov	r0, r4
    3844:	f002 ffd0 	bl	67e8 <net_buf_id>
    3848:	230c      	movs	r3, #12
    384a:	4e21      	ldr	r6, [pc, #132]	; (38d0 <bt_hci_cmd_send_sync+0xac>)
    384c:	fb03 6000 	mla	r0, r3, r0, r6
    3850:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_ref(buf);
    3854:	4620      	mov	r0, r4
    3856:	f011 fa9b 	bl	14d90 <net_buf_ref>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    385a:	4621      	mov	r1, r4
    385c:	481d      	ldr	r0, [pc, #116]	; (38d4 <bt_hci_cmd_send_sync+0xb0>)
    385e:	f011 fa8a 	bl	14d76 <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    3862:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    3866:	2300      	movs	r3, #0
    3868:	4668      	mov	r0, sp
    386a:	f00d fab9 	bl	10de0 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    386e:	4607      	mov	r7, r0
    3870:	b180      	cbz	r0, 3894 <bt_hci_cmd_send_sync+0x70>
    3872:	f240 134d 	movw	r3, #333	; 0x14d
    3876:	4a18      	ldr	r2, [pc, #96]	; (38d8 <bt_hci_cmd_send_sync+0xb4>)
    3878:	4918      	ldr	r1, [pc, #96]	; (38dc <bt_hci_cmd_send_sync+0xb8>)
    387a:	4819      	ldr	r0, [pc, #100]	; (38e0 <bt_hci_cmd_send_sync+0xbc>)
    387c:	f00e f860 	bl	11940 <printk>
    3880:	4639      	mov	r1, r7
    3882:	4818      	ldr	r0, [pc, #96]	; (38e4 <bt_hci_cmd_send_sync+0xc0>)
    3884:	f00e f85c 	bl	11940 <printk>
    3888:	4040      	eors	r0, r0
    388a:	f380 8811 	msr	BASEPRI, r0
    388e:	f04f 0003 	mov.w	r0, #3
    3892:	df02      	svc	2
	status = cmd(buf)->status;
    3894:	4620      	mov	r0, r4
    3896:	f002 ffa7 	bl	67e8 <net_buf_id>
    389a:	230c      	movs	r3, #12
    389c:	4343      	muls	r3, r0
    389e:	5cf6      	ldrb	r6, [r6, r3]
	if (status) {
    38a0:	b156      	cbz	r6, 38b8 <bt_hci_cmd_send_sync+0x94>
		net_buf_unref(buf);
    38a2:	4620      	mov	r0, r4
    38a4:	f003 f854 	bl	6950 <net_buf_unref>
			return -EIO;
    38a8:	2e09      	cmp	r6, #9
    38aa:	bf0c      	ite	eq
    38ac:	f06f 006e 	mvneq.w	r0, #110	; 0x6e
    38b0:	f06f 0004 	mvnne.w	r0, #4
}
    38b4:	b007      	add	sp, #28
    38b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (rsp) {
    38b8:	b115      	cbz	r5, 38c0 <bt_hci_cmd_send_sync+0x9c>
	return 0;
    38ba:	4630      	mov	r0, r6
		*rsp = buf;
    38bc:	602c      	str	r4, [r5, #0]
    38be:	e7f9      	b.n	38b4 <bt_hci_cmd_send_sync+0x90>
		net_buf_unref(buf);
    38c0:	4620      	mov	r0, r4
    38c2:	f003 f845 	bl	6950 <net_buf_unref>
	return 0;
    38c6:	4628      	mov	r0, r5
    38c8:	e7f4      	b.n	38b4 <bt_hci_cmd_send_sync+0x90>
			return -ENOBUFS;
    38ca:	f06f 0068 	mvn.w	r0, #104	; 0x68
    38ce:	e7f1      	b.n	38b4 <bt_hci_cmd_send_sync+0x90>
    38d0:	20025a5c 	.word	0x20025a5c
    38d4:	20000114 	.word	0x20000114
    38d8:	00043dd4 	.word	0x00043dd4
    38dc:	00043e6c 	.word	0x00043e6c
    38e0:	00043e21 	.word	0x00043e21
    38e4:	00043e75 	.word	0x00043e75

000038e8 <set_random_address>:
{
    38e8:	b570      	push	{r4, r5, r6, lr}
 *
 *  @return negative value if @a a < @a b, 0 if @a a == @a b, else positive
 */
static inline int bt_addr_cmp(const bt_addr_t *a, const bt_addr_t *b)
{
	return memcmp(a, b, sizeof(*a));
    38ea:	4e15      	ldr	r6, [pc, #84]	; (3940 <set_random_address+0x58>)
    38ec:	2206      	movs	r2, #6
    38ee:	f106 012d 	add.w	r1, r6, #45	; 0x2d
    38f2:	4605      	mov	r5, r0
    38f4:	f01a f827 	bl	1d946 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    38f8:	4602      	mov	r2, r0
    38fa:	b1d8      	cbz	r0, 3934 <set_random_address+0x4c>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    38fc:	2106      	movs	r1, #6
    38fe:	f242 0005 	movw	r0, #8197	; 0x2005
    3902:	f7ff ff57 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    3906:	4604      	mov	r4, r0
    3908:	b1b0      	cbz	r0, 3938 <set_random_address+0x50>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    390a:	2206      	movs	r2, #6
    390c:	4629      	mov	r1, r5
    390e:	3008      	adds	r0, #8
    3910:	f011 fa6a 	bl	14de8 <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    3914:	2200      	movs	r2, #0
    3916:	4621      	mov	r1, r4
    3918:	f242 0005 	movw	r0, #8197	; 0x2005
    391c:	f7ff ff82 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    3920:	4602      	mov	r2, r0
    3922:	b938      	cbnz	r0, 3934 <set_random_address+0x4c>
	bt_addr_copy(&bt_dev.random_addr.a, addr);
    3924:	4629      	mov	r1, r5
    3926:	f106 002d 	add.w	r0, r6, #45	; 0x2d
    392a:	f00f fdf0 	bl	1350e <bt_addr_copy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    392e:	2301      	movs	r3, #1
    3930:	f886 302c 	strb.w	r3, [r6, #44]	; 0x2c
}
    3934:	4610      	mov	r0, r2
    3936:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
    3938:	f06f 0268 	mvn.w	r2, #104	; 0x68
    393c:	e7fa      	b.n	3934 <set_random_address+0x4c>
    393e:	bf00      	nop
    3940:	20000000 	.word	0x20000000

00003944 <le_adv_set_random_addr.isra.0>:
static int le_adv_set_random_addr(struct bt_le_ext_adv *adv, uint32_t options,
    3944:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    3948:	4604      	mov	r4, r0
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    394a:	f011 0001 	ands.w	r0, r1, #1
static int le_adv_set_random_addr(struct bt_le_ext_adv *adv, uint32_t options,
    394e:	460e      	mov	r6, r1
    3950:	4690      	mov	r8, r2
    3952:	461d      	mov	r5, r3
	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    3954:	d027      	beq.n	39a6 <le_adv_set_random_addr.isra.0+0x62>
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
    3956:	4f27      	ldr	r7, [pc, #156]	; (39f4 <le_adv_set_random_addr.isra.0+0xb0>)
    3958:	b12a      	cbz	r2, 3966 <le_adv_set_random_addr.isra.0+0x22>
    395a:	0688      	lsls	r0, r1, #26
    395c:	d503      	bpl.n	3966 <le_adv_set_random_addr.isra.0+0x22>
    395e:	f897 3098 	ldrb.w	r3, [r7, #152]	; 0x98
    3962:	0659      	lsls	r1, r3, #25
    3964:	d542      	bpl.n	39ec <le_adv_set_random_addr.isra.0+0xa8>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    3966:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
    396a:	5cfb      	ldrb	r3, [r7, r3]
    396c:	ea4f 09c4 	mov.w	r9, r4, lsl #3
    3970:	2b01      	cmp	r3, #1
    3972:	d008      	beq.n	3986 <le_adv_set_random_addr.isra.0+0x42>
			*own_addr_type = id_addr->type;
    3974:	eba9 0404 	sub.w	r4, r9, r4
    3978:	5d3b      	ldrb	r3, [r7, r4]
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    397a:	f1b8 0f00 	cmp.w	r8, #0
    397e:	d10d      	bne.n	399c <le_adv_set_random_addr.isra.0+0x58>
	return 0;
    3980:	2000      	movs	r0, #0
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    3982:	702b      	strb	r3, [r5, #0]
    3984:	e007      	b.n	3996 <le_adv_set_random_addr.isra.0+0x52>
				err = set_adv_random_address(adv, &id_addr->a);
    3986:	2007      	movs	r0, #7
    3988:	fb10 3004 	smlabb	r0, r0, r4, r3
		return set_random_address(addr);
    398c:	4438      	add	r0, r7
    398e:	f7ff ffab 	bl	38e8 <set_random_address>
				if (err) {
    3992:	2800      	cmp	r0, #0
    3994:	d0ee      	beq.n	3974 <le_adv_set_random_addr.isra.0+0x30>
}
    3996:	b003      	add	sp, #12
    3998:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    399c:	06b2      	lsls	r2, r6, #26
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    399e:	bf48      	it	mi
    39a0:	f043 0302 	orrmi.w	r3, r3, #2
    39a4:	e7ec      	b.n	3980 <le_adv_set_random_addr.isra.0+0x3c>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
    39a6:	074b      	lsls	r3, r1, #29
    39a8:	d510      	bpl.n	39cc <le_adv_set_random_addr.isra.0+0x88>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    39aa:	4e12      	ldr	r6, [pc, #72]	; (39f4 <le_adv_set_random_addr.isra.0+0xb0>)
    39ac:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
    39b0:	5cf3      	ldrb	r3, [r6, r3]
    39b2:	00e7      	lsls	r7, r4, #3
    39b4:	2b01      	cmp	r3, #1
    39b6:	d105      	bne.n	39c4 <le_adv_set_random_addr.isra.0+0x80>
				err = set_adv_random_address(adv, &id_addr->a);
    39b8:	2007      	movs	r0, #7
    39ba:	fb10 3004 	smlabb	r0, r0, r4, r3
		return set_random_address(addr);
    39be:	4430      	add	r0, r6
    39c0:	f7ff ff92 	bl	38e8 <set_random_address>
			*own_addr_type = id_addr->type;
    39c4:	1b3c      	subs	r4, r7, r4
    39c6:	5d33      	ldrb	r3, [r6, r4]
			*own_addr_type = BT_ADDR_LE_RANDOM;
    39c8:	702b      	strb	r3, [r5, #0]
		if (err) {
    39ca:	e7e4      	b.n	3996 <le_adv_set_random_addr.isra.0+0x52>
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
    39cc:	2106      	movs	r1, #6
    39ce:	4668      	mov	r0, sp
    39d0:	f001 f856 	bl	4a80 <bt_rand>
	if (err) {
    39d4:	b940      	cbnz	r0, 39e8 <le_adv_set_random_addr.isra.0+0xa4>
	BT_ADDR_SET_NRPA(&nrpa);
    39d6:	f89d 3005 	ldrb.w	r3, [sp, #5]
		return set_random_address(addr);
    39da:	4668      	mov	r0, sp
	BT_ADDR_SET_NRPA(&nrpa);
    39dc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    39e0:	f88d 3005 	strb.w	r3, [sp, #5]
		return set_random_address(addr);
    39e4:	f7ff ff80 	bl	38e8 <set_random_address>
			*own_addr_type = BT_ADDR_LE_RANDOM;
    39e8:	2301      	movs	r3, #1
    39ea:	e7ed      	b.n	39c8 <le_adv_set_random_addr.isra.0+0x84>
			return -ENOTSUP;
    39ec:	f06f 0085 	mvn.w	r0, #133	; 0x85
    39f0:	e7d1      	b.n	3996 <le_adv_set_random_addr.isra.0+0x52>
    39f2:	bf00      	nop
    39f4:	20000000 	.word	0x20000000

000039f8 <le_adv_update.constprop.0>:
static int le_adv_update(struct bt_le_ext_adv *adv,
    39f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    39fc:	b087      	sub	sp, #28
    39fe:	f89d 8048 	ldrb.w	r8, [sp, #72]	; 0x48
    3a02:	4606      	mov	r6, r0
    3a04:	460c      	mov	r4, r1
    3a06:	4617      	mov	r7, r2
	struct bt_ad d[2] = {};
    3a08:	2100      	movs	r1, #0
    3a0a:	2210      	movs	r2, #16
    3a0c:	a802      	add	r0, sp, #8
static int le_adv_update(struct bt_le_ext_adv *adv,
    3a0e:	461d      	mov	r5, r3
    3a10:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    3a14:	f89d a044 	ldrb.w	sl, [sp, #68]	; 0x44
	struct bt_ad d[2] = {};
    3a18:	f019 ffb0 	bl	1d97c <memset>
	if (use_name) {
    3a1c:	f1b8 0f00 	cmp.w	r8, #0
    3a20:	d00e      	beq.n	3a40 <le_adv_update.constprop.0+0x48>
		if ((ad && ad_has_name(ad, ad_len)) ||
    3a22:	bbb4      	cbnz	r4, 3a92 <le_adv_update.constprop.0+0x9a>
    3a24:	2d00      	cmp	r5, #0
    3a26:	d13f      	bne.n	3aa8 <le_adv_update.constprop.0+0xb0>
		data = (struct bt_data)BT_DATA(
    3a28:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 3adc <le_adv_update.constprop.0+0xe4>
    3a2c:	4658      	mov	r0, fp
    3a2e:	f7fc fd19 	bl	464 <strlen>
    3a32:	2309      	movs	r3, #9
    3a34:	f88d 0001 	strb.w	r0, [sp, #1]
    3a38:	f88d 3000 	strb.w	r3, [sp]
    3a3c:	f8cd b004 	str.w	fp, [sp, #4]
		d[0].len = ad_len;
    3a40:	e9cd 4702 	strd	r4, r7, [sp, #8]
		if (use_name && !scannable) {
    3a44:	f1b8 0f00 	cmp.w	r8, #0
    3a48:	d030      	beq.n	3aac <le_adv_update.constprop.0+0xb4>
    3a4a:	f1ba 0f00 	cmp.w	sl, #0
    3a4e:	d12d      	bne.n	3aac <le_adv_update.constprop.0+0xb4>
			d[1].len = 1;
    3a50:	2301      	movs	r3, #1
			d_len = 2;
    3a52:	2202      	movs	r2, #2
			d[1].data = &data;
    3a54:	f8cd d010 	str.w	sp, [sp, #16]
			d[1].len = 1;
    3a58:	9305      	str	r3, [sp, #20]
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
    3a5a:	f242 0008 	movw	r0, #8200	; 0x2008
    3a5e:	a902      	add	r1, sp, #8
    3a60:	f00f fd7a 	bl	13558 <hci_set_ad>
		if (err) {
    3a64:	4604      	mov	r4, r0
    3a66:	b938      	cbnz	r0, 3a78 <le_adv_update.constprop.0+0x80>
	if (scannable) {
    3a68:	f1ba 0f00 	cmp.w	sl, #0
    3a6c:	d120      	bne.n	3ab0 <le_adv_update.constprop.0+0xb8>
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    3a6e:	2104      	movs	r1, #4
    3a70:	f106 0010 	add.w	r0, r6, #16
    3a74:	f00f fce6 	bl	13444 <atomic_or>
}
    3a78:	4620      	mov	r0, r4
    3a7a:	b007      	add	sp, #28
    3a7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
    3a80:	f814 2033 	ldrb.w	r2, [r4, r3, lsl #3]
    3a84:	3a08      	subs	r2, #8
    3a86:	2a01      	cmp	r2, #1
    3a88:	d925      	bls.n	3ad6 <le_adv_update.constprop.0+0xde>
	for (i = 0; i < ad_len; i++) {
    3a8a:	3301      	adds	r3, #1
    3a8c:	429f      	cmp	r7, r3
    3a8e:	d1f7      	bne.n	3a80 <le_adv_update.constprop.0+0x88>
    3a90:	e7c8      	b.n	3a24 <le_adv_update.constprop.0+0x2c>
    3a92:	2300      	movs	r3, #0
    3a94:	e7fa      	b.n	3a8c <le_adv_update.constprop.0+0x94>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
    3a96:	f815 2033 	ldrb.w	r2, [r5, r3, lsl #3]
    3a9a:	3a08      	subs	r2, #8
    3a9c:	2a01      	cmp	r2, #1
    3a9e:	d91a      	bls.n	3ad6 <le_adv_update.constprop.0+0xde>
	for (i = 0; i < ad_len; i++) {
    3aa0:	3301      	adds	r3, #1
    3aa2:	4599      	cmp	r9, r3
    3aa4:	d1f7      	bne.n	3a96 <le_adv_update.constprop.0+0x9e>
    3aa6:	e7bf      	b.n	3a28 <le_adv_update.constprop.0+0x30>
    3aa8:	2300      	movs	r3, #0
    3aaa:	e7fa      	b.n	3aa2 <le_adv_update.constprop.0+0xaa>
		d_len = 1;
    3aac:	2201      	movs	r2, #1
    3aae:	e7d4      	b.n	3a5a <le_adv_update.constprop.0+0x62>
		d[0].data = sd;
    3ab0:	2201      	movs	r2, #1
		d[0].len = sd_len;
    3ab2:	e9cd 5902 	strd	r5, r9, [sp, #8]
		if (use_name) {
    3ab6:	f1b8 0f00 	cmp.w	r8, #0
    3aba:	d003      	beq.n	3ac4 <le_adv_update.constprop.0+0xcc>
			d[1].len = 1;
    3abc:	9205      	str	r2, [sp, #20]
			d_len = 2;
    3abe:	2202      	movs	r2, #2
			d[1].data = &data;
    3ac0:	f8cd d010 	str.w	sp, [sp, #16]
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
    3ac4:	f242 0009 	movw	r0, #8201	; 0x2009
    3ac8:	a902      	add	r1, sp, #8
    3aca:	f00f fd45 	bl	13558 <hci_set_ad>
		if (err) {
    3ace:	2800      	cmp	r0, #0
    3ad0:	d0cd      	beq.n	3a6e <le_adv_update.constprop.0+0x76>
    3ad2:	4604      	mov	r4, r0
    3ad4:	e7d0      	b.n	3a78 <le_adv_update.constprop.0+0x80>
			return -EINVAL;
    3ad6:	f06f 0415 	mvn.w	r4, #21
    3ada:	e7cd      	b.n	3a78 <le_adv_update.constprop.0+0x80>
    3adc:	0001f5ba 	.word	0x0001f5ba

00003ae0 <set_le_adv_enable_legacy>:
{
    3ae0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    3ae2:	4606      	mov	r6, r0
    3ae4:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
    3ae6:	f242 000a 	movw	r0, #8202	; 0x200a
    3aea:	2101      	movs	r1, #1
    3aec:	f7ff fe62 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    3af0:	4604      	mov	r4, r0
    3af2:	b1e8      	cbz	r0, 3b30 <set_le_adv_enable_legacy+0x50>
	if (enable) {
    3af4:	3008      	adds	r0, #8
    3af6:	b1cd      	cbz	r5, 3b2c <set_le_adv_enable_legacy+0x4c>
	return net_buf_simple_add_u8(&buf->b, val);
    3af8:	2101      	movs	r1, #1
    3afa:	f011 f97f 	bl	14dfc <net_buf_simple_add_u8>
static inline void bt_hci_cmd_state_set_init(struct bt_hci_cmd_state_set *state,
					     atomic_t *target, int bit,
					     bool val)
{
	state->target = target;
	state->bit = bit;
    3afe:	2306      	movs	r3, #6
	cmd(buf)->state = &state;
    3b00:	4620      	mov	r0, r4
	bt_hci_cmd_state_set_init(&state, adv->flags, BT_ADV_ENABLED, enable);
    3b02:	3610      	adds	r6, #16
    3b04:	9302      	str	r3, [sp, #8]
	state->target = target;
    3b06:	9601      	str	r6, [sp, #4]
	state->val = val;
    3b08:	f88d 500c 	strb.w	r5, [sp, #12]
	cmd(buf)->state = &state;
    3b0c:	f002 fe6c 	bl	67e8 <net_buf_id>
    3b10:	220c      	movs	r2, #12
    3b12:	4b09      	ldr	r3, [pc, #36]	; (3b38 <set_le_adv_enable_legacy+0x58>)
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    3b14:	4621      	mov	r1, r4
	cmd(buf)->state = &state;
    3b16:	fb02 3000 	mla	r0, r2, r0, r3
    3b1a:	ab01      	add	r3, sp, #4
    3b1c:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
    3b1e:	2200      	movs	r2, #0
    3b20:	f242 000a 	movw	r0, #8202	; 0x200a
    3b24:	f7ff fe7e 	bl	3824 <bt_hci_cmd_send_sync>
}
    3b28:	b004      	add	sp, #16
    3b2a:	bd70      	pop	{r4, r5, r6, pc}
    3b2c:	4629      	mov	r1, r5
    3b2e:	e7e4      	b.n	3afa <set_le_adv_enable_legacy+0x1a>
		return -ENOBUFS;
    3b30:	f06f 0068 	mvn.w	r0, #104	; 0x68
    3b34:	e7f8      	b.n	3b28 <set_le_adv_enable_legacy+0x48>
    3b36:	bf00      	nop
    3b38:	20025a5c 	.word	0x20025a5c

00003b3c <bt_send>:
	return bt_dev.drv->send(buf);
    3b3c:	4b02      	ldr	r3, [pc, #8]	; (3b48 <bt_send+0xc>)
    3b3e:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
    3b42:	691b      	ldr	r3, [r3, #16]
    3b44:	4718      	bx	r3
    3b46:	bf00      	nop
    3b48:	20000000 	.word	0x20000000

00003b4c <bt_hci_cmd_send>:
{
    3b4c:	b538      	push	{r3, r4, r5, lr}
    3b4e:	4605      	mov	r5, r0
	if (!buf) {
    3b50:	460c      	mov	r4, r1
    3b52:	b919      	cbnz	r1, 3b5c <bt_hci_cmd_send+0x10>
		buf = bt_hci_cmd_create(opcode, 0);
    3b54:	f7ff fe2e 	bl	37b4 <bt_hci_cmd_create>
		if (!buf) {
    3b58:	4604      	mov	r4, r0
    3b5a:	b198      	cbz	r0, 3b84 <bt_hci_cmd_send+0x38>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
    3b5c:	f640 4335 	movw	r3, #3125	; 0xc35
    3b60:	429d      	cmp	r5, r3
    3b62:	d109      	bne.n	3b78 <bt_hci_cmd_send+0x2c>
		err = bt_send(buf);
    3b64:	4620      	mov	r0, r4
    3b66:	f7ff ffe9 	bl	3b3c <bt_send>
		if (err) {
    3b6a:	4605      	mov	r5, r0
    3b6c:	b110      	cbz	r0, 3b74 <bt_hci_cmd_send+0x28>
			net_buf_unref(buf);
    3b6e:	4620      	mov	r0, r4
    3b70:	f002 feee 	bl	6950 <net_buf_unref>
}
    3b74:	4628      	mov	r0, r5
    3b76:	bd38      	pop	{r3, r4, r5, pc}
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    3b78:	4621      	mov	r1, r4
    3b7a:	4804      	ldr	r0, [pc, #16]	; (3b8c <bt_hci_cmd_send+0x40>)
    3b7c:	f011 f8fb 	bl	14d76 <net_buf_put>
	return 0;
    3b80:	2500      	movs	r5, #0
    3b82:	e7f7      	b.n	3b74 <bt_hci_cmd_send+0x28>
			return -ENOBUFS;
    3b84:	f06f 0568 	mvn.w	r5, #104	; 0x68
    3b88:	e7f4      	b.n	3b74 <bt_hci_cmd_send+0x28>
    3b8a:	bf00      	nop
    3b8c:	20000114 	.word	0x20000114

00003b90 <bt_hci_host_num_completed_packets>:
{
    3b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3b92:	4604      	mov	r4, r0
	uint16_t handle = acl(buf)->handle;
    3b94:	8ac5      	ldrh	r5, [r0, #22]
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    3b96:	7980      	ldrb	r0, [r0, #6]
    3b98:	f002 fe1e 	bl	67d8 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
    3b9c:	4621      	mov	r1, r4
    3b9e:	f019 faf2 	bl	1d186 <k_queue_prepend>
	if (!BT_CMD_TEST(bt_dev.supported_commands, 10, 5)) {
    3ba2:	4b1b      	ldr	r3, [pc, #108]	; (3c10 <bt_hci_host_num_completed_packets+0x80>)
    3ba4:	f893 304e 	ldrb.w	r3, [r3, #78]	; 0x4e
    3ba8:	069b      	lsls	r3, r3, #26
    3baa:	d514      	bpl.n	3bd6 <bt_hci_host_num_completed_packets+0x46>
	conn = bt_conn_lookup_index(acl(buf)->index);
    3bac:	7d60      	ldrb	r0, [r4, #21]
    3bae:	f001 fb7b 	bl	52a8 <bt_conn_lookup_index>
	if (!conn) {
    3bb2:	4603      	mov	r3, r0
    3bb4:	b178      	cbz	r0, 3bd6 <bt_hci_host_num_completed_packets+0x46>
	if (!bt_conn_is_handle_valid(conn)) {
    3bb6:	7a82      	ldrb	r2, [r0, #10]
/* Look up an existing connection */
struct bt_conn *bt_conn_lookup_handle(uint16_t handle);

static inline bool bt_conn_is_handle_valid(struct bt_conn *conn)
{
	switch (conn->state) {
    3bb8:	2a01      	cmp	r2, #1
    3bba:	d002      	beq.n	3bc2 <bt_hci_host_num_completed_packets+0x32>
    3bbc:	3a07      	subs	r2, #7
    3bbe:	2a01      	cmp	r2, #1
    3bc0:	d80a      	bhi.n	3bd8 <bt_hci_host_num_completed_packets+0x48>
	bt_conn_unref(conn);
    3bc2:	4618      	mov	r0, r3
    3bc4:	f00f ff5f 	bl	13a86 <bt_conn_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS,
    3bc8:	2105      	movs	r1, #5
    3bca:	f640 4035 	movw	r0, #3125	; 0xc35
    3bce:	f7ff fdf1 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    3bd2:	4604      	mov	r4, r0
    3bd4:	b920      	cbnz	r0, 3be0 <bt_hci_host_num_completed_packets+0x50>
}
    3bd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3bd8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_conn_unref(conn);
    3bdc:	f00f bf53 	b.w	13a86 <bt_conn_unref>
	return net_buf_simple_add(&buf->b, len);
    3be0:	f100 0708 	add.w	r7, r0, #8
    3be4:	2101      	movs	r1, #1
    3be6:	4638      	mov	r0, r7
    3be8:	f011 f8f8 	bl	14ddc <net_buf_simple_add>
	cp->num_handles = sys_cpu_to_le16(1);
    3bec:	2601      	movs	r6, #1
    3bee:	2104      	movs	r1, #4
    3bf0:	7006      	strb	r6, [r0, #0]
    3bf2:	4638      	mov	r0, r7
    3bf4:	f011 f8f2 	bl	14ddc <net_buf_simple_add>
	hc->count  = sys_cpu_to_le16(1);
    3bf8:	2300      	movs	r3, #0
	hc->handle = sys_cpu_to_le16(handle);
    3bfa:	8005      	strh	r5, [r0, #0]
	hc->count  = sys_cpu_to_le16(1);
    3bfc:	7086      	strb	r6, [r0, #2]
    3bfe:	70c3      	strb	r3, [r0, #3]
	bt_hci_cmd_send(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS, buf);
    3c00:	4621      	mov	r1, r4
}
    3c02:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	bt_hci_cmd_send(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS, buf);
    3c06:	f640 4035 	movw	r0, #3125	; 0xc35
    3c0a:	f7ff bf9f 	b.w	3b4c <bt_hci_cmd_send>
    3c0e:	bf00      	nop
    3c10:	20000000 	.word	0x20000000

00003c14 <conn_auto_initiate>:
{
    3c14:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	if (conn->state != BT_CONN_CONNECTED) {
    3c16:	7a83      	ldrb	r3, [r0, #10]
{
    3c18:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
    3c1a:	2b07      	cmp	r3, #7
    3c1c:	d11e      	bne.n	3c5c <conn_auto_initiate+0x48>
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
    3c1e:	1d06      	adds	r6, r0, #4
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    3c20:	4630      	mov	r0, r6
    3c22:	f00f fbd5 	bl	133d0 <atomic_get>
    3c26:	0483      	lsls	r3, r0, #18
    3c28:	d41a      	bmi.n	3c60 <conn_auto_initiate+0x4c>
    3c2a:	78e3      	ldrb	r3, [r4, #3]
    3c2c:	b123      	cbz	r3, 3c38 <conn_auto_initiate+0x24>
	     BT_FEAT_LE_SLAVE_FEATURE_XCHG(bt_dev.le.features))) {
    3c2e:	4b25      	ldr	r3, [pc, #148]	; (3cc4 <conn_auto_initiate+0xb0>)
	    ((conn->role == BT_HCI_ROLE_MASTER) ||
    3c30:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
    3c34:	071d      	lsls	r5, r3, #28
    3c36:	d513      	bpl.n	3c60 <conn_auto_initiate+0x4c>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
    3c38:	2102      	movs	r1, #2
    3c3a:	f242 0016 	movw	r0, #8214	; 0x2016
    3c3e:	f7ff fdb9 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    3c42:	4605      	mov	r5, r0
    3c44:	b160      	cbz	r0, 3c60 <conn_auto_initiate+0x4c>
    3c46:	2102      	movs	r1, #2
    3c48:	3008      	adds	r0, #8
    3c4a:	f011 f8c7 	bl	14ddc <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
    3c4e:	8823      	ldrh	r3, [r4, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    3c50:	4629      	mov	r1, r5
	cp->handle = sys_cpu_to_le16(conn->handle);
    3c52:	8003      	strh	r3, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
    3c54:	f242 0016 	movw	r0, #8214	; 0x2016
    3c58:	f7ff ff78 	bl	3b4c <bt_hci_cmd_send>
}
    3c5c:	b004      	add	sp, #16
    3c5e:	bd70      	pop	{r4, r5, r6, pc}
    3c60:	4630      	mov	r0, r6
    3c62:	f00f fbb5 	bl	133d0 <atomic_get>
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
    3c66:	f410 5f80 	tst.w	r0, #4096	; 0x1000
    3c6a:	4d16      	ldr	r5, [pc, #88]	; (3cc4 <conn_auto_initiate+0xb0>)
    3c6c:	f3c0 3100 	ubfx	r1, r0, #12, #1
    3c70:	d10f      	bne.n	3c92 <conn_auto_initiate+0x7e>
	    !atomic_test_bit(conn->flags, BT_CONN_AUTO_PHY_COMPLETE) &&
    3c72:	f895 3099 	ldrb.w	r3, [r5, #153]	; 0x99
    3c76:	07d8      	lsls	r0, r3, #31
    3c78:	d50b      	bpl.n	3c92 <conn_auto_initiate+0x7e>
		err = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M,
    3c7a:	2302      	movs	r3, #2
    3c7c:	4620      	mov	r0, r4
    3c7e:	461a      	mov	r2, r3
    3c80:	9100      	str	r1, [sp, #0]
    3c82:	f00f fd22 	bl	136ca <bt_le_set_phy>
		if (!err) {
    3c86:	b920      	cbnz	r0, 3c92 <conn_auto_initiate+0x7e>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    3c88:	2180      	movs	r1, #128	; 0x80
    3c8a:	4630      	mov	r0, r6
    3c8c:	f00f fbda 	bl	13444 <atomic_or>
			return;
    3c90:	e7e4      	b.n	3c5c <conn_auto_initiate+0x48>
	if (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&
    3c92:	f895 3098 	ldrb.w	r3, [r5, #152]	; 0x98
    3c96:	069a      	lsls	r2, r3, #26
    3c98:	d5e0      	bpl.n	3c5c <conn_auto_initiate+0x48>
		if (IS_BT_QUIRK_NO_AUTO_DLE(&bt_dev)) {
    3c9a:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
    3c9e:	689b      	ldr	r3, [r3, #8]
    3ca0:	079b      	lsls	r3, r3, #30
    3ca2:	d5db      	bpl.n	3c5c <conn_auto_initiate+0x48>
			err = hci_le_read_max_data_len(&tx_octets, &tx_time);
    3ca4:	f10d 010e 	add.w	r1, sp, #14
    3ca8:	a803      	add	r0, sp, #12
    3caa:	f00f fc3d 	bl	13528 <hci_le_read_max_data_len>
			if (!err) {
    3cae:	2800      	cmp	r0, #0
    3cb0:	d1d4      	bne.n	3c5c <conn_auto_initiate+0x48>
				err = bt_le_set_data_len(conn,
    3cb2:	4620      	mov	r0, r4
    3cb4:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    3cb8:	f8bd 100c 	ldrh.w	r1, [sp, #12]
    3cbc:	f00f fce8 	bl	13690 <bt_le_set_data_len>
		}
    3cc0:	e7cc      	b.n	3c5c <conn_auto_initiate+0x48>
    3cc2:	bf00      	nop
    3cc4:	20000000 	.word	0x20000000

00003cc8 <hci_tx_thread>:
{
    3cc8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		events[0].state = K_POLL_STATE_NOT_READY;
    3ccc:	f8df 8104 	ldr.w	r8, [pc, #260]	; 3dd4 <hci_tx_thread+0x10c>
		BT_ASSERT(err == 0);
    3cd0:	f8df a114 	ldr.w	sl, [pc, #276]	; 3de8 <hci_tx_thread+0x120>
		events[0].state = K_POLL_STATE_NOT_READY;
    3cd4:	f8d8 300c 	ldr.w	r3, [r8, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    3cd8:	483d      	ldr	r0, [pc, #244]	; (3dd0 <hci_tx_thread+0x108>)
		events[0].state = K_POLL_STATE_NOT_READY;
    3cda:	f36f 3310 	bfc	r3, #12, #5
    3cde:	f8c8 300c 	str.w	r3, [r8, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    3ce2:	f001 f851 	bl	4d88 <bt_conn_prepare_events>
    3ce6:	1c45      	adds	r5, r0, #1
		parm0.val = timeout;
		return (int) arch_syscall_invoke4(*(uintptr_t *)&events, *(uintptr_t *)&num_events, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    3ce8:	f04f 32ff 	mov.w	r2, #4294967295
    3cec:	f04f 33ff 	mov.w	r3, #4294967295
    3cf0:	4629      	mov	r1, r5
    3cf2:	4838      	ldr	r0, [pc, #224]	; (3dd4 <hci_tx_thread+0x10c>)
    3cf4:	f00d fbf4 	bl	114e0 <z_impl_k_poll>
		BT_ASSERT(err == 0);
    3cf8:	b160      	cbz	r0, 3d14 <hci_tx_thread+0x4c>
    3cfa:	f241 4371 	movw	r3, #5233	; 0x1471
    3cfe:	4652      	mov	r2, sl
    3d00:	4935      	ldr	r1, [pc, #212]	; (3dd8 <hci_tx_thread+0x110>)
    3d02:	4836      	ldr	r0, [pc, #216]	; (3ddc <hci_tx_thread+0x114>)
    3d04:	f00d fe1c 	bl	11940 <printk>
    3d08:	4040      	eors	r0, r0
    3d0a:	f380 8811 	msr	BASEPRI, r0
    3d0e:	f04f 0003 	mov.w	r0, #3
    3d12:	df02      	svc	2
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    3d14:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 3dec <hci_tx_thread+0x124>
{
    3d18:	4e2e      	ldr	r6, [pc, #184]	; (3dd4 <hci_tx_thread+0x10c>)
	return z_impl_k_sem_take(sem, timeout);
    3d1a:	f5a9 778a 	sub.w	r7, r9, #276	; 0x114
    3d1e:	f1a9 0b34 	sub.w	fp, r9, #52	; 0x34
	for (; count; ev++, count--) {
    3d22:	b915      	cbnz	r5, 3d2a <hci_tx_thread+0x62>
	z_impl_k_yield();
    3d24:	f00c ffc0 	bl	10ca8 <z_impl_k_yield>
	while (1) {
    3d28:	e7d4      	b.n	3cd4 <hci_tx_thread+0xc>
		switch (ev->state) {
    3d2a:	68f3      	ldr	r3, [r6, #12]
    3d2c:	f3c3 3304 	ubfx	r3, r3, #12, #5
    3d30:	2b04      	cmp	r3, #4
    3d32:	d142      	bne.n	3dba <hci_tx_thread+0xf2>
			if (ev->tag == BT_EVENT_CMD_TX) {
    3d34:	7b33      	ldrb	r3, [r6, #12]
    3d36:	2b00      	cmp	r3, #0
    3d38:	d142      	bne.n	3dc0 <hci_tx_thread+0xf8>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    3d3a:	2200      	movs	r2, #0
    3d3c:	2300      	movs	r3, #0
    3d3e:	4648      	mov	r0, r9
    3d40:	f010 fffb 	bl	14d3a <net_buf_get>
	BT_ASSERT(buf);
    3d44:	4604      	mov	r4, r0
    3d46:	b960      	cbnz	r0, 3d62 <hci_tx_thread+0x9a>
    3d48:	f241 430e 	movw	r3, #5134	; 0x140e
    3d4c:	4652      	mov	r2, sl
    3d4e:	4924      	ldr	r1, [pc, #144]	; (3de0 <hci_tx_thread+0x118>)
    3d50:	4822      	ldr	r0, [pc, #136]	; (3ddc <hci_tx_thread+0x114>)
    3d52:	f00d fdf5 	bl	11940 <printk>
    3d56:	4040      	eors	r0, r0
    3d58:	f380 8811 	msr	BASEPRI, r0
    3d5c:	f04f 0003 	mov.w	r0, #3
    3d60:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
    3d62:	f04f 32ff 	mov.w	r2, #4294967295
    3d66:	f04f 33ff 	mov.w	r3, #4294967295
    3d6a:	4658      	mov	r0, fp
    3d6c:	f00d f838 	bl	10de0 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    3d70:	f8d7 00f8 	ldr.w	r0, [r7, #248]	; 0xf8
    3d74:	b120      	cbz	r0, 3d80 <hci_tx_thread+0xb8>
		net_buf_unref(bt_dev.sent_cmd);
    3d76:	f002 fdeb 	bl	6950 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    3d7a:	2300      	movs	r3, #0
    3d7c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
	bt_dev.sent_cmd = net_buf_ref(buf);
    3d80:	4620      	mov	r0, r4
    3d82:	f011 f805 	bl	14d90 <net_buf_ref>
    3d86:	f8c7 00f8 	str.w	r0, [r7, #248]	; 0xf8
	err = bt_send(buf);
    3d8a:	4620      	mov	r0, r4
    3d8c:	f7ff fed6 	bl	3b3c <bt_send>
	if (err) {
    3d90:	b198      	cbz	r0, 3dba <hci_tx_thread+0xf2>
	z_impl_k_sem_give(sem);
    3d92:	4814      	ldr	r0, [pc, #80]	; (3de4 <hci_tx_thread+0x11c>)
    3d94:	f00c fffe 	bl	10d94 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
    3d98:	4620      	mov	r0, r4
    3d9a:	f002 fd25 	bl	67e8 <net_buf_id>
    3d9e:	4621      	mov	r1, r4
    3da0:	201f      	movs	r0, #31
    3da2:	f7ff fc4b 	bl	363c <hci_cmd_done.isra.0>
		net_buf_unref(bt_dev.sent_cmd);
    3da6:	f8d7 00f8 	ldr.w	r0, [r7, #248]	; 0xf8
    3daa:	f002 fdd1 	bl	6950 <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    3dae:	2300      	movs	r3, #0
		net_buf_unref(buf);
    3db0:	4620      	mov	r0, r4
		bt_dev.sent_cmd = NULL;
    3db2:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
		net_buf_unref(buf);
    3db6:	f002 fdcb 	bl	6950 <net_buf_unref>
	for (; count; ev++, count--) {
    3dba:	3614      	adds	r6, #20
    3dbc:	3d01      	subs	r5, #1
    3dbe:	e7b0      	b.n	3d22 <hci_tx_thread+0x5a>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
    3dc0:	2b01      	cmp	r3, #1
    3dc2:	d1fa      	bne.n	3dba <hci_tx_thread+0xf2>
					conn = CONTAINER_OF(ev->fifo,
    3dc4:	6930      	ldr	r0, [r6, #16]
					bt_conn_process_tx(conn);
    3dc6:	3834      	subs	r0, #52	; 0x34
    3dc8:	f001 f9fe 	bl	51c8 <bt_conn_process_tx>
    3dcc:	e7f5      	b.n	3dba <hci_tx_thread+0xf2>
    3dce:	bf00      	nop
    3dd0:	20000318 	.word	0x20000318
    3dd4:	20000304 	.word	0x20000304
    3dd8:	00043e6c 	.word	0x00043e6c
    3ddc:	00043e21 	.word	0x00043e21
    3de0:	00043e95 	.word	0x00043e95
    3de4:	200000e0 	.word	0x200000e0
    3de8:	00043dd4 	.word	0x00043dd4
    3dec:	20000114 	.word	0x20000114

00003df0 <hci_event_prio>:
{
    3df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3df4:	4604      	mov	r4, r0
	net_buf_simple_save(&buf->b, &state);
    3df6:	f100 0608 	add.w	r6, r0, #8
	state->offset = net_buf_simple_headroom(buf);
    3dfa:	4630      	mov	r0, r6
    3dfc:	f011 f82f 	bl	14e5e <net_buf_simple_headroom>
	state->len = buf->len;
    3e00:	f8b4 800c 	ldrh.w	r8, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    3e04:	4605      	mov	r5, r0
	BT_ASSERT(buf->len >= sizeof(*hdr));
    3e06:	f1b8 0f01 	cmp.w	r8, #1
    3e0a:	d80c      	bhi.n	3e26 <hci_event_prio+0x36>
    3e0c:	f641 03ae 	movw	r3, #6318	; 0x18ae
    3e10:	4a1b      	ldr	r2, [pc, #108]	; (3e80 <hci_event_prio+0x90>)
    3e12:	491c      	ldr	r1, [pc, #112]	; (3e84 <hci_event_prio+0x94>)
    3e14:	481c      	ldr	r0, [pc, #112]	; (3e88 <hci_event_prio+0x98>)
    3e16:	f00d fd93 	bl	11940 <printk>
    3e1a:	4040      	eors	r0, r0
    3e1c:	f380 8811 	msr	BASEPRI, r0
    3e20:	f04f 0003 	mov.w	r0, #3
    3e24:	df02      	svc	2
	return net_buf_simple_pull_mem(&buf->b, len);
    3e26:	2102      	movs	r1, #2
    3e28:	4630      	mov	r0, r6
    3e2a:	f011 f808 	bl	14e3e <net_buf_simple_pull_mem>
    3e2e:	4607      	mov	r7, r0
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    3e30:	7800      	ldrb	r0, [r0, #0]
    3e32:	f00f fa97 	bl	13364 <bt_hci_evt_get_flags>
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    3e36:	07c2      	lsls	r2, r0, #31
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    3e38:	4606      	mov	r6, r0
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    3e3a:	d40c      	bmi.n	3e56 <hci_event_prio+0x66>
    3e3c:	f641 03b2 	movw	r3, #6322	; 0x18b2
    3e40:	4a0f      	ldr	r2, [pc, #60]	; (3e80 <hci_event_prio+0x90>)
    3e42:	4912      	ldr	r1, [pc, #72]	; (3e8c <hci_event_prio+0x9c>)
    3e44:	4810      	ldr	r0, [pc, #64]	; (3e88 <hci_event_prio+0x98>)
    3e46:	f00d fd7b 	bl	11940 <printk>
    3e4a:	4040      	eors	r0, r0
    3e4c:	f380 8811 	msr	BASEPRI, r0
    3e50:	f04f 0003 	mov.w	r0, #3
    3e54:	df02      	svc	2
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    3e56:	2305      	movs	r3, #5
    3e58:	4621      	mov	r1, r4
    3e5a:	4a0d      	ldr	r2, [pc, #52]	; (3e90 <hci_event_prio+0xa0>)
    3e5c:	7838      	ldrb	r0, [r7, #0]
    3e5e:	f00f fa93 	bl	13388 <handle_event>
	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    3e62:	07b3      	lsls	r3, r6, #30
    3e64:	d507      	bpl.n	3e76 <hci_event_prio+0x86>
	buf->data = buf->__buf + state->offset;
    3e66:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    3e68:	f8a4 800c 	strh.w	r8, [r4, #12]
	buf->data = buf->__buf + state->offset;
    3e6c:	fa10 f585 	uxtah	r5, r0, r5
    3e70:	60a5      	str	r5, [r4, #8]
}
    3e72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_buf_unref(buf);
    3e76:	4620      	mov	r0, r4
}
    3e78:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		net_buf_unref(buf);
    3e7c:	f002 bd68 	b.w	6950 <net_buf_unref>
    3e80:	00043dd4 	.word	0x00043dd4
    3e84:	00043e08 	.word	0x00043e08
    3e88:	00043e21 	.word	0x00043e21
    3e8c:	00043e99 	.word	0x00043e99
    3e90:	0001ed94 	.word	0x0001ed94

00003e94 <bt_recv>:
{
    3e94:	b538      	push	{r3, r4, r5, lr}
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
    3e96:	7d03      	ldrb	r3, [r0, #20]
    3e98:	4605      	mov	r5, r0
	switch (bt_buf_get_type(buf)) {
    3e9a:	2b01      	cmp	r3, #1
    3e9c:	d007      	beq.n	3eae <bt_recv+0x1a>
    3e9e:	2b03      	cmp	r3, #3
    3ea0:	d113      	bne.n	3eca <bt_recv+0x36>
			net_buf_put(&bt_dev.rx_queue, buf);
    3ea2:	480c      	ldr	r0, [pc, #48]	; (3ed4 <bt_recv+0x40>)
    3ea4:	4629      	mov	r1, r5
    3ea6:	f010 ff66 	bl	14d76 <net_buf_put>
		return 0;
    3eaa:	2000      	movs	r0, #0
    3eac:	e00c      	b.n	3ec8 <bt_recv+0x34>
		uint8_t evt_flags = bt_hci_evt_get_flags(hdr->evt);
    3eae:	6883      	ldr	r3, [r0, #8]
    3eb0:	7818      	ldrb	r0, [r3, #0]
    3eb2:	f00f fa57 	bl	13364 <bt_hci_evt_get_flags>
		if (evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO) {
    3eb6:	07c3      	lsls	r3, r0, #31
		uint8_t evt_flags = bt_hci_evt_get_flags(hdr->evt);
    3eb8:	4604      	mov	r4, r0
		if (evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO) {
    3eba:	d502      	bpl.n	3ec2 <bt_recv+0x2e>
			hci_event_prio(buf);
    3ebc:	4628      	mov	r0, r5
    3ebe:	f7ff ff97 	bl	3df0 <hci_event_prio>
		if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    3ec2:	f014 0002 	ands.w	r0, r4, #2
    3ec6:	d1ec      	bne.n	3ea2 <bt_recv+0xe>
}
    3ec8:	bd38      	pop	{r3, r4, r5, pc}
		net_buf_unref(buf);
    3eca:	f002 fd41 	bl	6950 <net_buf_unref>
		return -EINVAL;
    3ece:	f06f 0015 	mvn.w	r0, #21
    3ed2:	e7f9      	b.n	3ec8 <bt_recv+0x34>
    3ed4:	200000fc 	.word	0x200000fc

00003ed8 <bt_hci_driver_register>:
	if (bt_dev.drv) {
    3ed8:	4a08      	ldr	r2, [pc, #32]	; (3efc <bt_hci_driver_register+0x24>)
{
    3eda:	4603      	mov	r3, r0
	if (bt_dev.drv) {
    3edc:	f8d2 012c 	ldr.w	r0, [r2, #300]	; 0x12c
    3ee0:	b930      	cbnz	r0, 3ef0 <bt_hci_driver_register+0x18>
	if (!drv->open || !drv->send) {
    3ee2:	68d9      	ldr	r1, [r3, #12]
    3ee4:	b139      	cbz	r1, 3ef6 <bt_hci_driver_register+0x1e>
    3ee6:	6919      	ldr	r1, [r3, #16]
    3ee8:	b129      	cbz	r1, 3ef6 <bt_hci_driver_register+0x1e>
	bt_dev.drv = drv;
    3eea:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
	return 0;
    3eee:	4770      	bx	lr
		return -EALREADY;
    3ef0:	f06f 0077 	mvn.w	r0, #119	; 0x77
    3ef4:	4770      	bx	lr
		return -EINVAL;
    3ef6:	f06f 0015 	mvn.w	r0, #21
}
    3efa:	4770      	bx	lr
    3efc:	20000000 	.word	0x20000000

00003f00 <bt_finalize_init>:
    3f00:	2102      	movs	r1, #2
    3f02:	4801      	ldr	r0, [pc, #4]	; (3f08 <bt_finalize_init+0x8>)
    3f04:	f00f ba9e 	b.w	13444 <atomic_or>
    3f08:	20000094 	.word	0x20000094

00003f0c <bt_get_name>:
}
    3f0c:	4800      	ldr	r0, [pc, #0]	; (3f10 <bt_get_name+0x4>)
    3f0e:	4770      	bx	lr
    3f10:	0001f5ba 	.word	0x0001f5ba

00003f14 <bt_id_create>:
{
    3f14:	b537      	push	{r0, r1, r2, r4, r5, lr}
    3f16:	460c      	mov	r4, r1
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    3f18:	4605      	mov	r5, r0
    3f1a:	b918      	cbnz	r0, 3f24 <bt_id_create+0x10>
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
    3f1c:	b1ec      	cbz	r4, 3f5a <bt_id_create+0x46>
		return -EINVAL;
    3f1e:	f06f 0415 	mvn.w	r4, #21
    3f22:	e017      	b.n	3f54 <bt_id_create+0x40>
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    3f24:	2300      	movs	r3, #0
    3f26:	4669      	mov	r1, sp
    3f28:	9300      	str	r3, [sp, #0]
    3f2a:	f8cd 3003 	str.w	r3, [sp, #3]
    3f2e:	f00f fa52 	bl	133d6 <bt_addr_le_cmp>
    3f32:	2800      	cmp	r0, #0
    3f34:	d0f2      	beq.n	3f1c <bt_id_create+0x8>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    3f36:	782b      	ldrb	r3, [r5, #0]
    3f38:	2b01      	cmp	r3, #1
    3f3a:	d1f0      	bne.n	3f1e <bt_id_create+0xa>
    3f3c:	79ab      	ldrb	r3, [r5, #6]
    3f3e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    3f42:	2bc0      	cmp	r3, #192	; 0xc0
    3f44:	d1eb      	bne.n	3f1e <bt_id_create+0xa>
		if (id_find(addr) >= 0) {
    3f46:	4628      	mov	r0, r5
    3f48:	f7ff f9d4 	bl	32f4 <id_find>
    3f4c:	2800      	cmp	r0, #0
    3f4e:	dbe5      	blt.n	3f1c <bt_id_create+0x8>
			return -EALREADY;
    3f50:	f06f 0477 	mvn.w	r4, #119	; 0x77
}
    3f54:	4620      	mov	r0, r4
    3f56:	b003      	add	sp, #12
    3f58:	bd30      	pop	{r4, r5, pc}
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    3f5a:	4b07      	ldr	r3, [pc, #28]	; (3f78 <bt_id_create+0x64>)
    3f5c:	79dc      	ldrb	r4, [r3, #7]
    3f5e:	2c01      	cmp	r4, #1
    3f60:	d006      	beq.n	3f70 <bt_id_create+0x5c>
	new_id = bt_dev.id_count++;
    3f62:	1c62      	adds	r2, r4, #1
	id_create(new_id, addr, irk);
    3f64:	4629      	mov	r1, r5
    3f66:	4620      	mov	r0, r4
	new_id = bt_dev.id_count++;
    3f68:	71da      	strb	r2, [r3, #7]
	id_create(new_id, addr, irk);
    3f6a:	f7ff fa4d 	bl	3408 <id_create.isra.0>
	return new_id;
    3f6e:	e7f1      	b.n	3f54 <bt_id_create+0x40>
		return -ENOMEM;
    3f70:	f06f 040b 	mvn.w	r4, #11
    3f74:	e7ee      	b.n	3f54 <bt_id_create+0x40>
    3f76:	bf00      	nop
    3f78:	20000000 	.word	0x20000000

00003f7c <bt_setup_public_id_addr>:
{
    3f7c:	b570      	push	{r4, r5, r6, lr}
    3f7e:	b086      	sub	sp, #24
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    3f80:	2100      	movs	r1, #0
    3f82:	f241 0009 	movw	r0, #4105	; 0x1009
    3f86:	aa01      	add	r2, sp, #4
    3f88:	f7ff fc4c 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    3f8c:	4e1a      	ldr	r6, [pc, #104]	; (3ff8 <bt_setup_public_id_addr+0x7c>)
    3f8e:	4604      	mov	r4, r0
    3f90:	b118      	cbz	r0, 3f9a <bt_setup_public_id_addr+0x1e>
	bt_dev.id_count = bt_read_public_addr(&addr);
    3f92:	2300      	movs	r3, #0
    3f94:	71f3      	strb	r3, [r6, #7]
}
    3f96:	b006      	add	sp, #24
    3f98:	bd70      	pop	{r4, r5, r6, pc}
	rp = (void *)rsp->data;
    3f9a:	9b01      	ldr	r3, [sp, #4]
    3f9c:	2206      	movs	r2, #6
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    3f9e:	689d      	ldr	r5, [r3, #8]
    3fa0:	a904      	add	r1, sp, #16
    3fa2:	3501      	adds	r5, #1
    3fa4:	9004      	str	r0, [sp, #16]
    3fa6:	f8ad 0014 	strh.w	r0, [sp, #20]
    3faa:	4628      	mov	r0, r5
    3fac:	f019 fccb 	bl	1d946 <memcmp>
    3fb0:	b918      	cbnz	r0, 3fba <bt_setup_public_id_addr+0x3e>
		net_buf_unref(rsp);
    3fb2:	9801      	ldr	r0, [sp, #4]
    3fb4:	f002 fccc 	bl	6950 <net_buf_unref>
    3fb8:	e7eb      	b.n	3f92 <bt_setup_public_id_addr+0x16>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    3fba:	4b10      	ldr	r3, [pc, #64]	; (3ffc <bt_setup_public_id_addr+0x80>)
    3fbc:	2206      	movs	r2, #6
    3fbe:	6818      	ldr	r0, [r3, #0]
    3fc0:	889b      	ldrh	r3, [r3, #4]
    3fc2:	9002      	str	r0, [sp, #8]
    3fc4:	a902      	add	r1, sp, #8
    3fc6:	4628      	mov	r0, r5
    3fc8:	f8ad 300c 	strh.w	r3, [sp, #12]
    3fcc:	f019 fcbb 	bl	1d946 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    3fd0:	2800      	cmp	r0, #0
    3fd2:	d0ee      	beq.n	3fb2 <bt_setup_public_id_addr+0x36>
	bt_addr_copy(&addr->a, &rp->bdaddr);
    3fd4:	4629      	mov	r1, r5
    3fd6:	f10d 0011 	add.w	r0, sp, #17
    3fda:	f00f fa98 	bl	1350e <bt_addr_copy>
	net_buf_unref(rsp);
    3fde:	9801      	ldr	r0, [sp, #4]
	addr->type = BT_ADDR_LE_PUBLIC;
    3fe0:	f88d 4010 	strb.w	r4, [sp, #16]
	net_buf_unref(rsp);
    3fe4:	f002 fcb4 	bl	6950 <net_buf_unref>
	bt_dev.id_count = bt_read_public_addr(&addr);
    3fe8:	2301      	movs	r3, #1
	id_create(BT_ID_DEFAULT, &addr, irk);
    3fea:	4620      	mov	r0, r4
    3fec:	a904      	add	r1, sp, #16
	bt_dev.id_count = bt_read_public_addr(&addr);
    3fee:	71f3      	strb	r3, [r6, #7]
	id_create(BT_ID_DEFAULT, &addr, irk);
    3ff0:	f7ff fa0a 	bl	3408 <id_create.isra.0>
    3ff4:	e7cf      	b.n	3f96 <bt_setup_public_id_addr+0x1a>
    3ff6:	bf00      	nop
    3ff8:	20000000 	.word	0x20000000
    3ffc:	0001dd87 	.word	0x0001dd87

00004000 <bt_read_static_addr>:
{
    4000:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    4002:	4b18      	ldr	r3, [pc, #96]	; (4064 <CONFIG_FPROTECT_BLOCK_SIZE+0x64>)
{
    4004:	4605      	mov	r5, r0
    4006:	f893 4086 	ldrb.w	r4, [r3, #134]	; 0x86
    400a:	460e      	mov	r6, r1
	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    400c:	f014 0401 	ands.w	r4, r4, #1
    4010:	d015      	beq.n	403e <bt_read_static_addr+0x3e>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    4012:	2100      	movs	r1, #0
    4014:	f64f 4009 	movw	r0, #64521	; 0xfc09
    4018:	aa01      	add	r2, sp, #4
    401a:	f7ff fc03 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    401e:	4603      	mov	r3, r0
    4020:	b9e8      	cbnz	r0, 405e <bt_read_static_addr+0x5e>
	rp = (void *)rsp->data;
    4022:	9801      	ldr	r0, [sp, #4]
    4024:	f04f 0c16 	mov.w	ip, #22
    4028:	6882      	ldr	r2, [r0, #8]
	cnt = MIN(rp->num_addrs, size);
    402a:	7854      	ldrb	r4, [r2, #1]
    402c:	eb02 070c 	add.w	r7, r2, ip
    4030:	42b4      	cmp	r4, r6
    4032:	bf28      	it	cs
    4034:	4634      	movcs	r4, r6
	for (i = 0; i < cnt; i++) {
    4036:	42a3      	cmp	r3, r4
    4038:	db04      	blt.n	4044 <bt_read_static_addr+0x44>
	net_buf_unref(rsp);
    403a:	f002 fc89 	bl	6950 <net_buf_unref>
}
    403e:	4620      	mov	r0, r4
    4040:	b003      	add	sp, #12
    4042:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4044:	fb0c 5103 	mla	r1, ip, r3, r5
    4048:	1c96      	adds	r6, r2, #2
    404a:	f856 eb04 	ldr.w	lr, [r6], #4
    404e:	42be      	cmp	r6, r7
    4050:	f841 eb04 	str.w	lr, [r1], #4
    4054:	d1f9      	bne.n	404a <bt_read_static_addr+0x4a>
    4056:	883e      	ldrh	r6, [r7, #0]
	for (i = 0; i < cnt; i++) {
    4058:	3301      	adds	r3, #1
    405a:	800e      	strh	r6, [r1, #0]
    405c:	e7eb      	b.n	4036 <bt_read_static_addr+0x36>
		return 0;
    405e:	2400      	movs	r4, #0
    4060:	e7ed      	b.n	403e <bt_read_static_addr+0x3e>
    4062:	bf00      	nop
    4064:	20000000 	.word	0x20000000

00004068 <bt_setup_random_id_addr>:
{
    4068:	b570      	push	{r4, r5, r6, lr}
	if (!bt_dev.id_count) {
    406a:	4d13      	ldr	r5, [pc, #76]	; (40b8 <bt_setup_random_id_addr+0x50>)
{
    406c:	b088      	sub	sp, #32
	if (!bt_dev.id_count) {
    406e:	79ec      	ldrb	r4, [r5, #7]
    4070:	b9ec      	cbnz	r4, 40ae <bt_setup_random_id_addr+0x46>
		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
    4072:	2101      	movs	r1, #1
    4074:	a802      	add	r0, sp, #8
    4076:	f7ff ffc3 	bl	4000 <bt_read_static_addr>
    407a:	71e8      	strb	r0, [r5, #7]
		if (bt_dev.id_count) {
    407c:	b1b8      	cbz	r0, 40ae <bt_setup_random_id_addr+0x46>
				bt_addr_copy(&addr.a, &addrs[i].bdaddr);
    407e:	2616      	movs	r6, #22
    4080:	e00e      	b.n	40a0 <bt_setup_random_id_addr+0x38>
    4082:	ab02      	add	r3, sp, #8
    4084:	fb06 3102 	mla	r1, r6, r2, r3
    4088:	f10d 0001 	add.w	r0, sp, #1
    408c:	f00f fa3f 	bl	1350e <bt_addr_copy>
				addr.type = BT_ADDR_LE_RANDOM;
    4090:	2301      	movs	r3, #1
				id_create(i, &addr, irk);
    4092:	4669      	mov	r1, sp
    4094:	4610      	mov	r0, r2
				addr.type = BT_ADDR_LE_RANDOM;
    4096:	f88d 3000 	strb.w	r3, [sp]
				id_create(i, &addr, irk);
    409a:	f7ff f9b5 	bl	3408 <id_create.isra.0>
			for (uint8_t i = 0; i < bt_dev.id_count; i++) {
    409e:	3401      	adds	r4, #1
    40a0:	79eb      	ldrb	r3, [r5, #7]
    40a2:	b2e2      	uxtb	r2, r4
    40a4:	4293      	cmp	r3, r2
    40a6:	d8ec      	bhi.n	4082 <bt_setup_random_id_addr+0x1a>
			return 0;
    40a8:	2000      	movs	r0, #0
}
    40aa:	b008      	add	sp, #32
    40ac:	bd70      	pop	{r4, r5, r6, pc}
	return bt_id_create(NULL, NULL);
    40ae:	2100      	movs	r1, #0
    40b0:	4608      	mov	r0, r1
    40b2:	f7ff ff2f 	bl	3f14 <bt_id_create>
    40b6:	e7f8      	b.n	40aa <bt_setup_random_id_addr+0x42>
    40b8:	20000000 	.word	0x20000000

000040bc <hci_init>:
{
    40bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    40be:	4d5c      	ldr	r5, [pc, #368]	; (4230 <hci_init+0x174>)
    40c0:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
    40c4:	6899      	ldr	r1, [r3, #8]
    40c6:	f011 0101 	ands.w	r1, r1, #1
    40ca:	d11c      	bne.n	4106 <hci_init+0x4a>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    40cc:	f640 4003 	movw	r0, #3075	; 0xc03
    40d0:	aa01      	add	r2, sp, #4
    40d2:	f7ff fba7 	bl	3824 <bt_hci_cmd_send_sync>
		if (err) {
    40d6:	4604      	mov	r4, r0
    40d8:	2800      	cmp	r0, #0
    40da:	f040 80a6 	bne.w	422a <hci_init+0x16e>
		hci_reset_complete(rsp);
    40de:	9b01      	ldr	r3, [sp, #4]
	uint8_t status = buf->data[0];
    40e0:	689b      	ldr	r3, [r3, #8]
	if (status) {
    40e2:	781b      	ldrb	r3, [r3, #0]
    40e4:	b963      	cbnz	r3, 4100 <hci_init+0x44>
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    40e6:	f105 0394 	add.w	r3, r5, #148	; 0x94
    40ea:	4618      	mov	r0, r3
    40ec:	f00f f970 	bl	133d0 <atomic_get>
    40f0:	f000 0005 	and.w	r0, r0, #5
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    40f4:	e8d3 2fef 	ldaex	r2, [r3]
    40f8:	e8c3 0fe1 	stlex	r1, r0, [r3]
    40fc:	2900      	cmp	r1, #0
    40fe:	d1f9      	bne.n	40f4 <hci_init+0x38>
		net_buf_unref(rsp);
    4100:	9801      	ldr	r0, [sp, #4]
    4102:	f002 fc25 	bl	6950 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    4106:	2100      	movs	r1, #0
    4108:	f241 0003 	movw	r0, #4099	; 0x1003
    410c:	aa01      	add	r2, sp, #4
    410e:	f7ff fb89 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    4112:	4604      	mov	r4, r0
    4114:	2800      	cmp	r0, #0
    4116:	f040 8088 	bne.w	422a <hci_init+0x16e>
	read_local_features_complete(rsp);
    411a:	9a01      	ldr	r2, [sp, #4]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    411c:	4e45      	ldr	r6, [pc, #276]	; (4234 <hci_init+0x178>)
    411e:	6893      	ldr	r3, [r2, #8]
    4120:	f853 0f01 	ldr.w	r0, [r3, #1]!
    4124:	6859      	ldr	r1, [r3, #4]
    4126:	c603      	stmia	r6!, {r0, r1}
	net_buf_unref(rsp);
    4128:	4610      	mov	r0, r2
    412a:	f002 fc11 	bl	6950 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    412e:	4621      	mov	r1, r4
    4130:	f241 0001 	movw	r0, #4097	; 0x1001
    4134:	aa01      	add	r2, sp, #4
    4136:	f7ff fb75 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    413a:	4604      	mov	r4, r0
    413c:	2800      	cmp	r0, #0
    413e:	d174      	bne.n	422a <hci_init+0x16e>
	read_local_ver_complete(rsp);
    4140:	9801      	ldr	r0, [sp, #4]
    4142:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
    4144:	785a      	ldrb	r2, [r3, #1]
    4146:	f885 2034 	strb.w	r2, [r5, #52]	; 0x34
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    414a:	78d9      	ldrb	r1, [r3, #3]
    414c:	789a      	ldrb	r2, [r3, #2]
    414e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    4152:	86ea      	strh	r2, [r5, #54]	; 0x36
	bt_dev.lmp_version = rp->lmp_version;
    4154:	791a      	ldrb	r2, [r3, #4]
    4156:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    415a:	7a19      	ldrb	r1, [r3, #8]
    415c:	79da      	ldrb	r2, [r3, #7]
    415e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    4162:	872a      	strh	r2, [r5, #56]	; 0x38
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    4164:	795a      	ldrb	r2, [r3, #5]
    4166:	799b      	ldrb	r3, [r3, #6]
    4168:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    416c:	876b      	strh	r3, [r5, #58]	; 0x3a
	net_buf_unref(rsp);
    416e:	f002 fbef 	bl	6950 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    4172:	4621      	mov	r1, r4
    4174:	f241 0002 	movw	r0, #4098	; 0x1002
    4178:	aa01      	add	r2, sp, #4
    417a:	f7ff fb53 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    417e:	4604      	mov	r4, r0
    4180:	2800      	cmp	r0, #0
    4182:	d152      	bne.n	422a <hci_init+0x16e>
	read_supported_commands_complete(rsp);
    4184:	9f01      	ldr	r7, [sp, #4]
    4186:	68ba      	ldr	r2, [r7, #8]
	memcpy(bt_dev.supported_commands, rp->commands,
    4188:	1c53      	adds	r3, r2, #1
    418a:	3241      	adds	r2, #65	; 0x41
    418c:	4634      	mov	r4, r6
    418e:	6818      	ldr	r0, [r3, #0]
    4190:	6859      	ldr	r1, [r3, #4]
    4192:	3308      	adds	r3, #8
    4194:	c403      	stmia	r4!, {r0, r1}
    4196:	4293      	cmp	r3, r2
    4198:	4626      	mov	r6, r4
    419a:	d1f7      	bne.n	418c <hci_init+0xd0>
	net_buf_unref(rsp);
    419c:	4638      	mov	r0, r7
    419e:	f002 fbd7 	bl	6950 <net_buf_unref>
		err = prng_init();
    41a2:	f000 fc45 	bl	4a30 <prng_init>
		if (err) {
    41a6:	4604      	mov	r4, r0
    41a8:	2800      	cmp	r0, #0
    41aa:	d13e      	bne.n	422a <hci_init+0x16e>
	if (!BT_CMD_TEST(bt_dev.supported_commands, 10, 5)) {
    41ac:	f895 304e 	ldrb.w	r3, [r5, #78]	; 0x4e
    41b0:	069f      	lsls	r7, r3, #26
    41b2:	d406      	bmi.n	41c2 <hci_init+0x106>
	if (!BT_FEAT_LE(bt_dev.features)) {
    41b4:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    41b8:	065e      	lsls	r6, r3, #25
    41ba:	d43d      	bmi.n	4238 <hci_init+0x17c>
		return -ENODEV;
    41bc:	f06f 0412 	mvn.w	r4, #18
    41c0:	e033      	b.n	422a <hci_init+0x16e>
	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE,
    41c2:	2107      	movs	r1, #7
    41c4:	f640 4033 	movw	r0, #3123	; 0xc33
    41c8:	f7ff faf4 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    41cc:	4606      	mov	r6, r0
    41ce:	b910      	cbnz	r0, 41d6 <hci_init+0x11a>
		return -ENOBUFS;
    41d0:	f06f 0468 	mvn.w	r4, #104	; 0x68
    41d4:	e029      	b.n	422a <hci_init+0x16e>
	return net_buf_simple_add(&buf->b, len);
    41d6:	2107      	movs	r1, #7
    41d8:	3008      	adds	r0, #8
    41da:	f010 fdff 	bl	14ddc <net_buf_simple_add>
	hbs->acl_mtu = sys_cpu_to_le16(CONFIG_BT_L2CAP_RX_MTU +
    41de:	231b      	movs	r3, #27
    41e0:	7003      	strb	r3, [r0, #0]
	hbs->acl_pkts = sys_cpu_to_le16(CONFIG_BT_ACL_RX_COUNT);
    41e2:	2306      	movs	r3, #6
__ssp_bos_icheck3(memset, void *, int)
    41e4:	f8c0 4002 	str.w	r4, [r0, #2]
    41e8:	7184      	strb	r4, [r0, #6]
	hbs->acl_mtu = sys_cpu_to_le16(CONFIG_BT_L2CAP_RX_MTU +
    41ea:	7044      	strb	r4, [r0, #1]
	hbs->acl_pkts = sys_cpu_to_le16(CONFIG_BT_ACL_RX_COUNT);
    41ec:	7104      	strb	r4, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
    41ee:	4622      	mov	r2, r4
	hbs->acl_pkts = sys_cpu_to_le16(CONFIG_BT_ACL_RX_COUNT);
    41f0:	70c3      	strb	r3, [r0, #3]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
    41f2:	4631      	mov	r1, r6
    41f4:	f640 4033 	movw	r0, #3123	; 0xc33
    41f8:	f7ff fb14 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    41fc:	4604      	mov	r4, r0
    41fe:	b9a0      	cbnz	r0, 422a <hci_init+0x16e>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, 1);
    4200:	2101      	movs	r1, #1
    4202:	f640 4031 	movw	r0, #3121	; 0xc31
    4206:	f7ff fad5 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    420a:	4606      	mov	r6, r0
    420c:	2800      	cmp	r0, #0
    420e:	d0df      	beq.n	41d0 <hci_init+0x114>
	return net_buf_simple_add_u8(&buf->b, val);
    4210:	2101      	movs	r1, #1
    4212:	3008      	adds	r0, #8
    4214:	f010 fdf2 	bl	14dfc <net_buf_simple_add_u8>
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, buf, NULL);
    4218:	4622      	mov	r2, r4
    421a:	4631      	mov	r1, r6
    421c:	f640 4031 	movw	r0, #3121	; 0xc31
    4220:	f7ff fb00 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    4224:	4604      	mov	r4, r0
    4226:	2800      	cmp	r0, #0
    4228:	d0c4      	beq.n	41b4 <hci_init+0xf8>
}
    422a:	4620      	mov	r0, r4
    422c:	b003      	add	sp, #12
    422e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4230:	20000000 	.word	0x20000000
    4234:	2000003c 	.word	0x2000003c
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    4238:	2100      	movs	r1, #0
    423a:	f242 0003 	movw	r0, #8195	; 0x2003
    423e:	aa01      	add	r2, sp, #4
    4240:	f7ff faf0 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    4244:	4604      	mov	r4, r0
    4246:	2800      	cmp	r0, #0
    4248:	d1ef      	bne.n	422a <hci_init+0x16e>
	read_le_features_complete(rsp);
    424a:	9a01      	ldr	r2, [sp, #4]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    424c:	4e9d      	ldr	r6, [pc, #628]	; (44c4 <hci_init+0x408>)
    424e:	6893      	ldr	r3, [r2, #8]
    4250:	f853 0f01 	ldr.w	r0, [r3, #1]!
    4254:	6859      	ldr	r1, [r3, #4]
    4256:	c603      	stmia	r6!, {r0, r1}
	net_buf_unref(rsp);
    4258:	4610      	mov	r0, r2
    425a:	f002 fb79 	bl	6950 <net_buf_unref>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
    425e:	4621      	mov	r1, r4
    4260:	f242 0002 	movw	r0, #8194	; 0x2002
    4264:	aa01      	add	r2, sp, #4
    4266:	f7ff fadd 	bl	3824 <bt_hci_cmd_send_sync>
		if (err) {
    426a:	4604      	mov	r4, r0
    426c:	2800      	cmp	r0, #0
    426e:	d1dc      	bne.n	422a <hci_init+0x16e>
		le_read_buffer_size_complete(rsp);
    4270:	9b01      	ldr	r3, [sp, #4]
    4272:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->le_max_len);
    4274:	f8b3 2001 	ldrh.w	r2, [r3, #1]
    4278:	b291      	uxth	r1, r2
    427a:	f8a5 20c4 	strh.w	r2, [r5, #196]	; 0xc4
	if (!bt_dev.le.acl_mtu) {
    427e:	b129      	cbz	r1, 428c <hci_init+0x1d0>
	k_sem_init(&bt_dev.le.acl_pkts, rp->le_max_num, rp->le_max_num);
    4280:	78da      	ldrb	r2, [r3, #3]
	return z_impl_k_sem_init(sem, initial_count, limit);
    4282:	4611      	mov	r1, r2
    4284:	f106 0028 	add.w	r0, r6, #40	; 0x28
    4288:	f019 f8be 	bl	1d408 <z_impl_k_sem_init>
		net_buf_unref(rsp);
    428c:	9801      	ldr	r0, [sp, #4]
    428e:	f002 fb5f 	bl	6950 <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    4292:	f895 6040 	ldrb.w	r6, [r5, #64]	; 0x40
    4296:	f016 0620 	ands.w	r6, r6, #32
    429a:	f000 80f8 	beq.w	448e <hci_init+0x3d2>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    429e:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
    42a2:	071c      	lsls	r4, r3, #28
    42a4:	d511      	bpl.n	42ca <hci_init+0x20e>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    42a6:	2100      	movs	r1, #0
    42a8:	f242 001c 	movw	r0, #8220	; 0x201c
    42ac:	aa01      	add	r2, sp, #4
    42ae:	f7ff fab9 	bl	3824 <bt_hci_cmd_send_sync>
		if (err) {
    42b2:	4604      	mov	r4, r0
    42b4:	2800      	cmp	r0, #0
    42b6:	d1b8      	bne.n	422a <hci_init+0x16e>
		le_read_supp_states_complete(rsp);
    42b8:	9801      	ldr	r0, [sp, #4]
 *
 *  @return 64-bit integer in host endianness.
 */
static inline uint64_t sys_get_le64(const uint8_t src[8])
{
	return ((uint64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
    42ba:	6883      	ldr	r3, [r0, #8]
    42bc:	f853 2f01 	ldr.w	r2, [r3, #1]!
    42c0:	685b      	ldr	r3, [r3, #4]
	bt_dev.le.states = sys_get_le64(rp->le_states);
    42c2:	e9c5 2328 	strd	r2, r3, [r5, #160]	; 0xa0
		net_buf_unref(rsp);
    42c6:	f002 fb43 	bl	6950 <net_buf_unref>
	if (IS_ENABLED(CONFIG_BT_CONN) &&
    42ca:	f895 3098 	ldrb.w	r3, [r5, #152]	; 0x98
    42ce:	0698      	lsls	r0, r3, #26
    42d0:	d523      	bpl.n	431a <hci_init+0x25e>
		err = hci_le_read_max_data_len(&tx_octets, &tx_time);
    42d2:	4668      	mov	r0, sp
    42d4:	f10d 0102 	add.w	r1, sp, #2
    42d8:	f00f f926 	bl	13528 <hci_le_read_max_data_len>
		if (err) {
    42dc:	4604      	mov	r4, r0
    42de:	2800      	cmp	r0, #0
    42e0:	d1a3      	bne.n	422a <hci_init+0x16e>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    42e2:	2104      	movs	r1, #4
    42e4:	f242 0024 	movw	r0, #8228	; 0x2024
    42e8:	f7ff fa64 	bl	37b4 <bt_hci_cmd_create>
		if (!buf) {
    42ec:	4606      	mov	r6, r0
    42ee:	2800      	cmp	r0, #0
    42f0:	f43f af6e 	beq.w	41d0 <hci_init+0x114>
	return net_buf_simple_add(&buf->b, len);
    42f4:	2104      	movs	r1, #4
    42f6:	3008      	adds	r0, #8
    42f8:	f010 fd70 	bl	14ddc <net_buf_simple_add>
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
    42fc:	f8bd 3000 	ldrh.w	r3, [sp]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    4300:	4622      	mov	r2, r4
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
    4302:	8003      	strh	r3, [r0, #0]
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
    4304:	f8bd 3002 	ldrh.w	r3, [sp, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    4308:	4631      	mov	r1, r6
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
    430a:	8043      	strh	r3, [r0, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    430c:	f242 0024 	movw	r0, #8228	; 0x2024
    4310:	f7ff fa88 	bl	3824 <bt_hci_cmd_send_sync>
		if (err) {
    4314:	4604      	mov	r4, r0
    4316:	2800      	cmp	r0, #0
    4318:	d187      	bne.n	422a <hci_init+0x16e>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    431a:	2108      	movs	r1, #8
    431c:	f242 0001 	movw	r0, #8193	; 0x2001
    4320:	f7ff fa48 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    4324:	4604      	mov	r4, r0
    4326:	2800      	cmp	r0, #0
    4328:	f43f af52 	beq.w	41d0 <hci_init+0x114>
    432c:	2108      	movs	r1, #8
    432e:	4408      	add	r0, r1
    4330:	f010 fd54 	bl	14ddc <net_buf_simple_add>
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
    4334:	f895 2098 	ldrb.w	r2, [r5, #152]	; 0x98
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
    4338:	f012 0f02 	tst.w	r2, #2
    433c:	bf14      	ite	ne
    433e:	232f      	movne	r3, #47	; 0x2f
    4340:	230f      	moveq	r3, #15
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
    4342:	0691      	lsls	r1, r2, #26
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
    4344:	f895 2099 	ldrb.w	r2, [r5, #153]	; 0x99
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
    4348:	bf48      	it	mi
    434a:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
    434e:	f012 0f09 	tst.w	r2, #9
	dst[0] = val;
    4352:	f04f 0200 	mov.w	r2, #0
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
    4356:	bf18      	it	ne
    4358:	f443 6300 	orrne.w	r3, r3, #2048	; 0x800
    435c:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    435e:	f3c3 2307 	ubfx	r3, r3, #8, #8
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    4362:	4621      	mov	r1, r4
    4364:	7043      	strb	r3, [r0, #1]
	dst[0] = val;
    4366:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
    4368:	70c2      	strb	r2, [r0, #3]
	dst[0] = val;
    436a:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    436c:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    436e:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    4370:	71c2      	strb	r2, [r0, #7]
    4372:	f242 0001 	movw	r0, #8193	; 0x2001
    4376:	f7ff fa55 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    437a:	4604      	mov	r4, r0
    437c:	2800      	cmp	r0, #0
    437e:	f47f af54 	bne.w	422a <hci_init+0x16e>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    4382:	f895 3040 	ldrb.w	r3, [r5, #64]	; 0x40
    4386:	069a      	lsls	r2, r3, #26
    4388:	d41e      	bmi.n	43c8 <hci_init+0x30c>
	if (bt_dev.le.acl_mtu) {
    438a:	f8b5 10c4 	ldrh.w	r1, [r5, #196]	; 0xc4
    438e:	b9d9      	cbnz	r1, 43c8 <hci_init+0x30c>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
    4390:	f241 0005 	movw	r0, #4101	; 0x1005
    4394:	aa01      	add	r2, sp, #4
    4396:	f7ff fa45 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    439a:	4604      	mov	r4, r0
    439c:	2800      	cmp	r0, #0
    439e:	f47f af44 	bne.w	422a <hci_init+0x16e>
	if (bt_dev.le.acl_mtu) {
    43a2:	f8b5 30c4 	ldrh.w	r3, [r5, #196]	; 0xc4
    43a6:	b963      	cbnz	r3, 43c2 <hci_init+0x306>
	read_buffer_size_complete(rsp);
    43a8:	9b01      	ldr	r3, [sp, #4]
    43aa:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->acl_max_len);
    43ac:	785a      	ldrb	r2, [r3, #1]
    43ae:	7899      	ldrb	r1, [r3, #2]
    43b0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    43b4:	f8a5 20c4 	strh.w	r2, [r5, #196]	; 0xc4
	k_sem_init(&bt_dev.le.acl_pkts, pkts, pkts);
    43b8:	889a      	ldrh	r2, [r3, #4]
    43ba:	4843      	ldr	r0, [pc, #268]	; (44c8 <hci_init+0x40c>)
    43bc:	4611      	mov	r1, r2
    43be:	f019 f823 	bl	1d408 <z_impl_k_sem_init>
	net_buf_unref(rsp);
    43c2:	9801      	ldr	r0, [sp, #4]
    43c4:	f002 fac4 	bl	6950 <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
    43c8:	2108      	movs	r1, #8
    43ca:	f640 4001 	movw	r0, #3073	; 0xc01
    43ce:	f7ff f9f1 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    43d2:	4604      	mov	r4, r0
    43d4:	2800      	cmp	r0, #0
    43d6:	f43f aefb 	beq.w	41d0 <hci_init+0x114>
    43da:	2108      	movs	r1, #8
    43dc:	4408      	add	r0, r1
    43de:	f010 fcfd 	bl	14ddc <net_buf_simple_add>
	dst[0] = val;
    43e2:	2310      	movs	r3, #16
    43e4:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    43e6:	2388      	movs	r3, #136	; 0x88
    43e8:	7043      	strb	r3, [r0, #1]
    43ea:	2302      	movs	r3, #2
	dst[0] = val;
    43ec:	2200      	movs	r2, #0
	dst[1] = val >> 8;
    43ee:	70c3      	strb	r3, [r0, #3]
    43f0:	2320      	movs	r3, #32
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
    43f2:	4621      	mov	r1, r4
	dst[0] = val;
    43f4:	7082      	strb	r2, [r0, #2]
    43f6:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    43f8:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
    43fa:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
    43fc:	71c3      	strb	r3, [r0, #7]
    43fe:	f640 4001 	movw	r0, #3073	; 0xc01
    4402:	f7ff fa0f 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    4406:	4604      	mov	r4, r0
    4408:	2800      	cmp	r0, #0
    440a:	f47f af0e 	bne.w	422a <hci_init+0x16e>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    440e:	4601      	mov	r1, r0
    4410:	aa01      	add	r2, sp, #4
    4412:	f64f 4001 	movw	r0, #64513	; 0xfc01
    4416:	f7ff fa05 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    441a:	bb18      	cbnz	r0, 4464 <hci_init+0x3a8>
	net_buf_unref(rsp);
    441c:	9801      	ldr	r0, [sp, #4]
    441e:	f002 fa97 	bl	6950 <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    4422:	4621      	mov	r1, r4
    4424:	f64f 4002 	movw	r0, #64514	; 0xfc02
    4428:	aa01      	add	r2, sp, #4
    442a:	f7ff f9fb 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    442e:	b9c8      	cbnz	r0, 4464 <hci_init+0x3a8>
	rp.cmds = (void *)rsp->data;
    4430:	9801      	ldr	r0, [sp, #4]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    4432:	6883      	ldr	r3, [r0, #8]
    4434:	f8b3 3001 	ldrh.w	r3, [r3, #1]
    4438:	f8a5 3085 	strh.w	r3, [r5, #133]	; 0x85
	net_buf_unref(rsp);
    443c:	f002 fa88 	bl	6950 <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
    4440:	f895 3085 	ldrb.w	r3, [r5, #133]	; 0x85
    4444:	075b      	lsls	r3, r3, #29
    4446:	d50d      	bpl.n	4464 <hci_init+0x3a8>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    4448:	4621      	mov	r1, r4
    444a:	f64f 4003 	movw	r0, #64515	; 0xfc03
    444e:	aa01      	add	r2, sp, #4
    4450:	f7ff f9e8 	bl	3824 <bt_hci_cmd_send_sync>
		if (err) {
    4454:	b930      	cbnz	r0, 4464 <hci_init+0x3a8>
		rp.feat = (void *)rsp->data;
    4456:	9801      	ldr	r0, [sp, #4]
		memcpy(bt_dev.vs_features, rp.feat->features,
    4458:	6883      	ldr	r3, [r0, #8]
    445a:	785b      	ldrb	r3, [r3, #1]
    445c:	f885 3084 	strb.w	r3, [r5, #132]	; 0x84
		net_buf_unref(rsp);
    4460:	f002 fa76 	bl	6950 <net_buf_unref>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    4464:	79eb      	ldrb	r3, [r5, #7]
    4466:	2b00      	cmp	r3, #0
    4468:	f47f aedf 	bne.w	422a <hci_init+0x16e>
		bt_setup_public_id_addr();
    446c:	f7ff fd86 	bl	3f7c <bt_setup_public_id_addr>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    4470:	79eb      	ldrb	r3, [r5, #7]
    4472:	2b00      	cmp	r3, #0
    4474:	f47f aed9 	bne.w	422a <hci_init+0x16e>
		err = bt_setup_random_id_addr();
    4478:	f7ff fdf6 	bl	4068 <bt_setup_random_id_addr>
		if (err) {
    447c:	4604      	mov	r4, r0
    447e:	2800      	cmp	r0, #0
    4480:	f47f aed3 	bne.w	422a <hci_init+0x16e>
		err = set_random_address(&bt_dev.id_addr[0].a);
    4484:	4811      	ldr	r0, [pc, #68]	; (44cc <hci_init+0x410>)
    4486:	f7ff fa2f 	bl	38e8 <set_random_address>
    448a:	4604      	mov	r4, r0
		if (err) {
    448c:	e6cd      	b.n	422a <hci_init+0x16e>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    448e:	2102      	movs	r1, #2
    4490:	f640 406d 	movw	r0, #3181	; 0xc6d
    4494:	f7ff f98e 	bl	37b4 <bt_hci_cmd_create>
		if (!buf) {
    4498:	4604      	mov	r4, r0
    449a:	2800      	cmp	r0, #0
    449c:	f43f ae98 	beq.w	41d0 <hci_init+0x114>
    44a0:	2102      	movs	r1, #2
    44a2:	3008      	adds	r0, #8
    44a4:	f010 fc9a 	bl	14ddc <net_buf_simple_add>
		cp_le->le = 0x01;
    44a8:	2301      	movs	r3, #1
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    44aa:	4621      	mov	r1, r4
		cp_le->le = 0x01;
    44ac:	7003      	strb	r3, [r0, #0]
		cp_le->simul = 0x00;
    44ae:	7046      	strb	r6, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    44b0:	4632      	mov	r2, r6
    44b2:	f640 406d 	movw	r0, #3181	; 0xc6d
    44b6:	f7ff f9b5 	bl	3824 <bt_hci_cmd_send_sync>
		if (err) {
    44ba:	4604      	mov	r4, r0
    44bc:	2800      	cmp	r0, #0
    44be:	f43f aeee 	beq.w	429e <hci_init+0x1e2>
    44c2:	e6b2      	b.n	422a <hci_init+0x16e>
    44c4:	20000098 	.word	0x20000098
    44c8:	200000c8 	.word	0x200000c8
    44cc:	20000001 	.word	0x20000001

000044d0 <bt_enable>:
{
    44d0:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
	if (!bt_dev.drv) {
    44d4:	4d32      	ldr	r5, [pc, #200]	; (45a0 <bt_enable+0xd0>)
{
    44d6:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
    44d8:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
{
    44dc:	b088      	sub	sp, #32
	if (!bt_dev.drv) {
    44de:	2b00      	cmp	r3, #0
    44e0:	d057      	beq.n	4592 <bt_enable+0xc2>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    44e2:	2101      	movs	r1, #1
    44e4:	f105 0094 	add.w	r0, r5, #148	; 0x94
    44e8:	f00e ffac 	bl	13444 <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    44ec:	f010 0401 	ands.w	r4, r0, #1
    44f0:	d152      	bne.n	4598 <bt_enable+0xc8>
	ready_cb = cb;
    44f2:	4b2c      	ldr	r3, [pc, #176]	; (45a4 <bt_enable+0xd4>)
    44f4:	f04f 0800 	mov.w	r8, #0
    44f8:	f04f 0900 	mov.w	r9, #0
    44fc:	601e      	str	r6, [r3, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    44fe:	f06f 0308 	mvn.w	r3, #8
    4502:	f44f 6280 	mov.w	r2, #1024	; 0x400
    4506:	e9cd 4302 	strd	r4, r3, [sp, #8]
    450a:	e9cd 8906 	strd	r8, r9, [sp, #24]
    450e:	e9cd 4400 	strd	r4, r4, [sp]
    4512:	4b25      	ldr	r3, [pc, #148]	; (45a8 <bt_enable+0xd8>)
    4514:	4925      	ldr	r1, [pc, #148]	; (45ac <bt_enable+0xdc>)
    4516:	9404      	str	r4, [sp, #16]
    4518:	4825      	ldr	r0, [pc, #148]	; (45b0 <bt_enable+0xe0>)
    451a:	f00c fcd3 	bl	10ec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    451e:	4925      	ldr	r1, [pc, #148]	; (45b4 <bt_enable+0xe4>)
    4520:	4823      	ldr	r0, [pc, #140]	; (45b0 <bt_enable+0xe0>)
    4522:	f018 ff8b 	bl	1d43c <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4526:	f06f 0307 	mvn.w	r3, #7
    452a:	f44f 6280 	mov.w	r2, #1024	; 0x400
    452e:	e9cd 4302 	strd	r4, r3, [sp, #8]
    4532:	e9cd 8906 	strd	r8, r9, [sp, #24]
    4536:	e9cd 4400 	strd	r4, r4, [sp]
    453a:	4b1f      	ldr	r3, [pc, #124]	; (45b8 <bt_enable+0xe8>)
    453c:	491f      	ldr	r1, [pc, #124]	; (45bc <bt_enable+0xec>)
    453e:	9404      	str	r4, [sp, #16]
    4540:	481f      	ldr	r0, [pc, #124]	; (45c0 <bt_enable+0xf0>)
    4542:	f00c fcbf 	bl	10ec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
    4546:	491f      	ldr	r1, [pc, #124]	; (45c4 <bt_enable+0xf4>)
    4548:	481d      	ldr	r0, [pc, #116]	; (45c0 <bt_enable+0xf0>)
    454a:	f018 ff77 	bl	1d43c <z_impl_k_thread_name_set>
	err = bt_dev.drv->open();
    454e:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
    4552:	68db      	ldr	r3, [r3, #12]
    4554:	4798      	blx	r3
	if (err) {
    4556:	4604      	mov	r4, r0
    4558:	b950      	cbnz	r0, 4570 <bt_enable+0xa0>
	if (!cb) {
    455a:	b96e      	cbnz	r6, 4578 <bt_enable+0xa8>
	err = hci_init();
    455c:	f7ff fdae 	bl	40bc <hci_init>
	if (err) {
    4560:	4604      	mov	r4, r0
    4562:	b928      	cbnz	r0, 4570 <bt_enable+0xa0>
		err = bt_conn_init();
    4564:	f000 fea8 	bl	52b8 <bt_conn_init>
		if (err) {
    4568:	4604      	mov	r4, r0
    456a:	b908      	cbnz	r0, 4570 <bt_enable+0xa0>
	bt_finalize_init();
    456c:	f7ff fcc8 	bl	3f00 <bt_finalize_init>
}
    4570:	4620      	mov	r0, r4
    4572:	b008      	add	sp, #32
    4574:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    4578:	2101      	movs	r1, #1
    457a:	f105 0090 	add.w	r0, r5, #144	; 0x90
    457e:	f00e ff61 	bl	13444 <atomic_or>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    4582:	07c3      	lsls	r3, r0, #31
    4584:	d4f4      	bmi.n	4570 <bt_enable+0xa0>
		k_queue_append(&work_q->queue, work);
    4586:	4810      	ldr	r0, [pc, #64]	; (45c8 <bt_enable+0xf8>)
    4588:	f105 0188 	add.w	r1, r5, #136	; 0x88
    458c:	f018 fdf0 	bl	1d170 <k_queue_append>
    4590:	e7ee      	b.n	4570 <bt_enable+0xa0>
		return -ENODEV;
    4592:	f06f 0412 	mvn.w	r4, #18
    4596:	e7eb      	b.n	4570 <bt_enable+0xa0>
		return -EALREADY;
    4598:	f06f 0477 	mvn.w	r4, #119	; 0x77
    459c:	e7e8      	b.n	4570 <bt_enable+0xa0>
    459e:	bf00      	nop
    45a0:	20000000 	.word	0x20000000
    45a4:	20025a74 	.word	0x20025a74
    45a8:	00003cc9 	.word	0x00003cc9
    45ac:	2002bc80 	.word	0x2002bc80
    45b0:	20000b90 	.word	0x20000b90
    45b4:	00043eb2 	.word	0x00043eb2
    45b8:	0000345d 	.word	0x0000345d
    45bc:	2002b880 	.word	0x2002b880
    45c0:	20000b08 	.word	0x20000b08
    45c4:	00043eb8 	.word	0x00043eb8
    45c8:	20001168 	.word	0x20001168

000045cc <init_work>:
{
    45cc:	b510      	push	{r4, lr}
	err = hci_init();
    45ce:	f7ff fd75 	bl	40bc <hci_init>
	if (err) {
    45d2:	4604      	mov	r4, r0
    45d4:	b928      	cbnz	r0, 45e2 <init_work+0x16>
		err = bt_conn_init();
    45d6:	f000 fe6f 	bl	52b8 <bt_conn_init>
		if (err) {
    45da:	4604      	mov	r4, r0
    45dc:	b908      	cbnz	r0, 45e2 <init_work+0x16>
	bt_finalize_init();
    45de:	f7ff fc8f 	bl	3f00 <bt_finalize_init>
	if (ready_cb) {
    45e2:	4b04      	ldr	r3, [pc, #16]	; (45f4 <init_work+0x28>)
    45e4:	681b      	ldr	r3, [r3, #0]
    45e6:	b11b      	cbz	r3, 45f0 <init_work+0x24>
		ready_cb(err);
    45e8:	4620      	mov	r0, r4
}
    45ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
    45ee:	4718      	bx	r3
}
    45f0:	bd10      	pop	{r4, pc}
    45f2:	bf00      	nop
    45f4:	20025a74 	.word	0x20025a74

000045f8 <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
			   const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
    45f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    45fc:	469a      	mov	sl, r3
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
    45fe:	2300      	movs	r3, #0
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL), scannable;
    4600:	690d      	ldr	r5, [r1, #16]
{
    4602:	b08d      	sub	sp, #52	; 0x34
	bool dir_adv = (param->peer != NULL), scannable;
    4604:	ebb5 0b03 	subs.w	fp, r5, r3
{
    4608:	4606      	mov	r6, r0
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    460a:	487d      	ldr	r0, [pc, #500]	; (4800 <bt_le_adv_start_legacy+0x208>)
	bool dir_adv = (param->peer != NULL), scannable;
    460c:	bf18      	it	ne
    460e:	f04f 0b01 	movne.w	fp, #1
{
    4612:	460c      	mov	r4, r1
    4614:	4691      	mov	r9, r2
	struct bt_conn *conn = NULL;
    4616:	9305      	str	r3, [sp, #20]
    4618:	f00e feda 	bl	133d0 <atomic_get>
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    461c:	0787      	lsls	r7, r0, #30
    461e:	f140 80e1 	bpl.w	47e4 <bt_le_adv_start_legacy+0x1ec>
		return -EAGAIN;
	}

	if (!valid_adv_param(param)) {
    4622:	4608      	mov	r0, r1
    4624:	f7fe fe7e 	bl	3324 <valid_adv_param>
    4628:	4607      	mov	r7, r0
    462a:	2800      	cmp	r0, #0
    462c:	f000 80dd 	beq.w	47ea <bt_le_adv_start_legacy+0x1f2>

	if (!bt_le_adv_random_addr_check(param)) {
		return -EINVAL;
	}

	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    4630:	f106 0810 	add.w	r8, r6, #16
    4634:	4640      	mov	r0, r8
    4636:	f00e fecb 	bl	133d0 <atomic_get>
    463a:	f3c0 1180 	ubfx	r1, r0, #6, #1
    463e:	0640      	lsls	r0, r0, #25
    4640:	f100 80d6 	bmi.w	47f0 <bt_le_adv_start_legacy+0x1f8>
		return -EALREADY;
	}

	(void)memset(&set_param, 0, sizeof(set_param));

	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    4644:	68a3      	ldr	r3, [r4, #8]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
	set_param.channel_map  = get_adv_channel_map(param->options);
    4646:	6860      	ldr	r0, [r4, #4]
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    4648:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    464c:	68e3      	ldr	r3, [r4, #12]
	(void)memset(&set_param, 0, sizeof(set_param));
    464e:	e9cd 1109 	strd	r1, r1, [sp, #36]	; 0x24
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    4652:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	(void)memset(&set_param, 0, sizeof(set_param));
    4656:	f88d 102c 	strb.w	r1, [sp, #44]	; 0x2c
	set_param.channel_map  = get_adv_channel_map(param->options);
    465a:	f00e feaa 	bl	133b2 <get_adv_channel_map>
	set_param.filter_policy = get_filter_policy(param->options);

	if (adv->id != param->id) {
    465e:	7832      	ldrb	r2, [r6, #0]
    4660:	7823      	ldrb	r3, [r4, #0]
	set_param.channel_map  = get_adv_channel_map(param->options);
    4662:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
	if (adv->id != param->id) {
    4666:	429a      	cmp	r2, r3
	set_param.filter_policy = get_filter_policy(param->options);
    4668:	f88d 102e 	strb.w	r1, [sp, #46]	; 0x2e
	if (adv->id != param->id) {
    466c:	d004      	beq.n	4678 <bt_le_adv_start_legacy+0x80>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    466e:	f46f 5180 	mvn.w	r1, #4096	; 0x1000
    4672:	4863      	ldr	r0, [pc, #396]	; (4800 <bt_le_adv_start_legacy+0x208>)
    4674:	f00e fef1 	bl	1345a <atomic_and>
		atomic_clear_bit(bt_dev.flags, BT_DEV_RPA_VALID);
	}

	adv->id = param->id;
    4678:	7820      	ldrb	r0, [r4, #0]
	bt_dev.adv_conn_id = adv->id;
    467a:	4b62      	ldr	r3, [pc, #392]	; (4804 <bt_le_adv_start_legacy+0x20c>)
	adv->id = param->id;
    467c:	7030      	strb	r0, [r6, #0]
	bt_dev.adv_conn_id = adv->id;
    467e:	f883 0033 	strb.w	r0, [r3, #51]	; 0x33

	err = le_adv_set_random_addr(adv, param->options, dir_adv,
    4682:	465a      	mov	r2, fp
    4684:	6861      	ldr	r1, [r4, #4]
    4686:	f10d 0325 	add.w	r3, sp, #37	; 0x25
    468a:	f7ff f95b 	bl	3944 <le_adv_set_random_addr.isra.0>
				     &set_param.own_addr_type);
	if (err) {
    468e:	4683      	mov	fp, r0
    4690:	2800      	cmp	r0, #0
    4692:	d166      	bne.n	4762 <bt_le_adv_start_legacy+0x16a>
		return err;
	}

	if (dir_adv) {
    4694:	f106 0009 	add.w	r0, r6, #9
    4698:	2d00      	cmp	r5, #0
    469a:	d03f      	beq.n	471c <bt_le_adv_start_legacy+0x124>
		bt_addr_le_copy(&adv->target_addr, param->peer);
    469c:	6921      	ldr	r1, [r4, #16]
	} else {
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
    469e:	f00e ff3b 	bl	13518 <bt_addr_le_copy>
	}

	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    46a2:	6860      	ldr	r0, [r4, #4]
    46a4:	07c1      	lsls	r1, r0, #31
    46a6:	d541      	bpl.n	472c <bt_le_adv_start_legacy+0x134>
		scannable = true;

		if (dir_adv) {
    46a8:	2d00      	cmp	r5, #0
    46aa:	d03c      	beq.n	4726 <bt_le_adv_start_legacy+0x12e>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
				set_param.type = BT_HCI_ADV_DIRECT_IND_LOW_DUTY;
			} else {
				set_param.type = BT_HCI_ADV_DIRECT_IND;
    46ac:	f010 0f10 	tst.w	r0, #16
    46b0:	bf14      	ite	ne
    46b2:	2304      	movne	r3, #4
    46b4:	2301      	moveq	r3, #1
			}

			bt_addr_le_copy(&set_param.direct_addr, param->peer);
    46b6:	6921      	ldr	r1, [r4, #16]
    46b8:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    46bc:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    46c0:	f00e ff2a 	bl	13518 <bt_addr_le_copy>

		set_param.type = scannable ? BT_HCI_ADV_SCAN_IND :
					     BT_HCI_ADV_NONCONN_IND;
	}

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
    46c4:	210f      	movs	r1, #15
    46c6:	f242 0006 	movw	r0, #8198	; 0x2006
    46ca:	f7ff f873 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
    46ce:	4683      	mov	fp, r0
    46d0:	2800      	cmp	r0, #0
    46d2:	f000 8090 	beq.w	47f6 <bt_le_adv_start_legacy+0x1fe>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    46d6:	220f      	movs	r2, #15
    46d8:	a908      	add	r1, sp, #32
    46da:	3008      	adds	r0, #8
    46dc:	f010 fb84 	bl	14de8 <net_buf_simple_add_mem>
		return -ENOBUFS;
	}

	net_buf_add_mem(buf, &set_param, sizeof(set_param));

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
    46e0:	2200      	movs	r2, #0
    46e2:	4659      	mov	r1, fp
    46e4:	f242 0006 	movw	r0, #8198	; 0x2006
    46e8:	f7ff f89c 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
    46ec:	2800      	cmp	r0, #0
    46ee:	f040 8085 	bne.w	47fc <bt_le_adv_start_legacy+0x204>
		return err;
	}

	if (!dir_adv) {
    46f2:	b335      	cbz	r5, 4742 <bt_le_adv_start_legacy+0x14a>
			return err;
		}
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
	    (param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    46f4:	6863      	ldr	r3, [r4, #4]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    46f6:	07da      	lsls	r2, r3, #31
    46f8:	d437      	bmi.n	476a <bt_le_adv_start_legacy+0x172>
	return set_le_adv_enable_legacy(adv, enable);
    46fa:	2101      	movs	r1, #1
    46fc:	4630      	mov	r0, r6
    46fe:	f7ff f9ef 	bl	3ae0 <set_le_adv_enable_legacy>
			return err;
		}
	}

	err = set_le_adv_enable(adv, true);
	if (err) {
    4702:	4683      	mov	fp, r0
    4704:	9805      	ldr	r0, [sp, #20]
    4706:	f1bb 0f00 	cmp.w	fp, #0
    470a:	d065      	beq.n	47d8 <bt_le_adv_start_legacy+0x1e0>
		BT_ERR("Failed to start advertiser");
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    470c:	b348      	cbz	r0, 4762 <bt_le_adv_start_legacy+0x16a>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    470e:	2100      	movs	r1, #0
    4710:	f000 fbac 	bl	4e6c <bt_conn_set_state>
			bt_conn_unref(conn);
    4714:	9805      	ldr	r0, [sp, #20]
    4716:	f00f f9b6 	bl	13a86 <bt_conn_unref>
    471a:	e022      	b.n	4762 <bt_le_adv_start_legacy+0x16a>
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
    471c:	9506      	str	r5, [sp, #24]
    471e:	a906      	add	r1, sp, #24
    4720:	f8cd 501b 	str.w	r5, [sp, #27]
    4724:	e7bb      	b.n	469e <bt_le_adv_start_legacy+0xa6>
			set_param.type = BT_HCI_ADV_IND;
    4726:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
    472a:	e7cb      	b.n	46c4 <bt_le_adv_start_legacy+0xcc>
		scannable = sd || (param->options & BT_LE_ADV_OPT_USE_NAME);
    472c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    472e:	b933      	cbnz	r3, 473e <bt_le_adv_start_legacy+0x146>
    4730:	f3c0 07c0 	ubfx	r7, r0, #3, #1
		set_param.type = scannable ? BT_HCI_ADV_SCAN_IND :
    4734:	f1c7 0303 	rsb	r3, r7, #3
    4738:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    473c:	e7c2      	b.n	46c4 <bt_le_adv_start_legacy+0xcc>
		scannable = sd || (param->options & BT_LE_ADV_OPT_USE_NAME);
    473e:	2701      	movs	r7, #1
    4740:	e7f8      	b.n	4734 <bt_le_adv_start_legacy+0x13c>
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
    4742:	6863      	ldr	r3, [r4, #4]
    4744:	4652      	mov	r2, sl
    4746:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    474a:	e9cd 7301 	strd	r7, r3, [sp, #4]
    474e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    4750:	4649      	mov	r1, r9
    4752:	9300      	str	r3, [sp, #0]
    4754:	4630      	mov	r0, r6
    4756:	9b16      	ldr	r3, [sp, #88]	; 0x58
    4758:	f7ff f94e 	bl	39f8 <le_adv_update.constprop.0>
		if (err) {
    475c:	4683      	mov	fp, r0
    475e:	2800      	cmp	r0, #0
    4760:	d0c8      	beq.n	46f4 <bt_le_adv_start_legacy+0xfc>

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);

	return 0;
}
    4762:	4658      	mov	r0, fp
    4764:	b00d      	add	sp, #52	; 0x34
    4766:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		err = le_adv_start_add_conn(adv, &conn);
    476a:	4630      	mov	r0, r6
    476c:	a905      	add	r1, sp, #20
    476e:	f7fe ffb9 	bl	36e4 <le_adv_start_add_conn>
		if (err) {
    4772:	4683      	mov	fp, r0
    4774:	2800      	cmp	r0, #0
    4776:	d0c0      	beq.n	46fa <bt_le_adv_start_legacy+0x102>
			if (err == -ENOMEM && !dir_adv &&
    4778:	f110 0f0c 	cmn.w	r0, #12
    477c:	d1f1      	bne.n	4762 <bt_le_adv_start_legacy+0x16a>
    477e:	2d00      	cmp	r5, #0
    4780:	d1ef      	bne.n	4762 <bt_le_adv_start_legacy+0x16a>
			    !(param->options & BT_LE_ADV_OPT_ONE_TIME)) {
    4782:	6863      	ldr	r3, [r4, #4]
			if (err == -ENOMEM && !dir_adv &&
    4784:	079b      	lsls	r3, r3, #30
    4786:	d4ec      	bmi.n	4762 <bt_le_adv_start_legacy+0x16a>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    4788:	6860      	ldr	r0, [r4, #4]
    478a:	f080 0002 	eor.w	r0, r0, #2
    478e:	f3c0 0b40 	ubfx	fp, r0, #1, #1
    4792:	f00b 0201 	and.w	r2, fp, #1
    4796:	210c      	movs	r1, #12
    4798:	4640      	mov	r0, r8
    479a:	f00e fe69 	bl	13470 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME,
    479e:	6862      	ldr	r2, [r4, #4]
    47a0:	2107      	movs	r1, #7
    47a2:	4640      	mov	r0, r8
    47a4:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    47a8:	f00e fe62 	bl	13470 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
    47ac:	6862      	ldr	r2, [r4, #4]
    47ae:	2108      	movs	r1, #8
    47b0:	4640      	mov	r0, r8
    47b2:	f002 0201 	and.w	r2, r2, #1
    47b6:	f00e fe5b 	bl	13470 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);
    47ba:	463a      	mov	r2, r7
    47bc:	2109      	movs	r1, #9
    47be:	4640      	mov	r0, r8
    47c0:	f00e fe56 	bl	13470 <atomic_set_bit_to>
	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
    47c4:	6862      	ldr	r2, [r4, #4]
    47c6:	210b      	movs	r1, #11
    47c8:	4640      	mov	r0, r8
    47ca:	f3c2 0280 	ubfx	r2, r2, #2, #1
    47ce:	f00e fe4f 	bl	13470 <atomic_set_bit_to>
	return 0;
    47d2:	f04f 0b00 	mov.w	fp, #0
    47d6:	e7c4      	b.n	4762 <bt_le_adv_start_legacy+0x16a>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    47d8:	b108      	cbz	r0, 47de <bt_le_adv_start_legacy+0x1e6>
		bt_conn_unref(conn);
    47da:	f00f f954 	bl	13a86 <bt_conn_unref>
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    47de:	2d00      	cmp	r5, #0
    47e0:	d1d7      	bne.n	4792 <bt_le_adv_start_legacy+0x19a>
    47e2:	e7d1      	b.n	4788 <bt_le_adv_start_legacy+0x190>
		return -EAGAIN;
    47e4:	f06f 0b0a 	mvn.w	fp, #10
    47e8:	e7bb      	b.n	4762 <bt_le_adv_start_legacy+0x16a>
		return -EINVAL;
    47ea:	f06f 0b15 	mvn.w	fp, #21
    47ee:	e7b8      	b.n	4762 <bt_le_adv_start_legacy+0x16a>
		return -EALREADY;
    47f0:	f06f 0b77 	mvn.w	fp, #119	; 0x77
    47f4:	e7b5      	b.n	4762 <bt_le_adv_start_legacy+0x16a>
		return -ENOBUFS;
    47f6:	f06f 0b68 	mvn.w	fp, #104	; 0x68
    47fa:	e7b2      	b.n	4762 <bt_le_adv_start_legacy+0x16a>
    47fc:	4683      	mov	fp, r0
    47fe:	e7b0      	b.n	4762 <bt_le_adv_start_legacy+0x16a>
    4800:	20000094 	.word	0x20000094
    4804:	20000000 	.word	0x20000000

00004808 <bt_le_adv_start>:
}

int bt_le_adv_start(const struct bt_le_adv_param *param,
		    const struct bt_data *ad, size_t ad_len,
		    const struct bt_data *sd, size_t sd_len)
{
    4808:	b513      	push	{r0, r1, r4, lr}

	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
	} else {
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
    480a:	9c04      	ldr	r4, [sp, #16]
    480c:	e9cd 3400 	strd	r3, r4, [sp]
    4810:	4613      	mov	r3, r2
    4812:	460a      	mov	r2, r1
    4814:	4601      	mov	r1, r0
    4816:	4802      	ldr	r0, [pc, #8]	; (4820 <bt_le_adv_start+0x18>)
    4818:	f7ff feee 	bl	45f8 <bt_le_adv_start_legacy>
	if (err) {
		adv_delete_legacy();
	}

	return err;
}
    481c:	b002      	add	sp, #8
    481e:	bd10      	pop	{r4, pc}
    4820:	20000018 	.word	0x20000018

00004824 <bt_le_adv_resume>:
	return 0;
}

#if defined(CONFIG_BT_PERIPHERAL)
void bt_le_adv_resume(void)
{
    4824:	b513      	push	{r0, r1, r4, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    4826:	4818      	ldr	r0, [pc, #96]	; (4888 <bt_le_adv_resume+0x64>)
    4828:	f00e fdd2 	bl	133d0 <atomic_get>
	if (!adv) {
		BT_DBG("No valid legacy adv");
		return;
	}

	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
    482c:	04c1      	lsls	r1, r0, #19
    482e:	d529      	bpl.n	4884 <bt_le_adv_resume+0x60>
    4830:	4815      	ldr	r0, [pc, #84]	; (4888 <bt_le_adv_resume+0x64>)
    4832:	f00e fdcd 	bl	133d0 <atomic_get>
    4836:	0642      	lsls	r2, r0, #25
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    4838:	f3c0 1480 	ubfx	r4, r0, #6, #1
    483c:	d422      	bmi.n	4884 <bt_le_adv_resume+0x60>
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
    483e:	4812      	ldr	r0, [pc, #72]	; (4888 <bt_le_adv_resume+0x64>)
    4840:	f00e fdc6 	bl	133d0 <atomic_get>
	      !atomic_test_bit(adv->flags, BT_ADV_ENABLED))) {
		return;
	}

	if (!atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
    4844:	05c3      	lsls	r3, r0, #23
    4846:	d51d      	bpl.n	4884 <bt_le_adv_resume+0x60>
		return;
	}

	err = le_adv_start_add_conn(adv, &conn);
    4848:	4810      	ldr	r0, [pc, #64]	; (488c <bt_le_adv_resume+0x68>)
    484a:	a901      	add	r1, sp, #4
    484c:	f7fe ff4a 	bl	36e4 <le_adv_start_add_conn>
	if (err) {
    4850:	b9c0      	cbnz	r0, 4884 <bt_le_adv_resume+0x60>
	return set_le_adv_enable_legacy(adv, enable);
    4852:	2101      	movs	r1, #1
    4854:	480d      	ldr	r0, [pc, #52]	; (488c <bt_le_adv_resume+0x68>)
    4856:	f7ff f943 	bl	3ae0 <set_le_adv_enable_legacy>
	    !atomic_test_bit(adv->flags, BT_ADV_USE_IDENTITY)) {
		le_adv_set_private_addr(adv);
	}

	err = set_le_adv_enable(adv, true);
	if (err) {
    485a:	b150      	cbz	r0, 4872 <bt_le_adv_resume+0x4e>
		BT_DBG("Controller cannot resume connectable advertising (%d)",
		       err);
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    485c:	4621      	mov	r1, r4
    485e:	9801      	ldr	r0, [sp, #4]
    4860:	f000 fb04 	bl	4e6c <bt_conn_set_state>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    4864:	f46f 5180 	mvn.w	r1, #4096	; 0x1000
    4868:	4807      	ldr	r0, [pc, #28]	; (4888 <bt_le_adv_resume+0x64>)
    486a:	f00e fdf6 	bl	1345a <atomic_and>
	return (old & mask) != 0;
    486e:	f3c0 3400 	ubfx	r4, r0, #12, #1
	}

	/* Since we don't give the application a reference to manage in
	 * this case, we need to release this reference here.
	 */
	bt_conn_unref(conn);
    4872:	9801      	ldr	r0, [sp, #4]
    4874:	f00f f907 	bl	13a86 <bt_conn_unref>
	if (persist_paused) {
    4878:	b124      	cbz	r4, 4884 <bt_le_adv_resume+0x60>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    487a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    487e:	4802      	ldr	r0, [pc, #8]	; (4888 <bt_le_adv_resume+0x64>)
    4880:	f00e fde0 	bl	13444 <atomic_or>
		atomic_set_bit(adv->flags, BT_ADV_PERSIST);
	}
}
    4884:	b002      	add	sp, #8
    4886:	bd10      	pop	{r4, pc}
    4888:	20000028 	.word	0x20000028
    488c:	20000018 	.word	0x20000018

00004890 <enh_conn_complete>:
{
    4890:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (evt->status) {
    4892:	7805      	ldrb	r5, [r0, #0]
{
    4894:	4604      	mov	r4, r0
    4896:	b085      	sub	sp, #20
	if (evt->status) {
    4898:	b19d      	cbz	r5, 48c2 <enh_conn_complete+0x32>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    489a:	2d3c      	cmp	r5, #60	; 0x3c
    489c:	d13f      	bne.n	491e <enh_conn_complete+0x8e>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    489e:	f06f 0140 	mvn.w	r1, #64	; 0x40
    48a2:	4842      	ldr	r0, [pc, #264]	; (49ac <enh_conn_complete+0x11c>)
    48a4:	f00e fdd9 	bl	1345a <atomic_and>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
    48a8:	2000      	movs	r0, #0
    48aa:	f7fe fd8f 	bl	33cc <find_pending_connect.part.0>
		if (!conn) {
    48ae:	4604      	mov	r4, r0
    48b0:	b3a8      	cbz	r0, 491e <enh_conn_complete+0x8e>
		conn->err = BT_HCI_ERR_ADV_TIMEOUT;
    48b2:	7245      	strb	r5, [r0, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    48b4:	2100      	movs	r1, #0
    48b6:	f000 fad9 	bl	4e6c <bt_conn_set_state>
		bt_conn_unref(conn);
    48ba:	4620      	mov	r0, r4
	bt_conn_unref(conn);
    48bc:	f00f f8e3 	bl	13a86 <bt_conn_unref>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
    48c0:	e02d      	b.n	491e <enh_conn_complete+0x8e>
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    48c2:	7903      	ldrb	r3, [r0, #4]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    48c4:	f8b0 6001 	ldrh.w	r6, [r0, #1]
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    48c8:	3b02      	subs	r3, #2
    48ca:	2b01      	cmp	r3, #1
    48cc:	f100 0104 	add.w	r1, r0, #4
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    48d0:	b2b7      	uxth	r7, r6
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
    48d2:	a802      	add	r0, sp, #8
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    48d4:	d825      	bhi.n	4922 <enh_conn_complete+0x92>
		bt_addr_le_copy(&id_addr, &evt->peer_addr);
    48d6:	f00e fe1f 	bl	13518 <bt_addr_le_copy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    48da:	f89d 3008 	ldrb.w	r3, [sp, #8]
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
    48de:	f104 0111 	add.w	r1, r4, #17
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    48e2:	3b02      	subs	r3, #2
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
    48e4:	f10d 0001 	add.w	r0, sp, #1
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    48e8:	f88d 3008 	strb.w	r3, [sp, #8]
		bt_addr_copy(&peer_addr.a, &evt->peer_rpa);
    48ec:	f00e fe0f 	bl	1350e <bt_addr_copy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
    48f0:	2301      	movs	r3, #1
    48f2:	f88d 3000 	strb.w	r3, [sp]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_SLAVE) {
    48f6:	78e3      	ldrb	r3, [r4, #3]
    48f8:	2b01      	cmp	r3, #1
    48fa:	d10c      	bne.n	4916 <enh_conn_complete+0x86>
    48fc:	a802      	add	r0, sp, #8
    48fe:	f7fe fd65 	bl	33cc <find_pending_connect.part.0>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    4902:	78e3      	ldrb	r3, [r4, #3]
    4904:	4605      	mov	r5, r0
    4906:	2b01      	cmp	r3, #1
    4908:	d104      	bne.n	4914 <enh_conn_complete+0x84>
    490a:	f06f 0140 	mvn.w	r1, #64	; 0x40
    490e:	4827      	ldr	r0, [pc, #156]	; (49ac <enh_conn_complete+0x11c>)
    4910:	f00e fda3 	bl	1345a <atomic_and>
	if (!conn) {
    4914:	b95d      	cbnz	r5, 492e <enh_conn_complete+0x9e>
		bt_hci_disconnect(handle, BT_HCI_ERR_UNSPECIFIED);
    4916:	211f      	movs	r1, #31
    4918:	4638      	mov	r0, r7
    491a:	f00e fe7e 	bl	1361a <bt_hci_disconnect>
}
    491e:	b005      	add	sp, #20
    4920:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bt_addr_le_copy(&id_addr,
    4922:	f00e fdf9 	bl	13518 <bt_addr_le_copy>
		bt_addr_le_copy(&peer_addr, &evt->peer_addr);
    4926:	4668      	mov	r0, sp
    4928:	f00e fdf6 	bl	13518 <bt_addr_le_copy>
    492c:	e7e3      	b.n	48f6 <enh_conn_complete+0x66>
	conn->handle = handle;
    492e:	4628      	mov	r0, r5
	bt_addr_le_copy(&conn->le.dst, &id_addr);
    4930:	a902      	add	r1, sp, #8
	conn->handle = handle;
    4932:	f820 6b88 	strh.w	r6, [r0], #136
	bt_addr_le_copy(&conn->le.dst, &id_addr);
    4936:	f00e fdef 	bl	13518 <bt_addr_le_copy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
    493a:	7e22      	ldrb	r2, [r4, #24]
    493c:	7de3      	ldrb	r3, [r4, #23]
    493e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    4942:	f8a5 309e 	strh.w	r3, [r5, #158]	; 0x9e
	conn->le.latency = sys_le16_to_cpu(evt->latency);
    4946:	7ea2      	ldrb	r2, [r4, #26]
    4948:	7e63      	ldrb	r3, [r4, #25]
    494a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    494e:	f8a5 30a4 	strh.w	r3, [r5, #164]	; 0xa4
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    4952:	7ee3      	ldrb	r3, [r4, #27]
    4954:	7f22      	ldrb	r2, [r4, #28]
    4956:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    495a:	f8a5 30a6 	strh.w	r3, [r5, #166]	; 0xa6
	conn->role = evt->role;
    495e:	78e3      	ldrb	r3, [r4, #3]
	conn->err = 0U;
    4960:	2400      	movs	r4, #0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    4962:	2b01      	cmp	r3, #1
	conn->role = evt->role;
    4964:	70eb      	strb	r3, [r5, #3]
	conn->err = 0U;
    4966:	726c      	strb	r4, [r5, #9]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    4968:	d116      	bne.n	4998 <enh_conn_complete+0x108>
		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
    496a:	4669      	mov	r1, sp
    496c:	f105 008f 	add.w	r0, r5, #143	; 0x8f
    4970:	f00e fdd2 	bl	13518 <bt_addr_le_copy>
						&bt_dev.id_addr[conn->id]);
    4974:	7a29      	ldrb	r1, [r5, #8]
    4976:	4a0e      	ldr	r2, [pc, #56]	; (49b0 <enh_conn_complete+0x120>)
    4978:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
				bt_addr_le_copy(&conn->le.resp_addr,
    497c:	4411      	add	r1, r2
    497e:	f105 0096 	add.w	r0, r5, #150	; 0x96
    4982:	f00e fdc9 	bl	13518 <bt_addr_le_copy>
		if (BT_LE_STATES_SLAVE_CONN_ADV(bt_dev.le.states)) {
    4986:	f8d2 10a4 	ldr.w	r1, [r2, #164]	; 0xa4
    498a:	4622      	mov	r2, r4
    498c:	f001 0340 	and.w	r3, r1, #64	; 0x40
    4990:	4313      	orrs	r3, r2
    4992:	d001      	beq.n	4998 <enh_conn_complete+0x108>
			bt_le_adv_resume();
    4994:	f7ff ff46 	bl	4824 <bt_le_adv_resume>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
    4998:	2107      	movs	r1, #7
    499a:	4628      	mov	r0, r5
    499c:	f000 fa66 	bl	4e6c <bt_conn_set_state>
	conn_auto_initiate(conn);
    49a0:	4628      	mov	r0, r5
    49a2:	f7ff f937 	bl	3c14 <conn_auto_initiate>
	bt_conn_unref(conn);
    49a6:	4628      	mov	r0, r5
    49a8:	e788      	b.n	48bc <enh_conn_complete+0x2c>
    49aa:	bf00      	nop
    49ac:	20000028 	.word	0x20000028
    49b0:	20000000 	.word	0x20000000

000049b4 <prng_reseed.constprop.0>:

#include "hci_core.h"

static struct tc_hmac_prng_struct prng;

static int prng_reseed(struct tc_hmac_prng_struct *h)
    49b4:	e92d 4870 	stmdb	sp!, {r4, r5, r6, fp, lr}
	uint8_t seed[32];
	int64_t extra;
	size_t i;
	int ret;

	for (i = 0; i < (sizeof(seed) / 8); i++) {
    49b8:	2500      	movs	r5, #0
static int prng_reseed(struct tc_hmac_prng_struct *h)
    49ba:	b08d      	sub	sp, #52	; 0x34
		struct bt_hci_rp_le_rand *rp;
		struct net_buf *rsp;

		ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
    49bc:	2100      	movs	r1, #0
    49be:	f242 0018 	movw	r0, #8216	; 0x2018
    49c2:	aa02      	add	r2, sp, #8
    49c4:	f7fe ff2e 	bl	3824 <bt_hci_cmd_send_sync>
		if (ret) {
    49c8:	4604      	mov	r4, r0
    49ca:	bb58      	cbnz	r0, 4a24 <prng_reseed.constprop.0+0x70>
			return ret;
		}

		rp = (void *)rsp->data;
    49cc:	9802      	ldr	r0, [sp, #8]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    49ce:	ae04      	add	r6, sp, #16
    49d0:	6882      	ldr	r2, [r0, #8]
    49d2:	eb06 01c5 	add.w	r1, r6, r5, lsl #3
    49d6:	f852 3f01 	ldr.w	r3, [r2, #1]!
    49da:	f846 3035 	str.w	r3, [r6, r5, lsl #3]
    49de:	6853      	ldr	r3, [r2, #4]
	for (i = 0; i < (sizeof(seed) / 8); i++) {
    49e0:	3501      	adds	r5, #1
    49e2:	604b      	str	r3, [r1, #4]
		memcpy(&seed[i * 8], rp->rand, 8);

		net_buf_unref(rsp);
    49e4:	f001 ffb4 	bl	6950 <net_buf_unref>
	for (i = 0; i < (sizeof(seed) / 8); i++) {
    49e8:	2d04      	cmp	r5, #4
    49ea:	d1e7      	bne.n	49bc <prng_reseed.constprop.0+0x8>
	return z_impl_k_uptime_ticks();
    49ec:	f018 fddb 	bl	1d5a6 <z_impl_k_uptime_ticks>
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
    49f0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    49f4:	fba0 bc05 	umull	fp, ip, r0, r5
    49f8:	fb05 cc01 	mla	ip, r5, r1, ip
    49fc:	ea4f 32db 	mov.w	r2, fp, lsr #15
    4a00:	ea42 424c 	orr.w	r2, r2, ip, lsl #17
    4a04:	ea4f 33dc 	mov.w	r3, ip, lsr #15
	}

	extra = k_uptime_get();
    4a08:	e9cd 2302 	strd	r2, r3, [sp, #8]

	ret = tc_hmac_prng_reseed(h, seed, sizeof(seed), (uint8_t *)&extra,
    4a0c:	2308      	movs	r3, #8
    4a0e:	2220      	movs	r2, #32
    4a10:	9300      	str	r3, [sp, #0]
    4a12:	4631      	mov	r1, r6
    4a14:	4805      	ldr	r0, [pc, #20]	; (4a2c <prng_reseed.constprop.0+0x78>)
    4a16:	446b      	add	r3, sp
    4a18:	f00e fa31 	bl	12e7e <tc_hmac_prng_reseed>
				  sizeof(extra));
	if (ret == TC_CRYPTO_FAIL) {
		BT_ERR("Failed to re-seed PRNG");
		return -EIO;
    4a1c:	2800      	cmp	r0, #0
    4a1e:	bf08      	it	eq
    4a20:	f06f 0404 	mvneq.w	r4, #4
	}

	return 0;
}
    4a24:	4620      	mov	r0, r4
    4a26:	b00d      	add	sp, #52	; 0x34
    4a28:	e8bd 8870 	ldmia.w	sp!, {r4, r5, r6, fp, pc}
    4a2c:	20000c18 	.word	0x20000c18

00004a30 <prng_init>:

int prng_init(void)
{
    4a30:	b513      	push	{r0, r1, r4, lr}
	struct bt_hci_rp_le_rand *rp;
	struct net_buf *rsp;
	int ret;

	/* Check first that HCI_LE_Rand is supported */
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
    4a32:	4b11      	ldr	r3, [pc, #68]	; (4a78 <prng_init+0x48>)
    4a34:	f993 305f 	ldrsb.w	r3, [r3, #95]	; 0x5f
    4a38:	2b00      	cmp	r3, #0
    4a3a:	da16      	bge.n	4a6a <prng_init+0x3a>
		return -ENOTSUP;
	}

	ret = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
    4a3c:	2100      	movs	r1, #0
    4a3e:	f242 0018 	movw	r0, #8216	; 0x2018
    4a42:	aa01      	add	r2, sp, #4
    4a44:	f7fe feee 	bl	3824 <bt_hci_cmd_send_sync>
	if (ret) {
    4a48:	b968      	cbnz	r0, 4a66 <prng_init+0x36>
		return ret;
	}

	rp = (void *)rsp->data;
    4a4a:	9b01      	ldr	r3, [sp, #4]

	ret = tc_hmac_prng_init(&prng, rp->rand, sizeof(rp->rand));
    4a4c:	2208      	movs	r2, #8
    4a4e:	6899      	ldr	r1, [r3, #8]
    4a50:	480a      	ldr	r0, [pc, #40]	; (4a7c <prng_init+0x4c>)
    4a52:	3101      	adds	r1, #1
    4a54:	f00e f9f3 	bl	12e3e <tc_hmac_prng_init>
    4a58:	4604      	mov	r4, r0

	net_buf_unref(rsp);
    4a5a:	9801      	ldr	r0, [sp, #4]
    4a5c:	f001 ff78 	bl	6950 <net_buf_unref>

	if (ret == TC_CRYPTO_FAIL) {
    4a60:	b134      	cbz	r4, 4a70 <prng_init+0x40>
		BT_ERR("Failed to initialize PRNG");
		return -EIO;
	}

	/* re-seed is needed after init */
	return prng_reseed(&prng);
    4a62:	f7ff ffa7 	bl	49b4 <prng_reseed.constprop.0>
}
    4a66:	b002      	add	sp, #8
    4a68:	bd10      	pop	{r4, pc}
		return -ENOTSUP;
    4a6a:	f06f 0085 	mvn.w	r0, #133	; 0x85
    4a6e:	e7fa      	b.n	4a66 <prng_init+0x36>
		return -EIO;
    4a70:	f06f 0004 	mvn.w	r0, #4
    4a74:	e7f7      	b.n	4a66 <prng_init+0x36>
    4a76:	bf00      	nop
    4a78:	20000000 	.word	0x20000000
    4a7c:	20000c18 	.word	0x20000c18

00004a80 <bt_rand>:

int bt_rand(void *buf, size_t len)
{
    4a80:	b538      	push	{r3, r4, r5, lr}
	int ret;

	ret = tc_hmac_prng_generate(buf, len, &prng);
    4a82:	4a0a      	ldr	r2, [pc, #40]	; (4aac <bt_rand+0x2c>)
{
    4a84:	4604      	mov	r4, r0
    4a86:	460d      	mov	r5, r1
	ret = tc_hmac_prng_generate(buf, len, &prng);
    4a88:	f00e fa12 	bl	12eb0 <tc_hmac_prng_generate>
	if (ret == TC_HMAC_PRNG_RESEED_REQ) {
    4a8c:	1c43      	adds	r3, r0, #1
    4a8e:	d107      	bne.n	4aa0 <bt_rand+0x20>
		ret = prng_reseed(&prng);
    4a90:	f7ff ff90 	bl	49b4 <prng_reseed.constprop.0>
		if (ret) {
    4a94:	b948      	cbnz	r0, 4aaa <bt_rand+0x2a>
			return ret;
		}

		ret = tc_hmac_prng_generate(buf, len, &prng);
    4a96:	4629      	mov	r1, r5
    4a98:	4620      	mov	r0, r4
    4a9a:	4a04      	ldr	r2, [pc, #16]	; (4aac <bt_rand+0x2c>)
    4a9c:	f00e fa08 	bl	12eb0 <tc_hmac_prng_generate>
	}

	if (ret == TC_CRYPTO_SUCCESS) {
		return 0;
    4aa0:	2801      	cmp	r0, #1
    4aa2:	bf14      	ite	ne
    4aa4:	f06f 0004 	mvnne.w	r0, #4
    4aa8:	2000      	moveq	r0, #0
	}

	return -EIO;
}
    4aaa:	bd38      	pop	{r3, r4, r5, pc}
    4aac:	20000c18 	.word	0x20000c18

00004ab0 <tx_free>:
	return bt_l2cap_update_conn_param(conn, param);
}

static void tx_free(struct bt_conn_tx *tx)
{
	tx->cb = NULL;
    4ab0:	2300      	movs	r3, #0
{
    4ab2:	4601      	mov	r1, r0
	tx->user_data = NULL;
    4ab4:	e9c0 3301 	strd	r3, r3, [r0, #4]
	tx->pending_no_cb = 0U;
    4ab8:	60c3      	str	r3, [r0, #12]
	k_fifo_put(&free_tx, tx);
    4aba:	4801      	ldr	r0, [pc, #4]	; (4ac0 <tx_free+0x10>)
    4abc:	f018 bb58 	b.w	1d170 <k_queue_append>
    4ac0:	20000880 	.word	0x20000880

00004ac4 <notify_connected>:
{
    4ac4:	b538      	push	{r3, r4, r5, lr}
    4ac6:	4604      	mov	r4, r0
	for (cb = callback_list; cb; cb = cb->_next) {
    4ac8:	4b08      	ldr	r3, [pc, #32]	; (4aec <notify_connected+0x28>)
    4aca:	681d      	ldr	r5, [r3, #0]
    4acc:	7a61      	ldrb	r1, [r4, #9]
    4ace:	b92d      	cbnz	r5, 4adc <notify_connected+0x18>
	if (!conn->err) {
    4ad0:	b951      	cbnz	r1, 4ae8 <notify_connected+0x24>
		bt_gatt_connected(conn);
    4ad2:	4620      	mov	r0, r4
}
    4ad4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_gatt_connected(conn);
    4ad8:	f001 be16 	b.w	6708 <bt_gatt_connected>
		if (cb->connected) {
    4adc:	682b      	ldr	r3, [r5, #0]
    4ade:	b10b      	cbz	r3, 4ae4 <notify_connected+0x20>
			cb->connected(conn, conn->err);
    4ae0:	4620      	mov	r0, r4
    4ae2:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    4ae4:	692d      	ldr	r5, [r5, #16]
    4ae6:	e7f1      	b.n	4acc <notify_connected+0x8>
}
    4ae8:	bd38      	pop	{r3, r4, r5, pc}
    4aea:	bf00      	nop
    4aec:	20025a78 	.word	0x20025a78

00004af0 <send_frag>:
	return bt_send(buf);
}

static bool send_frag(struct bt_conn *conn, struct net_buf *buf, uint8_t flags,
		      bool always_consume)
{
    4af0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4af4:	4604      	mov	r4, r0
    4af6:	460e      	mov	r6, r1
    4af8:	4690      	mov	r8, r2
    4afa:	461f      	mov	r7, r3
	struct bt_conn_tx *tx = tx_data(buf)->tx;
    4afc:	694d      	ldr	r5, [r1, #20]
	return z_impl_k_sem_take(sem, timeout);
    4afe:	f04f 33ff 	mov.w	r3, #4294967295
    4b02:	f04f 32ff 	mov.w	r2, #4294967295
    4b06:	483e      	ldr	r0, [pc, #248]	; (4c00 <send_frag+0x110>)
    4b08:	f00c f96a 	bl	10de0 <z_impl_k_sem_take>

	/* Wait until the controller can accept ACL packets */
	k_sem_take(bt_conn_get_pkts(conn), K_FOREVER);

	/* Check for disconnection while waiting for pkts_sem */
	if (conn->state != BT_CONN_CONNECTED) {
    4b0c:	7aa3      	ldrb	r3, [r4, #10]
    4b0e:	2b07      	cmp	r3, #7
    4b10:	d146      	bne.n	4ba0 <send_frag+0xb0>
	__asm__ volatile(
    4b12:	f04f 0320 	mov.w	r3, #32
    4b16:	f3ef 8211 	mrs	r2, BASEPRI
    4b1a:	f383 8811 	msr	BASEPRI, r3
    4b1e:	f3bf 8f6f 	isb	sy
		goto fail;
	}

	/* Add to pending, it must be done before bt_buf_set_type */
	key = irq_lock();
	if (tx) {
    4b22:	2d00      	cmp	r5, #0
    4b24:	d04e      	beq.n	4bc4 <send_frag+0xd4>
	parent->next = child;
    4b26:	2300      	movs	r3, #0
    4b28:	602b      	str	r3, [r5, #0]
Z_GENLIST_APPEND(slist, snode)
    4b2a:	69a3      	ldr	r3, [r4, #24]
    4b2c:	2b00      	cmp	r3, #0
    4b2e:	d146      	bne.n	4bbe <send_frag+0xce>
	list->head = node;
    4b30:	e9c4 5505 	strd	r5, r5, [r4, #20]
	__asm__ volatile(
    4b34:	f382 8811 	msr	BASEPRI, r2
    4b38:	f3bf 8f6f 	isb	sy
	return net_buf_simple_push(&buf->b, len);
    4b3c:	2104      	movs	r1, #4
    4b3e:	f106 0008 	add.w	r0, r6, #8
    4b42:	f010 f963 	bl	14e0c <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    4b46:	8823      	ldrh	r3, [r4, #0]
    4b48:	f008 08fd 	and.w	r8, r8, #253	; 0xfd
    4b4c:	ea43 3808 	orr.w	r8, r3, r8, lsl #12
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    4b50:	89b3      	ldrh	r3, [r6, #12]
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
    4b52:	f8a0 8000 	strh.w	r8, [r0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
    4b56:	3b04      	subs	r3, #4
    4b58:	8043      	strh	r3, [r0, #2]
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    4b5a:	2302      	movs	r3, #2
	return bt_send(buf);
    4b5c:	4630      	mov	r0, r6
    4b5e:	7533      	strb	r3, [r6, #20]
    4b60:	f7fe ffec 	bl	3b3c <bt_send>
		err = send_iso(conn, buf, flags);
	} else {
		err = send_acl(conn, buf, flags);
	}

	if (err) {
    4b64:	2800      	cmp	r0, #0
    4b66:	d049      	beq.n	4bfc <send_frag+0x10c>
	__asm__ volatile(
    4b68:	f04f 0320 	mov.w	r3, #32
    4b6c:	f3ef 8111 	mrs	r1, BASEPRI
    4b70:	f383 8811 	msr	BASEPRI, r3
    4b74:	f3bf 8f6f 	isb	sy
		BT_ERR("Unable to send to driver (err %d)", err);
		key = irq_lock();
		/* Roll back the pending TX info */
		if (tx) {
    4b78:	2d00      	cmp	r5, #0
    4b7a:	d039      	beq.n	4bf0 <send_frag+0x100>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    4b7c:	2200      	movs	r2, #0
    4b7e:	6963      	ldr	r3, [r4, #20]
    4b80:	b153      	cbz	r3, 4b98 <send_frag+0xa8>
    4b82:	429d      	cmp	r5, r3
    4b84:	d131      	bne.n	4bea <send_frag+0xfa>
Z_GENLIST_REMOVE(slist, snode)
    4b86:	682b      	ldr	r3, [r5, #0]
    4b88:	bb4a      	cbnz	r2, 4bde <send_frag+0xee>
    4b8a:	69a2      	ldr	r2, [r4, #24]
	list->head = node;
    4b8c:	6163      	str	r3, [r4, #20]
Z_GENLIST_REMOVE(slist, snode)
    4b8e:	4295      	cmp	r5, r2
    4b90:	d100      	bne.n	4b94 <send_frag+0xa4>
	list->tail = node;
    4b92:	61a3      	str	r3, [r4, #24]
	parent->next = child;
    4b94:	2300      	movs	r3, #0
    4b96:	602b      	str	r3, [r5, #0]
	__asm__ volatile(
    4b98:	f381 8811 	msr	BASEPRI, r1
    4b9c:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
    4ba0:	4817      	ldr	r0, [pc, #92]	; (4c00 <send_frag+0x110>)
    4ba2:	f00c f8f7 	bl	10d94 <z_impl_k_sem_give>

	return true;

fail:
	k_sem_give(bt_conn_get_pkts(conn));
	if (tx) {
    4ba6:	b115      	cbz	r5, 4bae <send_frag+0xbe>
		tx_free(tx);
    4ba8:	4628      	mov	r0, r5
    4baa:	f7ff ff81 	bl	4ab0 <tx_free>
	}

	if (always_consume) {
    4bae:	b11f      	cbz	r7, 4bb8 <send_frag+0xc8>
		net_buf_unref(buf);
    4bb0:	4630      	mov	r0, r6
    4bb2:	f001 fecd 	bl	6950 <net_buf_unref>
	}
	return false;
    4bb6:	2700      	movs	r7, #0
}
    4bb8:	4638      	mov	r0, r7
    4bba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4bbe:	601d      	str	r5, [r3, #0]
	list->tail = node;
    4bc0:	61a5      	str	r5, [r4, #24]
}
    4bc2:	e7b7      	b.n	4b34 <send_frag+0x44>
		tail_tx = (void *)sys_slist_peek_tail(&conn->tx_pending);
    4bc4:	69a3      	ldr	r3, [r4, #24]
		if (tail_tx) {
    4bc6:	b133      	cbz	r3, 4bd6 <send_frag+0xe6>
			pending_no_cb = &tail_tx->pending_no_cb;
    4bc8:	f103 090c 	add.w	r9, r3, #12
    4bcc:	68db      	ldr	r3, [r3, #12]
		(*pending_no_cb)++;
    4bce:	3301      	adds	r3, #1
    4bd0:	f8c9 3000 	str.w	r3, [r9]
    4bd4:	e7ae      	b.n	4b34 <send_frag+0x44>
			pending_no_cb = &conn->pending_no_cb;
    4bd6:	69e3      	ldr	r3, [r4, #28]
    4bd8:	f104 091c 	add.w	r9, r4, #28
    4bdc:	e7f7      	b.n	4bce <send_frag+0xde>
	parent->next = child;
    4bde:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
    4be0:	69a3      	ldr	r3, [r4, #24]
    4be2:	429d      	cmp	r5, r3
	list->tail = node;
    4be4:	bf08      	it	eq
    4be6:	61a2      	streq	r2, [r4, #24]
}
    4be8:	e7d4      	b.n	4b94 <send_frag+0xa4>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    4bea:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    4bec:	681b      	ldr	r3, [r3, #0]
    4bee:	e7c7      	b.n	4b80 <send_frag+0x90>
			(*pending_no_cb)--;
    4bf0:	f8d9 3000 	ldr.w	r3, [r9]
    4bf4:	3b01      	subs	r3, #1
    4bf6:	f8c9 3000 	str.w	r3, [r9]
    4bfa:	e7cd      	b.n	4b98 <send_frag+0xa8>
	return true;
    4bfc:	2701      	movs	r7, #1
    4bfe:	e7db      	b.n	4bb8 <send_frag+0xc8>
    4c00:	200000c8 	.word	0x200000c8

00004c04 <bt_conn_get_pkts>:
}
    4c04:	4800      	ldr	r0, [pc, #0]	; (4c08 <bt_conn_get_pkts+0x4>)
    4c06:	4770      	bx	lr
    4c08:	200000c8 	.word	0x200000c8

00004c0c <notify_le_param_updated>:
{
    4c0c:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    4c0e:	1d03      	adds	r3, r0, #4
{
    4c10:	4604      	mov	r4, r0
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4c12:	e8d3 2faf 	lda	r2, [r3]
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    4c16:	0592      	lsls	r2, r2, #22
    4c18:	d515      	bpl.n	4c46 <notify_le_param_updated+0x3a>
	    conn->le.interval >= conn->le.interval_min &&
    4c1a:	f8b0 209e 	ldrh.w	r2, [r0, #158]	; 0x9e
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
    4c1e:	f8b0 10a0 	ldrh.w	r1, [r0, #160]	; 0xa0
    4c22:	4291      	cmp	r1, r2
    4c24:	d80f      	bhi.n	4c46 <notify_le_param_updated+0x3a>
	    conn->le.interval >= conn->le.interval_min &&
    4c26:	f8b0 10a2 	ldrh.w	r1, [r0, #162]	; 0xa2
    4c2a:	4291      	cmp	r1, r2
    4c2c:	d30b      	bcc.n	4c46 <notify_le_param_updated+0x3a>
	    conn->le.latency == conn->le.pending_latency &&
    4c2e:	e9d0 1229 	ldrd	r1, r2, [r0, #164]	; 0xa4
    4c32:	4291      	cmp	r1, r2
    4c34:	d107      	bne.n	4c46 <notify_le_param_updated+0x3a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4c36:	e8d3 2fef 	ldaex	r2, [r3]
    4c3a:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    4c3e:	e8c3 2fe1 	stlex	r1, r2, [r3]
    4c42:	2900      	cmp	r1, #0
    4c44:	d1f7      	bne.n	4c36 <notify_le_param_updated+0x2a>
	for (cb = callback_list; cb; cb = cb->_next) {
    4c46:	4b08      	ldr	r3, [pc, #32]	; (4c68 <notify_le_param_updated+0x5c>)
    4c48:	681d      	ldr	r5, [r3, #0]
    4c4a:	b905      	cbnz	r5, 4c4e <notify_le_param_updated+0x42>
}
    4c4c:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->le_param_updated) {
    4c4e:	68ee      	ldr	r6, [r5, #12]
    4c50:	b13e      	cbz	r6, 4c62 <notify_le_param_updated+0x56>
			cb->le_param_updated(conn, conn->le.interval,
    4c52:	4620      	mov	r0, r4
    4c54:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
    4c58:	f8b4 20a4 	ldrh.w	r2, [r4, #164]	; 0xa4
    4c5c:	f8b4 109e 	ldrh.w	r1, [r4, #158]	; 0x9e
    4c60:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
    4c62:	692d      	ldr	r5, [r5, #16]
    4c64:	e7f1      	b.n	4c4a <notify_le_param_updated+0x3e>
    4c66:	bf00      	nop
    4c68:	20025a78 	.word	0x20025a78

00004c6c <le_param_req>:
{
    4c6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4c6e:	4607      	mov	r7, r0
	if (!bt_le_conn_params_valid(param)) {
    4c70:	4608      	mov	r0, r1
{
    4c72:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    4c74:	f00e fcec 	bl	13650 <bt_le_conn_params_valid>
    4c78:	4604      	mov	r4, r0
    4c7a:	b910      	cbnz	r0, 4c82 <le_param_req+0x16>
		return false;
    4c7c:	2400      	movs	r4, #0
}
    4c7e:	4620      	mov	r0, r4
    4c80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (cb = callback_list; cb; cb = cb->_next) {
    4c82:	4b09      	ldr	r3, [pc, #36]	; (4ca8 <le_param_req+0x3c>)
    4c84:	681e      	ldr	r6, [r3, #0]
    4c86:	2e00      	cmp	r6, #0
    4c88:	d0f9      	beq.n	4c7e <le_param_req+0x12>
		if (!cb->le_param_req) {
    4c8a:	68b3      	ldr	r3, [r6, #8]
    4c8c:	b90b      	cbnz	r3, 4c92 <le_param_req+0x26>
	for (cb = callback_list; cb; cb = cb->_next) {
    4c8e:	6936      	ldr	r6, [r6, #16]
    4c90:	e7f9      	b.n	4c86 <le_param_req+0x1a>
		if (!cb->le_param_req(conn, param)) {
    4c92:	4629      	mov	r1, r5
    4c94:	4638      	mov	r0, r7
    4c96:	4798      	blx	r3
    4c98:	2800      	cmp	r0, #0
    4c9a:	d0ef      	beq.n	4c7c <le_param_req+0x10>
		if (!bt_le_conn_params_valid(param)) {
    4c9c:	4628      	mov	r0, r5
    4c9e:	f00e fcd7 	bl	13650 <bt_le_conn_params_valid>
    4ca2:	2800      	cmp	r0, #0
    4ca4:	d1f3      	bne.n	4c8e <le_param_req+0x22>
    4ca6:	e7e9      	b.n	4c7c <le_param_req+0x10>
    4ca8:	20025a78 	.word	0x20025a78

00004cac <bt_conn_cb_register>:
	cb->_next = callback_list;
    4cac:	4b02      	ldr	r3, [pc, #8]	; (4cb8 <bt_conn_cb_register+0xc>)
    4cae:	681a      	ldr	r2, [r3, #0]
	callback_list = cb;
    4cb0:	6018      	str	r0, [r3, #0]
	cb->_next = callback_list;
    4cb2:	6102      	str	r2, [r0, #16]
}
    4cb4:	4770      	bx	lr
    4cb6:	bf00      	nop
    4cb8:	20025a78 	.word	0x20025a78

00004cbc <conn_cleanup>:

static struct k_poll_signal conn_change =
		K_POLL_SIGNAL_INITIALIZER(conn_change);

static void conn_cleanup(struct bt_conn *conn)
{
    4cbc:	b570      	push	{r4, r5, r6, lr}
    4cbe:	4604      	mov	r4, r0
	struct net_buf *buf;

	/* Give back any allocated buffers */
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
    4cc0:	f100 0634 	add.w	r6, r0, #52	; 0x34
    4cc4:	2200      	movs	r2, #0
    4cc6:	2300      	movs	r3, #0
    4cc8:	4630      	mov	r0, r6
    4cca:	f010 f836 	bl	14d3a <net_buf_get>
    4cce:	4605      	mov	r5, r0
    4cd0:	b958      	cbnz	r0, 4cea <conn_cleanup+0x2e>
	}

	__ASSERT(sys_slist_is_empty(&conn->tx_pending), "Pending TX packets");
	__ASSERT_NO_MSG(conn->pending_no_cb == 0);

	bt_conn_reset_rx_state(conn);
    4cd2:	4620      	mov	r0, r4
    4cd4:	f00e fe53 	bl	1397e <bt_conn_reset_rx_state>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    4cd8:	f104 0158 	add.w	r1, r4, #88	; 0x58
    4cdc:	2200      	movs	r2, #0

	k_delayed_work_submit(&conn->deferred_work, K_NO_WAIT);
}
    4cde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    4ce2:	2300      	movs	r3, #0
    4ce4:	4805      	ldr	r0, [pc, #20]	; (4cfc <conn_cleanup+0x40>)
    4ce6:	f00c b9b1 	b.w	1104c <k_delayed_work_submit_to_queue>
		if (tx_data(buf)->tx) {
    4cea:	6968      	ldr	r0, [r5, #20]
    4cec:	b108      	cbz	r0, 4cf2 <conn_cleanup+0x36>
			tx_free(tx_data(buf)->tx);
    4cee:	f7ff fedf 	bl	4ab0 <tx_free>
		net_buf_unref(buf);
    4cf2:	4628      	mov	r0, r5
    4cf4:	f001 fe2c 	bl	6950 <net_buf_unref>
    4cf8:	e7e4      	b.n	4cc4 <conn_cleanup+0x8>
    4cfa:	bf00      	nop
    4cfc:	20001168 	.word	0x20001168

00004d00 <bt_conn_send_cb>:
{
    4d00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4d04:	4698      	mov	r8, r3
	if (conn->state != BT_CONN_CONNECTED) {
    4d06:	7a83      	ldrb	r3, [r0, #10]
{
    4d08:	4606      	mov	r6, r0
	if (conn->state != BT_CONN_CONNECTED) {
    4d0a:	2b07      	cmp	r3, #7
{
    4d0c:	460d      	mov	r5, r1
    4d0e:	4617      	mov	r7, r2
	if (conn->state != BT_CONN_CONNECTED) {
    4d10:	d005      	beq.n	4d1e <bt_conn_send_cb+0x1e>
		net_buf_unref(buf);
    4d12:	4608      	mov	r0, r1
    4d14:	f001 fe1c 	bl	6950 <net_buf_unref>
			return -ENOTCONN;
    4d18:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    4d1c:	e015      	b.n	4d4a <bt_conn_send_cb+0x4a>
	if (cb) {
    4d1e:	b362      	cbz	r2, 4d7a <bt_conn_send_cb+0x7a>
	return z_impl_k_current_get();
    4d20:	f00c f832 	bl	10d88 <z_impl_k_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
    4d24:	4b16      	ldr	r3, [pc, #88]	; (4d80 <bt_conn_send_cb+0x80>)
    4d26:	4283      	cmp	r3, r0
	return z_impl_k_queue_get(queue, timeout);
    4d28:	4816      	ldr	r0, [pc, #88]	; (4d84 <bt_conn_send_cb+0x84>)
    4d2a:	bf07      	ittee	eq
    4d2c:	2200      	moveq	r2, #0
    4d2e:	2300      	moveq	r3, #0
    4d30:	f04f 32ff 	movne.w	r2, #4294967295
    4d34:	f04f 33ff 	movne.w	r3, #4294967295
    4d38:	f00b fc5a 	bl	105f0 <z_impl_k_queue_get>
    4d3c:	4604      	mov	r4, r0
		if (!tx) {
    4d3e:	b930      	cbnz	r0, 4d4e <bt_conn_send_cb+0x4e>
			net_buf_unref(buf);
    4d40:	4628      	mov	r0, r5
    4d42:	f001 fe05 	bl	6950 <net_buf_unref>
			return -ENOBUFS;
    4d46:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
    4d4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (conn->state != BT_CONN_CONNECTED) {
    4d4e:	7ab3      	ldrb	r3, [r6, #10]
    4d50:	2b07      	cmp	r3, #7
    4d52:	d006      	beq.n	4d62 <bt_conn_send_cb+0x62>
			net_buf_unref(buf);
    4d54:	4628      	mov	r0, r5
    4d56:	f001 fdfb 	bl	6950 <net_buf_unref>
			tx_free(tx);
    4d5a:	4620      	mov	r0, r4
    4d5c:	f7ff fea8 	bl	4ab0 <tx_free>
    4d60:	e7da      	b.n	4d18 <bt_conn_send_cb+0x18>
		tx->pending_no_cb = 0U;
    4d62:	2300      	movs	r3, #0
		tx->user_data = user_data;
    4d64:	e9c0 7801 	strd	r7, r8, [r0, #4]
		tx->pending_no_cb = 0U;
    4d68:	60c3      	str	r3, [r0, #12]
		tx_data(buf)->tx = tx;
    4d6a:	6168      	str	r0, [r5, #20]
	net_buf_put(&conn->tx_queue, buf);
    4d6c:	f106 0034 	add.w	r0, r6, #52	; 0x34
    4d70:	4629      	mov	r1, r5
    4d72:	f010 f800 	bl	14d76 <net_buf_put>
	return 0;
    4d76:	2000      	movs	r0, #0
    4d78:	e7e7      	b.n	4d4a <bt_conn_send_cb+0x4a>
		tx_data(buf)->tx = NULL;
    4d7a:	614a      	str	r2, [r1, #20]
    4d7c:	e7f6      	b.n	4d6c <bt_conn_send_cb+0x6c>
    4d7e:	bf00      	nop
    4d80:	20001180 	.word	0x20001180
    4d84:	20000880 	.word	0x20000880

00004d88 <bt_conn_prepare_events>:

	return 0;
}

int bt_conn_prepare_events(struct k_poll_event events[])
{
    4d88:	b538      	push	{r3, r4, r5, lr}
	int i, ev_count = 0;
	struct bt_conn *conn;

	BT_DBG("");

	conn_change.signaled = 0U;
    4d8a:	2200      	movs	r2, #0
{
    4d8c:	4604      	mov	r4, r0
	conn_change.signaled = 0U;
    4d8e:	4b17      	ldr	r3, [pc, #92]	; (4dec <bt_conn_prepare_events+0x64>)
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    4d90:	2101      	movs	r1, #1
	conn_change.signaled = 0U;
    4d92:	609a      	str	r2, [r3, #8]
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    4d94:	f018 fd91 	bl	1d8ba <k_poll_event_init>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4d98:	4b15      	ldr	r3, [pc, #84]	; (4df0 <bt_conn_prepare_events+0x68>)
			  K_POLL_MODE_NOTIFY_ONLY, &conn_change);

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
		conn = &acl_conns[i];

		if (!conn_prepare_events(conn, &events[ev_count])) {
    4d9a:	f104 0014 	add.w	r0, r4, #20
    4d9e:	f103 02b8 	add.w	r2, r3, #184	; 0xb8
    4da2:	e8d2 2faf 	lda	r2, [r2]
    4da6:	4619      	mov	r1, r3
	if (!atomic_get(&conn->ref)) {
    4da8:	b90a      	cbnz	r2, 4dae <bt_conn_prepare_events+0x26>
		conn_cleanup(conn);
    4daa:	2001      	movs	r0, #1
		}
	}
#endif

	return ev_count;
}
    4dac:	bd38      	pop	{r3, r4, r5, pc}
	if (conn->state == BT_CONN_DISCONNECTED &&
    4dae:	7a9a      	ldrb	r2, [r3, #10]
    4db0:	b97a      	cbnz	r2, 4dd2 <bt_conn_prepare_events+0x4a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4db2:	1d1a      	adds	r2, r3, #4
    4db4:	e8d2 5fef 	ldaex	r5, [r2]
    4db8:	f025 0c40 	bic.w	ip, r5, #64	; 0x40
    4dbc:	e8c2 cfee 	stlex	lr, ip, [r2]
    4dc0:	f1be 0f00 	cmp.w	lr, #0
    4dc4:	d1f6      	bne.n	4db4 <bt_conn_prepare_events+0x2c>
    4dc6:	066a      	lsls	r2, r5, #25
    4dc8:	d503      	bpl.n	4dd2 <bt_conn_prepare_events+0x4a>
		conn_cleanup(conn);
    4dca:	4618      	mov	r0, r3
    4dcc:	f7ff ff76 	bl	4cbc <conn_cleanup>
    4dd0:	e7eb      	b.n	4daa <bt_conn_prepare_events+0x22>
	if (conn->state != BT_CONN_CONNECTED) {
    4dd2:	7a8b      	ldrb	r3, [r1, #10]
    4dd4:	2b07      	cmp	r3, #7
    4dd6:	d1e8      	bne.n	4daa <bt_conn_prepare_events+0x22>
	k_poll_event_init(&events[0],
    4dd8:	4b06      	ldr	r3, [pc, #24]	; (4df4 <bt_conn_prepare_events+0x6c>)
    4dda:	2200      	movs	r2, #0
    4ddc:	2104      	movs	r1, #4
    4dde:	f018 fd6c 	bl	1d8ba <k_poll_event_init>
	events[0].tag = BT_EVENT_CONN_TX_QUEUE;
    4de2:	2301      	movs	r3, #1
			ev_count++;
    4de4:	2002      	movs	r0, #2
	events[0].tag = BT_EVENT_CONN_TX_QUEUE;
    4de6:	f884 3020 	strb.w	r3, [r4, #32]
	return ev_count;
    4dea:	e7df      	b.n	4dac <bt_conn_prepare_events+0x24>
    4dec:	20000340 	.word	0x20000340
    4df0:	20000d50 	.word	0x20000d50
    4df4:	20000d84 	.word	0x20000d84

00004df8 <bt_conn_add_le>:

	return false;
}

struct bt_conn *bt_conn_add_le(uint8_t id, const bt_addr_le_t *peer)
{
    4df8:	b570      	push	{r4, r5, r6, lr}
    4dfa:	4606      	mov	r6, r0
    4dfc:	460d      	mov	r5, r1
	conn = bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
    4dfe:	4811      	ldr	r0, [pc, #68]	; (4e44 <bt_conn_add_le+0x4c>)
    4e00:	2101      	movs	r1, #1
    4e02:	f00e fd97 	bl	13934 <bt_conn_new>
	if (!conn) {
    4e06:	4604      	mov	r4, r0
    4e08:	b1d0      	cbz	r0, 4e40 <bt_conn_add_le+0x48>
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
    4e0a:	2230      	movs	r2, #48	; 0x30
    4e0c:	2100      	movs	r1, #0
    4e0e:	3058      	adds	r0, #88	; 0x58
    4e10:	f018 fdb4 	bl	1d97c <memset>
    4e14:	4b0c      	ldr	r3, [pc, #48]	; (4e48 <bt_conn_add_le+0x50>)
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    4e16:	4a0d      	ldr	r2, [pc, #52]	; (4e4c <bt_conn_add_le+0x54>)
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
    4e18:	65e3      	str	r3, [r4, #92]	; 0x5c
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    4e1a:	2300      	movs	r3, #0
    4e1c:	e9c4 230b 	strd	r2, r3, [r4, #44]	; 0x2c
    4e20:	62a3      	str	r3, [r4, #40]	; 0x28

	if (!conn) {
		return NULL;
	}

	conn->id = id;
    4e22:	7226      	strb	r6, [r4, #8]
    4e24:	682b      	ldr	r3, [r5, #0]
    4e26:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    4e2a:	88ab      	ldrh	r3, [r5, #4]
    4e2c:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
    4e30:	79ab      	ldrb	r3, [r5, #6]
    4e32:	f884 308e 	strb.w	r3, [r4, #142]	; 0x8e
	bt_addr_le_copy(&conn->le.dst, peer);
#if defined(CONFIG_BT_SMP)
	conn->sec_level = BT_SECURITY_L1;
	conn->required_sec_level = BT_SECURITY_L1;
#endif /* CONFIG_BT_SMP */
	conn->type = BT_CONN_TYPE_LE;
    4e36:	2301      	movs	r3, #1
    4e38:	70a3      	strb	r3, [r4, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
    4e3a:	4b05      	ldr	r3, [pc, #20]	; (4e50 <bt_conn_add_le+0x58>)
    4e3c:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
    4e40:	4620      	mov	r0, r4
    4e42:	bd70      	pop	{r4, r5, r6, pc}
    4e44:	20000d50 	.word	0x20000d50
    4e48:	000050a1 	.word	0x000050a1
    4e4c:	0001392f 	.word	0x0001392f
    4e50:	00280018 	.word	0x00280018

00004e54 <bt_conn_lookup_handle>:
		break;
	}
}

struct bt_conn *bt_conn_lookup_handle(uint16_t handle)
{
    4e54:	4602      	mov	r2, r0
	struct bt_conn *conn;

	conn = conn_lookup_handle(acl_conns, ARRAY_SIZE(acl_conns), handle);
    4e56:	2101      	movs	r1, #1
{
    4e58:	b508      	push	{r3, lr}
	conn = conn_lookup_handle(acl_conns, ARRAY_SIZE(acl_conns), handle);
    4e5a:	4803      	ldr	r0, [pc, #12]	; (4e68 <bt_conn_lookup_handle+0x14>)
    4e5c:	f00e fe21 	bl	13aa2 <conn_lookup_handle>
		return conn;
	}
#endif

	return NULL;
}
    4e60:	2800      	cmp	r0, #0
    4e62:	bf38      	it	cc
    4e64:	2000      	movcc	r0, #0
    4e66:	bd08      	pop	{r3, pc}
    4e68:	20000d50 	.word	0x20000d50

00004e6c <bt_conn_set_state>:
{
    4e6c:	b570      	push	{r4, r5, r6, lr}
	if (conn->state == state) {
    4e6e:	7a85      	ldrb	r5, [r0, #10]
{
    4e70:	4604      	mov	r4, r0
	if (conn->state == state) {
    4e72:	428d      	cmp	r5, r1
    4e74:	f000 809d 	beq.w	4fb2 <bt_conn_set_state+0x146>
	conn->state = state;
    4e78:	7281      	strb	r1, [r0, #10]
	switch (old_state) {
    4e7a:	b90d      	cbnz	r5, 4e80 <bt_conn_set_state+0x14>
		bt_conn_ref(conn);
    4e7c:	f00e fdef 	bl	13a5e <bt_conn_ref>
	switch (conn->state) {
    4e80:	7aa3      	ldrb	r3, [r4, #10]
    4e82:	2b01      	cmp	r3, #1
    4e84:	d116      	bne.n	4eb4 <bt_conn_set_state+0x48>
		tx->pending_no_cb = 0U;
    4e86:	2600      	movs	r6, #0
	z_impl_k_sem_give(sem);
    4e88:	4d4a      	ldr	r5, [pc, #296]	; (4fb4 <bt_conn_set_state+0x148>)
	__asm__ volatile(
    4e8a:	f04f 0320 	mov.w	r3, #32
    4e8e:	f3ef 8211 	mrs	r2, BASEPRI
    4e92:	f383 8811 	msr	BASEPRI, r3
    4e96:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
    4e9a:	69e3      	ldr	r3, [r4, #28]
    4e9c:	2b00      	cmp	r3, #0
    4e9e:	d069      	beq.n	4f74 <bt_conn_set_state+0x108>
			conn->pending_no_cb--;
    4ea0:	3b01      	subs	r3, #1
    4ea2:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
    4ea4:	f382 8811 	msr	BASEPRI, r2
    4ea8:	f3bf 8f6f 	isb	sy
    4eac:	4628      	mov	r0, r5
    4eae:	f00b ff71 	bl	10d94 <z_impl_k_sem_give>
}
    4eb2:	e7ea      	b.n	4e8a <bt_conn_set_state+0x1e>
	switch (conn->state) {
    4eb4:	2b07      	cmp	r3, #7
    4eb6:	d009      	beq.n	4ecc <bt_conn_set_state+0x60>
    4eb8:	2b00      	cmp	r3, #0
    4eba:	d17a      	bne.n	4fb2 <bt_conn_set_state+0x146>
		if (conn->type == BT_CONN_TYPE_SCO) {
    4ebc:	78a3      	ldrb	r3, [r4, #2]
    4ebe:	2b04      	cmp	r3, #4
    4ec0:	d125      	bne.n	4f0e <bt_conn_set_state+0xa2>
			bt_conn_unref(conn);
    4ec2:	4620      	mov	r0, r4
}
    4ec4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			bt_conn_unref(conn);
    4ec8:	f00e bddd 	b.w	13a86 <bt_conn_unref>
		if (conn->type == BT_CONN_TYPE_SCO) {
    4ecc:	78a3      	ldrb	r3, [r4, #2]
    4ece:	2b04      	cmp	r3, #4
    4ed0:	d06f      	beq.n	4fb2 <bt_conn_set_state+0x146>
	z_impl_k_queue_init(queue);
    4ed2:	f104 0034 	add.w	r0, r4, #52	; 0x34
    4ed6:	f018 f93f 	bl	1d158 <z_impl_k_queue_init>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
    4eda:	2100      	movs	r1, #0
    4edc:	4836      	ldr	r0, [pc, #216]	; (4fb8 <bt_conn_set_state+0x14c>)
    4ede:	f00c fb5b 	bl	11598 <z_impl_k_poll_signal_raise>
	list->head = NULL;
    4ee2:	2300      	movs	r3, #0
		bt_l2cap_connected(conn);
    4ee4:	4620      	mov	r0, r4
	list->tail = NULL;
    4ee6:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
    4eea:	f000 fa13 	bl	5314 <bt_l2cap_connected>
		notify_connected(conn);
    4eee:	4620      	mov	r0, r4
    4ef0:	f7ff fde8 	bl	4ac4 <notify_connected>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    4ef4:	78e3      	ldrb	r3, [r4, #3]
    4ef6:	2b01      	cmp	r3, #1
    4ef8:	d15b      	bne.n	4fb2 <bt_conn_set_state+0x146>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    4efa:	f104 0158 	add.w	r1, r4, #88	; 0x58
    4efe:	f44f 3220 	mov.w	r2, #163840	; 0x28000
}
    4f02:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    4f06:	2300      	movs	r3, #0
    4f08:	482c      	ldr	r0, [pc, #176]	; (4fbc <bt_conn_set_state+0x150>)
    4f0a:	f00c b89f 	b.w	1104c <k_delayed_work_submit_to_queue>
		switch (old_state) {
    4f0e:	3d01      	subs	r5, #1
    4f10:	2d05      	cmp	r5, #5
    4f12:	d84e      	bhi.n	4fb2 <bt_conn_set_state+0x146>
    4f14:	a301      	add	r3, pc, #4	; (adr r3, 4f1c <bt_conn_set_state+0xb0>)
    4f16:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
    4f1a:	bf00      	nop
    4f1c:	00004f35 	.word	0x00004f35
    4f20:	00004f67 	.word	0x00004f67
    4f24:	00004ec3 	.word	0x00004ec3
    4f28:	00004ec3 	.word	0x00004ec3
    4f2c:	00004f67 	.word	0x00004f67
    4f30:	00004f67 	.word	0x00004f67
			tx_notify(conn);
    4f34:	4620      	mov	r0, r4
    4f36:	f00e fcd7 	bl	138e8 <tx_notify>
			if (conn->type == BT_CONN_TYPE_LE) {
    4f3a:	78a3      	ldrb	r3, [r4, #2]
    4f3c:	2b01      	cmp	r3, #1
    4f3e:	d103      	bne.n	4f48 <bt_conn_set_state+0xdc>
				k_delayed_work_cancel(&conn->deferred_work);
    4f40:	f104 0058 	add.w	r0, r4, #88	; 0x58
    4f44:	f018 fad6 	bl	1d4f4 <k_delayed_work_cancel>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4f48:	3404      	adds	r4, #4
    4f4a:	e8d4 3fef 	ldaex	r3, [r4]
    4f4e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4f52:	e8c4 3fe2 	stlex	r2, r3, [r4]
    4f56:	2a00      	cmp	r2, #0
    4f58:	d1f7      	bne.n	4f4a <bt_conn_set_state+0xde>
}
    4f5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    4f5e:	2100      	movs	r1, #0
    4f60:	4815      	ldr	r0, [pc, #84]	; (4fb8 <bt_conn_set_state+0x14c>)
    4f62:	f00c bb19 	b.w	11598 <z_impl_k_poll_signal_raise>
			if (conn->err) {
    4f66:	7a63      	ldrb	r3, [r4, #9]
    4f68:	2b00      	cmp	r3, #0
    4f6a:	d0aa      	beq.n	4ec2 <bt_conn_set_state+0x56>
				notify_connected(conn);
    4f6c:	4620      	mov	r0, r4
    4f6e:	f7ff fda9 	bl	4ac4 <notify_connected>
    4f72:	e7a6      	b.n	4ec2 <bt_conn_set_state+0x56>
Z_GENLIST_IS_EMPTY(slist)
    4f74:	6960      	ldr	r0, [r4, #20]
Z_GENLIST_GET(slist, snode)
    4f76:	b128      	cbz	r0, 4f84 <bt_conn_set_state+0x118>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4f78:	69a1      	ldr	r1, [r4, #24]
    4f7a:	6803      	ldr	r3, [r0, #0]
    4f7c:	4288      	cmp	r0, r1
	list->head = node;
    4f7e:	6163      	str	r3, [r4, #20]
	list->tail = node;
    4f80:	bf08      	it	eq
    4f82:	61a3      	streq	r3, [r4, #24]
    4f84:	f382 8811 	msr	BASEPRI, r2
    4f88:	f3bf 8f6f 	isb	sy
		if (!node) {
    4f8c:	b188      	cbz	r0, 4fb2 <bt_conn_set_state+0x146>
	__asm__ volatile(
    4f8e:	f04f 0220 	mov.w	r2, #32
    4f92:	f3ef 8311 	mrs	r3, BASEPRI
    4f96:	f382 8811 	msr	BASEPRI, r2
    4f9a:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
    4f9e:	68c2      	ldr	r2, [r0, #12]
    4fa0:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
    4fa2:	60c6      	str	r6, [r0, #12]
	__asm__ volatile(
    4fa4:	f383 8811 	msr	BASEPRI, r3
    4fa8:	f3bf 8f6f 	isb	sy
		tx_free(tx);
    4fac:	f7ff fd80 	bl	4ab0 <tx_free>
    4fb0:	e77c      	b.n	4eac <bt_conn_set_state+0x40>
}
    4fb2:	bd70      	pop	{r4, r5, r6, pc}
    4fb4:	200000c8 	.word	0x200000c8
    4fb8:	20000340 	.word	0x20000340
    4fbc:	20001168 	.word	0x20001168

00004fc0 <bt_conn_lookup_addr_le>:

	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
}

struct bt_conn *bt_conn_lookup_addr_le(uint8_t id, const bt_addr_le_t *peer)
{
    4fc0:	b570      	push	{r4, r5, r6, lr}
    4fc2:	4605      	mov	r5, r0
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    4fc4:	480c      	ldr	r0, [pc, #48]	; (4ff8 <bt_conn_lookup_addr_le+0x38>)
{
    4fc6:	460e      	mov	r6, r1
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    4fc8:	f00e fd49 	bl	13a5e <bt_conn_ref>

		if (!conn) {
    4fcc:	4604      	mov	r4, r0
    4fce:	b128      	cbz	r0, 4fdc <bt_conn_lookup_addr_le+0x1c>
			continue;
		}

		if (conn->type != BT_CONN_TYPE_LE) {
    4fd0:	7883      	ldrb	r3, [r0, #2]
    4fd2:	2b01      	cmp	r3, #1
    4fd4:	d004      	beq.n	4fe0 <bt_conn_lookup_addr_le+0x20>
			bt_conn_unref(conn);
    4fd6:	f00e fd56 	bl	13a86 <bt_conn_unref>
		}

		return conn;
	}

	return NULL;
    4fda:	2400      	movs	r4, #0
}
    4fdc:	4620      	mov	r0, r4
    4fde:	bd70      	pop	{r4, r5, r6, pc}
		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
    4fe0:	4629      	mov	r1, r5
    4fe2:	4632      	mov	r2, r6
    4fe4:	f00e fd1b 	bl	13a1e <bt_conn_is_peer_addr_le>
    4fe8:	4605      	mov	r5, r0
    4fea:	2800      	cmp	r0, #0
    4fec:	d1f6      	bne.n	4fdc <bt_conn_lookup_addr_le+0x1c>
			bt_conn_unref(conn);
    4fee:	4620      	mov	r0, r4
    4ff0:	f00e fd49 	bl	13a86 <bt_conn_unref>
	return NULL;
    4ff4:	462c      	mov	r4, r5
			continue;
    4ff6:	e7f1      	b.n	4fdc <bt_conn_lookup_addr_le+0x1c>
    4ff8:	20000d50 	.word	0x20000d50

00004ffc <bt_conn_lookup_state_le>:

struct bt_conn *bt_conn_lookup_state_le(uint8_t id, const bt_addr_le_t *peer,
					const bt_conn_state_t state)
{
    4ffc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4ffe:	4605      	mov	r5, r0
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    5000:	480f      	ldr	r0, [pc, #60]	; (5040 <bt_conn_lookup_state_le+0x44>)
{
    5002:	460e      	mov	r6, r1
    5004:	4617      	mov	r7, r2
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    5006:	f00e fd2a 	bl	13a5e <bt_conn_ref>

		if (!conn) {
    500a:	4604      	mov	r4, r0
    500c:	b1b0      	cbz	r0, 503c <bt_conn_lookup_state_le+0x40>
			continue;
		}

		if (conn->type != BT_CONN_TYPE_LE) {
    500e:	7883      	ldrb	r3, [r0, #2]
    5010:	2b01      	cmp	r3, #1
    5012:	d003      	beq.n	501c <bt_conn_lookup_state_le+0x20>
			bt_conn_ref(conn);
    5014:	f00e fd23 	bl	13a5e <bt_conn_ref>
		}

		return conn;
	}

	return NULL;
    5018:	2400      	movs	r4, #0
			continue;
    501a:	e00f      	b.n	503c <bt_conn_lookup_state_le+0x40>
		if (peer && !bt_conn_is_peer_addr_le(conn, id, peer)) {
    501c:	b146      	cbz	r6, 5030 <bt_conn_lookup_state_le+0x34>
    501e:	4632      	mov	r2, r6
    5020:	4629      	mov	r1, r5
    5022:	f00e fcfc 	bl	13a1e <bt_conn_is_peer_addr_le>
    5026:	b918      	cbnz	r0, 5030 <bt_conn_lookup_state_le+0x34>
			bt_conn_unref(conn);
    5028:	4620      	mov	r0, r4
    502a:	f00e fd2c 	bl	13a86 <bt_conn_unref>
    502e:	e7f3      	b.n	5018 <bt_conn_lookup_state_le+0x1c>
		if (!(conn->state == state && conn->id == id)) {
    5030:	7aa3      	ldrb	r3, [r4, #10]
    5032:	42bb      	cmp	r3, r7
    5034:	d1f8      	bne.n	5028 <bt_conn_lookup_state_le+0x2c>
    5036:	7a23      	ldrb	r3, [r4, #8]
    5038:	42ab      	cmp	r3, r5
    503a:	d1f5      	bne.n	5028 <bt_conn_lookup_state_le+0x2c>
}
    503c:	4620      	mov	r0, r4
    503e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5040:	20000d50 	.word	0x20000d50

00005044 <send_conn_le_param_update>:
{
    5044:	b538      	push	{r3, r4, r5, lr}
    5046:	4604      	mov	r4, r0
	if (!bt_le_conn_params_valid(param)) {
    5048:	4608      	mov	r0, r1
{
    504a:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    504c:	f00e fb00 	bl	13650 <bt_le_conn_params_valid>
    5050:	b308      	cbz	r0, 5096 <send_conn_le_param_update+0x52>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    5052:	4b12      	ldr	r3, [pc, #72]	; (509c <send_conn_le_param_update+0x58>)
    5054:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
    5058:	0799      	lsls	r1, r3, #30
    505a:	d407      	bmi.n	506c <send_conn_le_param_update+0x28>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
    505c:	78e3      	ldrb	r3, [r4, #3]
    505e:	b173      	cbz	r3, 507e <send_conn_le_param_update+0x3a>
	return bt_l2cap_update_conn_param(conn, param);
    5060:	4629      	mov	r1, r5
    5062:	4620      	mov	r0, r4
}
    5064:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_l2cap_update_conn_param(conn, param);
    5068:	f000 b9aa 	b.w	53c0 <bt_l2cap_update_conn_param>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    506c:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
    5070:	079a      	lsls	r2, r3, #30
    5072:	d5f3      	bpl.n	505c <send_conn_le_param_update+0x18>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    5074:	1d23      	adds	r3, r4, #4
    5076:	e8d3 3faf 	lda	r3, [r3]
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
    507a:	055b      	lsls	r3, r3, #21
    507c:	d4ee      	bmi.n	505c <send_conn_le_param_update+0x18>
		rc = bt_conn_le_conn_update(conn, param);
    507e:	4629      	mov	r1, r5
    5080:	4620      	mov	r0, r4
    5082:	f00e fd38 	bl	13af6 <bt_conn_le_conn_update>
		if (rc == 0) {
    5086:	b928      	cbnz	r0, 5094 <send_conn_le_param_update+0x50>
			conn->le.pending_latency = param->latency;
    5088:	88ab      	ldrh	r3, [r5, #4]
    508a:	f8a4 30a8 	strh.w	r3, [r4, #168]	; 0xa8
			conn->le.pending_timeout = param->timeout;
    508e:	88eb      	ldrh	r3, [r5, #6]
    5090:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
}
    5094:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    5096:	f06f 0015 	mvn.w	r0, #21
    509a:	e7fb      	b.n	5094 <send_conn_le_param_update+0x50>
    509c:	20000000 	.word	0x20000000

000050a0 <deferred_work>:
{
    50a0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (conn->state == BT_CONN_DISCONNECTED) {
    50a2:	f810 3c4e 	ldrb.w	r3, [r0, #-78]
{
    50a6:	4604      	mov	r4, r0
	struct bt_conn *conn = CONTAINER_OF(work, struct bt_conn, deferred_work);
    50a8:	f1a0 0658 	sub.w	r6, r0, #88	; 0x58
	if (conn->state == BT_CONN_DISCONNECTED) {
    50ac:	b993      	cbnz	r3, 50d4 <deferred_work+0x34>
		bt_l2cap_disconnected(conn);
    50ae:	4630      	mov	r0, r6
    50b0:	f00e fda4 	bl	13bfc <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
    50b4:	4b1b      	ldr	r3, [pc, #108]	; (5124 <deferred_work+0x84>)
    50b6:	681d      	ldr	r5, [r3, #0]
    50b8:	b925      	cbnz	r5, 50c4 <deferred_work+0x24>
		bt_conn_unref(conn);
    50ba:	4630      	mov	r0, r6
    50bc:	f00e fce3 	bl	13a86 <bt_conn_unref>
}
    50c0:	b002      	add	sp, #8
    50c2:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->disconnected) {
    50c4:	686b      	ldr	r3, [r5, #4]
    50c6:	b11b      	cbz	r3, 50d0 <deferred_work+0x30>
			cb->disconnected(conn, conn->err);
    50c8:	4630      	mov	r0, r6
    50ca:	f814 1c4f 	ldrb.w	r1, [r4, #-79]
    50ce:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    50d0:	692d      	ldr	r5, [r5, #16]
    50d2:	e7f1      	b.n	50b8 <deferred_work+0x18>
	if (conn->type != BT_CONN_TYPE_LE) {
    50d4:	f810 3c56 	ldrb.w	r3, [r0, #-86]
    50d8:	2b01      	cmp	r3, #1
    50da:	d1f1      	bne.n	50c0 <deferred_work+0x20>
	if (atomic_test_and_clear_bit(conn->flags,
    50dc:	f1a0 0554 	sub.w	r5, r0, #84	; 0x54
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    50e0:	e8d5 3fef 	ldaex	r3, [r5]
    50e4:	f423 7200 	bic.w	r2, r3, #512	; 0x200
    50e8:	e8c5 2fe1 	stlex	r1, r2, [r5]
    50ec:	2900      	cmp	r1, #0
    50ee:	d1f7      	bne.n	50e0 <deferred_work+0x40>
    50f0:	059b      	lsls	r3, r3, #22
    50f2:	d510      	bpl.n	5116 <deferred_work+0x76>
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
    50f4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    50f6:	9300      	str	r3, [sp, #0]
    50f8:	6d23      	ldr	r3, [r4, #80]	; 0x50
    50fa:	9301      	str	r3, [sp, #4]
		send_conn_le_param_update(conn, param);
    50fc:	4669      	mov	r1, sp
    50fe:	4630      	mov	r0, r6
    5100:	f7ff ffa0 	bl	5044 <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    5104:	e8d5 3fef 	ldaex	r3, [r5]
    5108:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    510c:	e8c5 3fe2 	stlex	r2, r3, [r5]
    5110:	2a00      	cmp	r2, #0
    5112:	d0d5      	beq.n	50c0 <deferred_work+0x20>
    5114:	e7f6      	b.n	5104 <deferred_work+0x64>
		param = BT_LE_CONN_PARAM(
    5116:	466b      	mov	r3, sp
    5118:	4a03      	ldr	r2, [pc, #12]	; (5128 <deferred_work+0x88>)
    511a:	6810      	ldr	r0, [r2, #0]
    511c:	6851      	ldr	r1, [r2, #4]
    511e:	c303      	stmia	r3!, {r0, r1}
    5120:	e7ec      	b.n	50fc <deferred_work+0x5c>
    5122:	bf00      	nop
    5124:	20025a78 	.word	0x20025a78
    5128:	0001dd78 	.word	0x0001dd78

0000512c <bt_conn_create_pdu_timeout>:
						 const char *func, int line)
#else
struct net_buf *bt_conn_create_pdu_timeout(struct net_buf_pool *pool,
					   size_t reserve, k_timeout_t timeout)
#endif
{
    512c:	b538      	push	{r3, r4, r5, lr}
    512e:	460d      	mov	r5, r1
	return net_buf_alloc_fixed(pool, timeout);
    5130:	4906      	ldr	r1, [pc, #24]	; (514c <bt_conn_create_pdu_timeout+0x20>)
    5132:	2800      	cmp	r0, #0
    5134:	bf08      	it	eq
    5136:	4608      	moveq	r0, r1
    5138:	f00f fdfa 	bl	14d30 <net_buf_alloc_fixed>
#else
		buf = net_buf_alloc(pool, timeout);
#endif
	}

	if (!buf) {
    513c:	4604      	mov	r4, r0
    513e:	b118      	cbz	r0, 5148 <bt_conn_create_pdu_timeout+0x1c>
	net_buf_simple_reserve(&buf->b, reserve);
    5140:	1d69      	adds	r1, r5, #5
    5142:	3008      	adds	r0, #8
    5144:	f00f fe13 	bl	14d6e <net_buf_simple_reserve>

	reserve += sizeof(struct bt_hci_acl_hdr) + BT_BUF_RESERVE;
	net_buf_reserve(buf, reserve);

	return buf;
}
    5148:	4620      	mov	r0, r4
    514a:	bd38      	pop	{r3, r4, r5, pc}
    514c:	200008c0 	.word	0x200008c0

00005150 <bt_conn_create_frag_timeout>:
{
    5150:	4601      	mov	r1, r0
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
    5152:	4801      	ldr	r0, [pc, #4]	; (5158 <bt_conn_create_frag_timeout+0x8>)
    5154:	f7ff bfea 	b.w	512c <bt_conn_create_pdu_timeout>
    5158:	20000910 	.word	0x20000910

0000515c <create_frag.isra.0>:
static struct net_buf *create_frag(struct bt_conn *conn, struct net_buf *buf)
    515c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5160:	4606      	mov	r6, r0
		frag = bt_conn_create_frag(0);
    5162:	f04f 33ff 	mov.w	r3, #4294967295
    5166:	f04f 32ff 	mov.w	r2, #4294967295
    516a:	2000      	movs	r0, #0
static struct net_buf *create_frag(struct bt_conn *conn, struct net_buf *buf)
    516c:	460c      	mov	r4, r1
		frag = bt_conn_create_frag(0);
    516e:	f7ff ffef 	bl	5150 <bt_conn_create_frag_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
    5172:	7833      	ldrb	r3, [r6, #0]
		frag = bt_conn_create_frag(0);
    5174:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
    5176:	2b07      	cmp	r3, #7
    5178:	f04f 0600 	mov.w	r6, #0
    517c:	d005      	beq.n	518a <create_frag.isra.0+0x2e>
		net_buf_unref(frag);
    517e:	f001 fbe7 	bl	6950 <net_buf_unref>
		return NULL;
    5182:	4635      	mov	r5, r6
}
    5184:	4628      	mov	r0, r5
    5186:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tx_data(frag)->tx = NULL;
    518a:	6146      	str	r6, [r0, #20]
 *
 * @return Number of bytes available at the end of the buffer.
 */
static inline size_t net_buf_tailroom(struct net_buf *buf)
{
	return net_buf_simple_tailroom(&buf->b);
    518c:	f100 0708 	add.w	r7, r0, #8
	return bt_dev.le.acl_mtu;
    5190:	4e0c      	ldr	r6, [pc, #48]	; (51c4 <create_frag.isra.0+0x68>)
    5192:	4638      	mov	r0, r7
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    5194:	f8b6 80c4 	ldrh.w	r8, [r6, #196]	; 0xc4
    5198:	f00f fe65 	bl	14e66 <net_buf_simple_tailroom>
    519c:	4580      	cmp	r8, r0
    519e:	d20c      	bcs.n	51ba <create_frag.isra.0+0x5e>
	return bt_dev.le.acl_mtu;
    51a0:	f8b6 60c4 	ldrh.w	r6, [r6, #196]	; 0xc4
	return net_buf_simple_add_mem(&buf->b, mem, len);
    51a4:	f854 1f08 	ldr.w	r1, [r4, #8]!
    51a8:	4632      	mov	r2, r6
    51aa:	4638      	mov	r0, r7
    51ac:	f00f fe1c 	bl	14de8 <net_buf_simple_add_mem>
	return net_buf_simple_pull(&buf->b, len);
    51b0:	4631      	mov	r1, r6
    51b2:	4620      	mov	r0, r4
    51b4:	f00f fe3b 	bl	14e2e <net_buf_simple_pull>
    51b8:	e7e4      	b.n	5184 <create_frag.isra.0+0x28>
	return net_buf_simple_tailroom(&buf->b);
    51ba:	4638      	mov	r0, r7
    51bc:	f00f fe53 	bl	14e66 <net_buf_simple_tailroom>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    51c0:	b286      	uxth	r6, r0
    51c2:	e7ef      	b.n	51a4 <create_frag.isra.0+0x48>
    51c4:	20000000 	.word	0x20000000

000051c8 <bt_conn_process_tx>:
{
    51c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conn->state == BT_CONN_DISCONNECTED &&
    51ca:	7a83      	ldrb	r3, [r0, #10]
{
    51cc:	4605      	mov	r5, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
    51ce:	b973      	cbnz	r3, 51ee <bt_conn_process_tx+0x26>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    51d0:	1d03      	adds	r3, r0, #4
    51d2:	e8d3 2fef 	ldaex	r2, [r3]
    51d6:	f022 0140 	bic.w	r1, r2, #64	; 0x40
    51da:	e8c3 1fe4 	stlex	r4, r1, [r3]
    51de:	2c00      	cmp	r4, #0
    51e0:	d1f7      	bne.n	51d2 <bt_conn_process_tx+0xa>
    51e2:	0653      	lsls	r3, r2, #25
    51e4:	d503      	bpl.n	51ee <bt_conn_process_tx+0x26>
}
    51e6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		conn_cleanup(conn);
    51ea:	f7ff bd67 	b.w	4cbc <conn_cleanup>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
    51ee:	2200      	movs	r2, #0
    51f0:	2300      	movs	r3, #0
    51f2:	f105 0034 	add.w	r0, r5, #52	; 0x34
    51f6:	f00f fda0 	bl	14d3a <net_buf_get>
	BT_ASSERT(buf);
    51fa:	4604      	mov	r4, r0
    51fc:	b960      	cbnz	r0, 5218 <bt_conn_process_tx+0x50>
    51fe:	f240 535f 	movw	r3, #1375	; 0x55f
    5202:	4a1f      	ldr	r2, [pc, #124]	; (5280 <bt_conn_process_tx+0xb8>)
    5204:	491f      	ldr	r1, [pc, #124]	; (5284 <bt_conn_process_tx+0xbc>)
    5206:	4820      	ldr	r0, [pc, #128]	; (5288 <bt_conn_process_tx+0xc0>)
    5208:	f00c fb9a 	bl	11940 <printk>
    520c:	4040      	eors	r0, r0
    520e:	f380 8811 	msr	BASEPRI, r0
    5212:	f04f 0003 	mov.w	r0, #3
    5216:	df02      	svc	2
	return bt_dev.le.acl_mtu;
    5218:	4f1c      	ldr	r7, [pc, #112]	; (528c <bt_conn_process_tx+0xc4>)
	if (buf->len <= conn_mtu(conn)) {
    521a:	89a1      	ldrh	r1, [r4, #12]
    521c:	f8b7 20c4 	ldrh.w	r2, [r7, #196]	; 0xc4
    5220:	4291      	cmp	r1, r2
    5222:	d807      	bhi.n	5234 <bt_conn_process_tx+0x6c>
		return send_frag(conn, buf, FRAG_SINGLE, false);
    5224:	2300      	movs	r3, #0
    5226:	2202      	movs	r2, #2
	return send_frag(conn, buf, FRAG_END, false);
    5228:	4621      	mov	r1, r4
    522a:	4628      	mov	r0, r5
    522c:	f7ff fc60 	bl	4af0 <send_frag>
	if (!send_buf(conn, buf)) {
    5230:	b140      	cbz	r0, 5244 <bt_conn_process_tx+0x7c>
}
    5232:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	frag = create_frag(conn, buf);
    5234:	f105 060a 	add.w	r6, r5, #10
    5238:	4621      	mov	r1, r4
    523a:	4630      	mov	r0, r6
    523c:	f7ff ff8e 	bl	515c <create_frag.isra.0>
	if (!frag) {
    5240:	4601      	mov	r1, r0
    5242:	b920      	cbnz	r0, 524e <bt_conn_process_tx+0x86>
		net_buf_unref(buf);
    5244:	4620      	mov	r0, r4
}
    5246:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		net_buf_unref(buf);
    524a:	f001 bb81 	b.w	6950 <net_buf_unref>
	if (!send_frag(conn, frag, FRAG_START, true)) {
    524e:	2301      	movs	r3, #1
    5250:	2200      	movs	r2, #0
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
    5252:	4628      	mov	r0, r5
    5254:	f7ff fc4c 	bl	4af0 <send_frag>
    5258:	2800      	cmp	r0, #0
    525a:	d0f3      	beq.n	5244 <bt_conn_process_tx+0x7c>
	while (buf->len > conn_mtu(conn)) {
    525c:	89a2      	ldrh	r2, [r4, #12]
    525e:	f8b7 30c4 	ldrh.w	r3, [r7, #196]	; 0xc4
    5262:	429a      	cmp	r2, r3
    5264:	d802      	bhi.n	526c <bt_conn_process_tx+0xa4>
	return send_frag(conn, buf, FRAG_END, false);
    5266:	2300      	movs	r3, #0
    5268:	2203      	movs	r2, #3
    526a:	e7dd      	b.n	5228 <bt_conn_process_tx+0x60>
		frag = create_frag(conn, buf);
    526c:	4621      	mov	r1, r4
    526e:	4630      	mov	r0, r6
    5270:	f7ff ff74 	bl	515c <create_frag.isra.0>
		if (!frag) {
    5274:	4601      	mov	r1, r0
    5276:	2800      	cmp	r0, #0
    5278:	d0e4      	beq.n	5244 <bt_conn_process_tx+0x7c>
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
    527a:	2301      	movs	r3, #1
    527c:	461a      	mov	r2, r3
    527e:	e7e8      	b.n	5252 <bt_conn_process_tx+0x8a>
    5280:	00043ebe 	.word	0x00043ebe
    5284:	00043e95 	.word	0x00043e95
    5288:	00043e21 	.word	0x00043e21
    528c:	20000000 	.word	0x20000000

00005290 <bt_conn_index>:
		__ASSERT(0 <= index && index < ARRAY_SIZE(sco_conns),
			"Invalid bt_conn pointer");
		break;
#endif
	default:
		index = conn - acl_conns;
    5290:	4b03      	ldr	r3, [pc, #12]	; (52a0 <bt_conn_index+0x10>)
    5292:	1ac0      	subs	r0, r0, r3
    5294:	4b03      	ldr	r3, [pc, #12]	; (52a4 <bt_conn_index+0x14>)
    5296:	1180      	asrs	r0, r0, #6
    5298:	4358      	muls	r0, r3
			 "Invalid bt_conn pointer");
		break;
	}

	return (uint8_t)index;
}
    529a:	b2c0      	uxtb	r0, r0
    529c:	4770      	bx	lr
    529e:	bf00      	nop
    52a0:	20000d50 	.word	0x20000d50
    52a4:	aaaaaaab 	.word	0xaaaaaaab

000052a8 <bt_conn_lookup_index>:

struct bt_conn *bt_conn_lookup_index(uint8_t index)
{
	if (index >= ARRAY_SIZE(acl_conns)) {
    52a8:	b910      	cbnz	r0, 52b0 <bt_conn_lookup_index+0x8>
		return NULL;
	}

	return bt_conn_ref(&acl_conns[index]);
    52aa:	4802      	ldr	r0, [pc, #8]	; (52b4 <bt_conn_lookup_index+0xc>)
    52ac:	f00e bbd7 	b.w	13a5e <bt_conn_ref>
}
    52b0:	2000      	movs	r0, #0
    52b2:	4770      	bx	lr
    52b4:	20000d50 	.word	0x20000d50

000052b8 <bt_conn_init>:

int bt_conn_init(void)
{
    52b8:	b510      	push	{r4, lr}
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
    52ba:	490b      	ldr	r1, [pc, #44]	; (52e8 <bt_conn_init+0x30>)
    52bc:	480b      	ldr	r0, [pc, #44]	; (52ec <bt_conn_init+0x34>)
    52be:	f017 ff57 	bl	1d170 <k_queue_append>
    52c2:	490b      	ldr	r1, [pc, #44]	; (52f0 <bt_conn_init+0x38>)
    52c4:	4809      	ldr	r0, [pc, #36]	; (52ec <bt_conn_init+0x34>)
    52c6:	f017 ff53 	bl	1d170 <k_queue_append>
    52ca:	490a      	ldr	r1, [pc, #40]	; (52f4 <bt_conn_init+0x3c>)
    52cc:	4807      	ldr	r0, [pc, #28]	; (52ec <bt_conn_init+0x34>)
    52ce:	f017 ff4f 	bl	1d170 <k_queue_append>
	}

	bt_att_init();
    52d2:	f00f f915 	bl	14500 <bt_att_init>

	err = bt_smp_init();
    52d6:	f00f fd28 	bl	14d2a <bt_smp_init>
	if (err) {
    52da:	4604      	mov	r4, r0
    52dc:	b908      	cbnz	r0, 52e2 <bt_conn_init+0x2a>
		return err;
	}

	bt_l2cap_init();
    52de:	f00e fd27 	bl	13d30 <bt_l2cap_init>
			bt_conn_unref(conn);
		}
	}

	return 0;
}
    52e2:	4620      	mov	r0, r4
    52e4:	bd10      	pop	{r4, pc}
    52e6:	bf00      	nop
    52e8:	20025a7c 	.word	0x20025a7c
    52ec:	20000880 	.word	0x20000880
    52f0:	20025a8c 	.word	0x20025a8c
    52f4:	20025a9c 	.word	0x20025a9c

000052f8 <l2cap_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
		struct bt_l2cap *l2cap = &bt_l2cap_pool[i];

		if (l2cap->chan.chan.conn) {
    52f8:	4b04      	ldr	r3, [pc, #16]	; (530c <l2cap_accept+0x14>)
    52fa:	6818      	ldr	r0, [r3, #0]
    52fc:	b918      	cbnz	r0, 5306 <l2cap_accept+0xe>
			continue;
		}

		l2cap->chan.chan.ops = &ops;
    52fe:	4a04      	ldr	r2, [pc, #16]	; (5310 <l2cap_accept+0x18>)
    5300:	605a      	str	r2, [r3, #4]
		*chan = &l2cap->chan.chan;
    5302:	600b      	str	r3, [r1, #0]

		return 0;
    5304:	4770      	bx	lr
	}

	BT_ERR("No available L2CAP context for conn %p", conn);

	return -ENOMEM;
    5306:	f06f 000b 	mvn.w	r0, #11
}
    530a:	4770      	bx	lr
    530c:	20000e10 	.word	0x20000e10
    5310:	0001eddc 	.word	0x0001eddc

00005314 <bt_l2cap_connected>:
{
    5314:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    5318:	4605      	mov	r5, r0
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    531a:	4e26      	ldr	r6, [pc, #152]	; (53b4 <bt_l2cap_connected+0xa0>)
    531c:	4f26      	ldr	r7, [pc, #152]	; (53b8 <bt_l2cap_connected+0xa4>)
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
    531e:	f8df 809c 	ldr.w	r8, [pc, #156]	; 53bc <bt_l2cap_connected+0xa8>
    5322:	42be      	cmp	r6, r7
    5324:	d302      	bcc.n	532c <bt_l2cap_connected+0x18>
}
    5326:	b003      	add	sp, #12
    5328:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fchan->accept(conn, &chan) < 0) {
    532c:	4628      	mov	r0, r5
    532e:	6873      	ldr	r3, [r6, #4]
    5330:	a901      	add	r1, sp, #4
    5332:	4798      	blx	r3
    5334:	2800      	cmp	r0, #0
    5336:	db38      	blt.n	53aa <bt_l2cap_connected+0x96>
		ch = BT_L2CAP_LE_CHAN(chan);
    5338:	9c01      	ldr	r4, [sp, #4]
		ch->rx.cid = fchan->cid;
    533a:	8833      	ldrh	r3, [r6, #0]
    533c:	2230      	movs	r2, #48	; 0x30
    533e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
		ch->tx.cid = fchan->cid;
    5342:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
    5346:	2100      	movs	r1, #0
    5348:	f104 0010 	add.w	r0, r4, #16
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
    534c:	f8d6 9008 	ldr.w	r9, [r6, #8]
    5350:	f018 fb14 	bl	1d97c <memset>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    5354:	2200      	movs	r2, #0
    5356:	f8c4 8014 	str.w	r8, [r4, #20]
    535a:	f104 0340 	add.w	r3, r4, #64	; 0x40
    535e:	e8d3 1fef 	ldaex	r1, [r3]
    5362:	e8c3 2fe0 	stlex	r0, r2, [r3]
    5366:	2800      	cmp	r0, #0
    5368:	d1f9      	bne.n	535e <bt_l2cap_connected+0x4a>
	parent->next = child;
    536a:	60a2      	str	r2, [r4, #8]
Z_GENLIST_APPEND(slist, snode)
    536c:	6d2a      	ldr	r2, [r5, #80]	; 0x50
	sys_slist_append(&conn->channels, &chan->node);
    536e:	f104 0308 	add.w	r3, r4, #8
    5372:	b9e2      	cbnz	r2, 53ae <bt_l2cap_connected+0x9a>
	list->head = node;
    5374:	e9c5 3313 	strd	r3, r3, [r5, #76]	; 0x4c
		if (chan->ops->connected) {
    5378:	9801      	ldr	r0, [sp, #4]
	chan->conn = conn;
    537a:	6025      	str	r5, [r4, #0]
		if (chan->ops->connected) {
    537c:	6843      	ldr	r3, [r0, #4]
	chan->destroy = destroy;
    537e:	f8c4 900c 	str.w	r9, [r4, #12]
		if (chan->ops->connected) {
    5382:	681b      	ldr	r3, [r3, #0]
    5384:	b103      	cbz	r3, 5388 <bt_l2cap_connected+0x74>
			chan->ops->connected(chan);
    5386:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    5388:	9b01      	ldr	r3, [sp, #4]
    538a:	3340      	adds	r3, #64	; 0x40
    538c:	e8d3 2fef 	ldaex	r2, [r3]
    5390:	f042 0201 	orr.w	r2, r2, #1
    5394:	e8c3 2fe1 	stlex	r1, r2, [r3]
    5398:	2900      	cmp	r1, #0
    539a:	d1f7      	bne.n	538c <bt_l2cap_connected+0x78>
		if (chan->ops->status) {
    539c:	9801      	ldr	r0, [sp, #4]
    539e:	6843      	ldr	r3, [r0, #4]
    53a0:	699b      	ldr	r3, [r3, #24]
    53a2:	b113      	cbz	r3, 53aa <bt_l2cap_connected+0x96>
			chan->ops->status(chan, chan->status);
    53a4:	f100 0140 	add.w	r1, r0, #64	; 0x40
    53a8:	4798      	blx	r3
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    53aa:	360c      	adds	r6, #12
    53ac:	e7b9      	b.n	5322 <bt_l2cap_connected+0xe>
	parent->next = child;
    53ae:	6013      	str	r3, [r2, #0]
	list->tail = node;
    53b0:	652b      	str	r3, [r5, #80]	; 0x50
}
    53b2:	e7e1      	b.n	5378 <bt_l2cap_connected+0x64>
    53b4:	0001dcf0 	.word	0x0001dcf0
    53b8:	0001dd14 	.word	0x0001dd14
    53bc:	00013be5 	.word	0x00013be5

000053c0 <bt_l2cap_update_conn_param>:
{
    53c0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ident++;
    53c2:	4b15      	ldr	r3, [pc, #84]	; (5418 <bt_l2cap_update_conn_param+0x58>)
{
    53c4:	4605      	mov	r5, r0
	ident++;
    53c6:	781a      	ldrb	r2, [r3, #0]
{
    53c8:	460c      	mov	r4, r1
	ident++;
    53ca:	3201      	adds	r2, #1
	if (!ident) {
    53cc:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		ident++;
    53d0:	bf08      	it	eq
    53d2:	2201      	moveq	r2, #1
    53d4:	701a      	strb	r2, [r3, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
    53d6:	2012      	movs	r0, #18
    53d8:	2208      	movs	r2, #8
    53da:	7819      	ldrb	r1, [r3, #0]
    53dc:	f00e fbb4 	bl	13b48 <l2cap_create_le_sig_pdu.isra.0>
	if (!buf) {
    53e0:	4606      	mov	r6, r0
    53e2:	b1b0      	cbz	r0, 5412 <bt_l2cap_update_conn_param+0x52>
	return net_buf_simple_add(&buf->b, len);
    53e4:	2108      	movs	r1, #8
    53e6:	4408      	add	r0, r1
    53e8:	f00f fcf8 	bl	14ddc <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
    53ec:	8822      	ldrh	r2, [r4, #0]
		     bt_conn_tx_cb_t cb, void *user_data);

static inline void bt_l2cap_send(struct bt_conn *conn, uint16_t cid,
				 struct net_buf *buf)
{
	bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
    53ee:	2105      	movs	r1, #5
    53f0:	8002      	strh	r2, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
    53f2:	8862      	ldrh	r2, [r4, #2]
    53f4:	8042      	strh	r2, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
    53f6:	88a2      	ldrh	r2, [r4, #4]
    53f8:	8082      	strh	r2, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
    53fa:	88e2      	ldrh	r2, [r4, #6]
    53fc:	2400      	movs	r4, #0
    53fe:	80c2      	strh	r2, [r0, #6]
    5400:	4623      	mov	r3, r4
    5402:	4632      	mov	r2, r6
    5404:	4628      	mov	r0, r5
    5406:	9400      	str	r4, [sp, #0]
    5408:	f00e fc11 	bl	13c2e <bt_l2cap_send_cb>
	return 0;
    540c:	4620      	mov	r0, r4
}
    540e:	b002      	add	sp, #8
    5410:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
    5412:	f06f 000b 	mvn.w	r0, #11
    5416:	e7fa      	b.n	540e <bt_l2cap_update_conn_param+0x4e>
    5418:	20029f3d 	.word	0x20029f3d

0000541c <att_cfm_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_cfm_sent;
    541c:	4b02      	ldr	r3, [pc, #8]	; (5428 <att_cfm_sent+0xc>)
    541e:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120

	att_sent(conn, user_data);
    5422:	f00e bcb3 	b.w	13d8c <att_sent>
    5426:	bf00      	nop
    5428:	00014179 	.word	0x00014179

0000542c <att_rsp_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_rsp_sent;
    542c:	4b02      	ldr	r3, [pc, #8]	; (5438 <att_rsp_sent+0xc>)
    542e:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120

	att_sent(conn, user_data);
    5432:	f00e bcab 	b.w	13d8c <att_sent>
    5436:	bf00      	nop
    5438:	00014165 	.word	0x00014165

0000543c <att_req_sent>:
	struct bt_l2cap_chan *ch = user_data;
	struct bt_att_chan *chan = ATT_CHAN(ch);

	BT_DBG("conn %p chan %p", conn, chan);

	chan->sent = chan_req_sent;
    543c:	4b02      	ldr	r3, [pc, #8]	; (5448 <att_req_sent+0xc>)
    543e:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120

	att_sent(conn, user_data);
    5442:	f00e bca3 	b.w	13d8c <att_sent>
    5446:	bf00      	nop
    5448:	00005685 	.word	0x00005685

0000544c <bt_att_released>:
	/* Prepend back to the list as it could not be sent */
	sys_slist_prepend(&chan->att->reqs, node);
}

static void bt_att_released(struct bt_l2cap_chan *ch)
{
    544c:	b507      	push	{r0, r1, r2, lr}
	struct bt_att_chan *chan = ATT_CHAN(ch);
    544e:	3808      	subs	r0, #8
    5450:	9001      	str	r0, [sp, #4]

	BT_DBG("chan %p", chan);

	k_mem_slab_free(&chan_slab, (void **)&chan);
    5452:	a901      	add	r1, sp, #4
    5454:	4802      	ldr	r0, [pc, #8]	; (5460 <bt_att_released+0x14>)
    5456:	f00a ff2b 	bl	102b0 <k_mem_slab_free>
}
    545a:	b003      	add	sp, #12
    545c:	f85d fb04 	ldr.w	pc, [sp], #4
    5460:	20000794 	.word	0x20000794

00005464 <read_group_cb>:
{
    5464:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    5468:	f04f 0800 	mov.w	r8, #0
    546c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
{
    5470:	4606      	mov	r6, r0
    5472:	460d      	mov	r5, r1
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    5474:	6800      	ldr	r0, [r0, #0]
    5476:	a902      	add	r1, sp, #8
{
    5478:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
    547a:	6817      	ldr	r7, [r2, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    547c:	f88d 8008 	strb.w	r8, [sp, #8]
    5480:	f8ad 300a 	strh.w	r3, [sp, #10]
    5484:	f00d ff09 	bl	1329a <bt_uuid_cmp>
    5488:	b1a0      	cbz	r0, 54b4 <read_group_cb+0x50>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    548a:	f642 0301 	movw	r3, #10241	; 0x2801
    548e:	6830      	ldr	r0, [r6, #0]
    5490:	a903      	add	r1, sp, #12
    5492:	f88d 800c 	strb.w	r8, [sp, #12]
    5496:	f8ad 300e 	strh.w	r3, [sp, #14]
    549a:	f00d fefe 	bl	1329a <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    549e:	b148      	cbz	r0, 54b4 <read_group_cb+0x50>
		if (data->group &&
    54a0:	6923      	ldr	r3, [r4, #16]
    54a2:	b11b      	cbz	r3, 54ac <read_group_cb+0x48>
    54a4:	885a      	ldrh	r2, [r3, #2]
    54a6:	42aa      	cmp	r2, r5
    54a8:	d200      	bcs.n	54ac <read_group_cb+0x48>
			data->group->end_handle = sys_cpu_to_le16(handle);
    54aa:	805d      	strh	r5, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
    54ac:	2001      	movs	r0, #1
}
    54ae:	b004      	add	sp, #16
    54b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
    54b4:	6861      	ldr	r1, [r4, #4]
    54b6:	6830      	ldr	r0, [r6, #0]
    54b8:	f00d feef 	bl	1329a <bt_uuid_cmp>
    54bc:	b110      	cbz	r0, 54c4 <read_group_cb+0x60>
		data->group = NULL;
    54be:	2300      	movs	r3, #0
    54c0:	6123      	str	r3, [r4, #16]
    54c2:	e7f3      	b.n	54ac <read_group_cb+0x48>
	if (data->rsp->len &&
    54c4:	68e3      	ldr	r3, [r4, #12]
    54c6:	68a0      	ldr	r0, [r4, #8]
    54c8:	781a      	ldrb	r2, [r3, #0]
    54ca:	b13a      	cbz	r2, 54dc <read_group_cb+0x78>
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
    54cc:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
    54d0:	8981      	ldrh	r1, [r0, #12]
    54d2:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
    54d4:	4293      	cmp	r3, r2
    54d6:	da01      	bge.n	54dc <read_group_cb+0x78>
		return BT_GATT_ITER_STOP;
    54d8:	2000      	movs	r0, #0
    54da:	e7e8      	b.n	54ae <read_group_cb+0x4a>
    54dc:	2104      	movs	r1, #4
    54de:	3008      	adds	r0, #8
    54e0:	f00f fc7c 	bl	14ddc <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
    54e4:	4b09      	ldr	r3, [pc, #36]	; (550c <read_group_cb+0xa8>)
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    54e6:	6120      	str	r0, [r4, #16]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
    54e8:	4631      	mov	r1, r6
	data->group->start_handle = sys_cpu_to_le16(handle);
    54ea:	8005      	strh	r5, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
    54ec:	8045      	strh	r5, [r0, #2]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
    54ee:	68a2      	ldr	r2, [r4, #8]
    54f0:	9300      	str	r3, [sp, #0]
    54f2:	4638      	mov	r0, r7
    54f4:	2300      	movs	r3, #0
    54f6:	9401      	str	r4, [sp, #4]
    54f8:	f00e fc98 	bl	13e2c <att_chan_read>
	if (read < 0) {
    54fc:	2800      	cmp	r0, #0
    54fe:	dbeb      	blt.n	54d8 <read_group_cb+0x74>
	if (!data->group) {
    5500:	6920      	ldr	r0, [r4, #16]
		return BT_GATT_ITER_CONTINUE;
    5502:	3800      	subs	r0, #0
    5504:	bf18      	it	ne
    5506:	2001      	movne	r0, #1
    5508:	e7d1      	b.n	54ae <read_group_cb+0x4a>
    550a:	bf00      	nop
    550c:	0001406b 	.word	0x0001406b

00005510 <read_type_cb>:
{
    5510:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct bt_att_chan *chan = data->chan;
    5514:	f8d2 8000 	ldr.w	r8, [r2]
{
    5518:	4606      	mov	r6, r0
    551a:	4689      	mov	r9, r1
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
    551c:	6800      	ldr	r0, [r0, #0]
    551e:	6851      	ldr	r1, [r2, #4]
{
    5520:	4614      	mov	r4, r2
	struct bt_conn *conn = chan->chan.chan.conn;
    5522:	f8d8 5008 	ldr.w	r5, [r8, #8]
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
    5526:	f00d feb8 	bl	1329a <bt_uuid_cmp>
    552a:	4607      	mov	r7, r0
    552c:	2800      	cmp	r0, #0
    552e:	d13e      	bne.n	55ae <read_type_cb+0x9e>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
    5530:	4628      	mov	r0, r5
    5532:	2215      	movs	r2, #21
    5534:	4631      	mov	r1, r6
    5536:	f00f fb89 	bl	14c4c <bt_gatt_check_perm>
    553a:	4605      	mov	r5, r0
    553c:	7520      	strb	r0, [r4, #20]
	if (data->err) {
    553e:	b148      	cbz	r0, 5554 <read_type_cb+0x44>
		if (data->rsp->len) {
    5540:	68e3      	ldr	r3, [r4, #12]
    5542:	781b      	ldrb	r3, [r3, #0]
    5544:	b923      	cbnz	r3, 5550 <read_type_cb+0x40>
		return BT_GATT_ITER_STOP;
    5546:	2500      	movs	r5, #0
}
    5548:	4628      	mov	r0, r5
    554a:	b003      	add	sp, #12
    554c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			data->err = 0x00;
    5550:	7527      	strb	r7, [r4, #20]
    5552:	e7f8      	b.n	5546 <read_type_cb+0x36>
	data->item = net_buf_add(net_buf_frag_last(data->buf),
    5554:	68a0      	ldr	r0, [r4, #8]
    5556:	f00f fc1f 	bl	14d98 <net_buf_frag_last>
    555a:	2102      	movs	r1, #2
    555c:	3008      	adds	r0, #8
    555e:	f00f fc3d 	bl	14ddc <net_buf_simple_add>
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
    5562:	4b14      	ldr	r3, [pc, #80]	; (55b4 <read_type_cb+0xa4>)
	data->item = net_buf_add(net_buf_frag_last(data->buf),
    5564:	6120      	str	r0, [r4, #16]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
    5566:	4631      	mov	r1, r6
	data->item->handle = sys_cpu_to_le16(handle);
    5568:	f8a0 9000 	strh.w	r9, [r0]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
    556c:	68a2      	ldr	r2, [r4, #8]
    556e:	9300      	str	r3, [sp, #0]
    5570:	4640      	mov	r0, r8
    5572:	462b      	mov	r3, r5
    5574:	9401      	str	r4, [sp, #4]
    5576:	f00e fc59 	bl	13e2c <att_chan_read>
	if (read < 0) {
    557a:	2800      	cmp	r0, #0
    557c:	da07      	bge.n	558e <read_type_cb+0x7e>
	if (err < 0 && err >= -0xff) {
    557e:	f110 0fff 	cmn.w	r0, #255	; 0xff
	return BT_ATT_ERR_UNLIKELY;
    5582:	bf32      	itee	cc
    5584:	200e      	movcc	r0, #14
		return -err;
    5586:	4240      	negcs	r0, r0
    5588:	b2c0      	uxtbcs	r0, r0
		data->err = err_to_att(read);
    558a:	7520      	strb	r0, [r4, #20]
		return BT_GATT_ITER_STOP;
    558c:	e7dc      	b.n	5548 <read_type_cb+0x38>
	if (!data->item) {
    558e:	6923      	ldr	r3, [r4, #16]
    5590:	2b00      	cmp	r3, #0
    5592:	d0d8      	beq.n	5546 <read_type_cb+0x36>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
    5594:	68a0      	ldr	r0, [r4, #8]
    5596:	f00e fbf1 	bl	13d7c <net_buf_frags_len>
    559a:	f8b8 505e 	ldrh.w	r5, [r8, #94]	; 0x5e
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    559e:	68e3      	ldr	r3, [r4, #12]
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
    55a0:	1a2d      	subs	r5, r5, r0
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    55a2:	7818      	ldrb	r0, [r3, #0]
    55a4:	4285      	cmp	r5, r0
    55a6:	bf94      	ite	ls
    55a8:	2500      	movls	r5, #0
    55aa:	2501      	movhi	r5, #1
    55ac:	e7cc      	b.n	5548 <read_type_cb+0x38>
		return BT_GATT_ITER_CONTINUE;
    55ae:	2501      	movs	r5, #1
    55b0:	e7ca      	b.n	5548 <read_type_cb+0x38>
    55b2:	bf00      	nop
    55b4:	00013d99 	.word	0x00013d99

000055b8 <chan_send>:
{
    55b8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    55bc:	688b      	ldr	r3, [r1, #8]
{
    55be:	4605      	mov	r5, r0
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    55c0:	781b      	ldrb	r3, [r3, #0]
{
    55c2:	460c      	mov	r4, r1
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    55c4:	2bd2      	cmp	r3, #210	; 0xd2
{
    55c6:	4691      	mov	r9, r2
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    55c8:	d10c      	bne.n	55e4 <chan_send+0x2c>
		err = bt_smp_sign(chan->att->conn, buf);
    55ca:	6803      	ldr	r3, [r0, #0]
    55cc:	6818      	ldr	r0, [r3, #0]
    55ce:	f00f fba9 	bl	14d24 <bt_smp_sign>
		if (err) {
    55d2:	4606      	mov	r6, r0
    55d4:	b130      	cbz	r0, 55e4 <chan_send+0x2c>
		net_buf_unref(buf);
    55d6:	4620      	mov	r0, r4
    55d8:	f001 f9ba 	bl	6950 <net_buf_unref>
}
    55dc:	4630      	mov	r0, r6
    55de:	b003      	add	sp, #12
    55e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	state->offset = net_buf_simple_headroom(buf);
    55e4:	f104 0008 	add.w	r0, r4, #8
    55e8:	f00f fc39 	bl	14e5e <net_buf_simple_headroom>
	state->len = buf->len;
    55ec:	f8b4 800c 	ldrh.w	r8, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
    55f0:	4607      	mov	r7, r0
	chan->sent = cb ? cb : chan_cb(buf);
    55f2:	f1b9 0f00 	cmp.w	r9, #0
    55f6:	d10a      	bne.n	560e <chan_send+0x56>
	switch (att_op_get_type(buf->data[0])) {
    55f8:	68a3      	ldr	r3, [r4, #8]
    55fa:	7818      	ldrb	r0, [r3, #0]
    55fc:	f00e fbde 	bl	13dbc <att_op_get_type>
    5600:	1e43      	subs	r3, r0, #1
    5602:	b2db      	uxtb	r3, r3
    5604:	2b04      	cmp	r3, #4
    5606:	bf9c      	itt	ls
    5608:	4a16      	ldrls	r2, [pc, #88]	; (5664 <chan_send+0xac>)
    560a:	f852 9023 	ldrls.w	r9, [r2, r3, lsl #2]
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
    560e:	682b      	ldr	r3, [r5, #0]
    5610:	4620      	mov	r0, r4
	chan->sent = cb ? cb : chan_cb(buf);
    5612:	f8c5 9128 	str.w	r9, [r5, #296]	; 0x128
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
    5616:	681e      	ldr	r6, [r3, #0]
    5618:	f00f fbba 	bl	14d90 <net_buf_ref>
    561c:	f8d5 1128 	ldr.w	r1, [r5, #296]	; 0x128
	if (cb == chan_rsp_sent) {
    5620:	4b11      	ldr	r3, [pc, #68]	; (5668 <chan_send+0xb0>)
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
    5622:	4602      	mov	r2, r0
	if (cb == chan_rsp_sent) {
    5624:	4299      	cmp	r1, r3
    5626:	d019      	beq.n	565c <chan_send+0xa4>
	} else if (cb == chan_cfm_sent) {
    5628:	4b10      	ldr	r3, [pc, #64]	; (566c <chan_send+0xb4>)
    562a:	4299      	cmp	r1, r3
    562c:	d018      	beq.n	5660 <chan_send+0xa8>
		return att_sent;
    562e:	f8df c050 	ldr.w	ip, [pc, #80]	; 5680 <chan_send+0xc8>
    5632:	4b0f      	ldr	r3, [pc, #60]	; (5670 <chan_send+0xb8>)
    5634:	480f      	ldr	r0, [pc, #60]	; (5674 <chan_send+0xbc>)
    5636:	4561      	cmp	r1, ip
    5638:	bf18      	it	ne
    563a:	4603      	movne	r3, r0
				&chan->chan.chan);
    563c:	3508      	adds	r5, #8
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
    563e:	4630      	mov	r0, r6
    5640:	2104      	movs	r1, #4
    5642:	9500      	str	r5, [sp, #0]
    5644:	f00e faf3 	bl	13c2e <bt_l2cap_send_cb>
	if (!err) {
    5648:	4606      	mov	r6, r0
    564a:	2800      	cmp	r0, #0
    564c:	d0c3      	beq.n	55d6 <chan_send+0x1e>
	buf->data = buf->__buf + state->offset;
    564e:	6920      	ldr	r0, [r4, #16]
	buf->len = state->len;
    5650:	f8a4 800c 	strh.w	r8, [r4, #12]
	buf->data = buf->__buf + state->offset;
    5654:	fa10 f787 	uxtah	r7, r0, r7
    5658:	60a7      	str	r7, [r4, #8]
}
    565a:	e7bf      	b.n	55dc <chan_send+0x24>
		return att_rsp_sent;
    565c:	4b06      	ldr	r3, [pc, #24]	; (5678 <chan_send+0xc0>)
    565e:	e7ed      	b.n	563c <chan_send+0x84>
		return att_cfm_sent;
    5660:	4b06      	ldr	r3, [pc, #24]	; (567c <chan_send+0xc4>)
    5662:	e7eb      	b.n	563c <chan_send+0x84>
    5664:	0001edfc 	.word	0x0001edfc
    5668:	00014165 	.word	0x00014165
    566c:	00014179 	.word	0x00014179
    5670:	0000543d 	.word	0x0000543d
    5674:	00013d8d 	.word	0x00013d8d
    5678:	0000542d 	.word	0x0000542d
    567c:	0000541d 	.word	0x0000541d
    5680:	00005685 	.word	0x00005685

00005684 <chan_req_sent>:
	if (chan->req) {
    5684:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
    5688:	b13b      	cbz	r3, 569a <chan_req_sent+0x16>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    568a:	f100 01e0 	add.w	r1, r0, #224	; 0xe0
    568e:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    5692:	2300      	movs	r3, #0
    5694:	4801      	ldr	r0, [pc, #4]	; (569c <chan_req_sent+0x18>)
    5696:	f00b bcd9 	b.w	1104c <k_delayed_work_submit_to_queue>
}
    569a:	4770      	bx	lr
    569c:	20001168 	.word	0x20001168

000056a0 <bt_att_accept>:

	return chan;
}

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **ch)
{
    56a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct bt_att *att;
	struct bt_att_chan *chan;

	BT_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    56a2:	2300      	movs	r3, #0
{
    56a4:	4607      	mov	r7, r0
    56a6:	460e      	mov	r6, r1
	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    56a8:	2200      	movs	r2, #0
    56aa:	4669      	mov	r1, sp
    56ac:	481f      	ldr	r0, [pc, #124]	; (572c <bt_att_accept+0x8c>)
    56ae:	f00a fdcd 	bl	1024c <k_mem_slab_alloc>
    56b2:	4604      	mov	r4, r0
    56b4:	b120      	cbz	r0, 56c0 <bt_att_accept+0x20>
	sys_slist_init(&att->reqs);
	sys_slist_init(&att->chans);

	chan = att_chan_new(att, 0);
	if (!chan) {
		return -ENOMEM;
    56b6:	f06f 040b 	mvn.w	r4, #11
	}

	*ch = &chan->chan.chan;

	return 0;
}
    56ba:	4620      	mov	r0, r4
    56bc:	b003      	add	sp, #12
    56be:	bdf0      	pop	{r4, r5, r6, r7, pc}
__ssp_bos_icheck3(memset, void *, int)
    56c0:	4601      	mov	r1, r0
    56c2:	222c      	movs	r2, #44	; 0x2c
    56c4:	9800      	ldr	r0, [sp, #0]
    56c6:	f018 f959 	bl	1d97c <memset>
	att->conn = conn;
    56ca:	9d00      	ldr	r5, [sp, #0]
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
    56cc:	2200      	movs	r2, #0
	list->head = NULL;
    56ce:	e9c5 7400 	strd	r7, r4, [r5]
	list->tail = NULL;
    56d2:	e9c5 4409 	strd	r4, r4, [r5, #36]	; 0x24
    56d6:	60ac      	str	r4, [r5, #8]
    56d8:	2300      	movs	r3, #0
    56da:	4815      	ldr	r0, [pc, #84]	; (5730 <bt_att_accept+0x90>)
    56dc:	a901      	add	r1, sp, #4
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
    56de:	9401      	str	r4, [sp, #4]
	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
    56e0:	f00a fdb4 	bl	1024c <k_mem_slab_alloc>
    56e4:	4604      	mov	r4, r0
    56e6:	2800      	cmp	r0, #0
    56e8:	d1e5      	bne.n	56b6 <bt_att_accept+0x16>
    56ea:	4601      	mov	r1, r0
    56ec:	f44f 7298 	mov.w	r2, #304	; 0x130
    56f0:	9801      	ldr	r0, [sp, #4]
    56f2:	f018 f943 	bl	1d97c <memset>
	chan->chan.chan.ops = &ops;
    56f6:	9801      	ldr	r0, [sp, #4]
    56f8:	4b0e      	ldr	r3, [pc, #56]	; (5734 <bt_att_accept+0x94>)
    56fa:	60c3      	str	r3, [r0, #12]
	z_impl_k_queue_init(queue);
    56fc:	30c8      	adds	r0, #200	; 0xc8
    56fe:	f017 fd2b 	bl	1d158 <z_impl_k_queue_init>
	k_sem_init(&chan->tx_sem, CONFIG_BT_ATT_TX_MAX, CONFIG_BT_ATT_TX_MAX);
    5702:	9801      	ldr	r0, [sp, #4]
    5704:	f500 7088 	add.w	r0, r0, #272	; 0x110
	return z_impl_k_sem_init(sem, initial_count, limit);
    5708:	2203      	movs	r2, #3
    570a:	4611      	mov	r1, r2
    570c:	f017 fe7c 	bl	1d408 <z_impl_k_sem_init>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    5710:	9b01      	ldr	r3, [sp, #4]
    5712:	33c0      	adds	r3, #192	; 0xc0
    5714:	e8d3 2fef 	ldaex	r2, [r3]
    5718:	e8c3 4fe1 	stlex	r1, r4, [r3]
    571c:	2900      	cmp	r1, #0
    571e:	d1f9      	bne.n	5714 <bt_att_accept+0x74>
	chan->att = att;
    5720:	9b01      	ldr	r3, [sp, #4]
    5722:	f843 5b08 	str.w	r5, [r3], #8
	*ch = &chan->chan.chan;
    5726:	6033      	str	r3, [r6, #0]
	return 0;
    5728:	e7c7      	b.n	56ba <bt_att_accept+0x1a>
    572a:	bf00      	nop
    572c:	20000778 	.word	0x20000778
    5730:	20000794 	.word	0x20000794
    5734:	20000350 	.word	0x20000350

00005738 <bt_att_chan_send_rsp.constprop.0>:
static void bt_att_chan_send_rsp(struct bt_att_chan *chan, struct net_buf *buf,
    5738:	b538      	push	{r3, r4, r5, lr}
	return chan_send(chan, buf, cb);
    573a:	4a07      	ldr	r2, [pc, #28]	; (5758 <bt_att_chan_send_rsp.constprop.0+0x20>)
static void bt_att_chan_send_rsp(struct bt_att_chan *chan, struct net_buf *buf,
    573c:	4604      	mov	r4, r0
    573e:	460d      	mov	r5, r1
	return chan_send(chan, buf, cb);
    5740:	f7ff ff3a 	bl	55b8 <chan_send>
	if (err) {
    5744:	b130      	cbz	r0, 5754 <bt_att_chan_send_rsp.constprop.0+0x1c>
		net_buf_put(&chan->tx_queue, buf);
    5746:	4629      	mov	r1, r5
    5748:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
}
    574c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		net_buf_put(&chan->tx_queue, buf);
    5750:	f00f bb11 	b.w	14d76 <net_buf_put>
}
    5754:	bd38      	pop	{r3, r4, r5, pc}
    5756:	bf00      	nop
    5758:	00014165 	.word	0x00014165

0000575c <bt_att_connected>:
{
    575c:	b538      	push	{r3, r4, r5, lr}
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    575e:	2104      	movs	r1, #4
{
    5760:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
    5762:	6800      	ldr	r0, [r0, #0]
    5764:	f00e faa9 	bl	13cba <bt_l2cap_le_lookup_tx_cid>
	struct bt_att *att = att_chan->att;
    5768:	f850 5c08 	ldr.w	r5, [r0, #-8]
	if (sys_slist_is_empty(&att->chans)) {
    576c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    576e:	b91b      	cbnz	r3, 5778 <bt_att_connected+0x1c>
	z_impl_k_queue_init(queue);
    5770:	f105 000c 	add.w	r0, r5, #12
    5774:	f017 fcf0 	bl	1d158 <z_impl_k_queue_init>
Z_GENLIST_PREPEND(slist, snode)
    5778:	6a6a      	ldr	r2, [r5, #36]	; 0x24
	sys_slist_prepend(&att->chans, &chan->node);
    577a:	f504 7392 	add.w	r3, r4, #292	; 0x124
	parent->next = child;
    577e:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
Z_GENLIST_PREPEND(slist, snode)
    5782:	6aaa      	ldr	r2, [r5, #40]	; 0x28
	list->head = node;
    5784:	626b      	str	r3, [r5, #36]	; 0x24
Z_GENLIST_PREPEND(slist, snode)
    5786:	b902      	cbnz	r2, 578a <bt_att_connected+0x2e>
	list->tail = node;
    5788:	62ab      	str	r3, [r5, #40]	; 0x28
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    578a:	f104 03b8 	add.w	r3, r4, #184	; 0xb8
    578e:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_test_bit(att_chan->flags, ATT_ENHANCED)) {
    5792:	071b      	lsls	r3, r3, #28
		ch->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
    5794:	bf58      	it	pl
    5796:	2317      	movpl	r3, #23
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
    5798:	f04f 0230 	mov.w	r2, #48	; 0x30
    579c:	bf5c      	itt	pl
    579e:	f8a4 3056 	strhpl.w	r3, [r4, #86]	; 0x56
		ch->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
    57a2:	f8a4 304a 	strhpl.w	r3, [r4, #74]	; 0x4a
    57a6:	2100      	movs	r1, #0
    57a8:	f104 00d8 	add.w	r0, r4, #216	; 0xd8
    57ac:	f018 f8e6 	bl	1d97c <memset>
    57b0:	4b01      	ldr	r3, [pc, #4]	; (57b8 <bt_att_connected+0x5c>)
    57b2:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
}
    57b6:	bd38      	pop	{r3, r4, r5, pc}
    57b8:	000145a3 	.word	0x000145a3

000057bc <att_write_cmd>:
{
    57bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    57be:	4604      	mov	r4, r0
    57c0:	b087      	sub	sp, #28
	return net_buf_simple_pull_le16(&buf->b);
    57c2:	f101 0008 	add.w	r0, r1, #8
    57c6:	460d      	mov	r5, r1
    57c8:	f00f fb41 	bl	14e4e <net_buf_simple_pull_le16>
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
    57cc:	6823      	ldr	r3, [r4, #0]
    57ce:	4606      	mov	r6, r0
    57d0:	2100      	movs	r1, #0
    57d2:	6818      	ldr	r0, [r3, #0]
	return att_write_rsp(chan, 0, 0, handle, 0, buf->data, buf->len);
    57d4:	68af      	ldr	r7, [r5, #8]
    57d6:	89ad      	ldrh	r5, [r5, #12]
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
    57d8:	f00f fa5b 	bl	14c92 <bt_gatt_change_aware>
    57dc:	b320      	cbz	r0, 5828 <att_write_cmd+0x6c>
	if (!handle) {
    57de:	b32e      	cbz	r6, 582c <att_write_cmd+0x70>
	(void)memset(&data, 0, sizeof(data));
    57e0:	2214      	movs	r2, #20
    57e2:	2100      	movs	r1, #0
    57e4:	a801      	add	r0, sp, #4
    57e6:	f018 f8c9 	bl	1d97c <memset>
	data.conn = chan->att->conn;
    57ea:	6823      	ldr	r3, [r4, #0]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    57ec:	4631      	mov	r1, r6
	data.conn = chan->att->conn;
    57ee:	681b      	ldr	r3, [r3, #0]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    57f0:	4630      	mov	r0, r6
	data.conn = chan->att->conn;
    57f2:	9300      	str	r3, [sp, #0]
	data.req = req;
    57f4:	2300      	movs	r3, #0
    57f6:	f88d 3008 	strb.w	r3, [sp, #8]
	data.offset = offset;
    57fa:	f8ad 3012 	strh.w	r3, [sp, #18]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    57fe:	2301      	movs	r3, #1
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    5800:	4a0b      	ldr	r2, [pc, #44]	; (5830 <att_write_cmd+0x74>)
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    5802:	f88d 3014 	strb.w	r3, [sp, #20]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    5806:	466b      	mov	r3, sp
	data.value = value;
    5808:	9703      	str	r7, [sp, #12]
	data.len = len;
    580a:	f8ad 5010 	strh.w	r5, [sp, #16]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    580e:	f00e fb02 	bl	13e16 <bt_gatt_foreach_attr>
	if (data.err) {
    5812:	f89d 3014 	ldrb.w	r3, [sp, #20]
    5816:	b923      	cbnz	r3, 5822 <att_write_cmd+0x66>
	if (data.buf) {
    5818:	9901      	ldr	r1, [sp, #4]
    581a:	b111      	cbz	r1, 5822 <att_write_cmd+0x66>
		bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    581c:	4620      	mov	r0, r4
    581e:	f7ff ff8b 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
    5822:	2000      	movs	r0, #0
}
    5824:	b007      	add	sp, #28
    5826:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    5828:	2012      	movs	r0, #18
    582a:	e7fb      	b.n	5824 <att_write_cmd+0x68>
		return BT_ATT_ERR_INVALID_HANDLE;
    582c:	2001      	movs	r0, #1
    582e:	e7f9      	b.n	5824 <att_write_cmd+0x68>
    5830:	00014277 	.word	0x00014277

00005834 <bt_att_recv>:
	if (buf->len < sizeof(*hdr)) {
    5834:	898b      	ldrh	r3, [r1, #12]
{
    5836:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    583a:	4604      	mov	r4, r0
    583c:	460d      	mov	r5, r1
	if (buf->len < sizeof(*hdr)) {
    583e:	2b00      	cmp	r3, #0
    5840:	d056      	beq.n	58f0 <bt_att_recv+0xbc>
	return net_buf_simple_pull_mem(&buf->b, len);
    5842:	2101      	movs	r1, #1
    5844:	f105 0008 	add.w	r0, r5, #8
    5848:	f00f faf9 	bl	14e3e <net_buf_simple_pull_mem>
	if (!att_chan->att) {
    584c:	f854 3c08 	ldr.w	r3, [r4, #-8]
    5850:	4607      	mov	r7, r0
    5852:	2b00      	cmp	r3, #0
    5854:	d04c      	beq.n	58f0 <bt_att_recv+0xbc>
		if (hdr->code == handlers[i].op) {
    5856:	4a2a      	ldr	r2, [pc, #168]	; (5900 <bt_att_recv+0xcc>)
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    5858:	2300      	movs	r3, #0
    585a:	4694      	mov	ip, r2
		if (hdr->code == handlers[i].op) {
    585c:	7801      	ldrb	r1, [r0, #0]
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
    585e:	f1a4 0608 	sub.w	r6, r4, #8
		if (hdr->code == handlers[i].op) {
    5862:	f812 0033 	ldrb.w	r0, [r2, r3, lsl #3]
    5866:	4288      	cmp	r0, r1
    5868:	d116      	bne.n	5898 <bt_att_recv+0x64>
		if (handler->type == ATT_REQUEST &&
    586a:	00d9      	lsls	r1, r3, #3
    586c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    5870:	f893 8002 	ldrb.w	r8, [r3, #2]
    5874:	f1b8 0f01 	cmp.w	r8, #1
    5878:	d01c      	beq.n	58b4 <bt_att_recv+0x80>
		} else if (handler->type == ATT_INDICATION &&
    587a:	f1b8 0f05 	cmp.w	r8, #5
    587e:	d125      	bne.n	58cc <bt_att_recv+0x98>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    5880:	34b8      	adds	r4, #184	; 0xb8
    5882:	e8d4 2fef 	ldaex	r2, [r4]
    5886:	f042 0302 	orr.w	r3, r2, #2
    588a:	e8c4 3fe0 	stlex	r0, r3, [r4]
    588e:	2800      	cmp	r0, #0
    5890:	d1f7      	bne.n	5882 <bt_att_recv+0x4e>
    5892:	f012 0f02 	tst.w	r2, #2
    5896:	e018      	b.n	58ca <bt_att_recv+0x96>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    5898:	3301      	adds	r3, #1
    589a:	2b0d      	cmp	r3, #13
    589c:	d1e1      	bne.n	5862 <bt_att_recv+0x2e>
		if (att_op_get_type(hdr->code) != ATT_COMMAND) {
    589e:	4608      	mov	r0, r1
    58a0:	f00e fa8c 	bl	13dbc <att_op_get_type>
    58a4:	b320      	cbz	r0, 58f0 <bt_att_recv+0xbc>
	if (!req) {
    58a6:	b319      	cbz	r1, 58f0 <bt_att_recv+0xbc>
    58a8:	2306      	movs	r3, #6
    58aa:	2200      	movs	r2, #0
    58ac:	4630      	mov	r0, r6
    58ae:	f00e fd9d 	bl	143ec <send_err_rsp.part.0>
    58b2:	e01d      	b.n	58f0 <bt_att_recv+0xbc>
    58b4:	34b8      	adds	r4, #184	; 0xb8
    58b6:	e8d4 3fef 	ldaex	r3, [r4]
    58ba:	f043 0201 	orr.w	r2, r3, #1
    58be:	e8c4 2fe0 	stlex	r0, r2, [r4]
    58c2:	2800      	cmp	r0, #0
    58c4:	d1f7      	bne.n	58b6 <bt_att_recv+0x82>
		if (handler->type == ATT_REQUEST &&
    58c6:	f013 0f01 	tst.w	r3, #1
    58ca:	d111      	bne.n	58f0 <bt_att_recv+0xbc>
	if (buf->len < handler->expect_len) {
    58cc:	eb0c 0301 	add.w	r3, ip, r1
    58d0:	785a      	ldrb	r2, [r3, #1]
    58d2:	89a9      	ldrh	r1, [r5, #12]
    58d4:	4291      	cmp	r1, r2
    58d6:	d30e      	bcc.n	58f6 <bt_att_recv+0xc2>
		err = handler->func(att_chan, buf);
    58d8:	685b      	ldr	r3, [r3, #4]
    58da:	4629      	mov	r1, r5
    58dc:	4630      	mov	r0, r6
    58de:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
    58e0:	f1b8 0f01 	cmp.w	r8, #1
		err = handler->func(att_chan, buf);
    58e4:	4603      	mov	r3, r0
	if (handler->type == ATT_REQUEST && err) {
    58e6:	d103      	bne.n	58f0 <bt_att_recv+0xbc>
    58e8:	b110      	cbz	r0, 58f0 <bt_att_recv+0xbc>
		send_err_rsp(att_chan, hdr->code, 0, err);
    58ea:	7839      	ldrb	r1, [r7, #0]
	if (!req) {
    58ec:	2900      	cmp	r1, #0
    58ee:	d1dc      	bne.n	58aa <bt_att_recv+0x76>
}
    58f0:	2000      	movs	r0, #0
    58f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (handler->type == ATT_REQUEST && err) {
    58f6:	f1b8 0f01 	cmp.w	r8, #1
    58fa:	d1f9      	bne.n	58f0 <bt_att_recv+0xbc>
		err = BT_ATT_ERR_INVALID_PDU;
    58fc:	2304      	movs	r3, #4
    58fe:	e7f4      	b.n	58ea <bt_att_recv+0xb6>
    5900:	0001ee10 	.word	0x0001ee10

00005904 <att_write_req>:
{
    5904:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5908:	4604      	mov	r4, r0
    590a:	b087      	sub	sp, #28
	return net_buf_simple_pull_le16(&buf->b);
    590c:	f101 0008 	add.w	r0, r1, #8
    5910:	460d      	mov	r5, r1
    5912:	f00f fa9c 	bl	14e4e <net_buf_simple_pull_le16>
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
    5916:	6823      	ldr	r3, [r4, #0]
    5918:	4606      	mov	r6, r0
    591a:	2101      	movs	r1, #1
    591c:	6818      	ldr	r0, [r3, #0]
			     handle, 0, buf->data, buf->len);
    591e:	f8d5 9008 	ldr.w	r9, [r5, #8]
	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
    5922:	89ad      	ldrh	r5, [r5, #12]
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
    5924:	f00f f9b5 	bl	14c92 <bt_gatt_change_aware>
    5928:	2800      	cmp	r0, #0
    592a:	d03f      	beq.n	59ac <att_write_req+0xa8>
	if (!handle) {
    592c:	2e00      	cmp	r6, #0
    592e:	d03f      	beq.n	59b0 <att_write_req+0xac>
	(void)memset(&data, 0, sizeof(data));
    5930:	2218      	movs	r2, #24
    5932:	2100      	movs	r1, #0
    5934:	4668      	mov	r0, sp
    5936:	f018 f821 	bl	1d97c <memset>
		data.buf = bt_att_chan_create_pdu(chan, rsp, 0);
    593a:	2200      	movs	r2, #0
    593c:	2113      	movs	r1, #19
    593e:	4620      	mov	r0, r4
    5940:	f00e fd2f 	bl	143a2 <bt_att_chan_create_pdu>
    5944:	9001      	str	r0, [sp, #4]
		if (!data.buf) {
    5946:	b378      	cbz	r0, 59a8 <att_write_req+0xa4>
	data.conn = chan->att->conn;
    5948:	6823      	ldr	r3, [r4, #0]
	data.req = req;
    594a:	f04f 0812 	mov.w	r8, #18
	data.conn = chan->att->conn;
    594e:	681b      	ldr	r3, [r3, #0]
	data.offset = offset;
    5950:	2700      	movs	r7, #0
	data.conn = chan->att->conn;
    5952:	9300      	str	r3, [sp, #0]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    5954:	2301      	movs	r3, #1
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    5956:	4631      	mov	r1, r6
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    5958:	f88d 3014 	strb.w	r3, [sp, #20]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    595c:	4630      	mov	r0, r6
    595e:	466b      	mov	r3, sp
    5960:	4a14      	ldr	r2, [pc, #80]	; (59b4 <att_write_req+0xb0>)
	data.len = len;
    5962:	f8ad 5010 	strh.w	r5, [sp, #16]
	data.req = req;
    5966:	f88d 8008 	strb.w	r8, [sp, #8]
	data.offset = offset;
    596a:	f8ad 7012 	strh.w	r7, [sp, #18]
	data.value = value;
    596e:	f8cd 900c 	str.w	r9, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
    5972:	f00e fa50 	bl	13e16 <bt_gatt_foreach_attr>
	if (data.err) {
    5976:	f89d 5014 	ldrb.w	r5, [sp, #20]
    597a:	b175      	cbz	r5, 599a <att_write_req+0x96>
			net_buf_unref(data.buf);
    597c:	9801      	ldr	r0, [sp, #4]
    597e:	f000 ffe7 	bl	6950 <net_buf_unref>
	if (!req) {
    5982:	4632      	mov	r2, r6
    5984:	4641      	mov	r1, r8
    5986:	4620      	mov	r0, r4
    5988:	f89d 3014 	ldrb.w	r3, [sp, #20]
    598c:	f00e fd2e 	bl	143ec <send_err_rsp.part.0>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    5990:	463d      	mov	r5, r7
}
    5992:	4628      	mov	r0, r5
    5994:	b007      	add	sp, #28
    5996:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (data.buf) {
    599a:	9901      	ldr	r1, [sp, #4]
    599c:	2900      	cmp	r1, #0
    599e:	d0f8      	beq.n	5992 <att_write_req+0x8e>
		bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    59a0:	4620      	mov	r0, r4
    59a2:	f7ff fec9 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
    59a6:	e7f4      	b.n	5992 <att_write_req+0x8e>
			return BT_ATT_ERR_UNLIKELY;
    59a8:	250e      	movs	r5, #14
    59aa:	e7f2      	b.n	5992 <att_write_req+0x8e>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    59ac:	2512      	movs	r5, #18
    59ae:	e7f0      	b.n	5992 <att_write_req+0x8e>
		return BT_ATT_ERR_INVALID_HANDLE;
    59b0:	2501      	movs	r5, #1
    59b2:	e7ee      	b.n	5992 <att_write_req+0x8e>
    59b4:	00014277 	.word	0x00014277

000059b8 <att_read_group_req>:
{
    59b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t uuid_len = buf->len - sizeof(*req);
    59bc:	7b0c      	ldrb	r4, [r1, #12]
{
    59be:	4605      	mov	r5, r0
	uint8_t uuid_len = buf->len - sizeof(*req);
    59c0:	3c04      	subs	r4, #4
    59c2:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    59c4:	2c02      	cmp	r4, #2
{
    59c6:	4608      	mov	r0, r1
    59c8:	b08c      	sub	sp, #48	; 0x30
	if (uuid_len != 2 && uuid_len != 16) {
    59ca:	d001      	beq.n	59d0 <att_read_group_req+0x18>
    59cc:	2c10      	cmp	r4, #16
    59ce:	d16e      	bne.n	5aae <att_read_group_req+0xf6>
	return net_buf_simple_pull_mem(&buf->b, len);
    59d0:	2104      	movs	r1, #4
    59d2:	3008      	adds	r0, #8
    59d4:	f00f fa33 	bl	14e3e <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    59d8:	f10d 0808 	add.w	r8, sp, #8
	start_handle = sys_le16_to_cpu(req->start_handle);
    59dc:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    59de:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    59e0:	1d01      	adds	r1, r0, #4
    59e2:	4622      	mov	r2, r4
    59e4:	4640      	mov	r0, r8
    59e6:	f00d fc82 	bl	132ee <bt_uuid_create>
    59ea:	2800      	cmp	r0, #0
    59ec:	d061      	beq.n	5ab2 <att_read_group_req+0xfa>
	if (!start || !end) {
    59ee:	2e00      	cmp	r6, #0
    59f0:	d03a      	beq.n	5a68 <att_read_group_req+0xb0>
    59f2:	2400      	movs	r4, #0
    59f4:	2f00      	cmp	r7, #0
    59f6:	d036      	beq.n	5a66 <att_read_group_req+0xae>
	if (start > end) {
    59f8:	42be      	cmp	r6, r7
    59fa:	d835      	bhi.n	5a68 <att_read_group_req+0xb0>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    59fc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    5a00:	4640      	mov	r0, r8
    5a02:	a901      	add	r1, sp, #4
    5a04:	f88d 4004 	strb.w	r4, [sp, #4]
    5a08:	f8ad 3006 	strh.w	r3, [sp, #6]
    5a0c:	f00d fc45 	bl	1329a <bt_uuid_cmp>
    5a10:	2800      	cmp	r0, #0
    5a12:	d134      	bne.n	5a7e <att_read_group_req+0xc6>
	struct bt_conn *conn = chan->chan.chan.conn;
    5a14:	68ac      	ldr	r4, [r5, #8]
	(void)memset(&data, 0, sizeof(data));
    5a16:	2214      	movs	r2, #20
    5a18:	2100      	movs	r1, #0
    5a1a:	a807      	add	r0, sp, #28
    5a1c:	f017 ffae 	bl	1d97c <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
    5a20:	2201      	movs	r2, #1
    5a22:	2111      	movs	r1, #17
    5a24:	4620      	mov	r0, r4
    5a26:	f00e fcfe 	bl	14426 <bt_att_create_pdu>
    5a2a:	9009      	str	r0, [sp, #36]	; 0x24
	if (!data.buf) {
    5a2c:	2800      	cmp	r0, #0
    5a2e:	d040      	beq.n	5ab2 <att_read_group_req+0xfa>
	return net_buf_simple_add(&buf->b, len);
    5a30:	2101      	movs	r1, #1
    5a32:	3008      	adds	r0, #8
	data.uuid = uuid;
    5a34:	e9cd 5807 	strd	r5, r8, [sp, #28]
    5a38:	f00f f9d0 	bl	14ddc <net_buf_simple_add>
	data.rsp->len = 0U;
    5a3c:	f04f 0800 	mov.w	r8, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    5a40:	900a      	str	r0, [sp, #40]	; 0x28
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    5a42:	ab07      	add	r3, sp, #28
	data.rsp->len = 0U;
    5a44:	f880 8000 	strb.w	r8, [r0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    5a48:	4639      	mov	r1, r7
    5a4a:	4630      	mov	r0, r6
    5a4c:	4a1a      	ldr	r2, [pc, #104]	; (5ab8 <att_read_group_req+0x100>)
	data.group = NULL;
    5a4e:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
    5a52:	f00e f9e0 	bl	13e16 <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
    5a56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5a58:	781c      	ldrb	r4, [r3, #0]
    5a5a:	bb1c      	cbnz	r4, 5aa4 <att_read_group_req+0xec>
		net_buf_unref(data.buf);
    5a5c:	9809      	ldr	r0, [sp, #36]	; 0x24
    5a5e:	f000 ff77 	bl	6950 <net_buf_unref>
	if (!req) {
    5a62:	230a      	movs	r3, #10
    5a64:	e018      	b.n	5a98 <att_read_group_req+0xe0>
			*err = 0U;
    5a66:	463e      	mov	r6, r7
	if (!req) {
    5a68:	2301      	movs	r3, #1
    5a6a:	4632      	mov	r2, r6
    5a6c:	2110      	movs	r1, #16
    5a6e:	4628      	mov	r0, r5
    5a70:	f00e fcbc 	bl	143ec <send_err_rsp.part.0>
		return 0;
    5a74:	2400      	movs	r4, #0
}
    5a76:	4620      	mov	r0, r4
    5a78:	b00c      	add	sp, #48	; 0x30
    5a7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
    5a7e:	f642 0301 	movw	r3, #10241	; 0x2801
    5a82:	4640      	mov	r0, r8
    5a84:	a907      	add	r1, sp, #28
    5a86:	f88d 401c 	strb.w	r4, [sp, #28]
    5a8a:	f8ad 301e 	strh.w	r3, [sp, #30]
    5a8e:	f00d fc04 	bl	1329a <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
    5a92:	2800      	cmp	r0, #0
    5a94:	d0be      	beq.n	5a14 <att_read_group_req+0x5c>
	if (!req) {
    5a96:	2310      	movs	r3, #16
    5a98:	4632      	mov	r2, r6
    5a9a:	2110      	movs	r1, #16
    5a9c:	4628      	mov	r0, r5
    5a9e:	f00e fca5 	bl	143ec <send_err_rsp.part.0>
		return 0;
    5aa2:	e7e8      	b.n	5a76 <att_read_group_req+0xbe>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    5aa4:	4628      	mov	r0, r5
    5aa6:	9909      	ldr	r1, [sp, #36]	; 0x24
    5aa8:	f7ff fe46 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
	return 0;
    5aac:	e7e2      	b.n	5a74 <att_read_group_req+0xbc>
		return BT_ATT_ERR_INVALID_PDU;
    5aae:	2404      	movs	r4, #4
    5ab0:	e7e1      	b.n	5a76 <att_read_group_req+0xbe>
		return BT_ATT_ERR_UNLIKELY;
    5ab2:	240e      	movs	r4, #14
    5ab4:	e7df      	b.n	5a76 <att_read_group_req+0xbe>
    5ab6:	bf00      	nop
    5ab8:	00005465 	.word	0x00005465

00005abc <att_read_mult_req>:
{
    5abc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
    5ac0:	6886      	ldr	r6, [r0, #8]
{
    5ac2:	b085      	sub	sp, #20
	(void)memset(&data, 0, sizeof(data));
    5ac4:	2210      	movs	r2, #16
{
    5ac6:	4604      	mov	r4, r0
    5ac8:	460d      	mov	r5, r1
	(void)memset(&data, 0, sizeof(data));
    5aca:	4668      	mov	r0, sp
    5acc:	2100      	movs	r1, #0
    5ace:	f017 ff55 	bl	1d97c <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
    5ad2:	2200      	movs	r2, #0
    5ad4:	210f      	movs	r1, #15
    5ad6:	4630      	mov	r0, r6
    5ad8:	f00e fca5 	bl	14426 <bt_att_create_pdu>
    5adc:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
    5ade:	b358      	cbz	r0, 5b38 <att_read_mult_req+0x7c>
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    5ae0:	f04f 0801 	mov.w	r8, #1
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    5ae4:	f8df 9054 	ldr.w	r9, [pc, #84]	; 5b3c <att_read_mult_req+0x80>
	data.chan = chan;
    5ae8:	9400      	str	r4, [sp, #0]
	return net_buf_simple_pull_le16(&buf->b);
    5aea:	f105 0708 	add.w	r7, r5, #8
	while (buf->len >= sizeof(uint16_t)) {
    5aee:	89ab      	ldrh	r3, [r5, #12]
    5af0:	2b01      	cmp	r3, #1
    5af2:	d804      	bhi.n	5afe <att_read_mult_req+0x42>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    5af4:	4620      	mov	r0, r4
    5af6:	9902      	ldr	r1, [sp, #8]
    5af8:	f7ff fe1e 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
    5afc:	e018      	b.n	5b30 <att_read_mult_req+0x74>
    5afe:	4638      	mov	r0, r7
    5b00:	f00f f9a5 	bl	14e4e <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    5b04:	466b      	mov	r3, sp
    5b06:	464a      	mov	r2, r9
    5b08:	4601      	mov	r1, r0
    5b0a:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    5b0c:	f88d 800c 	strb.w	r8, [sp, #12]
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    5b10:	f00e f981 	bl	13e16 <bt_gatt_foreach_attr>
		if (data.err) {
    5b14:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5b18:	2b00      	cmp	r3, #0
    5b1a:	d0e8      	beq.n	5aee <att_read_mult_req+0x32>
			net_buf_unref(data.buf);
    5b1c:	9802      	ldr	r0, [sp, #8]
    5b1e:	f000 ff17 	bl	6950 <net_buf_unref>
	if (!req) {
    5b22:	4632      	mov	r2, r6
    5b24:	210e      	movs	r1, #14
    5b26:	4620      	mov	r0, r4
    5b28:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5b2c:	f00e fc5e 	bl	143ec <send_err_rsp.part.0>
	return 0;
    5b30:	2000      	movs	r0, #0
}
    5b32:	b005      	add	sp, #20
    5b34:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_ATT_ERR_UNLIKELY;
    5b38:	200e      	movs	r0, #14
    5b3a:	e7fa      	b.n	5b32 <att_read_mult_req+0x76>
    5b3c:	0001434f 	.word	0x0001434f

00005b40 <att_read_rsp>:
{
    5b40:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = chan->chan.chan.conn;
    5b44:	f8d0 8008 	ldr.w	r8, [r0, #8]
{
    5b48:	4605      	mov	r5, r0
    5b4a:	460f      	mov	r7, r1
	if (!bt_gatt_change_aware(conn, true)) {
    5b4c:	4640      	mov	r0, r8
    5b4e:	2101      	movs	r1, #1
{
    5b50:	4614      	mov	r4, r2
    5b52:	461e      	mov	r6, r3
	if (!bt_gatt_change_aware(conn, true)) {
    5b54:	f00f f89d 	bl	14c92 <bt_gatt_change_aware>
    5b58:	b388      	cbz	r0, 5bbe <att_read_rsp+0x7e>
	if (!handle) {
    5b5a:	b396      	cbz	r6, 5bc2 <att_read_rsp+0x82>
	(void)memset(&data, 0, sizeof(data));
    5b5c:	2210      	movs	r2, #16
    5b5e:	2100      	movs	r1, #0
    5b60:	4668      	mov	r0, sp
    5b62:	f017 ff0b 	bl	1d97c <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
    5b66:	2200      	movs	r2, #0
    5b68:	4621      	mov	r1, r4
    5b6a:	4640      	mov	r0, r8
    5b6c:	f00e fc5b 	bl	14426 <bt_att_create_pdu>
    5b70:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
    5b72:	b340      	cbz	r0, 5bc6 <att_read_rsp+0x86>
	data.offset = offset;
    5b74:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    5b78:	4631      	mov	r1, r6
	data.offset = offset;
    5b7a:	f8ad 3004 	strh.w	r3, [sp, #4]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    5b7e:	2301      	movs	r3, #1
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    5b80:	4630      	mov	r0, r6
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    5b82:	f88d 300c 	strb.w	r3, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    5b86:	4a11      	ldr	r2, [pc, #68]	; (5bcc <att_read_rsp+0x8c>)
    5b88:	466b      	mov	r3, sp
	data.chan = chan;
    5b8a:	9500      	str	r5, [sp, #0]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
    5b8c:	f00e f943 	bl	13e16 <bt_gatt_foreach_attr>
	if (data.err) {
    5b90:	f89d 400c 	ldrb.w	r4, [sp, #12]
    5b94:	b174      	cbz	r4, 5bb4 <att_read_rsp+0x74>
		net_buf_unref(data.buf);
    5b96:	9802      	ldr	r0, [sp, #8]
    5b98:	f000 feda 	bl	6950 <net_buf_unref>
	if (!req) {
    5b9c:	4632      	mov	r2, r6
    5b9e:	4639      	mov	r1, r7
    5ba0:	4628      	mov	r0, r5
    5ba2:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5ba6:	f00e fc21 	bl	143ec <send_err_rsp.part.0>
		return 0;
    5baa:	2400      	movs	r4, #0
}
    5bac:	4620      	mov	r0, r4
    5bae:	b004      	add	sp, #16
    5bb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    5bb4:	4628      	mov	r0, r5
    5bb6:	9902      	ldr	r1, [sp, #8]
    5bb8:	f7ff fdbe 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
	return 0;
    5bbc:	e7f6      	b.n	5bac <att_read_rsp+0x6c>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
    5bbe:	2412      	movs	r4, #18
    5bc0:	e7f4      	b.n	5bac <att_read_rsp+0x6c>
		return BT_ATT_ERR_INVALID_HANDLE;
    5bc2:	2401      	movs	r4, #1
    5bc4:	e7f2      	b.n	5bac <att_read_rsp+0x6c>
		return BT_ATT_ERR_UNLIKELY;
    5bc6:	240e      	movs	r4, #14
    5bc8:	e7f0      	b.n	5bac <att_read_rsp+0x6c>
    5bca:	bf00      	nop
    5bcc:	0001434f 	.word	0x0001434f

00005bd0 <att_read_type_req>:
{
    5bd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t uuid_len = buf->len - sizeof(*req);
    5bd4:	7b0c      	ldrb	r4, [r1, #12]
{
    5bd6:	4605      	mov	r5, r0
	uint8_t uuid_len = buf->len - sizeof(*req);
    5bd8:	3c04      	subs	r4, #4
    5bda:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
    5bdc:	2c02      	cmp	r4, #2
{
    5bde:	4608      	mov	r0, r1
    5be0:	b08c      	sub	sp, #48	; 0x30
	if (uuid_len != 2 && uuid_len != 16) {
    5be2:	d001      	beq.n	5be8 <att_read_type_req+0x18>
    5be4:	2c10      	cmp	r4, #16
    5be6:	d14f      	bne.n	5c88 <att_read_type_req+0xb8>
	return net_buf_simple_pull_mem(&buf->b, len);
    5be8:	2104      	movs	r1, #4
    5bea:	3008      	adds	r0, #8
    5bec:	f00f f927 	bl	14e3e <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    5bf0:	f10d 0804 	add.w	r8, sp, #4
	start_handle = sys_le16_to_cpu(req->start_handle);
    5bf4:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
    5bf6:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
    5bf8:	1d01      	adds	r1, r0, #4
    5bfa:	4622      	mov	r2, r4
    5bfc:	4640      	mov	r0, r8
    5bfe:	f00d fb76 	bl	132ee <bt_uuid_create>
    5c02:	b188      	cbz	r0, 5c28 <att_read_type_req+0x58>
	if (!start || !end) {
    5c04:	b19e      	cbz	r6, 5c2e <att_read_type_req+0x5e>
    5c06:	b18f      	cbz	r7, 5c2c <att_read_type_req+0x5c>
	if (start > end) {
    5c08:	42b7      	cmp	r7, r6
    5c0a:	d310      	bcc.n	5c2e <att_read_type_req+0x5e>
	(void)memset(&data, 0, sizeof(data));
    5c0c:	2218      	movs	r2, #24
	struct bt_conn *conn = chan->chan.chan.conn;
    5c0e:	68ac      	ldr	r4, [r5, #8]
	(void)memset(&data, 0, sizeof(data));
    5c10:	2100      	movs	r1, #0
    5c12:	eb0d 0002 	add.w	r0, sp, r2
    5c16:	f017 feb1 	bl	1d97c <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
    5c1a:	2201      	movs	r2, #1
    5c1c:	2109      	movs	r1, #9
    5c1e:	4620      	mov	r0, r4
    5c20:	f00e fc01 	bl	14426 <bt_att_create_pdu>
    5c24:	9008      	str	r0, [sp, #32]
	if (!data.buf) {
    5c26:	b968      	cbnz	r0, 5c44 <att_read_type_req+0x74>
		return BT_ATT_ERR_UNLIKELY;
    5c28:	240e      	movs	r4, #14
    5c2a:	e007      	b.n	5c3c <att_read_type_req+0x6c>
			*err = 0U;
    5c2c:	463e      	mov	r6, r7
	if (!req) {
    5c2e:	2301      	movs	r3, #1
    5c30:	4632      	mov	r2, r6
    5c32:	2108      	movs	r1, #8
    5c34:	4628      	mov	r0, r5
    5c36:	f00e fbd9 	bl	143ec <send_err_rsp.part.0>
		return 0;
    5c3a:	2400      	movs	r4, #0
}
    5c3c:	4620      	mov	r0, r4
    5c3e:	b00c      	add	sp, #48	; 0x30
    5c40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return net_buf_simple_add(&buf->b, len);
    5c44:	2101      	movs	r1, #1
    5c46:	3008      	adds	r0, #8
	data.uuid = uuid;
    5c48:	e9cd 5806 	strd	r5, r8, [sp, #24]
    5c4c:	f00f f8c6 	bl	14ddc <net_buf_simple_add>
	data.rsp->len = 0U;
    5c50:	f04f 0800 	mov.w	r8, #0
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    5c54:	230a      	movs	r3, #10
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    5c56:	9009      	str	r0, [sp, #36]	; 0x24
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    5c58:	4639      	mov	r1, r7
	data.rsp->len = 0U;
    5c5a:	f880 8000 	strb.w	r8, [r0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    5c5e:	4a0b      	ldr	r2, [pc, #44]	; (5c8c <att_read_type_req+0xbc>)
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    5c60:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
    5c64:	4630      	mov	r0, r6
    5c66:	ab06      	add	r3, sp, #24
    5c68:	f00e f8d5 	bl	13e16 <bt_gatt_foreach_attr>
	if (data.err) {
    5c6c:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
    5c70:	b12c      	cbz	r4, 5c7e <att_read_type_req+0xae>
		net_buf_unref(data.buf);
    5c72:	9808      	ldr	r0, [sp, #32]
    5c74:	f000 fe6c 	bl	6950 <net_buf_unref>
	if (!req) {
    5c78:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    5c7c:	e7d8      	b.n	5c30 <att_read_type_req+0x60>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    5c7e:	4628      	mov	r0, r5
    5c80:	9908      	ldr	r1, [sp, #32]
    5c82:	f7ff fd59 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
	return 0;
    5c86:	e7d9      	b.n	5c3c <att_read_type_req+0x6c>
		return BT_ATT_ERR_INVALID_PDU;
    5c88:	2404      	movs	r4, #4
    5c8a:	e7d7      	b.n	5c3c <att_read_type_req+0x6c>
    5c8c:	00005511 	.word	0x00005511

00005c90 <att_find_type_req>:
{
    5c90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5c94:	4688      	mov	r8, r1
    5c96:	4605      	mov	r5, r0
	return net_buf_simple_pull_mem(&buf->b, len);
    5c98:	2106      	movs	r1, #6
    5c9a:	b086      	sub	sp, #24
    5c9c:	f108 0008 	add.w	r0, r8, #8
    5ca0:	f00f f8cd 	bl	14e3e <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
    5ca4:	8807      	ldrh	r7, [r0, #0]
	if (!start || !end) {
    5ca6:	b317      	cbz	r7, 5cee <att_find_type_req+0x5e>
	end_handle = sys_le16_to_cpu(req->end_handle);
    5ca8:	f8b0 9002 	ldrh.w	r9, [r0, #2]
	if (!start || !end) {
    5cac:	f1b9 0f00 	cmp.w	r9, #0
    5cb0:	d01c      	beq.n	5cec <att_find_type_req+0x5c>
	if (start > end) {
    5cb2:	454f      	cmp	r7, r9
    5cb4:	d81b      	bhi.n	5cee <att_find_type_req+0x5e>
	type = sys_le16_to_cpu(req->type);
    5cb6:	8883      	ldrh	r3, [r0, #4]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    5cb8:	2400      	movs	r4, #0
    5cba:	f8ad 3002 	strh.w	r3, [sp, #2]
    5cbe:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    5cc2:	4668      	mov	r0, sp
    5cc4:	a901      	add	r1, sp, #4
	value = buf->data;
    5cc6:	f8d8 a008 	ldr.w	sl, [r8, #8]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
    5cca:	f88d 4000 	strb.w	r4, [sp]
    5cce:	f88d 4004 	strb.w	r4, [sp, #4]
    5cd2:	f8ad 3006 	strh.w	r3, [sp, #6]
    5cd6:	f00d fae0 	bl	1329a <bt_uuid_cmp>
    5cda:	4606      	mov	r6, r0
    5cdc:	b190      	cbz	r0, 5d04 <att_find_type_req+0x74>
	if (!req) {
    5cde:	230a      	movs	r3, #10
    5ce0:	463a      	mov	r2, r7
    5ce2:	2106      	movs	r1, #6
    5ce4:	4628      	mov	r0, r5
    5ce6:	f00e fb81 	bl	143ec <send_err_rsp.part.0>
		return 0;
    5cea:	e007      	b.n	5cfc <att_find_type_req+0x6c>
			*err = 0U;
    5cec:	464f      	mov	r7, r9
	if (!req) {
    5cee:	2301      	movs	r3, #1
    5cf0:	463a      	mov	r2, r7
    5cf2:	2106      	movs	r1, #6
    5cf4:	4628      	mov	r0, r5
    5cf6:	f00e fb79 	bl	143ec <send_err_rsp.part.0>
		return 0;
    5cfa:	2400      	movs	r4, #0
}
    5cfc:	4620      	mov	r0, r4
    5cfe:	b006      	add	sp, #24
    5d00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return att_find_type_rsp(chan, start_handle, end_handle, value,
    5d04:	f898 400c 	ldrb.w	r4, [r8, #12]
	struct bt_conn *conn = chan->chan.chan.conn;
    5d08:	f8d5 8008 	ldr.w	r8, [r5, #8]
	(void)memset(&data, 0, sizeof(data));
    5d0c:	4601      	mov	r1, r0
    5d0e:	2214      	movs	r2, #20
    5d10:	a801      	add	r0, sp, #4
    5d12:	f017 fe33 	bl	1d97c <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
    5d16:	4632      	mov	r2, r6
    5d18:	2107      	movs	r1, #7
    5d1a:	4640      	mov	r0, r8
    5d1c:	f00e fb83 	bl	14426 <bt_att_create_pdu>
    5d20:	9002      	str	r0, [sp, #8]
	if (!data.buf) {
    5d22:	b1d8      	cbz	r0, 5d5c <att_find_type_req+0xcc>
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    5d24:	230a      	movs	r3, #10
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    5d26:	4649      	mov	r1, r9
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    5d28:	f88d 3015 	strb.w	r3, [sp, #21]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    5d2c:	4638      	mov	r0, r7
    5d2e:	4a0c      	ldr	r2, [pc, #48]	; (5d60 <att_find_type_req+0xd0>)
    5d30:	ab01      	add	r3, sp, #4
	data.value_len = value_len;
    5d32:	f88d 4014 	strb.w	r4, [sp, #20]
	data.value = value;
    5d36:	e9cd 6a03 	strd	r6, sl, [sp, #12]
	data.chan = chan;
    5d3a:	9501      	str	r5, [sp, #4]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
    5d3c:	f00e f86b 	bl	13e16 <bt_gatt_foreach_attr>
	if (data.err) {
    5d40:	f89d 4015 	ldrb.w	r4, [sp, #21]
    5d44:	b12c      	cbz	r4, 5d52 <att_find_type_req+0xc2>
		net_buf_unref(data.buf);
    5d46:	9802      	ldr	r0, [sp, #8]
    5d48:	f000 fe02 	bl	6950 <net_buf_unref>
	if (!req) {
    5d4c:	f89d 3015 	ldrb.w	r3, [sp, #21]
    5d50:	e7ce      	b.n	5cf0 <att_find_type_req+0x60>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    5d52:	4628      	mov	r0, r5
    5d54:	9902      	ldr	r1, [sp, #8]
    5d56:	f7ff fcef 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
	return 0;
    5d5a:	e7cf      	b.n	5cfc <att_find_type_req+0x6c>
		return BT_ATT_ERR_UNLIKELY;
    5d5c:	240e      	movs	r4, #14
	return att_find_type_rsp(chan, start_handle, end_handle, value,
    5d5e:	e7cd      	b.n	5cfc <att_find_type_req+0x6c>
    5d60:	00013f43 	.word	0x00013f43

00005d64 <att_find_info_req>:
{
    5d64:	b5f0      	push	{r4, r5, r6, r7, lr}
	req = (void *)buf->data;
    5d66:	688b      	ldr	r3, [r1, #8]
{
    5d68:	4605      	mov	r5, r0
	start_handle = sys_le16_to_cpu(req->start_handle);
    5d6a:	881e      	ldrh	r6, [r3, #0]
{
    5d6c:	b085      	sub	sp, #20
	if (!start || !end) {
    5d6e:	b19e      	cbz	r6, 5d98 <att_find_info_req+0x34>
	end_handle = sys_le16_to_cpu(req->end_handle);
    5d70:	885c      	ldrh	r4, [r3, #2]
	if (!start || !end) {
    5d72:	b184      	cbz	r4, 5d96 <att_find_info_req+0x32>
	if (start > end) {
    5d74:	42b4      	cmp	r4, r6
    5d76:	d30f      	bcc.n	5d98 <att_find_info_req+0x34>
	struct bt_conn *conn = chan->chan.chan.conn;
    5d78:	6887      	ldr	r7, [r0, #8]
	(void)memset(&data, 0, sizeof(data));
    5d7a:	2210      	movs	r2, #16
    5d7c:	2100      	movs	r1, #0
    5d7e:	4668      	mov	r0, sp
    5d80:	f017 fdfc 	bl	1d97c <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
    5d84:	2200      	movs	r2, #0
    5d86:	2105      	movs	r1, #5
    5d88:	4638      	mov	r0, r7
    5d8a:	f00e fb4c 	bl	14426 <bt_att_create_pdu>
    5d8e:	9001      	str	r0, [sp, #4]
	if (!data.buf) {
    5d90:	b958      	cbnz	r0, 5daa <att_find_info_req+0x46>
		return BT_ATT_ERR_UNLIKELY;
    5d92:	200e      	movs	r0, #14
	return att_find_info_rsp(chan, start_handle, end_handle);
    5d94:	e007      	b.n	5da6 <att_find_info_req+0x42>
			*err = 0U;
    5d96:	4626      	mov	r6, r4
	if (!req) {
    5d98:	2301      	movs	r3, #1
    5d9a:	4632      	mov	r2, r6
    5d9c:	2104      	movs	r1, #4
    5d9e:	4628      	mov	r0, r5
    5da0:	f00e fb24 	bl	143ec <send_err_rsp.part.0>
	return 0;
    5da4:	2000      	movs	r0, #0
}
    5da6:	b005      	add	sp, #20
    5da8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    5daa:	4621      	mov	r1, r4
    5dac:	466b      	mov	r3, sp
    5dae:	4630      	mov	r0, r6
    5db0:	4a07      	ldr	r2, [pc, #28]	; (5dd0 <att_find_info_req+0x6c>)
	data.chan = chan;
    5db2:	9500      	str	r5, [sp, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
    5db4:	f00e f82f 	bl	13e16 <bt_gatt_foreach_attr>
	if (!data.rsp) {
    5db8:	9c02      	ldr	r4, [sp, #8]
    5dba:	b924      	cbnz	r4, 5dc6 <att_find_info_req+0x62>
		net_buf_unref(data.buf);
    5dbc:	9801      	ldr	r0, [sp, #4]
    5dbe:	f000 fdc7 	bl	6950 <net_buf_unref>
	if (!req) {
    5dc2:	230a      	movs	r3, #10
    5dc4:	e7e9      	b.n	5d9a <att_find_info_req+0x36>
	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
    5dc6:	4628      	mov	r0, r5
    5dc8:	9901      	ldr	r1, [sp, #4]
    5dca:	f7ff fcb5 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
    5dce:	e7e9      	b.n	5da4 <att_find_info_req+0x40>
    5dd0:	000140bf 	.word	0x000140bf

00005dd4 <bt_att_req_alloc>:

	return mtu;
}

struct bt_att_req *bt_att_req_alloc(k_timeout_t timeout)
{
    5dd4:	b513      	push	{r0, r1, r4, lr}
	struct bt_att_req *req = NULL;
    5dd6:	2400      	movs	r4, #0
{
    5dd8:	4602      	mov	r2, r0
    5dda:	460b      	mov	r3, r1

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    5ddc:	4807      	ldr	r0, [pc, #28]	; (5dfc <bt_att_req_alloc+0x28>)
    5dde:	a901      	add	r1, sp, #4
	struct bt_att_req *req = NULL;
    5de0:	9401      	str	r4, [sp, #4]
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    5de2:	f00a fa33 	bl	1024c <k_mem_slab_alloc>
    5de6:	4601      	mov	r1, r0
    5de8:	b930      	cbnz	r0, 5df8 <bt_att_req_alloc+0x24>
    5dea:	2218      	movs	r2, #24
    5dec:	9801      	ldr	r0, [sp, #4]
    5dee:	f017 fdc5 	bl	1d97c <memset>

	BT_DBG("req %p", req);

	memset(req, 0, sizeof(*req));

	return req;
    5df2:	9801      	ldr	r0, [sp, #4]
}
    5df4:	b002      	add	sp, #8
    5df6:	bd10      	pop	{r4, pc}
		return NULL;
    5df8:	4620      	mov	r0, r4
    5dfa:	e7fb      	b.n	5df4 <bt_att_req_alloc+0x20>
    5dfc:	200007b0 	.word	0x200007b0

00005e00 <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
    5e00:	b507      	push	{r0, r1, r2, lr}
    5e02:	9001      	str	r0, [sp, #4]
	BT_DBG("req %p", req);

	k_mem_slab_free(&req_slab, (void **)&req);
    5e04:	a901      	add	r1, sp, #4
    5e06:	4803      	ldr	r0, [pc, #12]	; (5e14 <bt_att_req_free+0x14>)
    5e08:	f00a fa52 	bl	102b0 <k_mem_slab_free>
}
    5e0c:	b003      	add	sp, #12
    5e0e:	f85d fb04 	ldr.w	pc, [sp], #4
    5e12:	bf00      	nop
    5e14:	200007b0 	.word	0x200007b0

00005e18 <att_handle_rsp>:
{
    5e18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5e1c:	4604      	mov	r4, r0
    5e1e:	b085      	sub	sp, #20
	k_delayed_work_cancel(&chan->timeout_work);
    5e20:	30e0      	adds	r0, #224	; 0xe0
{
    5e22:	4689      	mov	r9, r1
    5e24:	4692      	mov	sl, r2
    5e26:	4698      	mov	r8, r3
	k_delayed_work_cancel(&chan->timeout_work);
    5e28:	f017 fb64 	bl	1d4f4 <k_delayed_work_cancel>
	if (!chan->req) {
    5e2c:	f8d4 50c4 	ldr.w	r5, [r4, #196]	; 0xc4
    5e30:	2600      	movs	r6, #0
    5e32:	b12d      	cbz	r5, 5e40 <att_handle_rsp+0x28>
	if (chan->req == &cancel) {
    5e34:	4b2b      	ldr	r3, [pc, #172]	; (5ee4 <att_handle_rsp+0xcc>)
    5e36:	429d      	cmp	r5, r3
    5e38:	d123      	bne.n	5e82 <att_handle_rsp+0x6a>
	bt_att_func_t func = NULL;
    5e3a:	4635      	mov	r5, r6
		chan->req = NULL;
    5e3c:	f8c4 60c4 	str.w	r6, [r4, #196]	; 0xc4
	att_process(chan->att);
    5e40:	f8d4 b000 	ldr.w	fp, [r4]
	node = sys_slist_get(&att->reqs);
    5e44:	f10b 0004 	add.w	r0, fp, #4
    5e48:	f00d ff73 	bl	13d32 <sys_slist_get>
	if (!node) {
    5e4c:	4607      	mov	r7, r0
    5e4e:	b380      	cbz	r0, 5eb2 <att_handle_rsp+0x9a>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    5e50:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
    5e54:	b152      	cbz	r2, 5e6c <att_handle_rsp+0x54>
    5e56:	f5b2 7096 	subs.w	r0, r2, #300	; 0x12c
    5e5a:	d007      	beq.n	5e6c <att_handle_rsp+0x54>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    5e5c:	6816      	ldr	r6, [r2, #0]
    5e5e:	b10e      	cbz	r6, 5e64 <att_handle_rsp+0x4c>
    5e60:	f5a6 7696 	sub.w	r6, r6, #300	; 0x12c
		if (!chan->req) {
    5e64:	f8d0 20c4 	ldr.w	r2, [r0, #196]	; 0xc4
    5e68:	b1f2      	cbz	r2, 5ea8 <att_handle_rsp+0x90>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    5e6a:	bb7e      	cbnz	r6, 5ecc <att_handle_rsp+0xb4>
Z_GENLIST_PREPEND(slist, snode)
    5e6c:	f8db 2004 	ldr.w	r2, [fp, #4]
	parent->next = child;
    5e70:	603a      	str	r2, [r7, #0]
Z_GENLIST_PREPEND(slist, snode)
    5e72:	f8db 2008 	ldr.w	r2, [fp, #8]
	list->head = node;
    5e76:	f8cb 7004 	str.w	r7, [fp, #4]
Z_GENLIST_PREPEND(slist, snode)
    5e7a:	b9d2      	cbnz	r2, 5eb2 <att_handle_rsp+0x9a>
	list->tail = node;
    5e7c:	f8cb 7008 	str.w	r7, [fp, #8]
}
    5e80:	e017      	b.n	5eb2 <att_handle_rsp+0x9a>
	if (chan->req->buf) {
    5e82:	6928      	ldr	r0, [r5, #16]
    5e84:	b120      	cbz	r0, 5e90 <att_handle_rsp+0x78>
		net_buf_unref(chan->req->buf);
    5e86:	f000 fd63 	bl	6950 <net_buf_unref>
		chan->req->buf = NULL;
    5e8a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
    5e8e:	611e      	str	r6, [r3, #16]
	chan->req->func = NULL;
    5e90:	2600      	movs	r6, #0
	func = chan->req->func;
    5e92:	f8d4 00c4 	ldr.w	r0, [r4, #196]	; 0xc4
	params = chan->req->user_data;
    5e96:	6943      	ldr	r3, [r0, #20]
	func = chan->req->func;
    5e98:	6845      	ldr	r5, [r0, #4]
	chan->req->func = NULL;
    5e9a:	6046      	str	r6, [r0, #4]
	params = chan->req->user_data;
    5e9c:	9303      	str	r3, [sp, #12]
	att_req_destroy(chan->req);
    5e9e:	f00e fb31 	bl	14504 <att_req_destroy>
	chan->req = NULL;
    5ea2:	f8c4 60c4 	str.w	r6, [r4, #196]	; 0xc4
    5ea6:	e7cb      	b.n	5e40 <att_handle_rsp+0x28>
			if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
    5ea8:	4639      	mov	r1, r7
    5eaa:	f00e f9a9 	bl	14200 <bt_att_chan_req_send>
    5eae:	2800      	cmp	r0, #0
    5eb0:	dbdb      	blt.n	5e6a <att_handle_rsp+0x52>
	if (func) {
    5eb2:	b13d      	cbz	r5, 5ec4 <att_handle_rsp+0xac>
		func(chan->att->conn, err, pdu, len, params);
    5eb4:	9b03      	ldr	r3, [sp, #12]
    5eb6:	6820      	ldr	r0, [r4, #0]
    5eb8:	9300      	str	r3, [sp, #0]
    5eba:	464a      	mov	r2, r9
    5ebc:	4653      	mov	r3, sl
    5ebe:	4641      	mov	r1, r8
    5ec0:	6800      	ldr	r0, [r0, #0]
    5ec2:	47a8      	blx	r5
}
    5ec4:	2000      	movs	r0, #0
    5ec6:	b005      	add	sp, #20
    5ec8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
Z_GENLIST_PEEK_NEXT(slist, snode)
    5ecc:	f516 7296 	adds.w	r2, r6, #300	; 0x12c
    5ed0:	d004      	beq.n	5edc <att_handle_rsp+0xc4>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    5ed2:	f8d6 212c 	ldr.w	r2, [r6, #300]	; 0x12c
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    5ed6:	b10a      	cbz	r2, 5edc <att_handle_rsp+0xc4>
    5ed8:	f5a2 7296 	sub.w	r2, r2, #300	; 0x12c
	bt_att_func_t func = NULL;
    5edc:	4630      	mov	r0, r6
    5ede:	4616      	mov	r6, r2
    5ee0:	e7c0      	b.n	5e64 <att_handle_rsp+0x4c>
    5ee2:	bf00      	nop
    5ee4:	20025aac 	.word	0x20025aac

00005ee8 <att_reset>:
{
    5ee8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    5eea:	9003      	str	r0, [sp, #12]
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
    5eec:	9803      	ldr	r0, [sp, #12]
    5eee:	2200      	movs	r2, #0
    5ef0:	2300      	movs	r3, #0
    5ef2:	300c      	adds	r0, #12
    5ef4:	f00e ff21 	bl	14d3a <net_buf_get>
    5ef8:	b948      	cbnz	r0, 5f0e <att_reset+0x26>
	att->conn = NULL;
    5efa:	9a03      	ldr	r2, [sp, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
    5efc:	6855      	ldr	r5, [r2, #4]
	att->conn = NULL;
    5efe:	6010      	str	r0, [r2, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
    5f00:	b945      	cbnz	r5, 5f14 <att_reset+0x2c>
	k_mem_slab_free(&att_slab, (void **)&att);
    5f02:	4811      	ldr	r0, [pc, #68]	; (5f48 <att_reset+0x60>)
    5f04:	a903      	add	r1, sp, #12
    5f06:	f00a f9d3 	bl	102b0 <k_mem_slab_free>
}
    5f0a:	b004      	add	sp, #16
    5f0c:	bd70      	pop	{r4, r5, r6, pc}
		net_buf_unref(buf);
    5f0e:	f000 fd1f 	bl	6950 <net_buf_unref>
    5f12:	e7eb      	b.n	5eec <att_reset+0x4>
	return node->next;
    5f14:	682c      	ldr	r4, [r5, #0]
    5f16:	2c00      	cmp	r4, #0
    5f18:	bf38      	it	cc
    5f1a:	2400      	movcc	r4, #0
		if (req->func) {
    5f1c:	686e      	ldr	r6, [r5, #4]
    5f1e:	b136      	cbz	r6, 5f2e <att_reset+0x46>
			req->func(NULL, BT_ATT_ERR_UNLIKELY, NULL, 0,
    5f20:	696b      	ldr	r3, [r5, #20]
    5f22:	210e      	movs	r1, #14
    5f24:	9300      	str	r3, [sp, #0]
    5f26:	2300      	movs	r3, #0
    5f28:	461a      	mov	r2, r3
    5f2a:	4618      	mov	r0, r3
    5f2c:	47b0      	blx	r6
		att_req_destroy(req);
    5f2e:	4628      	mov	r0, r5
    5f30:	f00e fae8 	bl	14504 <att_req_destroy>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
    5f34:	2c00      	cmp	r4, #0
    5f36:	d0e4      	beq.n	5f02 <att_reset+0x1a>
    5f38:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    5f3a:	4625      	mov	r5, r4
    5f3c:	2b00      	cmp	r3, #0
    5f3e:	bf38      	it	cc
    5f40:	2300      	movcc	r3, #0
    5f42:	461c      	mov	r4, r3
    5f44:	e7ea      	b.n	5f1c <att_reset+0x34>
    5f46:	bf00      	nop
    5f48:	20000778 	.word	0x20000778

00005f4c <read_ppcp>:
	     (CONFIG_BT_PERIPHERAL_PREF_MIN_INT <=
	     CONFIG_BT_PERIPHERAL_PREF_MAX_INT));

static ssize_t read_ppcp(struct bt_conn *conn, const struct bt_gatt_attr *attr,
			 void *buf, uint16_t len, uint16_t offset)
{
    5f4c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    5f4e:	4619      	mov	r1, r3
		uint16_t timeout;
	} ppcp;

	ppcp.min_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MIN_INT);
	ppcp.max_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MAX_INT);
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
    5f50:	f44f 1328 	mov.w	r3, #2752512	; 0x2a0000
{
    5f54:	4610      	mov	r0, r2
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
    5f56:	4a06      	ldr	r2, [pc, #24]	; (5f70 <read_ppcp+0x24>)
    5f58:	e9cd 2302 	strd	r2, r3, [sp, #8]
	ppcp.timeout = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_TIMEOUT);

	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
    5f5c:	2308      	movs	r3, #8
    5f5e:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    5f62:	9300      	str	r3, [sp, #0]
    5f64:	446b      	add	r3, sp
    5f66:	f00e fc44 	bl	147f2 <bt_gatt_attr_read.constprop.0>
				 sizeof(ppcp));
}
    5f6a:	b005      	add	sp, #20
    5f6c:	f85d fb04 	ldr.w	pc, [sp], #4
    5f70:	00280018 	.word	0x00280018

00005f74 <find_sc_cfg>:
#endif
static struct gatt_sc_cfg sc_cfg[SC_CFG_MAX];
BUILD_ASSERT(sizeof(struct sc_data) == sizeof(sc_cfg[0].data));

static struct gatt_sc_cfg *find_sc_cfg(uint8_t id, bt_addr_le_t *addr)
{
    5f74:	b510      	push	{r4, lr}
	BT_DBG("id: %u, addr: %s", id, bt_addr_le_str(addr));

	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
		if (id == sc_cfg[i].id &&
    5f76:	4c06      	ldr	r4, [pc, #24]	; (5f90 <find_sc_cfg+0x1c>)
    5f78:	7823      	ldrb	r3, [r4, #0]
    5f7a:	4283      	cmp	r3, r0
    5f7c:	d104      	bne.n	5f88 <find_sc_cfg+0x14>
 *
 *  @return negative value if @a a < @a b, 0 if @a a == @a b, else positive
 */
static inline int bt_addr_le_cmp(const bt_addr_le_t *a, const bt_addr_le_t *b)
{
	return memcmp(a, b, sizeof(*a));
    5f7e:	2207      	movs	r2, #7
    5f80:	1c60      	adds	r0, r4, #1
    5f82:	f017 fce0 	bl	1d946 <memcmp>
    5f86:	b108      	cbz	r0, 5f8c <find_sc_cfg+0x18>
		    !bt_addr_le_cmp(&sc_cfg[i].peer, addr)) {
			return &sc_cfg[i];
		}
	}

	return NULL;
    5f88:	2000      	movs	r0, #0
}
    5f8a:	bd10      	pop	{r4, pc}
			return &sc_cfg[i];
    5f8c:	4620      	mov	r0, r4
    5f8e:	e7fc      	b.n	5f8a <find_sc_cfg+0x16>
    5f90:	20029f26 	.word	0x20029f26

00005f94 <find_cf_cfg>:
	atomic_set(cfg->flags, 0);
}

#if defined(CONFIG_BT_GATT_CACHING)
static struct gatt_cf_cfg *find_cf_cfg(struct bt_conn *conn)
{
    5f94:	b537      	push	{r0, r1, r2, r4, r5, lr}
	int i;

	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
		struct gatt_cf_cfg *cfg = &cf_cfg[i];

		if (!conn) {
    5f96:	4604      	mov	r4, r0
    5f98:	4d0c      	ldr	r5, [pc, #48]	; (5fcc <find_cf_cfg+0x38>)
    5f9a:	b968      	cbnz	r0, 5fb8 <find_cf_cfg+0x24>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    5f9c:	9000      	str	r0, [sp, #0]
    5f9e:	2207      	movs	r2, #7
    5fa0:	f8cd 0003 	str.w	r0, [sp, #3]
    5fa4:	4669      	mov	r1, sp
    5fa6:	1c68      	adds	r0, r5, #1
    5fa8:	f017 fccd 	bl	1d946 <memcmp>
		struct gatt_cf_cfg *cfg = &cf_cfg[i];
    5fac:	2800      	cmp	r0, #0
    5fae:	bf08      	it	eq
    5fb0:	462c      	moveq	r4, r5
			return cfg;
		}
	}

	return NULL;
}
    5fb2:	4620      	mov	r0, r4
    5fb4:	b003      	add	sp, #12
    5fb6:	bd30      	pop	{r4, r5, pc}
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    5fb8:	462a      	mov	r2, r5
    5fba:	f812 1b01 	ldrb.w	r1, [r2], #1
    5fbe:	f00d fd2e 	bl	13a1e <bt_conn_is_peer_addr_le>
    5fc2:	2800      	cmp	r0, #0
	return NULL;
    5fc4:	bf14      	ite	ne
    5fc6:	462c      	movne	r4, r5
    5fc8:	2400      	moveq	r4, #0
    5fca:	e7f2      	b.n	5fb2 <find_cf_cfg+0x1e>
    5fcc:	20025ac4 	.word	0x20025ac4

00005fd0 <sc_indicate_rsp>:
}

#if defined(CONFIG_BT_GATT_SERVICE_CHANGED)
static void sc_indicate_rsp(struct bt_conn *conn,
			    struct bt_gatt_indicate_params *params, uint8_t err)
{
    5fd0:	b510      	push	{r4, lr}
    5fd2:	4604      	mov	r4, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    5fd4:	4910      	ldr	r1, [pc, #64]	; (6018 <sc_indicate_rsp+0x48>)
    5fd6:	e8d1 3fef 	ldaex	r3, [r1]
    5fda:	f023 0302 	bic.w	r3, r3, #2
    5fde:	e8c1 3fe2 	stlex	r2, r3, [r1]
    5fe2:	2a00      	cmp	r2, #0
    5fe4:	d1f7      	bne.n	5fd6 <sc_indicate_rsp+0x6>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    5fe6:	e8d1 3faf 	lda	r3, [r1]
	BT_DBG("err 0x%02x", err);

	atomic_clear_bit(gatt_sc.flags, SC_INDICATE_PENDING);

	/* Check if there is new change in the meantime */
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    5fea:	07da      	lsls	r2, r3, #31
    5fec:	d505      	bpl.n	5ffa <sc_indicate_rsp+0x2a>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    5fee:	2200      	movs	r2, #0
    5ff0:	2300      	movs	r3, #0
    5ff2:	480a      	ldr	r0, [pc, #40]	; (601c <sc_indicate_rsp+0x4c>)
    5ff4:	3930      	subs	r1, #48	; 0x30
    5ff6:	f00b f829 	bl	1104c <k_delayed_work_submit_to_queue>
	/* BLUETOOTH CORE SPECIFICATION Version 5.1 | Vol 3, Part G page 2347:
	 * 2.5.2.1 Robust Caching
	 * A connected client becomes change-aware when...
	 * The client receives and confirms a Service Changed indication.
	 */
	cfg = find_cf_cfg(conn);
    5ffa:	4620      	mov	r0, r4
    5ffc:	f7ff ffca 	bl	5f94 <find_cf_cfg>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
    6000:	b140      	cbz	r0, 6014 <sc_indicate_rsp+0x44>
    6002:	7a03      	ldrb	r3, [r0, #8]
    6004:	07db      	lsls	r3, r3, #31
    6006:	d505      	bpl.n	6014 <sc_indicate_rsp+0x44>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
		BT_DBG("%s change-aware", bt_addr_le_str(&cfg->peer));
	}
#endif
}
    6008:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
    600c:	2100      	movs	r1, #0
    600e:	300c      	adds	r0, #12
    6010:	f00e bbd9 	b.w	147c6 <atomic_set_bit>
}
    6014:	bd10      	pop	{r4, pc}
    6016:	bf00      	nop
    6018:	20000f48 	.word	0x20000f48
    601c:	20001168 	.word	0x20001168

00006020 <gatt_indicate>:
	return err;
}

static int gatt_indicate(struct bt_conn *conn, uint16_t handle,
			 struct bt_gatt_indicate_params *params)
{
    6020:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6024:	4615      	mov	r5, r2
		return -EAGAIN;
	}
#endif

	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
				sizeof(*ind) + params->len);
    6026:	8a92      	ldrh	r2, [r2, #20]
{
    6028:	4689      	mov	r9, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
    602a:	3202      	adds	r2, #2
    602c:	211d      	movs	r1, #29
{
    602e:	4607      	mov	r7, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
    6030:	f00e f9f9 	bl	14426 <bt_att_create_pdu>
	if (!buf) {
    6034:	4606      	mov	r6, r0
    6036:	b308      	cbz	r0, 607c <gatt_indicate+0x5c>
	return net_buf_simple_add(&buf->b, len);
    6038:	f100 0808 	add.w	r8, r0, #8
    603c:	2102      	movs	r1, #2
    603e:	4640      	mov	r0, r8
    6040:	f00e fecc 	bl	14ddc <net_buf_simple_add>
	}

	BT_DBG("conn %p handle 0x%04x", conn, handle);

	ind = net_buf_add(buf, sizeof(*ind));
	ind->handle = sys_cpu_to_le16(handle);
    6044:	4604      	mov	r4, r0
    6046:	8aa9      	ldrh	r1, [r5, #20]
    6048:	f824 9b02 	strh.w	r9, [r4], #2
    604c:	4640      	mov	r0, r8
    604e:	f00e fec5 	bl	14ddc <net_buf_simple_add>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    6052:	4620      	mov	r0, r4
    6054:	8aaa      	ldrh	r2, [r5, #20]
    6056:	6929      	ldr	r1, [r5, #16]
    6058:	f017 fc83 	bl	1d962 <memcpy>

	net_buf_add(buf, params->len);
	memcpy(ind->value, params->data, params->len);

	if (!params->func) {
    605c:	68ab      	ldr	r3, [r5, #8]
    605e:	b933      	cbnz	r3, 606e <gatt_indicate+0x4e>
		err = bt_att_send(conn, buf, NULL, NULL);
    6060:	4631      	mov	r1, r6
    6062:	4638      	mov	r0, r7
		return gatt_send(conn, buf, NULL, NULL, NULL);
	}

	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
}
    6064:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		err = bt_att_send(conn, buf, NULL, NULL);
    6068:	461a      	mov	r2, r3
    606a:	f00e baac 	b.w	145c6 <bt_att_send>
		req = bt_att_req_alloc(BT_ATT_TIMEOUT);
    606e:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
    6072:	2100      	movs	r1, #0
    6074:	f7ff feae 	bl	5dd4 <bt_att_req_alloc>
		if (!req) {
    6078:	4604      	mov	r4, r0
    607a:	b910      	cbnz	r0, 6082 <gatt_indicate+0x62>
		return -ENOMEM;
    607c:	f06f 050b 	mvn.w	r5, #11
    6080:	e00e      	b.n	60a0 <gatt_indicate+0x80>
		req->func = func;
    6082:	4b09      	ldr	r3, [pc, #36]	; (60a8 <gatt_indicate+0x88>)
		req->user_data = params;
    6084:	6145      	str	r5, [r0, #20]
		req->func = func;
    6086:	6043      	str	r3, [r0, #4]
		req->destroy = destroy;
    6088:	2300      	movs	r3, #0
		err = bt_att_req_send(conn, req);
    608a:	4601      	mov	r1, r0
		req->buf = buf;
    608c:	6106      	str	r6, [r0, #16]
		req->destroy = destroy;
    608e:	6083      	str	r3, [r0, #8]
		err = bt_att_req_send(conn, req);
    6090:	4638      	mov	r0, r7
    6092:	f00e faec 	bl	1466e <bt_att_req_send>
		if (err) {
    6096:	4605      	mov	r5, r0
    6098:	b110      	cbz	r0, 60a0 <gatt_indicate+0x80>
			bt_att_req_free(req);
    609a:	4620      	mov	r0, r4
    609c:	f7ff feb0 	bl	5e00 <bt_att_req_free>
}
    60a0:	4628      	mov	r0, r5
    60a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    60a6:	bf00      	nop
    60a8:	000146ef 	.word	0x000146ef

000060ac <notify_cb>:

static uint8_t notify_cb(const struct bt_gatt_attr *attr, uint16_t handle,
			 void *user_data)
{
    60ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct notify_data *data = user_data;
	struct _bt_gatt_ccc *ccc;
	size_t i;

	/* Check attribute user_data must be of type struct _bt_gatt_ccc */
	if (attr->write != bt_gatt_attr_write_ccc) {
    60ae:	4b2e      	ldr	r3, [pc, #184]	; (6168 <notify_cb+0xbc>)
{
    60b0:	4614      	mov	r4, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
    60b2:	6882      	ldr	r2, [r0, #8]
{
    60b4:	4606      	mov	r6, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
    60b6:	429a      	cmp	r2, r3
    60b8:	d12e      	bne.n	6118 <notify_cb+0x6c>
		return BT_GATT_ITER_CONTINUE;
	}

	ccc = attr->user_data;
    60ba:	68c7      	ldr	r7, [r0, #12]

	/* Save Service Changed data if peer is not connected */
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
    60bc:	4b2b      	ldr	r3, [pc, #172]	; (616c <notify_cb+0xc0>)
    60be:	429f      	cmp	r7, r3
    60c0:	d11a      	bne.n	60f8 <notify_cb+0x4c>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
			struct gatt_sc_cfg *cfg = &sc_cfg[i];
			struct bt_conn *conn;

			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    60c2:	2300      	movs	r3, #0
    60c4:	4d2a      	ldr	r5, [pc, #168]	; (6170 <notify_cb+0xc4>)
    60c6:	2207      	movs	r2, #7
    60c8:	4669      	mov	r1, sp
    60ca:	1c68      	adds	r0, r5, #1
    60cc:	9300      	str	r3, [sp, #0]
    60ce:	f8cd 3003 	str.w	r3, [sp, #3]
    60d2:	f017 fc38 	bl	1d946 <memcmp>
    60d6:	b178      	cbz	r0, 60f8 <notify_cb+0x4c>
				continue;
			}

			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
    60d8:	4629      	mov	r1, r5
    60da:	2207      	movs	r2, #7
    60dc:	f811 0b01 	ldrb.w	r0, [r1], #1
    60e0:	f7fe ff8c 	bl	4ffc <bt_conn_lookup_state_le>
						       BT_CONN_CONNECTED);
			if (!conn) {
    60e4:	b9d8      	cbnz	r0, 611e <notify_cb+0x72>
				struct sc_data *sc;

				sc = (struct sc_data *)data->ind_params->data;
				sc_save(cfg->id, &cfg->peer,
    60e6:	4629      	mov	r1, r5
				sc = (struct sc_data *)data->ind_params->data;
    60e8:	6923      	ldr	r3, [r4, #16]
				sc_save(cfg->id, &cfg->peer,
    60ea:	f811 0b01 	ldrb.w	r0, [r1], #1
				sc = (struct sc_data *)data->ind_params->data;
    60ee:	691a      	ldr	r2, [r3, #16]
				sc_save(cfg->id, &cfg->peer,
    60f0:	8853      	ldrh	r3, [r2, #2]
    60f2:	8812      	ldrh	r2, [r2, #0]
    60f4:	f00e fbe4 	bl	148c0 <sc_save>
		int err;

		/* Check if config value matches data type since consolidated
		 * value may be for a different peer.
		 */
		if (cfg->value != data->type) {
    60f8:	893a      	ldrh	r2, [r7, #8]
    60fa:	89a3      	ldrh	r3, [r4, #12]
    60fc:	429a      	cmp	r2, r3
    60fe:	d10b      	bne.n	6118 <notify_cb+0x6c>
			continue;
		}

		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    6100:	4639      	mov	r1, r7
    6102:	f811 0b01 	ldrb.w	r0, [r1], #1
    6106:	f7fe ff5b 	bl	4fc0 <bt_conn_lookup_addr_le>
		if (!conn) {
    610a:	4605      	mov	r5, r0
    610c:	b120      	cbz	r0, 6118 <notify_cb+0x6c>
			continue;
		}

		if (conn->state != BT_CONN_CONNECTED) {
    610e:	7a83      	ldrb	r3, [r0, #10]
    6110:	2b07      	cmp	r3, #7
    6112:	d007      	beq.n	6124 <notify_cb+0x78>
			continue;
		}

		/* Confirm match if cfg is managed by application */
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
			bt_conn_unref(conn);
    6114:	f00d fcb7 	bl	13a86 <bt_conn_unref>
		}

		data->err = 0;
	}

	return BT_GATT_ITER_CONTINUE;
    6118:	2001      	movs	r0, #1
}
    611a:	b003      	add	sp, #12
    611c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			bt_conn_unref(conn);
    611e:	f00d fcb2 	bl	13a86 <bt_conn_unref>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    6122:	e7e9      	b.n	60f8 <notify_cb+0x4c>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
    6124:	697b      	ldr	r3, [r7, #20]
    6126:	b123      	cbz	r3, 6132 <notify_cb+0x86>
    6128:	4631      	mov	r1, r6
    612a:	4798      	blx	r3
    612c:	b908      	cbnz	r0, 6132 <notify_cb+0x86>
			bt_conn_unref(conn);
    612e:	4628      	mov	r0, r5
    6130:	e7f0      	b.n	6114 <notify_cb+0x68>
		if (data->type == BT_GATT_CCC_INDICATE) {
    6132:	89a3      	ldrh	r3, [r4, #12]
			err = gatt_indicate(conn, data->handle,
    6134:	4628      	mov	r0, r5
		if (data->type == BT_GATT_CCC_INDICATE) {
    6136:	2b02      	cmp	r3, #2
    6138:	88a1      	ldrh	r1, [r4, #4]
    613a:	6922      	ldr	r2, [r4, #16]
    613c:	d110      	bne.n	6160 <notify_cb+0xb4>
			err = gatt_indicate(conn, data->handle,
    613e:	f7ff ff6f 	bl	6020 <gatt_indicate>
			if (err == 0) {
    6142:	4606      	mov	r6, r0
    6144:	b918      	cbnz	r0, 614e <notify_cb+0xa2>
				data->ind_params->_ref++;
    6146:	6922      	ldr	r2, [r4, #16]
    6148:	7d93      	ldrb	r3, [r2, #22]
    614a:	3301      	adds	r3, #1
    614c:	7593      	strb	r3, [r2, #22]
		bt_conn_unref(conn);
    614e:	4628      	mov	r0, r5
    6150:	f00d fc99 	bl	13a86 <bt_conn_unref>
		if (err < 0) {
    6154:	2e00      	cmp	r6, #0
    6156:	f04f 0000 	mov.w	r0, #0
    615a:	dbde      	blt.n	611a <notify_cb+0x6e>
		data->err = 0;
    615c:	60a0      	str	r0, [r4, #8]
    615e:	e7db      	b.n	6118 <notify_cb+0x6c>
			err = gatt_notify(conn, data->handle, data->nfy_params);
    6160:	f00e fcf6 	bl	14b50 <gatt_notify>
    6164:	4606      	mov	r6, r0
    6166:	e7f2      	b.n	614e <notify_cb+0xa2>
    6168:	00014a71 	.word	0x00014a71
    616c:	200003a0 	.word	0x200003a0
    6170:	20029f26 	.word	0x20029f26

00006174 <disconnected_cb>:
	return BT_GATT_ITER_CONTINUE;
}

static uint8_t disconnected_cb(const struct bt_gatt_attr *attr, uint16_t handle,
			       void *user_data)
{
    6174:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct _bt_gatt_ccc *ccc;
	bool value_used;
	size_t i;

	/* Check attribute user_data must be of type struct _bt_gatt_ccc */
	if (attr->write != bt_gatt_attr_write_ccc) {
    6178:	4b23      	ldr	r3, [pc, #140]	; (6208 <disconnected_cb+0x94>)
{
    617a:	4615      	mov	r5, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
    617c:	6882      	ldr	r2, [r0, #8]
{
    617e:	4607      	mov	r7, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
    6180:	429a      	cmp	r2, r3
    6182:	d102      	bne.n	618a <disconnected_cb+0x16>
		return BT_GATT_ITER_CONTINUE;
	}

	ccc = attr->user_data;
    6184:	68c4      	ldr	r4, [r0, #12]

	/* If already disabled skip */
	if (!ccc->value) {
    6186:	8963      	ldrh	r3, [r4, #10]
    6188:	bb03      	cbnz	r3, 61cc <disconnected_cb+0x58>

		BT_DBG("ccc %p reseted", ccc);
	}

	return BT_GATT_ITER_CONTINUE;
}
    618a:	2001      	movs	r0, #1
    618c:	b002      	add	sp, #8
    618e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    6192:	f105 0888 	add.w	r8, r5, #136	; 0x88
    6196:	4641      	mov	r1, r8
    6198:	7a28      	ldrb	r0, [r5, #8]
    619a:	f00d fb68 	bl	1386e <bt_addr_le_is_bonded>
    619e:	b980      	cbnz	r0, 61c2 <disconnected_cb+0x4e>
				if (ccc == &sc_ccc) {
    61a0:	4b1a      	ldr	r3, [pc, #104]	; (620c <disconnected_cb+0x98>)
    61a2:	429c      	cmp	r4, r3
    61a4:	d102      	bne.n	61ac <disconnected_cb+0x38>
					sc_clear(conn);
    61a6:	4628      	mov	r0, r5
    61a8:	f00e fbb1 	bl	1490e <sc_clear>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
    61ac:	2200      	movs	r2, #0
    61ae:	4669      	mov	r1, sp
    61b0:	4630      	mov	r0, r6
    61b2:	9200      	str	r2, [sp, #0]
    61b4:	f8cd 2003 	str.w	r2, [sp, #3]
    61b8:	f00e fb0f 	bl	147da <bt_addr_le_copy>
	cfg->id = 0U;
    61bc:	7022      	strb	r2, [r4, #0]
	cfg->value = 0U;
    61be:	8122      	strh	r2, [r4, #8]
	if (!value_used) {
    61c0:	e019      	b.n	61f6 <disconnected_cb+0x82>
				bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    61c2:	4641      	mov	r1, r8
    61c4:	4630      	mov	r0, r6
    61c6:	f00e fb08 	bl	147da <bt_addr_le_copy>
	if (!value_used) {
    61ca:	e014      	b.n	61f6 <disconnected_cb+0x82>
		if (!cfg->value) {
    61cc:	8923      	ldrh	r3, [r4, #8]
    61ce:	b193      	cbz	r3, 61f6 <disconnected_cb+0x82>
		if (!bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    61d0:	4626      	mov	r6, r4
    61d2:	f816 1b01 	ldrb.w	r1, [r6], #1
    61d6:	4628      	mov	r0, r5
    61d8:	4632      	mov	r2, r6
    61da:	f00d fc20 	bl	13a1e <bt_conn_is_peer_addr_le>
    61de:	2800      	cmp	r0, #0
    61e0:	d1d7      	bne.n	6192 <disconnected_cb+0x1e>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    61e2:	4631      	mov	r1, r6
    61e4:	7820      	ldrb	r0, [r4, #0]
    61e6:	f7fe feeb 	bl	4fc0 <bt_conn_lookup_addr_le>
			if (tmp) {
    61ea:	b120      	cbz	r0, 61f6 <disconnected_cb+0x82>
				if (tmp->state == BT_CONN_CONNECTED) {
    61ec:	7a85      	ldrb	r5, [r0, #10]
				bt_conn_unref(tmp);
    61ee:	f00d fc4a 	bl	13a86 <bt_conn_unref>
	if (!value_used) {
    61f2:	2d07      	cmp	r5, #7
    61f4:	d0c9      	beq.n	618a <disconnected_cb+0x16>
		ccc->value = 0U;
    61f6:	2100      	movs	r1, #0
		if (ccc->cfg_changed) {
    61f8:	68e3      	ldr	r3, [r4, #12]
		ccc->value = 0U;
    61fa:	8161      	strh	r1, [r4, #10]
		if (ccc->cfg_changed) {
    61fc:	2b00      	cmp	r3, #0
    61fe:	d0c4      	beq.n	618a <disconnected_cb+0x16>
			ccc->cfg_changed(attr, ccc->value);
    6200:	4638      	mov	r0, r7
    6202:	4798      	blx	r3
    6204:	e7c1      	b.n	618a <disconnected_cb+0x16>
    6206:	bf00      	nop
    6208:	00014a71 	.word	0x00014a71
    620c:	200003a0 	.word	0x200003a0

00006210 <bt_gatt_init>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    6210:	2201      	movs	r2, #1
{
    6212:	b510      	push	{r4, lr}
    6214:	4b1d      	ldr	r3, [pc, #116]	; (628c <bt_gatt_init+0x7c>)
    6216:	e8d3 1fef 	ldaex	r1, [r3]
    621a:	2900      	cmp	r1, #0
    621c:	d103      	bne.n	6226 <bt_gatt_init+0x16>
    621e:	e8c3 2fe0 	stlex	r0, r2, [r3]
    6222:	2800      	cmp	r0, #0
    6224:	d1f7      	bne.n	6216 <bt_gatt_init+0x6>
	if (!atomic_cas(&init, 0, 1)) {
    6226:	d12a      	bne.n	627e <bt_gatt_init+0x6e>
    6228:	4b19      	ldr	r3, [pc, #100]	; (6290 <bt_gatt_init+0x80>)
    622a:	e8d3 1fef 	ldaex	r1, [r3]
    622e:	2900      	cmp	r1, #0
    6230:	d103      	bne.n	623a <bt_gatt_init+0x2a>
    6232:	e8c3 2fe0 	stlex	r0, r2, [r3]
    6236:	2800      	cmp	r0, #0
    6238:	d1f7      	bne.n	622a <bt_gatt_init+0x1a>
	if (!atomic_cas(&service_init, 0, 1)) {
    623a:	d108      	bne.n	624e <bt_gatt_init+0x3e>
    623c:	2000      	movs	r0, #0
    623e:	4a15      	ldr	r2, [pc, #84]	; (6294 <bt_gatt_init+0x84>)
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    6240:	4915      	ldr	r1, [pc, #84]	; (6298 <bt_gatt_init+0x88>)
    6242:	8813      	ldrh	r3, [r2, #0]
    6244:	4c15      	ldr	r4, [pc, #84]	; (629c <bt_gatt_init+0x8c>)
    6246:	42a1      	cmp	r1, r4
    6248:	d31a      	bcc.n	6280 <bt_gatt_init+0x70>
    624a:	b100      	cbz	r0, 624e <bt_gatt_init+0x3e>
    624c:	8013      	strh	r3, [r2, #0]
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
    624e:	4c14      	ldr	r4, [pc, #80]	; (62a0 <bt_gatt_init+0x90>)
    6250:	2230      	movs	r2, #48	; 0x30
    6252:	2100      	movs	r1, #0
    6254:	4620      	mov	r0, r4
    6256:	f017 fb91 	bl	1d97c <memset>
    625a:	4b12      	ldr	r3, [pc, #72]	; (62a4 <bt_gatt_init+0x94>)
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    625c:	4621      	mov	r1, r4
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
    625e:	6063      	str	r3, [r4, #4]
    6260:	4c11      	ldr	r4, [pc, #68]	; (62a8 <bt_gatt_init+0x98>)
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    6262:	2300      	movs	r3, #0
    6264:	f44f 72a4 	mov.w	r2, #328	; 0x148
    6268:	4810      	ldr	r0, [pc, #64]	; (62ac <bt_gatt_init+0x9c>)
    626a:	f00a feef 	bl	1104c <k_delayed_work_submit_to_queue>
	*work = (struct k_delayed_work)Z_DELAYED_WORK_INITIALIZER(handler);
    626e:	2230      	movs	r2, #48	; 0x30
    6270:	2100      	movs	r1, #0
    6272:	f104 0020 	add.w	r0, r4, #32
    6276:	f017 fb81 	bl	1d97c <memset>
    627a:	4b0d      	ldr	r3, [pc, #52]	; (62b0 <bt_gatt_init+0xa0>)
    627c:	6263      	str	r3, [r4, #36]	; 0x24
}
    627e:	bd10      	pop	{r4, pc}
		last_static_handle += svc->attr_count;
    6280:	6848      	ldr	r0, [r1, #4]
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    6282:	3108      	adds	r1, #8
		last_static_handle += svc->attr_count;
    6284:	4403      	add	r3, r0
    6286:	b29b      	uxth	r3, r3
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    6288:	2001      	movs	r0, #1
    628a:	e7dc      	b.n	6246 <bt_gatt_init+0x36>
    628c:	20025ad4 	.word	0x20025ad4
    6290:	20025af0 	.word	0x20025af0
    6294:	20029f24 	.word	0x20029f24
    6298:	0001dd14 	.word	0x0001dd14
    629c:	0001dd2c 	.word	0x0001dd2c
    62a0:	20000ec8 	.word	0x20000ec8
    62a4:	00014c49 	.word	0x00014c49
    62a8:	20000ef8 	.word	0x20000ef8
    62ac:	20001168 	.word	0x20001168
    62b0:	000065f9 	.word	0x000065f9

000062b4 <bt_gatt_attr_get_handle>:
	if (!attr) {
    62b4:	4603      	mov	r3, r0
{
    62b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!attr) {
    62ba:	b148      	cbz	r0, 62d0 <bt_gatt_attr_get_handle+0x1c>
	if (attr->handle) {
    62bc:	8a00      	ldrh	r0, [r0, #16]
    62be:	b938      	cbnz	r0, 62d0 <bt_gatt_attr_get_handle+0x1c>
	uint16_t handle = 1;
    62c0:	2401      	movs	r4, #1
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
    62c2:	f04f 0c14 	mov.w	ip, #20
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    62c6:	4911      	ldr	r1, [pc, #68]	; (630c <bt_gatt_attr_get_handle+0x58>)
    62c8:	f8df e044 	ldr.w	lr, [pc, #68]	; 6310 <bt_gatt_attr_get_handle+0x5c>
    62cc:	4571      	cmp	r1, lr
    62ce:	d301      	bcc.n	62d4 <bt_gatt_attr_get_handle+0x20>
}
    62d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if ((attr < &static_svc->attrs[0]) ||
    62d4:	e9d1 7600 	ldrd	r7, r6, [r1]
    62d8:	42bb      	cmp	r3, r7
    62da:	d304      	bcc.n	62e6 <bt_gatt_attr_get_handle+0x32>
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
    62dc:	fb0c 7206 	mla	r2, ip, r6, r7
    62e0:	3a14      	subs	r2, #20
		if ((attr < &static_svc->attrs[0]) ||
    62e2:	4293      	cmp	r3, r2
    62e4:	d90e      	bls.n	6304 <bt_gatt_attr_get_handle+0x50>
			handle += static_svc->attr_count;
    62e6:	19a2      	adds	r2, r4, r6
    62e8:	b292      	uxth	r2, r2
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    62ea:	4614      	mov	r4, r2
    62ec:	3108      	adds	r1, #8
    62ee:	e7ed      	b.n	62cc <bt_gatt_attr_get_handle+0x18>
			if (attr == &static_svc->attrs[i]) {
    62f0:	fb0c 7805 	mla	r8, ip, r5, r7
    62f4:	4543      	cmp	r3, r8
    62f6:	d007      	beq.n	6308 <bt_gatt_attr_get_handle+0x54>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
    62f8:	3501      	adds	r5, #1
    62fa:	1962      	adds	r2, r4, r5
    62fc:	42b5      	cmp	r5, r6
    62fe:	b292      	uxth	r2, r2
    6300:	d1f6      	bne.n	62f0 <bt_gatt_attr_get_handle+0x3c>
    6302:	e7f2      	b.n	62ea <bt_gatt_attr_get_handle+0x36>
    6304:	2500      	movs	r5, #0
    6306:	e7f8      	b.n	62fa <bt_gatt_attr_get_handle+0x46>
    6308:	4610      	mov	r0, r2
    630a:	e7e1      	b.n	62d0 <bt_gatt_attr_get_handle+0x1c>
    630c:	0001dd14 	.word	0x0001dd14
    6310:	0001dd2c 	.word	0x0001dd2c

00006314 <bt_gatt_foreach_attr_type>:
{
    6314:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6318:	4699      	mov	r9, r3
		num_matches = UINT16_MAX;
    631a:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
    631e:	f8bd 5030 	ldrh.w	r5, [sp, #48]	; 0x30
    6322:	4607      	mov	r7, r0
		num_matches = UINT16_MAX;
    6324:	2d00      	cmp	r5, #0
    6326:	bf08      	it	eq
    6328:	461d      	moveq	r5, r3
	if (start_handle <= last_static_handle) {
    632a:	4b24      	ldr	r3, [pc, #144]	; (63bc <bt_gatt_foreach_attr_type+0xa8>)
{
    632c:	4690      	mov	r8, r2
	if (start_handle <= last_static_handle) {
    632e:	881b      	ldrh	r3, [r3, #0]
{
    6330:	9100      	str	r1, [sp, #0]
	if (start_handle <= last_static_handle) {
    6332:	4283      	cmp	r3, r0
    6334:	d23c      	bcs.n	63b0 <bt_gatt_foreach_attr_type+0x9c>
}
    6336:	b003      	add	sp, #12
    6338:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (handle + static_svc->attr_count < start_handle) {
    633c:	6873      	ldr	r3, [r6, #4]
    633e:	4423      	add	r3, r4
    6340:	42bb      	cmp	r3, r7
    6342:	d232      	bcs.n	63aa <bt_gatt_foreach_attr_type+0x96>
				handle += static_svc->attr_count;
    6344:	b29c      	uxth	r4, r3
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    6346:	3608      	adds	r6, #8
    6348:	4b1d      	ldr	r3, [pc, #116]	; (63c0 <bt_gatt_foreach_attr_type+0xac>)
    634a:	429e      	cmp	r6, r3
    634c:	d3f6      	bcc.n	633c <bt_gatt_foreach_attr_type+0x28>
    634e:	e7f2      	b.n	6336 <bt_gatt_foreach_attr_type+0x22>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    6350:	4640      	mov	r0, r8
    6352:	5889      	ldr	r1, [r1, r2]
    6354:	9301      	str	r3, [sp, #4]
    6356:	f00c ffa0 	bl	1329a <bt_uuid_cmp>
    635a:	9b01      	ldr	r3, [sp, #4]
    635c:	b190      	cbz	r0, 6384 <bt_gatt_foreach_attr_type+0x70>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    635e:	3401      	adds	r4, #1
    6360:	f10a 0a01 	add.w	sl, sl, #1
    6364:	b2a4      	uxth	r4, r4
    6366:	6873      	ldr	r3, [r6, #4]
    6368:	4553      	cmp	r3, sl
    636a:	d9ec      	bls.n	6346 <bt_gatt_foreach_attr_type+0x32>
	if (handle > end_handle) {
    636c:	9b00      	ldr	r3, [sp, #0]
    636e:	429c      	cmp	r4, r3
    6370:	d8e1      	bhi.n	6336 <bt_gatt_foreach_attr_type+0x22>
	if (handle < start_handle) {
    6372:	42bc      	cmp	r4, r7
    6374:	d3f3      	bcc.n	635e <bt_gatt_foreach_attr_type+0x4a>
				if (gatt_foreach_iter(&static_svc->attrs[i],
    6376:	fb0b f20a 	mul.w	r2, fp, sl
    637a:	6831      	ldr	r1, [r6, #0]
    637c:	188b      	adds	r3, r1, r2
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
    637e:	f1b8 0f00 	cmp.w	r8, #0
    6382:	d1e5      	bne.n	6350 <bt_gatt_foreach_attr_type+0x3c>
	if (attr_data && attr_data != attr->user_data) {
    6384:	f1b9 0f00 	cmp.w	r9, #0
    6388:	d10b      	bne.n	63a2 <bt_gatt_foreach_attr_type+0x8e>
	*num_matches -= 1;
    638a:	3d01      	subs	r5, #1
	result = func(attr, handle, user_data);
    638c:	4618      	mov	r0, r3
	*num_matches -= 1;
    638e:	b2ad      	uxth	r5, r5
	result = func(attr, handle, user_data);
    6390:	4621      	mov	r1, r4
    6392:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    6394:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    6396:	4798      	blx	r3
	if (!*num_matches) {
    6398:	2d00      	cmp	r5, #0
    639a:	d0cc      	beq.n	6336 <bt_gatt_foreach_attr_type+0x22>
				if (gatt_foreach_iter(&static_svc->attrs[i],
    639c:	2800      	cmp	r0, #0
    639e:	d1de      	bne.n	635e <bt_gatt_foreach_attr_type+0x4a>
    63a0:	e7c9      	b.n	6336 <bt_gatt_foreach_attr_type+0x22>
	if (attr_data && attr_data != attr->user_data) {
    63a2:	68da      	ldr	r2, [r3, #12]
    63a4:	4591      	cmp	r9, r2
    63a6:	d1da      	bne.n	635e <bt_gatt_foreach_attr_type+0x4a>
    63a8:	e7ef      	b.n	638a <bt_gatt_foreach_attr_type+0x76>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    63aa:	f04f 0a00 	mov.w	sl, #0
    63ae:	e7da      	b.n	6366 <bt_gatt_foreach_attr_type+0x52>
		uint16_t handle = 1;
    63b0:	2401      	movs	r4, #1
				if (gatt_foreach_iter(&static_svc->attrs[i],
    63b2:	f04f 0b14 	mov.w	fp, #20
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    63b6:	4e03      	ldr	r6, [pc, #12]	; (63c4 <bt_gatt_foreach_attr_type+0xb0>)
    63b8:	e7c6      	b.n	6348 <bt_gatt_foreach_attr_type+0x34>
    63ba:	bf00      	nop
    63bc:	20029f24 	.word	0x20029f24
    63c0:	0001dd2c 	.word	0x0001dd2c
    63c4:	0001dd14 	.word	0x0001dd14

000063c8 <db_hash_gen.isra.0>:
	uint8_t key[16] = {};
    63c8:	2300      	movs	r3, #0
static void db_hash_gen(bool store)
    63ca:	b510      	push	{r4, lr}
    63cc:	b0c8      	sub	sp, #288	; 0x120
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
    63ce:	4669      	mov	r1, sp
    63d0:	aa1c      	add	r2, sp, #112	; 0x70
    63d2:	a804      	add	r0, sp, #16
	uint8_t key[16] = {};
    63d4:	e9cd 3300 	strd	r3, r3, [sp]
    63d8:	e9cd 3302 	strd	r3, r3, [sp, #8]
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
    63dc:	f00c fac2 	bl	12964 <tc_cmac_setup>
    63e0:	b1b8      	cbz	r0, 6412 <db_hash_gen.isra.0+0x4a>
	bt_gatt_foreach_attr(0x0001, 0xffff, gen_hash_m, &state);
    63e2:	f64f 71ff 	movw	r1, #65535	; 0xffff
    63e6:	2001      	movs	r0, #1
    63e8:	4a0b      	ldr	r2, [pc, #44]	; (6418 <db_hash_gen.isra.0+0x50>)
    63ea:	ab04      	add	r3, sp, #16
    63ec:	f00e fc21 	bl	14c32 <bt_gatt_foreach_attr>
	if (tc_cmac_final(db_hash, &state.state) == TC_CRYPTO_FAIL) {
    63f0:	480a      	ldr	r0, [pc, #40]	; (641c <db_hash_gen.isra.0+0x54>)
    63f2:	a904      	add	r1, sp, #16
    63f4:	f00c fb4d 	bl	12a92 <tc_cmac_final>
    63f8:	b158      	cbz	r0, 6412 <db_hash_gen.isra.0+0x4a>
    63fa:	2208      	movs	r2, #8
    63fc:	4b07      	ldr	r3, [pc, #28]	; (641c <db_hash_gen.isra.0+0x54>)
    63fe:	f103 0110 	add.w	r1, r3, #16
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
		uint8_t tmp = ((uint8_t *)buf)[i];
    6402:	7818      	ldrb	r0, [r3, #0]

		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
    6404:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
	for (i = 0; i < (length/2); i++) {
    6408:	3a01      	subs	r2, #1
		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
    640a:	f803 4b01 	strb.w	r4, [r3], #1
		((uint8_t *)buf)[length - 1 - i] = tmp;
    640e:	7008      	strb	r0, [r1, #0]
	for (i = 0; i < (length/2); i++) {
    6410:	d1f7      	bne.n	6402 <db_hash_gen.isra.0+0x3a>
}
    6412:	b048      	add	sp, #288	; 0x120
    6414:	bd10      	pop	{r4, pc}
    6416:	bf00      	nop
    6418:	0001471b 	.word	0x0001471b
    641c:	20029f3e 	.word	0x20029f3e

00006420 <bt_gatt_notify_cb>:
{
    6420:	b530      	push	{r4, r5, lr}
    6422:	4604      	mov	r4, r0
    6424:	460d      	mov	r5, r1
    6426:	b08b      	sub	sp, #44	; 0x2c
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    6428:	4b34      	ldr	r3, [pc, #208]	; (64fc <bt_gatt_notify_cb+0xdc>)
    642a:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    642e:	079a      	lsls	r2, r3, #30
    6430:	d55d      	bpl.n	64ee <bt_gatt_notify_cb+0xce>
	data.attr = params->attr;
    6432:	6848      	ldr	r0, [r1, #4]
    6434:	9005      	str	r0, [sp, #20]
	if (conn && conn->state != BT_CONN_CONNECTED) {
    6436:	b114      	cbz	r4, 643e <bt_gatt_notify_cb+0x1e>
    6438:	7aa3      	ldrb	r3, [r4, #10]
    643a:	2b07      	cmp	r3, #7
    643c:	d15a      	bne.n	64f4 <bt_gatt_notify_cb+0xd4>
	data.handle = bt_gatt_attr_get_handle(data.attr);
    643e:	f7ff ff39 	bl	62b4 <bt_gatt_attr_get_handle>
    6442:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (!data.handle) {
    6446:	b918      	cbnz	r0, 6450 <bt_gatt_notify_cb+0x30>
		return -ENOENT;
    6448:	f06f 0001 	mvn.w	r0, #1
}
    644c:	b00b      	add	sp, #44	; 0x2c
    644e:	bd30      	pop	{r4, r5, pc}
	if (params->uuid) {
    6450:	682a      	ldr	r2, [r5, #0]
    6452:	b9aa      	cbnz	r2, 6480 <bt_gatt_notify_cb+0x60>
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
    6454:	9b05      	ldr	r3, [sp, #20]
    6456:	a904      	add	r1, sp, #16
    6458:	6818      	ldr	r0, [r3, #0]
    645a:	2300      	movs	r3, #0
    645c:	f88d 3010 	strb.w	r3, [sp, #16]
    6460:	f642 0303 	movw	r3, #10243	; 0x2803
    6464:	f8ad 3012 	strh.w	r3, [sp, #18]
    6468:	f00c ff17 	bl	1329a <bt_uuid_cmp>
    646c:	b1c0      	cbz	r0, 64a0 <bt_gatt_notify_cb+0x80>
	if (conn) {
    646e:	f8bd 0018 	ldrh.w	r0, [sp, #24]
    6472:	b314      	cbz	r4, 64ba <bt_gatt_notify_cb+0x9a>
		return gatt_notify(conn, data.handle, params);
    6474:	4601      	mov	r1, r0
    6476:	462a      	mov	r2, r5
    6478:	4620      	mov	r0, r4
    647a:	f00e fb69 	bl	14b50 <gatt_notify>
    647e:	e7e5      	b.n	644c <bt_gatt_notify_cb+0x2c>
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    6480:	a905      	add	r1, sp, #20
    6482:	9102      	str	r1, [sp, #8]
    6484:	491e      	ldr	r1, [pc, #120]	; (6500 <bt_gatt_notify_cb+0xe0>)
	found->attr = NULL;
    6486:	2300      	movs	r3, #0
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    6488:	9101      	str	r1, [sp, #4]
    648a:	2101      	movs	r1, #1
    648c:	9100      	str	r1, [sp, #0]
    648e:	f64f 71ff 	movw	r1, #65535	; 0xffff
	found->attr = NULL;
    6492:	9305      	str	r3, [sp, #20]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    6494:	f7ff ff3e 	bl	6314 <bt_gatt_foreach_attr_type>
		if (!gatt_find_by_uuid(&data, params->uuid)) {
    6498:	9b05      	ldr	r3, [sp, #20]
    649a:	2b00      	cmp	r3, #0
    649c:	d1da      	bne.n	6454 <bt_gatt_notify_cb+0x34>
    649e:	e7d3      	b.n	6448 <bt_gatt_notify_cb+0x28>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
    64a0:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_NOTIFY)) {
    64a2:	68c3      	ldr	r3, [r0, #12]
    64a4:	799b      	ldrb	r3, [r3, #6]
    64a6:	06db      	lsls	r3, r3, #27
    64a8:	d402      	bmi.n	64b0 <bt_gatt_notify_cb+0x90>
			return -EINVAL;
    64aa:	f06f 0015 	mvn.w	r0, #21
    64ae:	e7cd      	b.n	644c <bt_gatt_notify_cb+0x2c>
		data.handle = bt_gatt_attr_value_handle(data.attr);
    64b0:	f00e fb78 	bl	14ba4 <bt_gatt_attr_value_handle>
    64b4:	f8ad 0018 	strh.w	r0, [sp, #24]
    64b8:	e7d9      	b.n	646e <bt_gatt_notify_cb+0x4e>
	data.err = -ENOTCONN;
    64ba:	f06f 037f 	mvn.w	r3, #127	; 0x7f
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    64be:	f642 1202 	movw	r2, #10498	; 0x2902
	data.err = -ENOTCONN;
    64c2:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_NOTIFY;
    64c4:	2301      	movs	r3, #1
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    64c6:	f8ad 2012 	strh.w	r2, [sp, #18]
    64ca:	aa05      	add	r2, sp, #20
    64cc:	9202      	str	r2, [sp, #8]
    64ce:	4a0d      	ldr	r2, [pc, #52]	; (6504 <bt_gatt_notify_cb+0xe4>)
	data.type = BT_GATT_CCC_NOTIFY;
    64d0:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    64d4:	e9cd 3200 	strd	r3, r2, [sp]
    64d8:	f64f 71ff 	movw	r1, #65535	; 0xffff
    64dc:	4623      	mov	r3, r4
    64de:	aa04      	add	r2, sp, #16
	data.nfy_params = params;
    64e0:	9509      	str	r5, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    64e2:	f88d 4010 	strb.w	r4, [sp, #16]
    64e6:	f7ff ff15 	bl	6314 <bt_gatt_foreach_attr_type>
	return data.err;
    64ea:	9807      	ldr	r0, [sp, #28]
    64ec:	e7ae      	b.n	644c <bt_gatt_notify_cb+0x2c>
		return -EAGAIN;
    64ee:	f06f 000a 	mvn.w	r0, #10
    64f2:	e7ab      	b.n	644c <bt_gatt_notify_cb+0x2c>
		return -ENOTCONN;
    64f4:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    64f8:	e7a8      	b.n	644c <bt_gatt_notify_cb+0x2c>
    64fa:	bf00      	nop
    64fc:	20000094 	.word	0x20000094
    6500:	00014713 	.word	0x00014713
    6504:	000060ad 	.word	0x000060ad

00006508 <bt_gatt_indicate>:
{
    6508:	b530      	push	{r4, r5, lr}
    650a:	4604      	mov	r4, r0
    650c:	460d      	mov	r5, r1
    650e:	b08b      	sub	sp, #44	; 0x2c
    6510:	4b36      	ldr	r3, [pc, #216]	; (65ec <bt_gatt_indicate+0xe4>)
    6512:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    6516:	079a      	lsls	r2, r3, #30
    6518:	d561      	bpl.n	65de <bt_gatt_indicate+0xd6>
	data.attr = params->attr;
    651a:	6848      	ldr	r0, [r1, #4]
    651c:	9005      	str	r0, [sp, #20]
	if (conn && conn->state != BT_CONN_CONNECTED) {
    651e:	b114      	cbz	r4, 6526 <bt_gatt_indicate+0x1e>
    6520:	7aa3      	ldrb	r3, [r4, #10]
    6522:	2b07      	cmp	r3, #7
    6524:	d15e      	bne.n	65e4 <bt_gatt_indicate+0xdc>
	data.handle = bt_gatt_attr_get_handle(data.attr);
    6526:	f7ff fec5 	bl	62b4 <bt_gatt_attr_get_handle>
    652a:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (!data.handle) {
    652e:	b918      	cbnz	r0, 6538 <bt_gatt_indicate+0x30>
		return -ENOENT;
    6530:	f06f 0001 	mvn.w	r0, #1
}
    6534:	b00b      	add	sp, #44	; 0x2c
    6536:	bd30      	pop	{r4, r5, pc}
	if (params->uuid) {
    6538:	682a      	ldr	r2, [r5, #0]
    653a:	b9ba      	cbnz	r2, 656c <bt_gatt_indicate+0x64>
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
    653c:	9b05      	ldr	r3, [sp, #20]
    653e:	a904      	add	r1, sp, #16
    6540:	6818      	ldr	r0, [r3, #0]
    6542:	2300      	movs	r3, #0
    6544:	f88d 3010 	strb.w	r3, [sp, #16]
    6548:	f642 0303 	movw	r3, #10243	; 0x2803
    654c:	f8ad 3012 	strh.w	r3, [sp, #18]
    6550:	f00c fea3 	bl	1329a <bt_uuid_cmp>
    6554:	b1d0      	cbz	r0, 658c <bt_gatt_indicate+0x84>
	if (conn) {
    6556:	f8bd 0018 	ldrh.w	r0, [sp, #24]
    655a:	b324      	cbz	r4, 65a6 <bt_gatt_indicate+0x9e>
		params->_ref = 1;
    655c:	2301      	movs	r3, #1
		return gatt_indicate(conn, data.handle, params);
    655e:	4601      	mov	r1, r0
    6560:	462a      	mov	r2, r5
    6562:	4620      	mov	r0, r4
		params->_ref = 1;
    6564:	75ab      	strb	r3, [r5, #22]
		return gatt_indicate(conn, data.handle, params);
    6566:	f7ff fd5b 	bl	6020 <gatt_indicate>
    656a:	e7e3      	b.n	6534 <bt_gatt_indicate+0x2c>
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    656c:	a905      	add	r1, sp, #20
    656e:	9102      	str	r1, [sp, #8]
    6570:	491f      	ldr	r1, [pc, #124]	; (65f0 <bt_gatt_indicate+0xe8>)
	found->attr = NULL;
    6572:	2300      	movs	r3, #0
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    6574:	9101      	str	r1, [sp, #4]
    6576:	2101      	movs	r1, #1
    6578:	9100      	str	r1, [sp, #0]
    657a:	f64f 71ff 	movw	r1, #65535	; 0xffff
	found->attr = NULL;
    657e:	9305      	str	r3, [sp, #20]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    6580:	f7ff fec8 	bl	6314 <bt_gatt_foreach_attr_type>
		if (!gatt_find_by_uuid(&data, params->uuid)) {
    6584:	9b05      	ldr	r3, [sp, #20]
    6586:	2b00      	cmp	r3, #0
    6588:	d1d8      	bne.n	653c <bt_gatt_indicate+0x34>
    658a:	e7d1      	b.n	6530 <bt_gatt_indicate+0x28>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
    658c:	9805      	ldr	r0, [sp, #20]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
    658e:	68c3      	ldr	r3, [r0, #12]
    6590:	799b      	ldrb	r3, [r3, #6]
    6592:	069b      	lsls	r3, r3, #26
    6594:	d402      	bmi.n	659c <bt_gatt_indicate+0x94>
			return -EINVAL;
    6596:	f06f 0015 	mvn.w	r0, #21
    659a:	e7cb      	b.n	6534 <bt_gatt_indicate+0x2c>
		data.handle = bt_gatt_attr_value_handle(data.attr);
    659c:	f00e fb02 	bl	14ba4 <bt_gatt_attr_value_handle>
    65a0:	f8ad 0018 	strh.w	r0, [sp, #24]
    65a4:	e7d7      	b.n	6556 <bt_gatt_indicate+0x4e>
	data.err = -ENOTCONN;
    65a6:	f06f 037f 	mvn.w	r3, #127	; 0x7f
    65aa:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
    65ac:	2302      	movs	r3, #2
    65ae:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    65b2:	f642 1302 	movw	r3, #10498	; 0x2902
    65b6:	f8ad 3012 	strh.w	r3, [sp, #18]
    65ba:	ab05      	add	r3, sp, #20
    65bc:	9302      	str	r3, [sp, #8]
    65be:	4b0d      	ldr	r3, [pc, #52]	; (65f4 <bt_gatt_indicate+0xec>)
    65c0:	f64f 71ff 	movw	r1, #65535	; 0xffff
    65c4:	9301      	str	r3, [sp, #4]
    65c6:	2301      	movs	r3, #1
	params->_ref = 0;
    65c8:	75ac      	strb	r4, [r5, #22]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    65ca:	9300      	str	r3, [sp, #0]
    65cc:	aa04      	add	r2, sp, #16
    65ce:	4623      	mov	r3, r4
	data.ind_params = params;
    65d0:	9509      	str	r5, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    65d2:	f88d 4010 	strb.w	r4, [sp, #16]
    65d6:	f7ff fe9d 	bl	6314 <bt_gatt_foreach_attr_type>
	return data.err;
    65da:	9807      	ldr	r0, [sp, #28]
    65dc:	e7aa      	b.n	6534 <bt_gatt_indicate+0x2c>
		return -EAGAIN;
    65de:	f06f 000a 	mvn.w	r0, #10
    65e2:	e7a7      	b.n	6534 <bt_gatt_indicate+0x2c>
		return -ENOTCONN;
    65e4:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    65e8:	e7a4      	b.n	6534 <bt_gatt_indicate+0x2c>
    65ea:	bf00      	nop
    65ec:	20000094 	.word	0x20000094
    65f0:	00014713 	.word	0x00014713
    65f4:	000060ad 	.word	0x000060ad

000065f8 <sc_process>:
{
    65f8:	4603      	mov	r3, r0
    65fa:	b513      	push	{r0, r1, r4, lr}
	sc_range[0] = sys_cpu_to_le16(sc->start);
    65fc:	f850 2c08 	ldr.w	r2, [r0, #-8]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    6600:	f1a0 0120 	sub.w	r1, r0, #32
	sc_range[0] = sys_cpu_to_le16(sc->start);
    6604:	9201      	str	r2, [sp, #4]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    6606:	f100 0430 	add.w	r4, r0, #48	; 0x30
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    660a:	e8d4 2fef 	ldaex	r2, [r4]
    660e:	f022 0201 	bic.w	r2, r2, #1
    6612:	e8c4 2fe0 	stlex	r0, r2, [r4]
    6616:	2800      	cmp	r0, #0
    6618:	d1f7      	bne.n	660a <sc_process+0x12>
	sc->params.attr = &_1_gatt_svc.attrs[2];
    661a:	4a0d      	ldr	r2, [pc, #52]	; (6650 <sc_process+0x58>)
	sc->start = 0U;
    661c:	2000      	movs	r0, #0
	sc->params.attr = &_1_gatt_svc.attrs[2];
    661e:	f843 2c1c 	str.w	r2, [r3, #-28]
	sc->params.func = sc_indicate_rsp;
    6622:	4a0c      	ldr	r2, [pc, #48]	; (6654 <sc_process+0x5c>)
	sc->start = 0U;
    6624:	f823 0c08 	strh.w	r0, [r3, #-8]
	sc->params.func = sc_indicate_rsp;
    6628:	f843 2c18 	str.w	r2, [r3, #-24]
	sc->params.data = &sc_range[0];
    662c:	aa01      	add	r2, sp, #4
    662e:	f843 2c10 	str.w	r2, [r3, #-16]
	sc->params.len = sizeof(sc_range);
    6632:	2204      	movs	r2, #4
	sc->end = 0U;
    6634:	f823 0c06 	strh.w	r0, [r3, #-6]
	sc->params.len = sizeof(sc_range);
    6638:	f823 2c0c 	strh.w	r2, [r3, #-12]
	if (bt_gatt_indicate(NULL, &sc->params)) {
    663c:	f7ff ff64 	bl	6508 <bt_gatt_indicate>
    6640:	b918      	cbnz	r0, 664a <sc_process+0x52>
	atomic_set_bit(sc->flags, SC_INDICATE_PENDING);
    6642:	2101      	movs	r1, #1
    6644:	4620      	mov	r0, r4
    6646:	f00e f8be 	bl	147c6 <atomic_set_bit>
}
    664a:	b002      	add	sp, #8
    664c:	bd10      	pop	{r4, pc}
    664e:	bf00      	nop
    6650:	0001eea0 	.word	0x0001eea0
    6654:	00005fd1 	.word	0x00005fd1

00006658 <update_ccc>:
{
    6658:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    665a:	4b26      	ldr	r3, [pc, #152]	; (66f4 <update_ccc+0x9c>)
	struct bt_conn *conn = data->conn;
    665c:	6815      	ldr	r5, [r2, #0]
	if (attr->write != bt_gatt_attr_write_ccc) {
    665e:	6882      	ldr	r2, [r0, #8]
{
    6660:	4604      	mov	r4, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
    6662:	429a      	cmp	r2, r3
    6664:	d142      	bne.n	66ec <update_ccc+0x94>
	ccc = attr->user_data;
    6666:	68c6      	ldr	r6, [r0, #12]
		if (!cfg->value ||
    6668:	8933      	ldrh	r3, [r6, #8]
    666a:	2b00      	cmp	r3, #0
    666c:	d03e      	beq.n	66ec <update_ccc+0x94>
		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    666e:	4632      	mov	r2, r6
    6670:	4628      	mov	r0, r5
    6672:	f812 1b01 	ldrb.w	r1, [r2], #1
    6676:	f00d f9d2 	bl	13a1e <bt_conn_is_peer_addr_le>
		if (!cfg->value ||
    667a:	2800      	cmp	r0, #0
    667c:	d036      	beq.n	66ec <update_ccc+0x94>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
    667e:	222a      	movs	r2, #42	; 0x2a
    6680:	4621      	mov	r1, r4
    6682:	4628      	mov	r0, r5
    6684:	f00e fae2 	bl	14c4c <bt_gatt_check_perm>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
    6688:	2803      	cmp	r0, #3
    668a:	d02f      	beq.n	66ec <update_ccc+0x94>
		gatt_ccc_changed(attr, ccc);
    668c:	4631      	mov	r1, r6
    668e:	4620      	mov	r0, r4
    6690:	f00e f823 	bl	146da <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
    6694:	4b18      	ldr	r3, [pc, #96]	; (66f8 <update_ccc+0xa0>)
    6696:	429e      	cmp	r6, r3
    6698:	d128      	bne.n	66ec <update_ccc+0x94>
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
    669a:	7a28      	ldrb	r0, [r5, #8]
    669c:	f105 0188 	add.w	r1, r5, #136	; 0x88
    66a0:	f7ff fc68 	bl	5f74 <find_sc_cfg>
	if (!cfg) {
    66a4:	4604      	mov	r4, r0
    66a6:	b308      	cbz	r0, 66ec <update_ccc+0x94>
	if (!(cfg->data.start || cfg->data.end)) {
    66a8:	8902      	ldrh	r2, [r0, #8]
    66aa:	8943      	ldrh	r3, [r0, #10]
    66ac:	ea53 0102 	orrs.w	r1, r3, r2
    66b0:	d01c      	beq.n	66ec <update_ccc+0x94>
	index = bt_conn_index(conn);
    66b2:	4628      	mov	r0, r5
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
    66b4:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
    66b8:	f8ad 3006 	strh.w	r3, [sp, #6]
	index = bt_conn_index(conn);
    66bc:	f7fe fde8 	bl	5290 <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    66c0:	2318      	movs	r3, #24
    66c2:	490e      	ldr	r1, [pc, #56]	; (66fc <update_ccc+0xa4>)
    66c4:	4a0e      	ldr	r2, [pc, #56]	; (6700 <update_ccc+0xa8>)
    66c6:	fb03 1300 	mla	r3, r3, r0, r1
    66ca:	605a      	str	r2, [r3, #4]
	sc_restore_params[index].func = sc_restore_rsp;
    66cc:	4a0d      	ldr	r2, [pc, #52]	; (6704 <update_ccc+0xac>)
    66ce:	609a      	str	r2, [r3, #8]
	sc_restore_params[index].data = &sc_range[0];
    66d0:	aa01      	add	r2, sp, #4
    66d2:	611a      	str	r2, [r3, #16]
	sc_restore_params[index].len = sizeof(sc_range);
    66d4:	2204      	movs	r2, #4
    66d6:	829a      	strh	r2, [r3, #20]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    66d8:	b203      	sxth	r3, r0
    66da:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    66de:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    66e2:	4628      	mov	r0, r5
    66e4:	f7ff ff10 	bl	6508 <bt_gatt_indicate>
__ssp_bos_icheck3(memset, void *, int)
    66e8:	2300      	movs	r3, #0
    66ea:	60a3      	str	r3, [r4, #8]
}
    66ec:	2001      	movs	r0, #1
    66ee:	b002      	add	sp, #8
    66f0:	bd70      	pop	{r4, r5, r6, pc}
    66f2:	bf00      	nop
    66f4:	00014a71 	.word	0x00014a71
    66f8:	200003a0 	.word	0x200003a0
    66fc:	20025ad8 	.word	0x20025ad8
    6700:	0001eea0 	.word	0x0001eea0
    6704:	000149f1 	.word	0x000149f1

00006708 <bt_gatt_connected>:
	}
	return 0;
}

void bt_gatt_connected(struct bt_conn *conn)
{
    6708:	b507      	push	{r0, r1, r2, lr}
	struct conn_data data;

	BT_DBG("conn %p", conn);

	data.conn = conn;
    670a:	9000      	str	r0, [sp, #0]
	data.sec = BT_SECURITY_L1;
    670c:	2001      	movs	r0, #1
		}

		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
	}

	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    670e:	466b      	mov	r3, sp
    6710:	f64f 71ff 	movw	r1, #65535	; 0xffff
    6714:	4a03      	ldr	r2, [pc, #12]	; (6724 <bt_gatt_connected+0x1c>)
	data.sec = BT_SECURITY_L1;
    6716:	f88d 0004 	strb.w	r0, [sp, #4]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
    671a:	f00e fa8a 	bl	14c32 <bt_gatt_foreach_attr>
	}

#if defined(CONFIG_BT_GATT_CLIENT)
	add_subscriptions(conn);
#endif /* CONFIG_BT_GATT_CLIENT */
}
    671e:	b003      	add	sp, #12
    6720:	f85d fb04 	ldr.w	pc, [sp], #4
    6724:	00006659 	.word	0x00006659

00006728 <db_hash_read>:
{
    6728:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    672c:	4606      	mov	r6, r0
	err = k_delayed_work_cancel(&db_hash_work);
    672e:	480c      	ldr	r0, [pc, #48]	; (6760 <db_hash_read+0x38>)
{
    6730:	4614      	mov	r4, r2
    6732:	461d      	mov	r5, r3
    6734:	f8bd 7018 	ldrh.w	r7, [sp, #24]
	err = k_delayed_work_cancel(&db_hash_work);
    6738:	f016 fedc 	bl	1d4f4 <k_delayed_work_cancel>
	if (!err) {
    673c:	b908      	cbnz	r0, 6742 <db_hash_read+0x1a>
		db_hash_gen(true);
    673e:	f7ff fe43 	bl	63c8 <db_hash_gen.isra.0>
	bt_gatt_change_aware(conn, true);
    6742:	2101      	movs	r1, #1
    6744:	4630      	mov	r0, r6
    6746:	f00e faa4 	bl	14c92 <bt_gatt_change_aware>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash,
    674a:	2310      	movs	r3, #16
    674c:	463a      	mov	r2, r7
    674e:	9306      	str	r3, [sp, #24]
    6750:	4629      	mov	r1, r5
    6752:	4620      	mov	r0, r4
}
    6754:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash,
    6758:	4b02      	ldr	r3, [pc, #8]	; (6764 <db_hash_read+0x3c>)
    675a:	f00e b84a 	b.w	147f2 <bt_gatt_attr_read.constprop.0>
    675e:	bf00      	nop
    6760:	20000ec8 	.word	0x20000ec8
    6764:	20029f3e 	.word	0x20029f3e

00006768 <bt_gatt_disconnected>:

	return 0;
}

void bt_gatt_disconnected(struct bt_conn *conn)
{
    6768:	b570      	push	{r4, r5, r6, lr}
    676a:	4605      	mov	r5, r0
	BT_DBG("conn %p", conn);
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
    676c:	4603      	mov	r3, r0
    676e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    6772:	2001      	movs	r0, #1
    6774:	4a10      	ldr	r2, [pc, #64]	; (67b8 <bt_gatt_disconnected+0x50>)
    6776:	f00e fa5c 	bl	14c32 <bt_gatt_foreach_attr>
	cfg = find_cf_cfg(conn);
    677a:	4628      	mov	r0, r5
    677c:	f7ff fc0a 	bl	5f94 <find_cf_cfg>
	if (!cfg) {
    6780:	4604      	mov	r4, r0
    6782:	b1c0      	cbz	r0, 67b6 <bt_gatt_disconnected+0x4e>
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    6784:	f105 0688 	add.w	r6, r5, #136	; 0x88
    6788:	4631      	mov	r1, r6
    678a:	7a28      	ldrb	r0, [r5, #8]
    678c:	f00d f86f 	bl	1386e <bt_addr_le_is_bonded>
    6790:	b920      	cbnz	r0, 679c <bt_gatt_disconnected+0x34>
		clear_cf_cfg(cfg);
    6792:	4620      	mov	r0, r4
#endif /* CONFIG_BT_GATT_CLIENT */

#if defined(CONFIG_BT_GATT_CACHING)
	remove_cf_cfg(conn);
#endif
}
    6794:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		clear_cf_cfg(cfg);
    6798:	f00e b87e 	b.w	14898 <clear_cf_cfg>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
    679c:	1c60      	adds	r0, r4, #1
    679e:	4631      	mov	r1, r6
    67a0:	f00e f81b 	bl	147da <bt_addr_le_copy>
    67a4:	340c      	adds	r4, #12
    67a6:	e8d4 3fef 	ldaex	r3, [r4]
    67aa:	f023 0302 	bic.w	r3, r3, #2
    67ae:	e8c4 3fe2 	stlex	r2, r3, [r4]
    67b2:	2a00      	cmp	r2, #0
    67b4:	d1f7      	bne.n	67a6 <bt_gatt_disconnected+0x3e>
}
    67b6:	bd70      	pop	{r4, r5, r6, pc}
    67b8:	00006175 	.word	0x00006175

000067bc <bt_smp_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
		struct bt_l2cap_le_chan *smp = &bt_smp_pool[i];

		if (smp->chan.conn) {
    67bc:	4b04      	ldr	r3, [pc, #16]	; (67d0 <bt_smp_accept+0x14>)
    67be:	6818      	ldr	r0, [r3, #0]
    67c0:	b918      	cbnz	r0, 67ca <bt_smp_accept+0xe>
			continue;
		}

		smp->chan.ops = &ops;
    67c2:	4a04      	ldr	r2, [pc, #16]	; (67d4 <bt_smp_accept+0x18>)
    67c4:	605a      	str	r2, [r3, #4]

		*chan = &smp->chan;
    67c6:	600b      	str	r3, [r1, #0]

		return 0;
    67c8:	4770      	bx	lr
	}

	BT_ERR("No available SMP context for conn %p", conn);

	return -ENOMEM;
    67ca:	f06f 000b 	mvn.w	r0, #11
}
    67ce:	4770      	bx	lr
    67d0:	20000f50 	.word	0x20000f50
    67d4:	0001efa4 	.word	0x0001efa4

000067d8 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
    67d8:	2228      	movs	r2, #40	; 0x28
    67da:	4b02      	ldr	r3, [pc, #8]	; (67e4 <net_buf_pool_get+0xc>)
    67dc:	fb02 3000 	mla	r0, r2, r0, r3
    67e0:	4770      	bx	lr
    67e2:	bf00      	nop
    67e4:	20000898 	.word	0x20000898

000067e8 <net_buf_id>:

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	return buf - pool->__bufs;
    67e8:	2128      	movs	r1, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    67ea:	7983      	ldrb	r3, [r0, #6]
	return buf - pool->__bufs;
    67ec:	4a04      	ldr	r2, [pc, #16]	; (6800 <net_buf_id+0x18>)
    67ee:	fb01 2303 	mla	r3, r1, r3, r2
    67f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    67f4:	1ac0      	subs	r0, r0, r3
}
    67f6:	4b03      	ldr	r3, [pc, #12]	; (6804 <net_buf_id+0x1c>)
	return buf - pool->__bufs;
    67f8:	10c0      	asrs	r0, r0, #3
}
    67fa:	4358      	muls	r0, r3
    67fc:	4770      	bx	lr
    67fe:	bf00      	nop
    6800:	20000898 	.word	0x20000898
    6804:	aaaaaaab 	.word	0xaaaaaaab

00006808 <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static uint8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
    6808:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    680a:	2428      	movs	r4, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    680c:	7983      	ldrb	r3, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    680e:	4a09      	ldr	r2, [pc, #36]	; (6834 <fixed_data_alloc+0x2c>)
    6810:	fb04 2303 	mla	r3, r4, r3, r2
    6814:	6a1b      	ldr	r3, [r3, #32]

	*size = MIN(fixed->data_size, *size);
    6816:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    6818:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
    681a:	6823      	ldr	r3, [r4, #0]
    681c:	429a      	cmp	r2, r3
    681e:	bf94      	ite	ls
    6820:	600a      	strls	r2, [r1, #0]
    6822:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    6824:	f7ff ffe0 	bl	67e8 <net_buf_id>
    6828:	e9d4 2300 	ldrd	r2, r3, [r4]
}
    682c:	fb02 3000 	mla	r0, r2, r0, r3
    6830:	bd10      	pop	{r4, pc}
    6832:	bf00      	nop
    6834:	20000898 	.word	0x20000898

00006838 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
    6838:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    683c:	4605      	mov	r5, r0
    683e:	9101      	str	r1, [sp, #4]
	uint64_t end = z_timeout_end_calc(timeout);
    6840:	4610      	mov	r0, r2
    6842:	4619      	mov	r1, r3
{
    6844:	4616      	mov	r6, r2
    6846:	461f      	mov	r7, r3
	uint64_t end = z_timeout_end_calc(timeout);
    6848:	f016 feaf 	bl	1d5aa <z_timeout_end_calc>
    684c:	4680      	mov	r8, r0
    684e:	4689      	mov	r9, r1
	__asm__ volatile(
    6850:	f04f 0320 	mov.w	r3, #32
    6854:	f3ef 8a11 	mrs	sl, BASEPRI
    6858:	f383 8811 	msr	BASEPRI, r3
    685c:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    6860:	8b6b      	ldrh	r3, [r5, #26]
    6862:	2b00      	cmp	r3, #0
    6864:	d054      	beq.n	6910 <net_buf_alloc_len+0xd8>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    6866:	8b2a      	ldrh	r2, [r5, #24]
    6868:	429a      	cmp	r2, r3
    686a:	d93d      	bls.n	68e8 <net_buf_alloc_len+0xb0>
	return z_impl_k_queue_get(queue, timeout);
    686c:	2200      	movs	r2, #0
    686e:	2300      	movs	r3, #0
    6870:	4628      	mov	r0, r5
    6872:	f009 febd 	bl	105f0 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
    6876:	4604      	mov	r4, r0
    6878:	2800      	cmp	r0, #0
    687a:	d035      	beq.n	68e8 <net_buf_alloc_len+0xb0>
	__asm__ volatile(
    687c:	f38a 8811 	msr	BASEPRI, sl
    6880:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
    6884:	9b01      	ldr	r3, [sp, #4]
    6886:	2b00      	cmp	r3, #0
    6888:	d052      	beq.n	6930 <net_buf_alloc_len+0xf8>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    688a:	ea56 0307 	orrs.w	r3, r6, r7
    688e:	d010      	beq.n	68b2 <net_buf_alloc_len+0x7a>
    6890:	1c7b      	adds	r3, r7, #1
    6892:	bf08      	it	eq
    6894:	f1b6 3fff 	cmpeq.w	r6, #4294967295
    6898:	d00b      	beq.n	68b2 <net_buf_alloc_len+0x7a>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - z_tick_get();
    689a:	f00a fd85 	bl	113a8 <z_tick_get>
    689e:	ebb8 0600 	subs.w	r6, r8, r0
    68a2:	eb69 0701 	sbc.w	r7, r9, r1
    68a6:	2e00      	cmp	r6, #0
    68a8:	f177 0300 	sbcs.w	r3, r7, #0
    68ac:	bfbc      	itt	lt
    68ae:	2600      	movlt	r6, #0
    68b0:	2700      	movlt	r7, #0
	return pool->alloc->cb->alloc(buf, size, timeout);
    68b2:	2228      	movs	r2, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    68b4:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
    68b6:	f8df 8090 	ldr.w	r8, [pc, #144]	; 6948 <net_buf_alloc_len+0x110>
    68ba:	4620      	mov	r0, r4
    68bc:	fb02 8303 	mla	r3, r2, r3, r8
    68c0:	6a1b      	ldr	r3, [r3, #32]
    68c2:	4632      	mov	r2, r6
    68c4:	681b      	ldr	r3, [r3, #0]
    68c6:	a901      	add	r1, sp, #4
    68c8:	681d      	ldr	r5, [r3, #0]
    68ca:	463b      	mov	r3, r7
    68cc:	47a8      	blx	r5
    68ce:	4605      	mov	r5, r0
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
    68d0:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
    68d2:	bb70      	cbnz	r0, 6932 <net_buf_alloc_len+0xfa>
	k_lifo_put(&pool->free, buf);
    68d4:	79a0      	ldrb	r0, [r4, #6]
    68d6:	4621      	mov	r1, r4
    68d8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    68dc:	eb08 00c0 	add.w	r0, r8, r0, lsl #3
    68e0:	f016 fc51 	bl	1d186 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
    68e4:	462c      	mov	r4, r5
}
    68e6:	e01f      	b.n	6928 <net_buf_alloc_len+0xf0>
		uninit_count = pool->uninit_count--;
    68e8:	8b68      	ldrh	r0, [r5, #26]
    68ea:	1e43      	subs	r3, r0, #1
    68ec:	836b      	strh	r3, [r5, #26]
    68ee:	f38a 8811 	msr	BASEPRI, sl
    68f2:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    68f6:	2318      	movs	r3, #24
    68f8:	8b2c      	ldrh	r4, [r5, #24]
    68fa:	1a24      	subs	r4, r4, r0
    68fc:	6a68      	ldr	r0, [r5, #36]	; 0x24
    68fe:	fb03 0404 	mla	r4, r3, r4, r0
	return pool - _net_buf_pool_list;
    6902:	4811      	ldr	r0, [pc, #68]	; (6948 <net_buf_alloc_len+0x110>)
    6904:	4b11      	ldr	r3, [pc, #68]	; (694c <net_buf_alloc_len+0x114>)
    6906:	1a2d      	subs	r5, r5, r0
    6908:	10ed      	asrs	r5, r5, #3
    690a:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
    690c:	71a5      	strb	r5, [r4, #6]
		goto success;
    690e:	e7b9      	b.n	6884 <net_buf_alloc_len+0x4c>
    6910:	f38a 8811 	msr	BASEPRI, sl
    6914:	f3bf 8f6f 	isb	sy
    6918:	4632      	mov	r2, r6
    691a:	463b      	mov	r3, r7
    691c:	4628      	mov	r0, r5
    691e:	f009 fe67 	bl	105f0 <z_impl_k_queue_get>
	if (!buf) {
    6922:	4604      	mov	r4, r0
    6924:	2800      	cmp	r0, #0
    6926:	d1ad      	bne.n	6884 <net_buf_alloc_len+0x4c>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
    6928:	4620      	mov	r0, r4
    692a:	b002      	add	sp, #8
    692c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		buf->__buf = NULL;
    6930:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
    6932:	2300      	movs	r3, #0
	buf->ref   = 1U;
    6934:	2201      	movs	r2, #1
	buf->frags = NULL;
    6936:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
    6938:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
    693a:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
    693c:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
    693e:	6923      	ldr	r3, [r4, #16]
    6940:	81e2      	strh	r2, [r4, #14]
    6942:	60a3      	str	r3, [r4, #8]
	return buf;
    6944:	e7f0      	b.n	6928 <net_buf_alloc_len+0xf0>
    6946:	bf00      	nop
    6948:	20000898 	.word	0x20000898
    694c:	cccccccd 	.word	0xcccccccd

00006950 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    6950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6954:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
    6956:	2600      	movs	r6, #0
	pool->alloc->cb->unref(buf, data);
    6958:	2728      	movs	r7, #40	; 0x28
    695a:	4d16      	ldr	r5, [pc, #88]	; (69b4 <net_buf_unref+0x64>)
	while (buf) {
    695c:	b90c      	cbnz	r4, 6962 <net_buf_unref+0x12>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    695e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (--buf->ref > 0) {
    6962:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
    6964:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
    6968:	3b01      	subs	r3, #1
    696a:	b2db      	uxtb	r3, r3
    696c:	7123      	strb	r3, [r4, #4]
    696e:	2b00      	cmp	r3, #0
    6970:	d1f5      	bne.n	695e <net_buf_unref+0xe>
		if (buf->__buf) {
    6972:	6921      	ldr	r1, [r4, #16]
    6974:	b159      	cbz	r1, 698e <net_buf_unref+0x3e>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
    6976:	7963      	ldrb	r3, [r4, #5]
    6978:	079b      	lsls	r3, r3, #30
    697a:	d407      	bmi.n	698c <net_buf_unref+0x3c>
	pool->alloc->cb->unref(buf, data);
    697c:	79a3      	ldrb	r3, [r4, #6]
    697e:	4620      	mov	r0, r4
    6980:	fb07 5303 	mla	r3, r7, r3, r5
    6984:	6a1b      	ldr	r3, [r3, #32]
    6986:	681b      	ldr	r3, [r3, #0]
    6988:	689b      	ldr	r3, [r3, #8]
    698a:	4798      	blx	r3
			buf->__buf = NULL;
    698c:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
    698e:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
    6990:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
    6992:	fb07 5300 	mla	r3, r7, r0, r5
    6996:	69db      	ldr	r3, [r3, #28]
		buf->frags = NULL;
    6998:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
    699a:	b11b      	cbz	r3, 69a4 <net_buf_unref+0x54>
			pool->destroy(buf);
    699c:	4620      	mov	r0, r4
    699e:	4798      	blx	r3
{
    69a0:	4644      	mov	r4, r8
    69a2:	e7db      	b.n	695c <net_buf_unref+0xc>
	k_lifo_put(&pool->free, buf);
    69a4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    69a8:	4621      	mov	r1, r4
    69aa:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
    69ae:	f016 fbea 	bl	1d186 <k_queue_prepend>
}
    69b2:	e7f5      	b.n	69a0 <net_buf_unref+0x50>
    69b4:	20000898 	.word	0x20000898

000069b8 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    69b8:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    69ba:	4b09      	ldr	r3, [pc, #36]	; (69e0 <gpio_nrfx_init+0x28>)
    69bc:	781a      	ldrb	r2, [r3, #0]
    69be:	b96a      	cbnz	r2, 69dc <gpio_nrfx_init+0x24>
		gpio_initialized = true;
    69c0:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    69c2:	200d      	movs	r0, #13
		gpio_initialized = true;
    69c4:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    69c6:	2105      	movs	r1, #5
    69c8:	f7fb ff06 	bl	27d8 <z_arm_irq_priority_set>
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_IRQN(GPIOTE_NODE));
    69cc:	200d      	movs	r0, #13
    69ce:	f7fb fee5 	bl	279c <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    69d2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    69d6:	4b03      	ldr	r3, [pc, #12]	; (69e4 <gpio_nrfx_init+0x2c>)
    69d8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    69dc:	2000      	movs	r0, #0
    69de:	bd08      	pop	{r3, pc}
    69e0:	20029f4e 	.word	0x20029f4e
    69e4:	5000d000 	.word	0x5000d000

000069e8 <gpio_nrfx_config>:
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    69e8:	4b2a      	ldr	r3, [pc, #168]	; (6a94 <gpio_nrfx_config+0xac>)
{
    69ea:	b5f0      	push	{r4, r5, r6, r7, lr}
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    69ec:	6844      	ldr	r4, [r0, #4]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    69ee:	482a      	ldr	r0, [pc, #168]	; (6a98 <gpio_nrfx_config+0xb0>)
    69f0:	4013      	ands	r3, r2
    69f2:	4283      	cmp	r3, r0
    69f4:	d03f      	beq.n	6a76 <gpio_nrfx_config+0x8e>
    69f6:	d80d      	bhi.n	6a14 <gpio_nrfx_config+0x2c>
    69f8:	2b06      	cmp	r3, #6
    69fa:	d015      	beq.n	6a28 <gpio_nrfx_config+0x40>
    69fc:	d805      	bhi.n	6a0a <gpio_nrfx_config+0x22>
    69fe:	b19b      	cbz	r3, 6a28 <gpio_nrfx_config+0x40>
    6a00:	2b02      	cmp	r3, #2
    6a02:	d03a      	beq.n	6a7a <gpio_nrfx_config+0x92>
    6a04:	f06f 0015 	mvn.w	r0, #21
    6a08:	e034      	b.n	6a74 <gpio_nrfx_config+0x8c>
    6a0a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    6a0e:	d1f9      	bne.n	6a04 <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_H0S1;
    6a10:	2301      	movs	r3, #1
    6a12:	e009      	b.n	6a28 <gpio_nrfx_config+0x40>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    6a14:	4821      	ldr	r0, [pc, #132]	; (6a9c <gpio_nrfx_config+0xb4>)
    6a16:	4283      	cmp	r3, r0
    6a18:	d031      	beq.n	6a7e <gpio_nrfx_config+0x96>
    6a1a:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    6a1e:	d030      	beq.n	6a82 <gpio_nrfx_config+0x9a>
    6a20:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    6a24:	d1ee      	bne.n	6a04 <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_S0H1;
    6a26:	2302      	movs	r3, #2
	if ((flags & GPIO_PULL_UP) != 0) {
    6a28:	06d0      	lsls	r0, r2, #27
		pull = NRF_GPIO_PIN_PULLUP;
    6a2a:	bf4c      	ite	mi
    6a2c:	2603      	movmi	r6, #3
		pull = NRF_GPIO_PIN_NOPULL;
    6a2e:	f3c2 1640 	ubfxpl	r6, r2, #5, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    6a32:	f482 7580 	eor.w	r5, r2, #256	; 0x100
	if ((flags & GPIO_OUTPUT) != 0) {
    6a36:	0597      	lsls	r7, r2, #22
	dir = ((flags & GPIO_OUTPUT) != 0)
    6a38:	f3c2 2040 	ubfx	r0, r2, #9, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    6a3c:	f3c5 2500 	ubfx	r5, r5, #8, #1
	if ((flags & GPIO_OUTPUT) != 0) {
    6a40:	d506      	bpl.n	6a50 <gpio_nrfx_config+0x68>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    6a42:	f412 6f00 	tst.w	r2, #2048	; 0x800
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    6a46:	6867      	ldr	r7, [r4, #4]
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    6a48:	d01d      	beq.n	6a86 <gpio_nrfx_config+0x9e>
			nrf_gpio_port_out_set(reg, BIT(pin));
    6a4a:	2201      	movs	r2, #1
    6a4c:	408a      	lsls	r2, r1
    p_reg->OUTSET = set_mask;
    6a4e:	60ba      	str	r2, [r7, #8]
    return pin_number >> 5;
    6a50:	7a27      	ldrb	r7, [r4, #8]
        case 1: return NRF_P1;
    6a52:	4a13      	ldr	r2, [pc, #76]	; (6aa0 <gpio_nrfx_config+0xb8>)
    6a54:	4c13      	ldr	r4, [pc, #76]	; (6aa4 <gpio_nrfx_config+0xbc>)
    *p_pin = pin_number & 0x1F;
    6a56:	f001 011f 	and.w	r1, r1, #31
        case 1: return NRF_P1;
    6a5a:	2f01      	cmp	r7, #1
    6a5c:	bf08      	it	eq
    6a5e:	4614      	moveq	r4, r2
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    6a60:	ea40 0245 	orr.w	r2, r0, r5, lsl #1
	return 0;
    6a64:	2000      	movs	r0, #0
    6a66:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    6a6a:	ea43 0386 	orr.w	r3, r3, r6, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    6a6e:	3180      	adds	r1, #128	; 0x80
    6a70:	f844 3021 	str.w	r3, [r4, r1, lsl #2]
}
    6a74:	bdf0      	pop	{r4, r5, r6, r7, pc}
		drive = NRF_GPIO_PIN_H0D1;
    6a76:	2307      	movs	r3, #7
    6a78:	e7d6      	b.n	6a28 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0S1;
    6a7a:	2304      	movs	r3, #4
    6a7c:	e7d4      	b.n	6a28 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0H1;
    6a7e:	2305      	movs	r3, #5
    6a80:	e7d2      	b.n	6a28 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_H0H1;
    6a82:	2303      	movs	r3, #3
    6a84:	e7d0      	b.n	6a28 <gpio_nrfx_config+0x40>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    6a86:	0552      	lsls	r2, r2, #21
			nrf_gpio_port_out_clear(reg, BIT(pin));
    6a88:	bf42      	ittt	mi
    6a8a:	2201      	movmi	r2, #1
    6a8c:	408a      	lslmi	r2, r1
    p_reg->OUTCLR = clr_mask;
    6a8e:	60fa      	strmi	r2, [r7, #12]
}
    6a90:	e7de      	b.n	6a50 <gpio_nrfx_config+0x68>
    6a92:	bf00      	nop
    6a94:	00f00006 	.word	0x00f00006
    6a98:	00100006 	.word	0x00100006
    6a9c:	00400002 	.word	0x00400002
    6aa0:	50842800 	.word	0x50842800
    6aa4:	50842500 	.word	0x50842500

00006aa8 <nrf_gpio_cfg_sense_set>:
{
    6aa8:	b510      	push	{r4, lr}
        case 1: return NRF_P1;
    6aaa:	4b09      	ldr	r3, [pc, #36]	; (6ad0 <nrf_gpio_cfg_sense_set+0x28>)
    6aac:	4c09      	ldr	r4, [pc, #36]	; (6ad4 <nrf_gpio_cfg_sense_set+0x2c>)
    *p_pin = pin_number & 0x1F;
    6aae:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    6ab2:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    6ab4:	2801      	cmp	r0, #1
    6ab6:	bf08      	it	eq
    6ab8:	4623      	moveq	r3, r4
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    6aba:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    6abe:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    6ac2:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    6ac6:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    6aca:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
    6ace:	bd10      	pop	{r4, pc}
    6ad0:	50842500 	.word	0x50842500
    6ad4:	50842800 	.word	0x50842800

00006ad8 <gpio_nrfx_pin_interrupt_configure>:
{
    6ad8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6ada:	460e      	mov	r6, r1
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    6adc:	6841      	ldr	r1, [r0, #4]
    6ade:	f006 051f 	and.w	r5, r6, #31
    6ae2:	7a09      	ldrb	r1, [r1, #8]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    6ae4:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
	struct gpio_nrfx_data *data = get_port_data(port);
    6ae8:	68c7      	ldr	r7, [r0, #12]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    6aea:	ea45 1541 	orr.w	r5, r5, r1, lsl #5
    6aee:	d111      	bne.n	6b14 <gpio_nrfx_pin_interrupt_configure+0x3c>
        case 1: return NRF_P1;
    6af0:	4c5f      	ldr	r4, [pc, #380]	; (6c70 <gpio_nrfx_pin_interrupt_configure+0x198>)
    6af2:	f8df c188 	ldr.w	ip, [pc, #392]	; 6c7c <gpio_nrfx_pin_interrupt_configure+0x1a4>
    return pin_number >> 5;
    6af6:	0968      	lsrs	r0, r5, #5
        case 1: return NRF_P1;
    6af8:	2801      	cmp	r0, #1
    6afa:	bf14      	ite	ne
    6afc:	4620      	movne	r0, r4
    6afe:	4660      	moveq	r0, ip
    *p_pin = pin_number & 0x1F;
    6b00:	f005 011f 	and.w	r1, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    6b04:	3180      	adds	r1, #128	; 0x80
    6b06:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    6b0a:	07c8      	lsls	r0, r1, #31
    6b0c:	d507      	bpl.n	6b1e <gpio_nrfx_pin_interrupt_configure+0x46>
		return -ENOTSUP;
    6b0e:	f06f 0085 	mvn.w	r0, #133	; 0x85
    6b12:	e093      	b.n	6c3c <gpio_nrfx_pin_interrupt_configure+0x164>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    6b14:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    6b18:	68f9      	ldr	r1, [r7, #12]
    6b1a:	f000 8091 	beq.w	6c40 <gpio_nrfx_pin_interrupt_configure+0x168>
    6b1e:	2101      	movs	r1, #1
    6b20:	68f8      	ldr	r0, [r7, #12]
    6b22:	40b1      	lsls	r1, r6
    6b24:	4301      	orrs	r1, r0
    6b26:	60f9      	str	r1, [r7, #12]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    6b28:	2101      	movs	r1, #1
    6b2a:	6978      	ldr	r0, [r7, #20]
    6b2c:	40b1      	lsls	r1, r6
    6b2e:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    6b32:	bf0c      	ite	eq
    6b34:	4308      	orreq	r0, r1
    6b36:	4388      	bicne	r0, r1
    6b38:	6178      	str	r0, [r7, #20]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    6b3a:	2000      	movs	r0, #0
    6b3c:	69ba      	ldr	r2, [r7, #24]
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    6b3e:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    6b42:	bf0c      	ite	eq
    6b44:	430a      	orreq	r2, r1
    6b46:	438a      	bicne	r2, r1
    6b48:	61ba      	str	r2, [r7, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    6b4a:	693a      	ldr	r2, [r7, #16]
    6b4c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    6b50:	bf0c      	ite	eq
    6b52:	4311      	orreq	r1, r2
    6b54:	ea22 0101 	bicne.w	r1, r2, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    6b58:	4a46      	ldr	r2, [pc, #280]	; (6c74 <gpio_nrfx_pin_interrupt_configure+0x19c>)
    6b5a:	6139      	str	r1, [r7, #16]
    6b5c:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
    6b60:	b2db      	uxtb	r3, r3
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    6b62:	f500 71a2 	add.w	r1, r0, #324	; 0x144
    6b66:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    6b6a:	f3c1 2105 	ubfx	r1, r1, #8, #6
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    6b6e:	428d      	cmp	r5, r1
    6b70:	d16b      	bne.n	6c4a <gpio_nrfx_pin_interrupt_configure+0x172>
		    && (intenset & BIT(i))) {
    6b72:	fa23 f100 	lsr.w	r1, r3, r0
    6b76:	07c9      	lsls	r1, r1, #31
    6b78:	d567      	bpl.n	6c4a <gpio_nrfx_pin_interrupt_configure+0x172>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    6b7a:	0083      	lsls	r3, r0, #2
    6b7c:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
    6b80:	f503 4350 	add.w	r3, r3, #53248	; 0xd000
    6b84:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
    6b88:	f021 0101 	bic.w	r1, r1, #1
    6b8c:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    6b90:	2301      	movs	r3, #1
    6b92:	4083      	lsls	r3, r0
    p_reg->INTENCLR = mask;
    6b94:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
			nrfx_gpiote_channel_free(i);
    6b98:	b2c0      	uxtb	r0, r0
    6b9a:	f000 ff69 	bl	7a70 <nrfx_gpiote_channel_free>
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
    6b9e:	4628      	mov	r0, r5
    6ba0:	2100      	movs	r1, #0
    6ba2:	f7ff ff81 	bl	6aa8 <nrf_gpio_cfg_sense_set>
	if (data->pin_int_en & BIT(pin)) {
    6ba6:	68f8      	ldr	r0, [r7, #12]
    6ba8:	40f0      	lsrs	r0, r6
    6baa:	f010 0001 	ands.w	r0, r0, #1
    6bae:	d045      	beq.n	6c3c <gpio_nrfx_pin_interrupt_configure+0x164>
		if (data->trig_edge & BIT(pin)) {
    6bb0:	6978      	ldr	r0, [r7, #20]
    6bb2:	40f0      	lsrs	r0, r6
    6bb4:	f010 0401 	ands.w	r4, r0, #1
    6bb8:	d04e      	beq.n	6c58 <gpio_nrfx_pin_interrupt_configure+0x180>
			if (data->double_edge & BIT(pin)) {
    6bba:	69bb      	ldr	r3, [r7, #24]
	if (nrfx_gpiote_channel_alloc(&channel) != NRFX_SUCCESS) {
    6bbc:	f10d 0007 	add.w	r0, sp, #7
			if (data->double_edge & BIT(pin)) {
    6bc0:	40f3      	lsrs	r3, r6
    6bc2:	07db      	lsls	r3, r3, #31
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
    6bc4:	bf57      	itett	pl
    6bc6:	6939      	ldrpl	r1, [r7, #16]
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    6bc8:	2603      	movmi	r6, #3
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
    6bca:	fa21 f606 	lsrpl.w	r6, r1, r6
    6bce:	f006 0601 	andpl.w	r6, r6, #1
    6bd2:	bf5c      	itt	pl
    6bd4:	f1c6 0602 	rsbpl	r6, r6, #2
    6bd8:	b2f6      	uxtbpl	r6, r6
	if (nrfx_gpiote_channel_alloc(&channel) != NRFX_SUCCESS) {
    6bda:	f000 ff6b 	bl	7ab4 <nrfx_gpiote_channel_alloc>
    6bde:	4b26      	ldr	r3, [pc, #152]	; (6c78 <gpio_nrfx_pin_interrupt_configure+0x1a0>)
    6be0:	4298      	cmp	r0, r3
    6be2:	d136      	bne.n	6c52 <gpio_nrfx_pin_interrupt_configure+0x17a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    6be4:	2000      	movs	r0, #0
	nrf_gpiote_event_t evt = offsetof(NRF_GPIOTE_Type, EVENTS_IN[channel]);
    6be6:	f89d 1007 	ldrb.w	r1, [sp, #7]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    6bea:	022d      	lsls	r5, r5, #8
    6bec:	008b      	lsls	r3, r1, #2
    6bee:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
    6bf2:	f503 4350 	add.w	r3, r3, #53248	; 0xd000
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    6bf6:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    6bfa:	f405 557c 	and.w	r5, r5, #16128	; 0x3f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    6bfe:	f422 324f 	bic.w	r2, r2, #211968	; 0x33c00
    6c02:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    6c06:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    6c0a:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    6c0e:	4315      	orrs	r5, r2
    return ((uint32_t)p_reg + event);
    6c10:	008a      	lsls	r2, r1, #2
    6c12:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
    6c16:	f502 4251 	add.w	r2, r2, #53504	; 0xd100
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    6c1a:	ea45 4606 	orr.w	r6, r5, r6, lsl #16
    6c1e:	f8c3 6510 	str.w	r6, [r3, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    6c22:	6010      	str	r0, [r2, #0]
    6c24:	6812      	ldr	r2, [r2, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    6c26:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    6c2a:	f042 0201 	orr.w	r2, r2, #1
    6c2e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    6c32:	2301      	movs	r3, #1
    p_reg->INTENSET = mask;
    6c34:	4a0f      	ldr	r2, [pc, #60]	; (6c74 <gpio_nrfx_pin_interrupt_configure+0x19c>)
    6c36:	408b      	lsls	r3, r1
    6c38:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
    6c3c:	b003      	add	sp, #12
    6c3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    6c40:	2001      	movs	r0, #1
    6c42:	40b0      	lsls	r0, r6
    6c44:	ea21 0100 	bic.w	r1, r1, r0
    6c48:	e76d      	b.n	6b26 <gpio_nrfx_pin_interrupt_configure+0x4e>
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    6c4a:	3001      	adds	r0, #1
    6c4c:	2808      	cmp	r0, #8
    6c4e:	d188      	bne.n	6b62 <gpio_nrfx_pin_interrupt_configure+0x8a>
    6c50:	e7a5      	b.n	6b9e <gpio_nrfx_pin_interrupt_configure+0xc6>
		return -ENODEV;
    6c52:	f06f 0012 	mvn.w	r0, #18
    6c56:	e7f1      	b.n	6c3c <gpio_nrfx_pin_interrupt_configure+0x164>
	if ((BIT(pin) & data->int_active_level) != 0U) {
    6c58:	6939      	ldr	r1, [r7, #16]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
    6c5a:	4628      	mov	r0, r5
	if ((BIT(pin) & data->int_active_level) != 0U) {
    6c5c:	40f1      	lsrs	r1, r6
    6c5e:	f001 0101 	and.w	r1, r1, #1
    6c62:	f1c1 0103 	rsb	r1, r1, #3
			nrf_gpio_cfg_sense_set(abs_pin, sense);
    6c66:	b2c9      	uxtb	r1, r1
    6c68:	f7ff ff1e 	bl	6aa8 <nrf_gpio_cfg_sense_set>
	int res = 0;
    6c6c:	4620      	mov	r0, r4
    6c6e:	e7e5      	b.n	6c3c <gpio_nrfx_pin_interrupt_configure+0x164>
    6c70:	50842500 	.word	0x50842500
    6c74:	5000d000 	.word	0x5000d000
    6c78:	0bad0000 	.word	0x0bad0000
    6c7c:	50842800 	.word	0x50842800

00006c80 <gpiote_event_handler>:
{
    6c80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint32_t fired_triggers[GPIO_COUNT] = {0};
    6c82:	2600      	movs	r6, #0
    6c84:	e9cd 6600 	strd	r6, r6, [sp]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    6c88:	4d26      	ldr	r5, [pc, #152]	; (6d24 <gpiote_event_handler+0xa4>)
    6c8a:	682c      	ldr	r4, [r5, #0]
	if (port_event) {
    6c8c:	b14c      	cbz	r4, 6ca2 <gpiote_event_handler+0x22>
			check_level_trigger_pins(DEVICE_DT_GET(GPIO(0)));
    6c8e:	4826      	ldr	r0, [pc, #152]	; (6d28 <gpiote_event_handler+0xa8>)
    6c90:	f00e f954 	bl	14f3c <check_level_trigger_pins>
		fired_triggers[0] =
    6c94:	9000      	str	r0, [sp, #0]
			check_level_trigger_pins(DEVICE_DT_GET(GPIO(1)));
    6c96:	4825      	ldr	r0, [pc, #148]	; (6d2c <gpiote_event_handler+0xac>)
    6c98:	f00e f950 	bl	14f3c <check_level_trigger_pins>
		fired_triggers[1] =
    6c9c:	9001      	str	r0, [sp, #4]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    6c9e:	602e      	str	r6, [r5, #0]
    6ca0:	682b      	ldr	r3, [r5, #0]
{
    6ca2:	2200      	movs	r2, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    6ca4:	2601      	movs	r6, #1
    6ca6:	4694      	mov	ip, r2
    return p_reg->INTENSET & mask;
    6ca8:	4d21      	ldr	r5, [pc, #132]	; (6d30 <gpiote_event_handler+0xb0>)
    6caa:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
    6cae:	fa06 f102 	lsl.w	r1, r6, r2
    6cb2:	4219      	tst	r1, r3
    6cb4:	d01b      	beq.n	6cee <gpiote_event_handler+0x6e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    6cb6:	0091      	lsls	r1, r2, #2
    6cb8:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000
    6cbc:	f501 4151 	add.w	r1, r1, #53504	; 0xd100
    6cc0:	680b      	ldr	r3, [r1, #0]
    6cc2:	b1a3      	cbz	r3, 6cee <gpiote_event_handler+0x6e>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    6cc4:	f502 73a2 	add.w	r3, r2, #324	; 0x144
    6cc8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    6ccc:	af02      	add	r7, sp, #8
    6cce:	f3c3 3040 	ubfx	r0, r3, #13, #1
    6cd2:	eb07 0080 	add.w	r0, r7, r0, lsl #2
    6cd6:	f850 7c08 	ldr.w	r7, [r0, #-8]
    6cda:	f3c3 2304 	ubfx	r3, r3, #8, #5
    6cde:	fa06 f303 	lsl.w	r3, r6, r3
    6ce2:	433b      	orrs	r3, r7
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    6ce4:	f8c1 c000 	str.w	ip, [r1]
    6ce8:	f840 3c08 	str.w	r3, [r0, #-8]
    6cec:	680b      	ldr	r3, [r1, #0]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    6cee:	3201      	adds	r2, #1
    6cf0:	2a08      	cmp	r2, #8
    6cf2:	d1da      	bne.n	6caa <gpiote_event_handler+0x2a>
	if (fired_triggers[0]) {
    6cf4:	9a00      	ldr	r2, [sp, #0]
    6cf6:	b11a      	cbz	r2, 6d00 <gpiote_event_handler+0x80>
	gpio_fire_callbacks(list, port, pins);
    6cf8:	490b      	ldr	r1, [pc, #44]	; (6d28 <gpiote_event_handler+0xa8>)
    6cfa:	480e      	ldr	r0, [pc, #56]	; (6d34 <gpiote_event_handler+0xb4>)
    6cfc:	f00e f8bb 	bl	14e76 <gpio_fire_callbacks>
	if (fired_triggers[1]) {
    6d00:	9a01      	ldr	r2, [sp, #4]
    6d02:	b11a      	cbz	r2, 6d0c <gpiote_event_handler+0x8c>
	gpio_fire_callbacks(list, port, pins);
    6d04:	4909      	ldr	r1, [pc, #36]	; (6d2c <gpiote_event_handler+0xac>)
    6d06:	480c      	ldr	r0, [pc, #48]	; (6d38 <gpiote_event_handler+0xb8>)
    6d08:	f00e f8b5 	bl	14e76 <gpio_fire_callbacks>
	if (port_event) {
    6d0c:	b144      	cbz	r4, 6d20 <gpiote_event_handler+0xa0>
		cfg_level_pins(DEVICE_DT_GET(GPIO(0)));
    6d0e:	4806      	ldr	r0, [pc, #24]	; (6d28 <gpiote_event_handler+0xa8>)
    6d10:	f00e f93c 	bl	14f8c <cfg_level_pins>
		cfg_level_pins(DEVICE_DT_GET(GPIO(1)));
    6d14:	4805      	ldr	r0, [pc, #20]	; (6d2c <gpiote_event_handler+0xac>)
}
    6d16:	b003      	add	sp, #12
    6d18:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		cfg_level_pins(DEVICE_DT_GET(GPIO(1)));
    6d1c:	f00e b936 	b.w	14f8c <cfg_level_pins>
}
    6d20:	b003      	add	sp, #12
    6d22:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6d24:	5000d17c 	.word	0x5000d17c
    6d28:	20000698 	.word	0x20000698
    6d2c:	200006a8 	.word	0x200006a8
    6d30:	5000d000 	.word	0x5000d000
    6d34:	20025af8 	.word	0x20025af8
    6d38:	20025b14 	.word	0x20025b14

00006d3c <twim_1_init>:
#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
    6d3c:	b510      	push	{r4, lr}
    6d3e:	4604      	mov	r4, r0
    6d40:	2200      	movs	r2, #0
    6d42:	2101      	movs	r1, #1
    6d44:	2009      	movs	r0, #9
    6d46:	f7fb fd47 	bl	27d8 <z_arm_irq_priority_set>
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
    6d4a:	6860      	ldr	r0, [r4, #4]
    6d4c:	68e3      	ldr	r3, [r4, #12]
    6d4e:	4a06      	ldr	r2, [pc, #24]	; (6d68 <twim_1_init+0x2c>)
    6d50:	f100 0108 	add.w	r1, r0, #8
    6d54:	f001 f8cc 	bl	7ef0 <nrfx_twim_init>
	if (result != NRFX_SUCCESS) {
    6d58:	4b04      	ldr	r3, [pc, #16]	; (6d6c <twim_1_init+0x30>)
    6d5a:	4298      	cmp	r0, r3
I2C_NRFX_TWIM_DEVICE(1);
    6d5c:	bf14      	ite	ne
    6d5e:	f06f 000f 	mvnne.w	r0, #15
    6d62:	2000      	moveq	r0, #0
    6d64:	bd10      	pop	{r4, pc}
    6d66:	bf00      	nop
    6d68:	00006d71 	.word	0x00006d71
    6d6c:	0bad0000 	.word	0x0bad0000

00006d70 <event_handler>:
	switch (p_event->type) {
    6d70:	7803      	ldrb	r3, [r0, #0]
    6d72:	2b01      	cmp	r3, #1
    6d74:	d008      	beq.n	6d88 <event_handler+0x18>
    6d76:	2b02      	cmp	r3, #2
    6d78:	d008      	beq.n	6d8c <event_handler+0x1c>
    6d7a:	b94b      	cbnz	r3, 6d90 <event_handler+0x20>
		dev_data->res = NRFX_SUCCESS;
    6d7c:	4b05      	ldr	r3, [pc, #20]	; (6d94 <event_handler+0x24>)
		dev_data->res = NRFX_ERROR_INTERNAL;
    6d7e:	630b      	str	r3, [r1, #48]	; 0x30
	z_impl_k_sem_give(sem);
    6d80:	f101 0018 	add.w	r0, r1, #24
    6d84:	f00a b806 	b.w	10d94 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    6d88:	4b03      	ldr	r3, [pc, #12]	; (6d98 <event_handler+0x28>)
    6d8a:	e7f8      	b.n	6d7e <event_handler+0xe>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    6d8c:	4b03      	ldr	r3, [pc, #12]	; (6d9c <event_handler+0x2c>)
    6d8e:	e7f6      	b.n	6d7e <event_handler+0xe>
		dev_data->res = NRFX_ERROR_INTERNAL;
    6d90:	4b03      	ldr	r3, [pc, #12]	; (6da0 <event_handler+0x30>)
    6d92:	e7f4      	b.n	6d7e <event_handler+0xe>
    6d94:	0bad0000 	.word	0x0bad0000
    6d98:	0bae0001 	.word	0x0bae0001
    6d9c:	0bae0002 	.word	0x0bae0002
    6da0:	0bad0001 	.word	0x0bad0001

00006da4 <i2c_nrfx_twim_transfer>:
{
    6da4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6da8:	461d      	mov	r5, r3
	uint8_t *concat_buf = get_dev_data(dev)->concat_buf;
    6daa:	68c4      	ldr	r4, [r0, #12]
{
    6dac:	b089      	sub	sp, #36	; 0x24
	uint16_t concat_buf_size = get_dev_data(dev)->concat_buf_size;
    6dae:	8f23      	ldrh	r3, [r4, #56]	; 0x38
{
    6db0:	4606      	mov	r6, r0
    6db2:	4689      	mov	r9, r1
    6db4:	4692      	mov	sl, r2
	nrfx_twim_xfer_desc_t cur_xfer = {
    6db6:	2100      	movs	r1, #0
    6db8:	2214      	movs	r2, #20
    6dba:	a803      	add	r0, sp, #12
	uint8_t *concat_buf = get_dev_data(dev)->concat_buf;
    6dbc:	f8d4 803c 	ldr.w	r8, [r4, #60]	; 0x3c
	uint16_t concat_buf_size = get_dev_data(dev)->concat_buf_size;
    6dc0:	9300      	str	r3, [sp, #0]
	nrfx_twim_xfer_desc_t cur_xfer = {
    6dc2:	f016 fddb 	bl	1d97c <memset>
    6dc6:	f88d 500d 	strb.w	r5, [sp, #13]
	return z_impl_k_sem_take(sem, timeout);
    6dca:	f04f 32ff 	mov.w	r2, #4294967295
    6dce:	f04f 33ff 	mov.w	r3, #4294967295
    6dd2:	4620      	mov	r0, r4
    6dd4:	f00a f804 	bl	10de0 <z_impl_k_sem_take>
	k_sem_take(&(get_dev_data(dev)->completion_sync), K_NO_WAIT);
    6dd8:	68f0      	ldr	r0, [r6, #12]
    6dda:	3018      	adds	r0, #24
	for (size_t i = 0; i < num_msgs; i++) {
    6ddc:	2700      	movs	r7, #0
    6dde:	2200      	movs	r2, #0
    6de0:	2300      	movs	r3, #0
    6de2:	f009 fffd 	bl	10de0 <z_impl_k_sem_take>
	nrfx_twim_enable(&get_dev_config(dev)->twim);
    6de6:	6870      	ldr	r0, [r6, #4]
    6de8:	f001 f8dc 	bl	7fa4 <nrfx_twim_enable>
	for (size_t i = 0; i < num_msgs; i++) {
    6dec:	464d      	mov	r5, r9
	uint32_t concat_len = 0;
    6dee:	463c      	mov	r4, r7
		if (res != NRFX_SUCCESS) {
    6df0:	f8df b114 	ldr.w	fp, [pc, #276]	; 6f08 <i2c_nrfx_twim_transfer+0x164>
	for (size_t i = 0; i < num_msgs; i++) {
    6df4:	4557      	cmp	r7, sl
    6df6:	d301      	bcc.n	6dfc <i2c_nrfx_twim_transfer+0x58>
    6df8:	2400      	movs	r4, #0
    6dfa:	e02e      	b.n	6e5a <i2c_nrfx_twim_transfer+0xb6>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
    6dfc:	7a29      	ldrb	r1, [r5, #8]
    6dfe:	070b      	lsls	r3, r1, #28
    6e00:	d477      	bmi.n	6ef2 <i2c_nrfx_twim_transfer+0x14e>
			&& ((msgs[i].flags & I2C_MSG_READ)
    6e02:	9b00      	ldr	r3, [sp, #0]
    6e04:	b16b      	cbz	r3, 6e22 <i2c_nrfx_twim_transfer+0x7e>
			&& ((i + 1) < num_msgs)
    6e06:	1c7b      	adds	r3, r7, #1
    6e08:	4553      	cmp	r3, sl
    6e0a:	d20a      	bcs.n	6e22 <i2c_nrfx_twim_transfer+0x7e>
			&& !(msgs[i].flags & I2C_MSG_STOP)
    6e0c:	0788      	lsls	r0, r1, #30
    6e0e:	d408      	bmi.n	6e22 <i2c_nrfx_twim_transfer+0x7e>
			&& !(msgs[i + 1].flags & I2C_MSG_RESTART)
    6e10:	7d2b      	ldrb	r3, [r5, #20]
			    == (msgs[i + 1].flags & I2C_MSG_READ));
    6e12:	ea81 0203 	eor.w	r2, r1, r3
			&& ((msgs[i].flags & I2C_MSG_READ)
    6e16:	f002 0201 	and.w	r2, r2, #1
    6e1a:	f003 0304 	and.w	r3, r3, #4
    6e1e:	4313      	orrs	r3, r2
    6e20:	d025      	beq.n	6e6e <i2c_nrfx_twim_transfer+0xca>
		if (concat_next || (concat_len != 0)) {
    6e22:	2c00      	cmp	r4, #0
    6e24:	d13c      	bne.n	6ea0 <i2c_nrfx_twim_transfer+0xfc>
			cur_xfer.p_primary_buf = msgs[i].buf;
    6e26:	2400      	movs	r4, #0
    6e28:	682b      	ldr	r3, [r5, #0]
    6e2a:	9306      	str	r3, [sp, #24]
			cur_xfer.primary_length = msgs[i].len;
    6e2c:	686b      	ldr	r3, [r5, #4]
    6e2e:	9304      	str	r3, [sp, #16]
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
    6e30:	7a2b      	ldrb	r3, [r5, #8]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
    6e32:	6870      	ldr	r0, [r6, #4]
			NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX;
    6e34:	f003 0201 	and.w	r2, r3, #1
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
    6e38:	f013 0f02 	tst.w	r3, #2
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
    6e3c:	f88d 200c 	strb.w	r2, [sp, #12]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
    6e40:	a903      	add	r1, sp, #12
    6e42:	bf0c      	ite	eq
    6e44:	2220      	moveq	r2, #32
    6e46:	2200      	movne	r2, #0
    6e48:	f001 f8d8 	bl	7ffc <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
    6e4c:	4558      	cmp	r0, fp
    6e4e:	d029      	beq.n	6ea4 <i2c_nrfx_twim_transfer+0x100>
			if (res == NRFX_ERROR_BUSY) {
    6e50:	4b2c      	ldr	r3, [pc, #176]	; (6f04 <i2c_nrfx_twim_transfer+0x160>)
    6e52:	4298      	cmp	r0, r3
    6e54:	d053      	beq.n	6efe <i2c_nrfx_twim_transfer+0x15a>
				ret = -EIO;
    6e56:	f06f 0404 	mvn.w	r4, #4
	nrfx_twim_disable(&get_dev_config(dev)->twim);
    6e5a:	6870      	ldr	r0, [r6, #4]
    6e5c:	f001 f8b2 	bl	7fc4 <nrfx_twim_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
    6e60:	68f0      	ldr	r0, [r6, #12]
	z_impl_k_sem_give(sem);
    6e62:	f009 ff97 	bl	10d94 <z_impl_k_sem_give>
}
    6e66:	4620      	mov	r0, r4
    6e68:	b009      	add	sp, #36	; 0x24
    6e6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			&& ((msgs[i].flags & I2C_MSG_READ)
    6e6e:	2301      	movs	r3, #1
			if ((concat_len + msgs[i].len) > concat_buf_size) {
    6e70:	686a      	ldr	r2, [r5, #4]
    6e72:	9800      	ldr	r0, [sp, #0]
    6e74:	eb02 0c04 	add.w	ip, r2, r4
    6e78:	4584      	cmp	ip, r0
    6e7a:	d83d      	bhi.n	6ef8 <i2c_nrfx_twim_transfer+0x154>
			if (!(msgs[i].flags & I2C_MSG_READ)) {
    6e7c:	07c9      	lsls	r1, r1, #31
    6e7e:	d406      	bmi.n	6e8e <i2c_nrfx_twim_transfer+0xea>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    6e80:	6829      	ldr	r1, [r5, #0]
    6e82:	eb08 0004 	add.w	r0, r8, r4
    6e86:	9301      	str	r3, [sp, #4]
    6e88:	f016 fd6b 	bl	1d962 <memcpy>
    6e8c:	9b01      	ldr	r3, [sp, #4]
			concat_len += msgs[i].len;
    6e8e:	686a      	ldr	r2, [r5, #4]
    6e90:	4414      	add	r4, r2
		if (concat_next) {
    6e92:	b9c3      	cbnz	r3, 6ec6 <i2c_nrfx_twim_transfer+0x122>
		if (concat_len == 0) {
    6e94:	2c00      	cmp	r4, #0
    6e96:	d0c6      	beq.n	6e26 <i2c_nrfx_twim_transfer+0x82>
			cur_xfer.p_primary_buf = concat_buf;
    6e98:	f8cd 8018 	str.w	r8, [sp, #24]
			cur_xfer.primary_length = concat_len;
    6e9c:	9404      	str	r4, [sp, #16]
    6e9e:	e7c7      	b.n	6e30 <i2c_nrfx_twim_transfer+0x8c>
			&& ((msgs[i].flags & I2C_MSG_READ)
    6ea0:	2300      	movs	r3, #0
    6ea2:	e7e5      	b.n	6e70 <i2c_nrfx_twim_transfer+0xcc>
		ret = k_sem_take(&(get_dev_data(dev)->completion_sync),
    6ea4:	68f0      	ldr	r0, [r6, #12]
    6ea6:	3018      	adds	r0, #24
	return z_impl_k_sem_take(sem, timeout);
    6ea8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    6eac:	2300      	movs	r3, #0
    6eae:	f009 ff97 	bl	10de0 <z_impl_k_sem_take>
		if (ret != 0) {
    6eb2:	2800      	cmp	r0, #0
    6eb4:	d1cf      	bne.n	6e56 <i2c_nrfx_twim_transfer+0xb2>
		res = get_dev_data(dev)->res;
    6eb6:	68f3      	ldr	r3, [r6, #12]
    6eb8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
    6eba:	455b      	cmp	r3, fp
    6ebc:	d1cb      	bne.n	6e56 <i2c_nrfx_twim_transfer+0xb2>
		if ((msgs[i].flags & I2C_MSG_READ)
    6ebe:	7a2b      	ldrb	r3, [r5, #8]
    6ec0:	07db      	lsls	r3, r3, #31
    6ec2:	d403      	bmi.n	6ecc <i2c_nrfx_twim_transfer+0x128>
		concat_len = 0;
    6ec4:	2400      	movs	r4, #0
	for (size_t i = 0; i < num_msgs; i++) {
    6ec6:	3701      	adds	r7, #1
    6ec8:	350c      	adds	r5, #12
    6eca:	e793      	b.n	6df4 <i2c_nrfx_twim_transfer+0x50>
		    && cur_xfer.p_primary_buf == concat_buf) {
    6ecc:	9b06      	ldr	r3, [sp, #24]
    6ece:	4598      	cmp	r8, r3
    6ed0:	d1f8      	bne.n	6ec4 <i2c_nrfx_twim_transfer+0x120>
			while (concat_len >= msgs[j].len) {
    6ed2:	230c      	movs	r3, #12
    6ed4:	fb03 9307 	mla	r3, r3, r7, r9
    6ed8:	685a      	ldr	r2, [r3, #4]
    6eda:	3b0c      	subs	r3, #12
    6edc:	4294      	cmp	r4, r2
    6ede:	d3f1      	bcc.n	6ec4 <i2c_nrfx_twim_transfer+0x120>
				concat_len -= msgs[j].len;
    6ee0:	1aa4      	subs	r4, r4, r2
    6ee2:	68d8      	ldr	r0, [r3, #12]
    6ee4:	eb08 0104 	add.w	r1, r8, r4
    6ee8:	9301      	str	r3, [sp, #4]
    6eea:	f016 fd3a 	bl	1d962 <memcpy>
    6eee:	9b01      	ldr	r3, [sp, #4]
				j--;
    6ef0:	e7f2      	b.n	6ed8 <i2c_nrfx_twim_transfer+0x134>
			ret = -ENOTSUP;
    6ef2:	f06f 0485 	mvn.w	r4, #133	; 0x85
    6ef6:	e7b0      	b.n	6e5a <i2c_nrfx_twim_transfer+0xb6>
				ret = -ENOSPC;
    6ef8:	f06f 041b 	mvn.w	r4, #27
    6efc:	e7ad      	b.n	6e5a <i2c_nrfx_twim_transfer+0xb6>
				ret = -EBUSY;
    6efe:	f06f 040f 	mvn.w	r4, #15
    6f02:	e7aa      	b.n	6e5a <i2c_nrfx_twim_transfer+0xb6>
    6f04:	0bad000b 	.word	0x0bad000b
    6f08:	0bad0000 	.word	0x0bad0000

00006f0c <vipm_nrf_1_register_callback>:
		    &vipm_nrf_##_idx##_driver_api)

#define VIPM_DEVICE(_idx, _)						\
	IF_ENABLED(CONFIG_IPM_MSG_CH_##_idx##_ENABLE, (VIPM_DEVICE_1(_idx);))

UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
    6f0c:	4b02      	ldr	r3, [pc, #8]	; (6f18 <vipm_nrf_1_register_callback+0xc>)
    6f0e:	6059      	str	r1, [r3, #4]
    6f10:	645a      	str	r2, [r3, #68]	; 0x44
    6f12:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
    6f16:	4770      	bx	lr
    6f18:	20025b34 	.word	0x20025b34

00006f1c <vipm_nrf_init>:
{
    6f1c:	b538      	push	{r3, r4, r5, lr}
	if (!nrfx_vipm_data.ipm_init) {
    6f1e:	4d0b      	ldr	r5, [pc, #44]	; (6f4c <vipm_nrf_init+0x30>)
    6f20:	f895 40c0 	ldrb.w	r4, [r5, #192]	; 0xc0
    6f24:	b97c      	cbnz	r4, 6f46 <vipm_nrf_init+0x2a>
{
	/* Init IPC */
#if IS_ENABLED(CONFIG_IPM_NRF_SINGLE_INSTANCE)
	nrfx_ipc_init(0, nrfx_ipc_handler, (void *)&nrfx_ipm_data);
#else
	nrfx_ipc_init(0, vipm_dispatcher, (void *)&nrfx_ipm_data);
    6f26:	4a0a      	ldr	r2, [pc, #40]	; (6f50 <vipm_nrf_init+0x34>)
    6f28:	490a      	ldr	r1, [pc, #40]	; (6f54 <vipm_nrf_init+0x38>)
    6f2a:	4620      	mov	r0, r4
    6f2c:	f000 fdfa 	bl	7b24 <nrfx_ipc_init>
#endif
	IRQ_CONNECT(DT_INST_IRQN(0),
    6f30:	4622      	mov	r2, r4
    6f32:	2101      	movs	r1, #1
    6f34:	202a      	movs	r0, #42	; 0x2a
    6f36:	f7fb fc4f 	bl	27d8 <z_arm_irq_priority_set>
		    DT_INST_IRQ(0, priority),
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	/* Set up signals and channels */
	nrfx_ipc_config_load(&ipc_cfg);
    6f3a:	4807      	ldr	r0, [pc, #28]	; (6f58 <vipm_nrf_init+0x3c>)
    6f3c:	f000 fe0a 	bl	7b54 <nrfx_ipc_config_load>
		nrfx_vipm_data.ipm_init = true;
    6f40:	2301      	movs	r3, #1
    6f42:	f885 30c0 	strb.w	r3, [r5, #192]	; 0xc0
}
    6f46:	2000      	movs	r0, #0
    6f48:	bd38      	pop	{r3, r4, r5, pc}
    6f4a:	bf00      	nop
    6f4c:	20025b34 	.word	0x20025b34
    6f50:	20025b2c 	.word	0x20025b2c
    6f54:	00006f5d 	.word	0x00006f5d
    6f58:	0001f038 	.word	0x0001f038

00006f5c <vipm_dispatcher>:
{
    6f5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6f60:	4605      	mov	r5, r0
		event_mask &= ~BIT(event_idx);
    6f62:	f04f 0801 	mov.w	r8, #1
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
    6f66:	4e0e      	ldr	r6, [pc, #56]	; (6fa0 <vipm_dispatcher+0x44>)
	while (event_mask) {
    6f68:	b90d      	cbnz	r5, 6f6e <vipm_dispatcher+0x12>
}
    6f6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
    6f6e:	fa95 f3a5 	rbit	r3, r5
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
    6f72:	fab3 f383 	clz	r3, r3
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
    6f76:	f856 7023 	ldr.w	r7, [r6, r3, lsl #2]
		event_mask &= ~BIT(event_idx);
    6f7a:	fa08 f203 	lsl.w	r2, r8, r3
    6f7e:	ea25 0502 	bic.w	r5, r5, r2
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
    6f82:	2f00      	cmp	r7, #0
    6f84:	d0f0      	beq.n	6f68 <vipm_dispatcher+0xc>
			nrfx_vipm_data.callback[event_idx]
    6f86:	f103 0420 	add.w	r4, r3, #32
    6f8a:	f103 0110 	add.w	r1, r3, #16
    6f8e:	2300      	movs	r3, #0
    6f90:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
    6f94:	461a      	mov	r2, r3
    6f96:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
    6f9a:	47b8      	blx	r7
    6f9c:	e7e4      	b.n	6f68 <vipm_dispatcher+0xc>
    6f9e:	bf00      	nop
    6fa0:	20025b34 	.word	0x20025b34

00006fa4 <vipm_nrf_0_send>:
UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
    6fa4:	2a10      	cmp	r2, #16

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    6fa6:	bf9f      	itttt	ls
    6fa8:	2201      	movls	r2, #1
    6faa:	4b03      	ldrls	r3, [pc, #12]	; (6fb8 <vipm_nrf_0_send+0x14>)
    6fac:	2000      	movls	r0, #0
    6fae:	601a      	strls	r2, [r3, #0]
    6fb0:	bf88      	it	hi
    6fb2:	f06f 0015 	mvnhi.w	r0, #21
    6fb6:	4770      	bx	lr
    6fb8:	5002a000 	.word	0x5002a000

00006fbc <spi_4_init>:
#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(3);
#endif

#ifdef CONFIG_SPI_4_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(4);
    6fbc:	b538      	push	{r3, r4, r5, lr}
    6fbe:	4604      	mov	r4, r0
    6fc0:	2200      	movs	r2, #0
    6fc2:	2101      	movs	r1, #1
    6fc4:	200a      	movs	r0, #10
    6fc6:	f7fb fc07 	bl	27d8 <z_arm_irq_priority_set>
	struct spi_nrfx_data *data = get_dev_data(dev);
    6fca:	68e3      	ldr	r3, [r4, #12]
	result = nrfx_spim_init(&get_dev_config(dev)->spim,
    6fcc:	4a08      	ldr	r2, [pc, #32]	; (6ff0 <spi_4_init+0x34>)
	data->dev = dev;
    6fce:	65dc      	str	r4, [r3, #92]	; 0x5c
	result = nrfx_spim_init(&get_dev_config(dev)->spim,
    6fd0:	6860      	ldr	r0, [r4, #4]
    6fd2:	f100 010c 	add.w	r1, r0, #12
    6fd6:	f000 fe1d 	bl	7c14 <nrfx_spim_init>
	if (result != NRFX_SUCCESS) {
    6fda:	4b06      	ldr	r3, [pc, #24]	; (6ff4 <spi_4_init+0x38>)
    6fdc:	4298      	cmp	r0, r3
		return -EBUSY;
    6fde:	bf0c      	ite	eq
    6fe0:	2500      	moveq	r5, #0
    6fe2:	f06f 050f 	mvnne.w	r5, #15
SPI_NRFX_SPIM_DEVICE(4);
    6fe6:	68e0      	ldr	r0, [r4, #12]
    6fe8:	f00e f85e 	bl	150a8 <spi_context_unlock_unconditionally>
    6fec:	4628      	mov	r0, r5
    6fee:	bd38      	pop	{r3, r4, r5, pc}
    6ff0:	000150ed 	.word	0x000150ed
    6ff4:	0bad0000 	.word	0x0bad0000

00006ff8 <transfer_next_chunk>:
{
    6ff8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    6ffc:	68c5      	ldr	r5, [r0, #12]
{
    6ffe:	b085      	sub	sp, #20
 * directions have a continuous buffer, i.e. the maximum SPI transfer that
 * can be done with DMA that handles only non-scattered buffers.
 */
static inline size_t spi_context_max_continuous_chunk(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
    7000:	6d2f      	ldr	r7, [r5, #80]	; 0x50
    7002:	6dac      	ldr	r4, [r5, #88]	; 0x58
    7004:	b98f      	cbnz	r7, 702a <transfer_next_chunk+0x32>
	if (chunk_len > 0) {
    7006:	2c00      	cmp	r4, #0
    7008:	d14c      	bne.n	70a4 <transfer_next_chunk+0xac>
	_spi_context_cs_control(ctx, on, false);
    700a:	2200      	movs	r2, #0
    700c:	4628      	mov	r0, r5
    700e:	4611      	mov	r1, r2
    7010:	f00e f825 	bl	1505e <_spi_context_cs_control.isra.0>
	ctx->sync_status = status;
    7014:	63ac      	str	r4, [r5, #56]	; 0x38
	z_impl_k_sem_give(sem);
    7016:	f105 0020 	add.w	r0, r5, #32
    701a:	f009 febb 	bl	10d94 <z_impl_k_sem_give>
	dev_data->busy = false;
    701e:	2300      	movs	r3, #0
    7020:	f885 3064 	strb.w	r3, [r5, #100]	; 0x64
}
    7024:	b005      	add	sp, #20
    7026:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
    702a:	463e      	mov	r6, r7
    702c:	b114      	cbz	r4, 7034 <transfer_next_chunk+0x3c>
		return ctx->tx_len;
	}

	return MIN(ctx->tx_len, ctx->rx_len);
    702e:	42a7      	cmp	r7, r4
    7030:	bf28      	it	cs
    7032:	4626      	movcs	r6, r4
		const uint8_t *tx_buf = ctx->tx_buf;
    7034:	f8d5 804c 	ldr.w	r8, [r5, #76]	; 0x4c
	const struct spi_nrfx_config *dev_config = get_dev_config(dev);
    7038:	f8d0 9004 	ldr.w	r9, [r0, #4]
	return !!(ctx->tx_buf && ctx->tx_len);
    703c:	f1b8 0f00 	cmp.w	r8, #0
    7040:	d032      	beq.n	70a8 <transfer_next_chunk+0xb0>
		if (spi_context_tx_buf_on(ctx) && !nrfx_is_in_ram(tx_buf)) {
    7042:	b38f      	cbz	r7, 70a8 <transfer_next_chunk+0xb0>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    7044:	f008 4360 	and.w	r3, r8, #3758096384	; 0xe0000000
    7048:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    704c:	d02c      	beq.n	70a8 <transfer_next_chunk+0xb0>
			if (chunk_len > sizeof(dev_data->buffer)) {
    704e:	2e08      	cmp	r6, #8
    7050:	bf28      	it	cs
    7052:	2608      	movcs	r6, #8
			memcpy(dev_data->buffer, tx_buf, chunk_len);
    7054:	f105 0365 	add.w	r3, r5, #101	; 0x65
    7058:	4618      	mov	r0, r3
    705a:	4632      	mov	r2, r6
    705c:	4641      	mov	r1, r8
    705e:	f016 fc80 	bl	1d962 <memcpy>
    7062:	4603      	mov	r3, r0
		if (chunk_len > dev_config->max_chunk_len) {
    7064:	f8d9 2008 	ldr.w	r2, [r9, #8]
		xfer.p_tx_buffer = tx_buf;
    7068:	9300      	str	r3, [sp, #0]
    706a:	4296      	cmp	r6, r2
    706c:	bf28      	it	cs
    706e:	4616      	movcs	r6, r2
		dev_data->chunk_len = chunk_len;
    7070:	662e      	str	r6, [r5, #96]	; 0x60
    7072:	f1b8 0f00 	cmp.w	r8, #0
    7076:	d019      	beq.n	70ac <transfer_next_chunk+0xb4>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    7078:	2f00      	cmp	r7, #0
    707a:	bf18      	it	ne
    707c:	4637      	movne	r7, r6
		xfer.p_rx_buffer = ctx->rx_buf;
    707e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    7080:	9701      	str	r7, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    7082:	9302      	str	r3, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    7084:	b1a3      	cbz	r3, 70b0 <transfer_next_chunk+0xb8>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    7086:	2c00      	cmp	r4, #0
    7088:	bf18      	it	ne
    708a:	4634      	movne	r4, r6
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
    708c:	2200      	movs	r2, #0
    708e:	4669      	mov	r1, sp
    7090:	4648      	mov	r0, r9
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    7092:	9403      	str	r4, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
    7094:	f000 fe70 	bl	7d78 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
    7098:	4b06      	ldr	r3, [pc, #24]	; (70b4 <transfer_next_chunk+0xbc>)
    709a:	4298      	cmp	r0, r3
    709c:	d0c2      	beq.n	7024 <transfer_next_chunk+0x2c>
			error = -EIO;
    709e:	f06f 0404 	mvn.w	r4, #4
    70a2:	e7b2      	b.n	700a <transfer_next_chunk+0x12>
    70a4:	4626      	mov	r6, r4
    70a6:	e7c5      	b.n	7034 <transfer_next_chunk+0x3c>
    70a8:	4643      	mov	r3, r8
    70aa:	e7db      	b.n	7064 <transfer_next_chunk+0x6c>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    70ac:	4647      	mov	r7, r8
    70ae:	e7e6      	b.n	707e <transfer_next_chunk+0x86>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    70b0:	461c      	mov	r4, r3
    70b2:	e7eb      	b.n	708c <transfer_next_chunk+0x94>
    70b4:	0bad0000 	.word	0x0bad0000

000070b8 <spi_nrfx_transceive>:
{
    70b8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    70bc:	461e      	mov	r6, r3
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
    70be:	888b      	ldrh	r3, [r1, #4]
    70c0:	4680      	mov	r8, r0
    70c2:	045b      	lsls	r3, r3, #17
    70c4:	460d      	mov	r5, r1
    70c6:	4617      	mov	r7, r2
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    70c8:	68c4      	ldr	r4, [r0, #12]
    70ca:	f100 80b2 	bmi.w	7232 <spi_nrfx_transceive+0x17a>
	return z_impl_k_sem_take(sem, timeout);
    70ce:	f04f 32ff 	mov.w	r2, #4294967295
    70d2:	f04f 33ff 	mov.w	r3, #4294967295
    70d6:	f104 0008 	add.w	r0, r4, #8
    70da:	f009 fe81 	bl	10de0 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
    70de:	6065      	str	r5, [r4, #4]
	struct spi_context *ctx = &get_dev_data(dev)->ctx;
    70e0:	f8d8 200c 	ldr.w	r2, [r8, #12]
	if (spi_context_configured(ctx, spi_cfg)) {
    70e4:	6813      	ldr	r3, [r2, #0]
    70e6:	429d      	cmp	r5, r3
    70e8:	d06c      	beq.n	71c4 <spi_nrfx_transceive+0x10c>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
    70ea:	f641 0109 	movw	r1, #6153	; 0x1809
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    70ee:	88ab      	ldrh	r3, [r5, #4]
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
    70f0:	420b      	tst	r3, r1
    70f2:	f040 80d0 	bne.w	7296 <spi_nrfx_transceive+0x1de>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    70f6:	f3c3 1345 	ubfx	r3, r3, #5, #6
    70fa:	2b08      	cmp	r3, #8
    70fc:	f040 80cb 	bne.w	7296 <spi_nrfx_transceive+0x1de>
	if (spi_cfg->frequency < 125000) {
    7100:	6829      	ldr	r1, [r5, #0]
    7102:	4b66      	ldr	r3, [pc, #408]	; (729c <spi_nrfx_transceive+0x1e4>)
    7104:	4299      	cmp	r1, r3
    7106:	f240 80c6 	bls.w	7296 <spi_nrfx_transceive+0x1de>
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
    710a:	68ab      	ldr	r3, [r5, #8]
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
    710c:	f8d8 b004 	ldr.w	fp, [r8, #4]
	ctx->config = spi_cfg;
    7110:	6015      	str	r5, [r2, #0]
    7112:	b30b      	cbz	r3, 7158 <spi_nrfx_transceive+0xa0>
    7114:	6818      	ldr	r0, [r3, #0]
    7116:	b1f8      	cbz	r0, 7158 <spi_nrfx_transceive+0xa0>
				   ctx->config->cs->gpio_dt_flags |
    7118:	f893 9009 	ldrb.w	r9, [r3, #9]
		gpio_pin_configure(ctx->config->cs->gpio_dev,
    711c:	7a19      	ldrb	r1, [r3, #8]
		 != (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH),
		 "Output cannot be initialized low and high");

	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
    711e:	f019 0f01 	tst.w	r9, #1
    7122:	bf0c      	ite	eq
    7124:	f449 59b0 	orreq.w	r9, r9, #5632	; 0x1600
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH
    7128:	f489 6920 	eorne.w	r9, r9, #2560	; 0xa00
	struct gpio_driver_data *data =
    712c:	f8d0 a00c 	ldr.w	sl, [r0, #12]
	return api->pin_configure(port, pin, flags);
    7130:	6883      	ldr	r3, [r0, #8]
    7132:	464a      	mov	r2, r9
    7134:	681b      	ldr	r3, [r3, #0]
    7136:	9101      	str	r1, [sp, #4]
    7138:	4798      	blx	r3
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	ret = gpio_config(port, pin, flags);
	if (ret != 0) {
    713a:	b968      	cbnz	r0, 7158 <spi_nrfx_transceive+0xa0>
		return ret;
	}

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
    713c:	2301      	movs	r3, #1
    713e:	9901      	ldr	r1, [sp, #4]
    7140:	f8da 2000 	ldr.w	r2, [sl]
    7144:	fa03 f101 	lsl.w	r1, r3, r1
    7148:	f019 0f01 	tst.w	r9, #1
		data->invert |= (gpio_port_pins_t)BIT(pin);
    714c:	bf14      	ite	ne
    714e:	4311      	orrne	r1, r2
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    7150:	ea22 0101 	biceq.w	r1, r2, r1
    7154:	f8ca 1000 	str.w	r1, [sl]
	nrf_spim_configure(spim->p_reg,
    7158:	88a9      	ldrh	r1, [r5, #4]
    715a:	f8db 2000 	ldr.w	r2, [fp]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    715e:	0788      	lsls	r0, r1, #30
    7160:	f001 0304 	and.w	r3, r1, #4
    7164:	d56e      	bpl.n	7244 <spi_nrfx_transceive+0x18c>
			return NRF_SPIM_MODE_2;
    7166:	2b00      	cmp	r3, #0
    7168:	bf14      	ite	ne
    716a:	2303      	movne	r3, #3
    716c:	2302      	moveq	r3, #2
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
    716e:	2b02      	cmp	r3, #2
	if (operation & SPI_TRANSFER_LSB) {
    7170:	f3c1 1100 	ubfx	r1, r1, #4, #1
    7174:	d06a      	beq.n	724c <spi_nrfx_transceive+0x194>
    7176:	2b03      	cmp	r3, #3
    7178:	d06b      	beq.n	7252 <spi_nrfx_transceive+0x19a>
    717a:	2b01      	cmp	r3, #1
    717c:	d101      	bne.n	7182 <spi_nrfx_transceive+0xca>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
    717e:	f041 0102 	orr.w	r1, r1, #2
	if (frequency < 250000) {
    7182:	4b47      	ldr	r3, [pc, #284]	; (72a0 <spi_nrfx_transceive+0x1e8>)
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
    7184:	f8c2 1554 	str.w	r1, [r2, #1364]	; 0x554
	nrf_spim_frequency_set(spim->p_reg,
    7188:	6829      	ldr	r1, [r5, #0]
	if (frequency < 250000) {
    718a:	4299      	cmp	r1, r3
    718c:	d964      	bls.n	7258 <spi_nrfx_transceive+0x1a0>
	} else if (frequency < 500000) {
    718e:	4b45      	ldr	r3, [pc, #276]	; (72a4 <spi_nrfx_transceive+0x1ec>)
    7190:	4299      	cmp	r1, r3
    7192:	d964      	bls.n	725e <spi_nrfx_transceive+0x1a6>
	} else if (frequency < 1000000) {
    7194:	4b44      	ldr	r3, [pc, #272]	; (72a8 <spi_nrfx_transceive+0x1f0>)
    7196:	4299      	cmp	r1, r3
    7198:	d964      	bls.n	7264 <spi_nrfx_transceive+0x1ac>
	} else if (frequency < 2000000) {
    719a:	4b44      	ldr	r3, [pc, #272]	; (72ac <spi_nrfx_transceive+0x1f4>)
    719c:	4299      	cmp	r1, r3
    719e:	d964      	bls.n	726a <spi_nrfx_transceive+0x1b2>
	} else if (frequency < 4000000) {
    71a0:	4b43      	ldr	r3, [pc, #268]	; (72b0 <spi_nrfx_transceive+0x1f8>)
    71a2:	4299      	cmp	r1, r3
    71a4:	d964      	bls.n	7270 <spi_nrfx_transceive+0x1b8>
	} else if (frequency < 8000000) {
    71a6:	4b43      	ldr	r3, [pc, #268]	; (72b4 <spi_nrfx_transceive+0x1fc>)
    71a8:	4299      	cmp	r1, r3
    71aa:	d364      	bcc.n	7276 <spi_nrfx_transceive+0x1be>
	} else if (frequency < 16000000) {
    71ac:	4b42      	ldr	r3, [pc, #264]	; (72b8 <spi_nrfx_transceive+0x200>)
    71ae:	4299      	cmp	r1, r3
    71b0:	d364      	bcc.n	727c <spi_nrfx_transceive+0x1c4>
		return NRF_SPIM_FREQ_32M;
    71b2:	4b42      	ldr	r3, [pc, #264]	; (72bc <spi_nrfx_transceive+0x204>)
    71b4:	4299      	cmp	r1, r3
    71b6:	bf34      	ite	cc
    71b8:	f04f 6120 	movcc.w	r1, #167772160	; 0xa000000
    71bc:	f04f 51a0 	movcs.w	r1, #335544320	; 0x14000000
    p_reg->FREQUENCY = (uint32_t)frequency;
    71c0:	f8c2 1524 	str.w	r1, [r2, #1316]	; 0x524
		dev_data->busy = true;
    71c4:	2301      	movs	r3, #1
    71c6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
	if (tx_bufs) {
    71ca:	2f00      	cmp	r7, #0
    71cc:	d059      	beq.n	7282 <spi_nrfx_transceive+0x1ca>
		ctx->current_tx = tx_bufs->buffers;
    71ce:	683b      	ldr	r3, [r7, #0]
		ctx->tx_count = tx_bufs->count;
    71d0:	687a      	ldr	r2, [r7, #4]
		ctx->current_tx = tx_bufs->buffers;
    71d2:	63e3      	str	r3, [r4, #60]	; 0x3c
		ctx->tx_count = tx_bufs->count;
    71d4:	6422      	str	r2, [r4, #64]	; 0x40
		ctx->tx_buf = (const uint8_t *)ctx->current_tx->buf;
    71d6:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
    71d8:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const uint8_t *)ctx->current_tx->buf;
    71da:	64e2      	str	r2, [r4, #76]	; 0x4c
		ctx->tx_len = ctx->current_tx->len / dfs;
    71dc:	6523      	str	r3, [r4, #80]	; 0x50
	if (rx_bufs) {
    71de:	2e00      	cmp	r6, #0
    71e0:	d054      	beq.n	728c <spi_nrfx_transceive+0x1d4>
		ctx->current_rx = rx_bufs->buffers;
    71e2:	6833      	ldr	r3, [r6, #0]
		ctx->rx_count = rx_bufs->count;
    71e4:	6872      	ldr	r2, [r6, #4]
		ctx->current_rx = rx_bufs->buffers;
    71e6:	6463      	str	r3, [r4, #68]	; 0x44
		ctx->rx_count = rx_bufs->count;
    71e8:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->rx_buf = (uint8_t *)ctx->current_rx->buf;
    71ea:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
    71ec:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (uint8_t *)ctx->current_rx->buf;
    71ee:	6562      	str	r2, [r4, #84]	; 0x54
		ctx->rx_len = ctx->current_rx->len / dfs;
    71f0:	65a3      	str	r3, [r4, #88]	; 0x58
	ctx->sync_status = 0;
    71f2:	2200      	movs	r2, #0
	_spi_context_cs_control(ctx, on, false);
    71f4:	2101      	movs	r1, #1
    71f6:	4620      	mov	r0, r4
	ctx->sync_status = 0;
    71f8:	63a2      	str	r2, [r4, #56]	; 0x38
	_spi_context_cs_control(ctx, on, false);
    71fa:	f00d ff30 	bl	1505e <_spi_context_cs_control.isra.0>
		transfer_next_chunk(dev);
    71fe:	4640      	mov	r0, r8
    7200:	f7ff fefa 	bl	6ff8 <transfer_next_chunk>
    7204:	f04f 32ff 	mov.w	r2, #4294967295
    7208:	f04f 33ff 	mov.w	r3, #4294967295
    720c:	f104 0020 	add.w	r0, r4, #32
    7210:	f009 fde6 	bl	10de0 <z_impl_k_sem_take>
	status = ctx->sync_status;
    7214:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
    7216:	6823      	ldr	r3, [r4, #0]
    7218:	889b      	ldrh	r3, [r3, #4]
    721a:	f413 4380 	ands.w	r3, r3, #16384	; 0x4000
    721e:	d104      	bne.n	722a <spi_nrfx_transceive+0x172>
		ctx->owner = NULL;
    7220:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
    7222:	f104 0008 	add.w	r0, r4, #8
    7226:	f009 fdb5 	bl	10d94 <z_impl_k_sem_give>
}
    722a:	4628      	mov	r0, r5
    722c:	b003      	add	sp, #12
    722e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
    7232:	6923      	ldr	r3, [r4, #16]
    7234:	2b00      	cmp	r3, #0
    7236:	f47f af4a 	bne.w	70ce <spi_nrfx_transceive+0x16>
		(k_sem_count_get(&ctx->lock) == 0) &&
    723a:	6863      	ldr	r3, [r4, #4]
    723c:	4299      	cmp	r1, r3
    723e:	f47f af46 	bne.w	70ce <spi_nrfx_transceive+0x16>
    7242:	e74d      	b.n	70e0 <spi_nrfx_transceive+0x28>
			return NRF_SPIM_MODE_0;
    7244:	3b00      	subs	r3, #0
    7246:	bf18      	it	ne
    7248:	2301      	movne	r3, #1
    724a:	e790      	b.n	716e <spi_nrfx_transceive+0xb6>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    724c:	f041 0104 	orr.w	r1, r1, #4
        break;
    7250:	e797      	b.n	7182 <spi_nrfx_transceive+0xca>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    7252:	f041 0106 	orr.w	r1, r1, #6
        break;
    7256:	e794      	b.n	7182 <spi_nrfx_transceive+0xca>
		return NRF_SPIM_FREQ_125K;
    7258:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
    725c:	e7b0      	b.n	71c0 <spi_nrfx_transceive+0x108>
		return NRF_SPIM_FREQ_250K;
    725e:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
    7262:	e7ad      	b.n	71c0 <spi_nrfx_transceive+0x108>
		return NRF_SPIM_FREQ_500K;
    7264:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
    7268:	e7aa      	b.n	71c0 <spi_nrfx_transceive+0x108>
		return NRF_SPIM_FREQ_1M;
    726a:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    726e:	e7a7      	b.n	71c0 <spi_nrfx_transceive+0x108>
		return NRF_SPIM_FREQ_2M;
    7270:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    7274:	e7a4      	b.n	71c0 <spi_nrfx_transceive+0x108>
		return NRF_SPIM_FREQ_4M;
    7276:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    727a:	e7a1      	b.n	71c0 <spi_nrfx_transceive+0x108>
		return NRF_SPIM_FREQ_8M;
    727c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    7280:	e79e      	b.n	71c0 <spi_nrfx_transceive+0x108>
		ctx->tx_count = 0;
    7282:	e9c4 770f 	strd	r7, r7, [r4, #60]	; 0x3c
		ctx->tx_len = 0;
    7286:	e9c4 7713 	strd	r7, r7, [r4, #76]	; 0x4c
    728a:	e7a8      	b.n	71de <spi_nrfx_transceive+0x126>
		ctx->rx_count = 0;
    728c:	e9c4 6611 	strd	r6, r6, [r4, #68]	; 0x44
		ctx->rx_len = 0;
    7290:	e9c4 6615 	strd	r6, r6, [r4, #84]	; 0x54
    7294:	e7ad      	b.n	71f2 <spi_nrfx_transceive+0x13a>
		return -EINVAL;
    7296:	f06f 0515 	mvn.w	r5, #21
    729a:	e7bc      	b.n	7216 <spi_nrfx_transceive+0x15e>
    729c:	0001e847 	.word	0x0001e847
    72a0:	0003d08f 	.word	0x0003d08f
    72a4:	0007a11f 	.word	0x0007a11f
    72a8:	000f423f 	.word	0x000f423f
    72ac:	001e847f 	.word	0x001e847f
    72b0:	003d08ff 	.word	0x003d08ff
    72b4:	007a1200 	.word	0x007a1200
    72b8:	00f42400 	.word	0x00f42400
    72bc:	01e84800 	.word	0x01e84800

000072c0 <ft5336_init>:

	return 0;
}

static int ft5336_init(const struct device *dev)
{
    72c0:	b538      	push	{r3, r4, r5, lr}
	const struct ft5336_config *config = dev->config;
	struct ft5336_data *data = dev->data;

	data->i2c = device_get_binding(config->i2c_name);
    72c2:	6843      	ldr	r3, [r0, #4]
{
    72c4:	4604      	mov	r4, r0
	struct ft5336_data *data = dev->data;
    72c6:	68c5      	ldr	r5, [r0, #12]
	data->i2c = device_get_binding(config->i2c_name);
    72c8:	6818      	ldr	r0, [r3, #0]
    72ca:	f008 fe8f 	bl	ffec <z_impl_device_get_binding>
    72ce:	6068      	str	r0, [r5, #4]
	if (!data->i2c) {
    72d0:	b168      	cbz	r0, 72ee <ft5336_init+0x2e>
		LOG_ERR("Could not find I2C controller");
		return -ENODEV;
	}

	data->dev = dev;
    72d2:	602c      	str	r4, [r5, #0]
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    72d4:	2400      	movs	r4, #0
    72d6:	4b07      	ldr	r3, [pc, #28]	; (72f4 <ft5336_init+0x34>)
	}

	gpio_init_callback(&data->int_gpio_cb, ft5336_isr_handler,
			   BIT(config->int_gpio.pin));
#else
	k_timer_init(&data->timer, ft5336_timer_handler, NULL);
    72d8:	f105 0018 	add.w	r0, r5, #24
    72dc:	4622      	mov	r2, r4
    72de:	e9c5 3404 	strd	r3, r4, [r5, #16]
    72e2:	4905      	ldr	r1, [pc, #20]	; (72f8 <ft5336_init+0x38>)
    72e4:	60ec      	str	r4, [r5, #12]
    72e6:	f016 f989 	bl	1d5fc <k_timer_init>
#endif

	return 0;
    72ea:	4620      	mov	r0, r4
}
    72ec:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    72ee:	f06f 0012 	mvn.w	r0, #18
    72f2:	e7fb      	b.n	72ec <ft5336_init+0x2c>
    72f4:	0001519b 	.word	0x0001519b
    72f8:	000072fd 	.word	0x000072fd

000072fc <ft5336_timer_handler>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    72fc:	1f03      	subs	r3, r0, #4
    72fe:	e8d3 2fef 	ldaex	r2, [r3]
    7302:	f042 0101 	orr.w	r1, r2, #1
    7306:	e8c3 1fec 	stlex	ip, r1, [r3]
    730a:	f1bc 0f00 	cmp.w	ip, #0
    730e:	d1f6      	bne.n	72fe <ft5336_timer_handler+0x2>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    7310:	07d3      	lsls	r3, r2, #31
    7312:	d404      	bmi.n	731e <ft5336_timer_handler+0x22>
		k_queue_append(&work_q->queue, work);
    7314:	f1a0 010c 	sub.w	r1, r0, #12
    7318:	4801      	ldr	r0, [pc, #4]	; (7320 <ft5336_timer_handler+0x24>)
    731a:	f015 bf29 	b.w	1d170 <k_queue_append>
}
    731e:	4770      	bx	lr
    7320:	20001168 	.word	0x20001168

00007324 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
    7324:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
    7326:	794b      	ldrb	r3, [r1, #5]
    7328:	2b01      	cmp	r3, #1
    732a:	d02b      	beq.n	7384 <uarte_nrfx_configure+0x60>
    732c:	2b03      	cmp	r3, #3
    732e:	d126      	bne.n	737e <uarte_nrfx_configure+0x5a>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
    7330:	2710      	movs	r7, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    7332:	798b      	ldrb	r3, [r1, #6]
    7334:	2b03      	cmp	r3, #3
    7336:	d122      	bne.n	737e <uarte_nrfx_configure+0x5a>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    7338:	79cd      	ldrb	r5, [r1, #7]
    733a:	b125      	cbz	r5, 7346 <uarte_nrfx_configure+0x22>
    733c:	2d01      	cmp	r5, #1
    733e:	d11e      	bne.n	737e <uarte_nrfx_configure+0x5a>
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
    7340:	6843      	ldr	r3, [r0, #4]
    7342:	791b      	ldrb	r3, [r3, #4]
    7344:	b1db      	cbz	r3, 737e <uarte_nrfx_configure+0x5a>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    7346:	790a      	ldrb	r2, [r1, #4]
    7348:	2a01      	cmp	r2, #1
    734a:	d01d      	beq.n	7388 <uarte_nrfx_configure+0x64>
    734c:	2a02      	cmp	r2, #2
    734e:	d01f      	beq.n	7390 <uarte_nrfx_configure+0x6c>
    7350:	b9aa      	cbnz	r2, 737e <uarte_nrfx_configure+0x5a>
    7352:	4614      	mov	r4, r2
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    7354:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    7356:	6846      	ldr	r6, [r0, #4]
	switch (baudrate) {
    7358:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
    735c:	6836      	ldr	r6, [r6, #0]
	switch (baudrate) {
    735e:	d06e      	beq.n	743e <uarte_nrfx_configure+0x11a>
    7360:	d833      	bhi.n	73ca <uarte_nrfx_configure+0xa6>
    7362:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    7366:	d06d      	beq.n	7444 <uarte_nrfx_configure+0x120>
    7368:	d81c      	bhi.n	73a4 <uarte_nrfx_configure+0x80>
    736a:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    736e:	d06b      	beq.n	7448 <uarte_nrfx_configure+0x124>
    7370:	d810      	bhi.n	7394 <uarte_nrfx_configure+0x70>
    7372:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    7376:	d06a      	beq.n	744e <uarte_nrfx_configure+0x12a>
    7378:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    737c:	d06a      	beq.n	7454 <uarte_nrfx_configure+0x130>
    737e:	f06f 0085 	mvn.w	r0, #133	; 0x85
    7382:	e05b      	b.n	743c <uarte_nrfx_configure+0x118>
	switch (cfg->stop_bits) {
    7384:	2700      	movs	r7, #0
    7386:	e7d4      	b.n	7332 <uarte_nrfx_configure+0xe>
		uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_ODD;
    7388:	f44f 7480 	mov.w	r4, #256	; 0x100
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    738c:	220e      	movs	r2, #14
    738e:	e7e1      	b.n	7354 <uarte_nrfx_configure+0x30>
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
    7390:	2400      	movs	r4, #0
    7392:	e7fb      	b.n	738c <uarte_nrfx_configure+0x68>
	switch (baudrate) {
    7394:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    7398:	d05f      	beq.n	745a <uarte_nrfx_configure+0x136>
    739a:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    739e:	d1ee      	bne.n	737e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    73a0:	4b38      	ldr	r3, [pc, #224]	; (7484 <uarte_nrfx_configure+0x160>)
    73a2:	e03e      	b.n	7422 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    73a4:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    73a8:	d05a      	beq.n	7460 <uarte_nrfx_configure+0x13c>
    73aa:	d807      	bhi.n	73bc <uarte_nrfx_configure+0x98>
    73ac:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    73b0:	d058      	beq.n	7464 <uarte_nrfx_configure+0x140>
    73b2:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    73b6:	d1e2      	bne.n	737e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    73b8:	4b33      	ldr	r3, [pc, #204]	; (7488 <uarte_nrfx_configure+0x164>)
    73ba:	e032      	b.n	7422 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    73bc:	f647 2c12 	movw	ip, #31250	; 0x7a12
    73c0:	4563      	cmp	r3, ip
    73c2:	d1dc      	bne.n	737e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    73c4:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    73c8:	e02b      	b.n	7422 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    73ca:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    73ce:	d04b      	beq.n	7468 <uarte_nrfx_configure+0x144>
    73d0:	d813      	bhi.n	73fa <uarte_nrfx_configure+0xd6>
    73d2:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    73d6:	d04a      	beq.n	746e <uarte_nrfx_configure+0x14a>
    73d8:	d809      	bhi.n	73ee <uarte_nrfx_configure+0xca>
    73da:	f64d 2cc0 	movw	ip, #56000	; 0xdac0
    73de:	4563      	cmp	r3, ip
    73e0:	d047      	beq.n	7472 <uarte_nrfx_configure+0x14e>
    73e2:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    73e6:	d1ca      	bne.n	737e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    73e8:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    73ec:	e019      	b.n	7422 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    73ee:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    73f2:	d1c4      	bne.n	737e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    73f4:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    73f8:	e013      	b.n	7422 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    73fa:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    73fe:	d03b      	beq.n	7478 <uarte_nrfx_configure+0x154>
    7400:	d809      	bhi.n	7416 <uarte_nrfx_configure+0xf2>
    7402:	f8df c098 	ldr.w	ip, [pc, #152]	; 749c <uarte_nrfx_configure+0x178>
    7406:	4563      	cmp	r3, ip
    7408:	d039      	beq.n	747e <uarte_nrfx_configure+0x15a>
    740a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    740e:	d1b6      	bne.n	737e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    7410:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    7414:	e005      	b.n	7422 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    7416:	f8df c088 	ldr.w	ip, [pc, #136]	; 74a0 <uarte_nrfx_configure+0x17c>
    741a:	4563      	cmp	r3, ip
    741c:	d1af      	bne.n	737e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    741e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    7422:	f8c6 3524 	str.w	r3, [r6, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
    7426:	68c3      	ldr	r3, [r0, #12]
                    | (uint32_t)p_cfg->hwfc;
    7428:	432c      	orrs	r4, r5
                    | (uint32_t)p_cfg->stop
    742a:	433a      	orrs	r2, r7
                    | (uint32_t)p_cfg->hwfc;
    742c:	4322      	orrs	r2, r4
    742e:	3304      	adds	r3, #4
    7430:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    7432:	f8c6 256c 	str.w	r2, [r6, #1388]	; 0x56c
    7436:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    743a:	2000      	movs	r0, #0
}
    743c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    743e:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    7442:	e7ee      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    7444:	4b11      	ldr	r3, [pc, #68]	; (748c <uarte_nrfx_configure+0x168>)
    7446:	e7ec      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    7448:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    744c:	e7e9      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = 0x00014000;
    744e:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    7452:	e7e6      	b.n	7422 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    7454:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    7458:	e7e3      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    745a:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    745e:	e7e0      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    7460:	4b0b      	ldr	r3, [pc, #44]	; (7490 <uarte_nrfx_configure+0x16c>)
    7462:	e7de      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    7464:	4b0b      	ldr	r3, [pc, #44]	; (7494 <uarte_nrfx_configure+0x170>)
    7466:	e7dc      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    7468:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    746c:	e7d9      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    746e:	4b0a      	ldr	r3, [pc, #40]	; (7498 <uarte_nrfx_configure+0x174>)
    7470:	e7d7      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    7472:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    7476:	e7d4      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    7478:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    747c:	e7d1      	b.n	7422 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    747e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    7482:	e7ce      	b.n	7422 <uarte_nrfx_configure+0xfe>
    7484:	0013b000 	.word	0x0013b000
    7488:	004ea000 	.word	0x004ea000
    748c:	00275000 	.word	0x00275000
    7490:	0075c000 	.word	0x0075c000
    7494:	003af000 	.word	0x003af000
    7498:	013a9000 	.word	0x013a9000
    749c:	0003d090 	.word	0x0003d090
    74a0:	000f4240 	.word	0x000f4240

000074a4 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
    74a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    74a8:	4606      	mov	r6, r0
    74aa:	4688      	mov	r8, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
    74ac:	68c7      	ldr	r7, [r0, #12]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    74ae:	f015 ffbb 	bl	1d428 <k_is_in_isr>
    74b2:	b9b8      	cbnz	r0, 74e4 <uarte_nrfx_poll_out+0x40>
	return !z_sys_post_kernel;
    74b4:	4b28      	ldr	r3, [pc, #160]	; (7558 <uarte_nrfx_poll_out+0xb4>)
    74b6:	781b      	ldrb	r3, [r3, #0]
    74b8:	f083 0301 	eor.w	r3, r3, #1
	return config->uarte_regs;
    74bc:	6872      	ldr	r2, [r6, #4]
    74be:	6815      	ldr	r5, [r2, #0]
#ifdef CONFIG_PM_DEVICE
	if (data->pm_state != DEVICE_PM_ACTIVE_STATE) {
		return;
	}
#endif
	if (isr_mode) {
    74c0:	b193      	cbz	r3, 74e8 <uarte_nrfx_poll_out+0x44>
	__asm__ volatile(
    74c2:	f04f 0320 	mov.w	r3, #32
    74c6:	f3ef 8411 	mrs	r4, BASEPRI
    74ca:	f383 8811 	msr	BASEPRI, r3
    74ce:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
    74d2:	4630      	mov	r0, r6
    74d4:	f00d fef1 	bl	152ba <is_tx_ready>
    74d8:	bb38      	cbnz	r0, 752a <uarte_nrfx_poll_out+0x86>
	__asm__ volatile(
    74da:	f384 8811 	msr	BASEPRI, r4
    74de:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    74e2:	e7ee      	b.n	74c2 <uarte_nrfx_poll_out+0x1e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    74e4:	2301      	movs	r3, #1
    74e6:	e7e9      	b.n	74bc <uarte_nrfx_poll_out+0x18>
    74e8:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
    74ea:	4630      	mov	r0, r6
    74ec:	f00d fee5 	bl	152ba <is_tx_ready>
    74f0:	b970      	cbnz	r0, 7510 <uarte_nrfx_poll_out+0x6c>
    74f2:	2001      	movs	r0, #1
    74f4:	f00d ff11 	bl	1531a <nrfx_busy_wait>
    74f8:	3c01      	subs	r4, #1
    74fa:	d1f6      	bne.n	74ea <uarte_nrfx_poll_out+0x46>
	return z_impl_k_sleep(timeout);
    74fc:	2100      	movs	r1, #0
    74fe:	2021      	movs	r0, #33	; 0x21
    7500:	f009 fc20 	bl	10d44 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    7504:	e7f0      	b.n	74e8 <uarte_nrfx_poll_out+0x44>
	__asm__ volatile(
    7506:	f384 8811 	msr	BASEPRI, r4
    750a:	f3bf 8f6f 	isb	sy
}
    750e:	e7f5      	b.n	74fc <uarte_nrfx_poll_out+0x58>
	__asm__ volatile(
    7510:	f04f 0320 	mov.w	r3, #32
    7514:	f3ef 8411 	mrs	r4, BASEPRI
    7518:	f383 8811 	msr	BASEPRI, r3
    751c:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
    7520:	4630      	mov	r0, r6
    7522:	f00d feca 	bl	152ba <is_tx_ready>
    7526:	2800      	cmp	r0, #0
    7528:	d0ed      	beq.n	7506 <uarte_nrfx_poll_out+0x62>
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
    752a:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    752c:	2200      	movs	r2, #0
	}

	/* At this point we should have irq locked and any previous transfer
	 * completed. Transfer can be started, no need to wait for completion.
	 */
	data->char_out = c;
    752e:	f807 8f10 	strb.w	r8, [r7, #16]!
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    7532:	f8c5 7544 	str.w	r7, [r5, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    7536:	f8c5 3548 	str.w	r3, [r5, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    753a:	f8c5 2120 	str.w	r2, [r5, #288]	; 0x120
    753e:	f8d5 1120 	ldr.w	r1, [r5, #288]	; 0x120
    7542:	f8c5 2158 	str.w	r2, [r5, #344]	; 0x158
    7546:	f8d5 2158 	ldr.w	r2, [r5, #344]	; 0x158
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    754a:	60ab      	str	r3, [r5, #8]
	__asm__ volatile(
    754c:	f384 8811 	msr	BASEPRI, r4
    7550:	f3bf 8f6f 	isb	sy
	tx_start(uarte, &data->char_out, 1);

	irq_unlock(key);
}
    7554:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7558:	2002a079 	.word	0x2002a079

0000755c <nrf_gpio_cfg_output>:
        case 1: return NRF_P1;
    755c:	4b07      	ldr	r3, [pc, #28]	; (757c <nrf_gpio_cfg_output+0x20>)
    755e:	4908      	ldr	r1, [pc, #32]	; (7580 <nrf_gpio_cfg_output+0x24>)
    *p_pin = pin_number & 0x1F;
    7560:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    7564:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    7566:	2801      	cmp	r0, #1
    7568:	bf14      	ite	ne
    756a:	4618      	movne	r0, r3
    756c:	4608      	moveq	r0, r1
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    756e:	f102 0380 	add.w	r3, r2, #128	; 0x80
    7572:	2203      	movs	r2, #3
    7574:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
    7578:	4770      	bx	lr
    757a:	bf00      	nop
    757c:	50842500 	.word	0x50842500
    7580:	50842800 	.word	0x50842800

00007584 <nrf_gpio_pin_set>:
        case 1: return NRF_P1;
    7584:	4b06      	ldr	r3, [pc, #24]	; (75a0 <nrf_gpio_pin_set+0x1c>)
    7586:	4907      	ldr	r1, [pc, #28]	; (75a4 <nrf_gpio_pin_set+0x20>)
    *p_pin = pin_number & 0x1F;
    7588:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    758c:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    758e:	2801      	cmp	r0, #1
    7590:	bf14      	ite	ne
    7592:	4618      	movne	r0, r3
    7594:	4608      	moveq	r0, r1
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    7596:	2301      	movs	r3, #1
    7598:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    759a:	6083      	str	r3, [r0, #8]
}
    759c:	4770      	bx	lr
    759e:	bf00      	nop
    75a0:	50842500 	.word	0x50842500
    75a4:	50842800 	.word	0x50842800

000075a8 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
    75a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    75aa:	4605      	mov	r5, r0
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    75ac:	2700      	movs	r7, #0
    75ae:	2101      	movs	r1, #1
    75b0:	2200      	movs	r2, #0
    75b2:	2008      	movs	r0, #8
    75b4:	f7fb f910 	bl	27d8 <z_arm_irq_priority_set>
    75b8:	2008      	movs	r0, #8
    75ba:	f7fb f8ef 	bl	279c <arch_irq_enable>
	return config->uarte_regs;
    75be:	686b      	ldr	r3, [r5, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
    75c0:	68ee      	ldr	r6, [r5, #12]
	return config->uarte_regs;
    75c2:	681c      	ldr	r4, [r3, #0]
        nrf_gpio_pin_set(pin_number);
    75c4:	2014      	movs	r0, #20
    75c6:	f8c4 7500 	str.w	r7, [r4, #1280]	; 0x500
	data->dev = dev;
    75ca:	6035      	str	r5, [r6, #0]
    75cc:	f7ff ffda 	bl	7584 <nrf_gpio_pin_set>
	nrf_gpio_cfg_output(config->pseltxd);
    75d0:	2014      	movs	r0, #20
    75d2:	f7ff ffc3 	bl	755c <nrf_gpio_cfg_output>
    p_reg->PSEL.TXD = pseltxd;
    75d6:	2214      	movs	r2, #20
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    75d8:	4b2c      	ldr	r3, [pc, #176]	; (768c <uarte_0_init+0xe4>)
        nrf_gpio_pin_set(pin_number);
    75da:	2013      	movs	r0, #19
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    75dc:	f8c3 7258 	str.w	r7, [r3, #600]	; 0x258
    75e0:	f8c4 250c 	str.w	r2, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    75e4:	2216      	movs	r2, #22
    75e6:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
    75ea:	f8c3 7254 	str.w	r7, [r3, #596]	; 0x254
        nrf_gpio_pin_set(pin_number);
    75ee:	f7ff ffc9 	bl	7584 <nrf_gpio_pin_set>
		nrf_gpio_cfg_output(config->pselrts);
    75f2:	2013      	movs	r0, #19
    75f4:	f7ff ffb2 	bl	755c <nrf_gpio_cfg_output>
    p_reg->PSEL.RTS = pselrts;
    75f8:	2313      	movs	r3, #19
    75fa:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    75fe:	2315      	movs	r3, #21
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    7600:	68e9      	ldr	r1, [r5, #12]
    7602:	4628      	mov	r0, r5
    7604:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
    7608:	3104      	adds	r1, #4
    760a:	f7ff fe8b 	bl	7324 <uarte_nrfx_configure>
	if (err) {
    760e:	4607      	mov	r7, r0
    7610:	2800      	cmp	r0, #0
    7612:	d136      	bne.n	7682 <uarte_0_init+0xda>
	if (get_dev_config(dev)->ppi_endtx) {
    7614:	686b      	ldr	r3, [r5, #4]
    7616:	799b      	ldrb	r3, [r3, #6]
    7618:	b19b      	cbz	r3, 7642 <uarte_0_init+0x9a>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
    761a:	f106 0012 	add.w	r0, r6, #18
    761e:	f000 fa0b 	bl	7a38 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
    7622:	4b1b      	ldr	r3, [pc, #108]	; (7690 <uarte_0_init+0xe8>)
    7624:	4298      	cmp	r0, r3
    7626:	d12e      	bne.n	7686 <uarte_0_init+0xde>
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    7628:	7cb3      	ldrb	r3, [r6, #18]
    762a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    762e:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
}

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    7632:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
    7636:	2301      	movs	r3, #1
    7638:	7cb2      	ldrb	r2, [r6, #18]
    763a:	4093      	lsls	r3, r2
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
    763c:	4a15      	ldr	r2, [pc, #84]	; (7694 <uarte_0_init+0xec>)
    763e:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    7642:	2308      	movs	r3, #8
    7644:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7648:	2300      	movs	r3, #0
    764a:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
    764e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    7652:	f106 0311 	add.w	r3, r6, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    7656:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    765a:	2301      	movs	r3, #1
    765c:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7660:	6023      	str	r3, [r4, #0]
	if (!get_dev_config(dev)->ppi_endtx) {
    7662:	686b      	ldr	r3, [r5, #4]
    7664:	799b      	ldrb	r3, [r3, #6]
    7666:	b91b      	cbnz	r3, 7670 <uarte_0_init+0xc8>
    p_reg->INTENSET = mask;
    7668:	f44f 7380 	mov.w	r3, #256	; 0x100
    766c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    p_reg->TXD.MAXCNT = length;
    7670:	2300      	movs	r3, #0
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
    7672:	3610      	adds	r6, #16
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    7674:	f8c4 6544 	str.w	r6, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    7678:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    767c:	2301      	movs	r3, #1
    767e:	60a3      	str	r3, [r4, #8]
    7680:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
    7682:	4638      	mov	r0, r7
    7684:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EIO;
    7686:	f06f 0704 	mvn.w	r7, #4
UART_NRF_UARTE_DEVICE(0);
    768a:	e7fa      	b.n	7682 <uarte_0_init+0xda>
    768c:	50842500 	.word	0x50842500
    7690:	0bad0000 	.word	0x0bad0000
    7694:	50017000 	.word	0x50017000

00007698 <nrf53_errata_42>:
    #ifndef NRF53_SERIES
        return false;
    #else
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined(NRF_APPLICATION)
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    7698:	4b06      	ldr	r3, [pc, #24]	; (76b4 <nrf53_errata_42+0x1c>)
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    769a:	681b      	ldr	r3, [r3, #0]
    769c:	2b07      	cmp	r3, #7
    769e:	d107      	bne.n	76b0 <nrf53_errata_42+0x18>
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    76a0:	4b05      	ldr	r3, [pc, #20]	; (76b8 <nrf53_errata_42+0x20>)
    76a2:	681b      	ldr	r3, [r3, #0]
    76a4:	3b02      	subs	r3, #2
    76a6:	2b03      	cmp	r3, #3
    76a8:	d802      	bhi.n	76b0 <nrf53_errata_42+0x18>
    76aa:	4a04      	ldr	r2, [pc, #16]	; (76bc <nrf53_errata_42+0x24>)
    76ac:	5cd0      	ldrb	r0, [r2, r3]
    76ae:	4770      	bx	lr
                            return false;
                    }
                }
            #endif
        #endif
        return false;
    76b0:	2000      	movs	r0, #0
    #endif
}
    76b2:	4770      	bx	lr
    76b4:	00ff0130 	.word	0x00ff0130
    76b8:	00ff0134 	.word	0x00ff0134
    76bc:	00043f06 	.word	0x00043f06

000076c0 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
#if defined(NRF_TRUSTZONE_NONSECURE)
    SystemCoreClock = __SYSTEM_CLOCK_MAX >> (NRF_CLOCK_NS->HFCLKCTRL & (CLOCK_HFCLKCTRL_HCLK_Msk));
#else
    SystemCoreClock = __SYSTEM_CLOCK_MAX >> (NRF_CLOCK_S->HFCLKCTRL & (CLOCK_HFCLKCTRL_HCLK_Msk));
    76c0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    76c4:	f8d3 2558 	ldr.w	r2, [r3, #1368]	; 0x558
    76c8:	4b03      	ldr	r3, [pc, #12]	; (76d8 <SystemCoreClockUpdate+0x18>)
    76ca:	f002 0203 	and.w	r2, r2, #3
    76ce:	40d3      	lsrs	r3, r2
    76d0:	4a02      	ldr	r2, [pc, #8]	; (76dc <SystemCoreClockUpdate+0x1c>)
    76d2:	6013      	str	r3, [r2, #0]
#endif
}
    76d4:	4770      	bx	lr
    76d6:	bf00      	nop
    76d8:	07a12000 	.word	0x07a12000
    76dc:	2000047c 	.word	0x2000047c

000076e0 <SystemInit>:

void SystemInit(void)
{
    76e0:	b508      	push	{r3, lr}
          SAU->CTRL |= (1 << SAU_CTRL_ALLNS_Pos);
        #endif

        /* Workaround for Errata 97 "ERASEPROTECT, APPROTECT, or startup problems" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_97())
    76e2:	f7ff ffd9 	bl	7698 <nrf53_errata_42>
    76e6:	b148      	cbz	r0, 76fc <SystemInit+0x1c>
        {
            if (*((volatile uint32_t *)0x50004A20ul) == 0)
    76e8:	4b35      	ldr	r3, [pc, #212]	; (77c0 <SystemInit+0xe0>)
    76ea:	681a      	ldr	r2, [r3, #0]
    76ec:	b932      	cbnz	r2, 76fc <SystemInit+0x1c>
            {
                *((volatile uint32_t *)0x50004A20ul) = 0xDul;
    76ee:	210d      	movs	r1, #13
    76f0:	6019      	str	r1, [r3, #0]
                *((volatile uint32_t *)0x5000491Cul) = 0x1ul;
    76f2:	2101      	movs	r1, #1
    76f4:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
    76f8:	6019      	str	r1, [r3, #0]
                *((volatile uint32_t *)0x5000491Cul) = 0x0ul;
    76fa:	601a      	str	r2, [r3, #0]
{
    76fc:	2200      	movs	r2, #0
    76fe:	00d3      	lsls	r3, r2, #3
    7700:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
        }

        /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim
         until one ADDR is not initialized. */
        uint32_t index = 0;
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
    7704:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    7708:	3101      	adds	r1, #1
    770a:	d007      	beq.n	771c <SystemInit+0x3c>
            #if defined ( __ICCARM__ )
                /* IAR will complain about the order of volatile pointer accesses. */
                #pragma diag_suppress=Pa082
            #endif
            *NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    770c:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
    7710:	3201      	adds	r2, #1
            *NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    7712:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
    7716:	2a20      	cmp	r2, #32
            *NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    7718:	600b      	str	r3, [r1, #0]
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
    771a:	d1f0      	bne.n	76fe <SystemInit+0x1e>
        }

        /* errata 64 must be before errata 42, as errata 42 is dependant on the changes in errata 64*/
        /* Workaround for Errata 64 "VREGMAIN has invalid configuration when CPU is running at 128 MHz" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_64())
    771c:	f7ff ffbc 	bl	7698 <nrf53_errata_42>
    7720:	2800      	cmp	r0, #0
    7722:	d146      	bne.n	77b2 <SystemInit+0xd2>
            *((volatile uint32_t *)0x5000473Cul) = 0x3ul;
        }

        /* Workaround for Errata 42 "Reset value of HFCLKCTRL is invalid" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_42())
    7724:	f7ff ffb8 	bl	7698 <nrf53_errata_42>
    7728:	b138      	cbz	r0, 773a <SystemInit+0x5a>
        {
            *((volatile uint32_t *)0x50039530ul) = 0xBEEF0044ul;
    772a:	4b26      	ldr	r3, [pc, #152]	; (77c4 <SystemInit+0xe4>)
    772c:	4a26      	ldr	r2, [pc, #152]	; (77c8 <SystemInit+0xe8>)
    772e:	601a      	str	r2, [r3, #0]
            NRF_CLOCK_S->HFCLKCTRL = CLOCK_HFCLKCTRL_HCLK_Div2 << CLOCK_HFCLKCTRL_HCLK_Pos;
    7730:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7734:	2201      	movs	r2, #1
    7736:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558
    #ifndef NRF53_SERIES
        return false;
    #else
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined(NRF_APPLICATION)
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    773a:	4b24      	ldr	r3, [pc, #144]	; (77cc <SystemInit+0xec>)
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    773c:	681b      	ldr	r3, [r3, #0]
    773e:	2b07      	cmp	r3, #7

        /* Workaround for Errata 46 "Higher power consumption of LFRC" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_46())
        {
            *((volatile uint32_t *)0x5003254Cul) = 0;
    7740:	bf02      	ittt	eq
    7742:	2200      	moveq	r2, #0
    7744:	4b22      	ldreq	r3, [pc, #136]	; (77d0 <SystemInit+0xf0>)
    7746:	601a      	streq	r2, [r3, #0]
        }

        /* Workaround for Errata 49 "SLEEPENTER and SLEEPEXIT events asserted after pin reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_49())
    7748:	f7ff ffa6 	bl	7698 <nrf53_errata_42>
    774c:	b150      	cbz	r0, 7764 <SystemInit+0x84>
        {
            if (NRF_RESET_S->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
    774e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7752:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    7756:	07d1      	lsls	r1, r2, #31
            {
                NRF_POWER_S->EVENTS_SLEEPENTER = 0;
    7758:	bf42      	ittt	mi
    775a:	2200      	movmi	r2, #0
    775c:	f8c3 2114 	strmi.w	r2, [r3, #276]	; 0x114
                NRF_POWER_S->EVENTS_SLEEPEXIT = 0;
    7760:	f8c3 2118 	strmi.w	r2, [r3, #280]	; 0x118
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    7764:	4b19      	ldr	r3, [pc, #100]	; (77cc <SystemInit+0xec>)
                if (var1 == 0x07)
    7766:	681b      	ldr	r3, [r3, #0]
    7768:	2b07      	cmp	r3, #7
    776a:	d109      	bne.n	7780 <SystemInit+0xa0>

        /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_55())
        {
            if (NRF_RESET_S->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
    776c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7770:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    7774:	07d2      	lsls	r2, r2, #31
                NRF_RESET_S->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
    7776:	bf44      	itt	mi
    7778:	f06f 0201 	mvnmi.w	r2, #1
    777c:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
            }
        }

        /* Workaround for Errata 69 "VREGMAIN configuration is not retained in System OFF" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_69())
    7780:	f7ff ff8a 	bl	7698 <nrf53_errata_42>
    7784:	b110      	cbz	r0, 778c <SystemInit+0xac>
        {
            *((volatile uint32_t *)0x5000470Cul) =0x65ul;
    7786:	2265      	movs	r2, #101	; 0x65
    7788:	4b12      	ldr	r3, [pc, #72]	; (77d4 <SystemInit+0xf4>)
    778a:	601a      	str	r2, [r3, #0]

        #endif

        /* Allow Non-Secure code to run FPU instructions.
         * If only the secure code should control FPU power state these registers should be configured accordingly in the secure application code. */
        SCB->NSACR |= (3UL << 10);
    778c:	4a12      	ldr	r2, [pc, #72]	; (77d8 <SystemInit+0xf8>)
    778e:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    7792:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
    7796:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                /* Do nothing, allow user code to handle APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load APPROTECT soft branch from UICR.
               If UICR->APPROTECT is disabled, CTRLAP->APPROTECT will be disabled. */
            NRF_CTRLAP_S->APPROTECT.DISABLE = NRF_UICR_S->APPROTECT;
    779a:	4a10      	ldr	r2, [pc, #64]	; (77dc <SystemInit+0xfc>)
    779c:	4b10      	ldr	r3, [pc, #64]	; (77e0 <SystemInit+0x100>)
    779e:	6811      	ldr	r1, [r2, #0]
    77a0:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
                /* Do nothing, allow user code to handle SECURE APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load SECURE APPROTECT soft branch from UICR.
               If UICR->SECUREAPPROTECT is disabled, CTRLAP->SECUREAPPROTECT will be disabled. */
            NRF_CTRLAP_S->SECUREAPPROTECT.DISABLE = NRF_UICR_S->SECUREAPPROTECT;
    77a4:	69d2      	ldr	r2, [r2, #28]
    77a6:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c
        __DSB();
        __ISB();
    #endif

    SystemCoreClockUpdate();
}
    77aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SystemCoreClockUpdate();
    77ae:	f7ff bf87 	b.w	76c0 <SystemCoreClockUpdate>
            *((volatile uint32_t *)0x5000470Cul) = 0x29ul;
    77b2:	2229      	movs	r2, #41	; 0x29
    77b4:	4b07      	ldr	r3, [pc, #28]	; (77d4 <SystemInit+0xf4>)
    77b6:	601a      	str	r2, [r3, #0]
            *((volatile uint32_t *)0x5000473Cul) = 0x3ul;
    77b8:	2203      	movs	r2, #3
    77ba:	631a      	str	r2, [r3, #48]	; 0x30
    77bc:	e7b2      	b.n	7724 <SystemInit+0x44>
    77be:	bf00      	nop
    77c0:	50004a20 	.word	0x50004a20
    77c4:	50039530 	.word	0x50039530
    77c8:	beef0044 	.word	0xbeef0044
    77cc:	00ff0130 	.word	0x00ff0130
    77d0:	5003254c 	.word	0x5003254c
    77d4:	5000470c 	.word	0x5000470c
    77d8:	e000ed00 	.word	0xe000ed00
    77dc:	00ff8000 	.word	0x00ff8000
    77e0:	50006000 	.word	0x50006000

000077e4 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    77e4:	4b04      	ldr	r3, [pc, #16]	; (77f8 <nrfx_clock_init+0x14>)
    77e6:	791a      	ldrb	r2, [r3, #4]
    77e8:	b922      	cbnz	r2, 77f4 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
    77ea:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
    77ec:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    77ee:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
    77f0:	4802      	ldr	r0, [pc, #8]	; (77fc <nrfx_clock_init+0x18>)
    77f2:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    77f4:	4802      	ldr	r0, [pc, #8]	; (7800 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    77f6:	4770      	bx	lr
    77f8:	20025bf8 	.word	0x20025bf8
    77fc:	0bad0000 	.word	0x0bad0000
    7800:	0bad000c 	.word	0x0bad000c

00007804 <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    7804:	2803      	cmp	r0, #3
    7806:	d847      	bhi.n	7898 <nrfx_clock_start+0x94>
    7808:	e8df f000 	tbb	[pc, r0]
    780c:	3a2d2202 	.word	0x3a2d2202
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    7810:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    7814:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    7818:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    781c:	03c9      	lsls	r1, r1, #15
    781e:	d511      	bpl.n	7844 <nrfx_clock_start+0x40>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    7820:	f003 0303 	and.w	r3, r3, #3
    7824:	2b02      	cmp	r3, #2
    7826:	d10d      	bne.n	7844 <nrfx_clock_start+0x40>
    p_reg->LFCLKSRC = (uint32_t)(source);
    7828:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    782c:	2200      	movs	r2, #0
    782e:	4b1b      	ldr	r3, [pc, #108]	; (789c <nrfx_clock_start+0x98>)
    7830:	601a      	str	r2, [r3, #0]
    7832:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    7834:	2202      	movs	r2, #2
    7836:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    783a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    783e:	2201      	movs	r2, #1
    7840:	609a      	str	r2, [r3, #8]
}
    7842:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
    7844:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7848:	2201      	movs	r2, #1
    784a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    784e:	e7ed      	b.n	782c <nrfx_clock_start+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7850:	2200      	movs	r2, #0
    7852:	4b13      	ldr	r3, [pc, #76]	; (78a0 <nrfx_clock_start+0x9c>)
    7854:	601a      	str	r2, [r3, #0]
    7856:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    7858:	2201      	movs	r2, #1
    785a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    785e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7862:	601a      	str	r2, [r3, #0]
}
    7864:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7866:	2200      	movs	r2, #0
    7868:	4b0e      	ldr	r3, [pc, #56]	; (78a4 <nrfx_clock_start+0xa0>)
    786a:	601a      	str	r2, [r3, #0]
    786c:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    786e:	f44f 7200 	mov.w	r2, #512	; 0x200
    7872:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7876:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    787a:	2201      	movs	r2, #1
    787c:	621a      	str	r2, [r3, #32]
}
    787e:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7880:	2200      	movs	r2, #0
    7882:	4b09      	ldr	r3, [pc, #36]	; (78a8 <nrfx_clock_start+0xa4>)
    7884:	601a      	str	r2, [r3, #0]
    7886:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    7888:	f44f 7280 	mov.w	r2, #256	; 0x100
    788c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7890:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7894:	2201      	movs	r2, #1
    7896:	619a      	str	r2, [r3, #24]
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
    7898:	4770      	bx	lr
    789a:	bf00      	nop
    789c:	50005104 	.word	0x50005104
    78a0:	50005100 	.word	0x50005100
    78a4:	50005124 	.word	0x50005124
    78a8:	50005120 	.word	0x50005120

000078ac <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    78ac:	b570      	push	{r4, r5, r6, lr}
    78ae:	4604      	mov	r4, r0
    78b0:	2803      	cmp	r0, #3
    78b2:	d83e      	bhi.n	7932 <nrfx_clock_stop+0x86>
    78b4:	e8df f000 	tbb	[pc, r0]
    78b8:	4b3e2202 	.word	0x4b3e2202
    p_reg->INTENCLR = mask;
    78bc:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    78c0:	2202      	movs	r2, #2
    78c2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    78c6:	2200      	movs	r2, #0
    78c8:	f503 7382 	add.w	r3, r3, #260	; 0x104
    78cc:	601a      	str	r2, [r3, #0]
    78ce:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    78d0:	4b28      	ldr	r3, [pc, #160]	; (7974 <nrfx_clock_stop+0xc8>)
    78d2:	2201      	movs	r2, #1
    78d4:	f242 7510 	movw	r5, #10000	; 0x2710
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
    78d8:	f04f 2650 	mov.w	r6, #1342197760	; 0x50005000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    78dc:	601a      	str	r2, [r3, #0]
    switch (domain)
    78de:	2c02      	cmp	r4, #2
    78e0:	d042      	beq.n	7968 <nrfx_clock_stop+0xbc>
    78e2:	2c03      	cmp	r4, #3
    78e4:	d043      	beq.n	796e <nrfx_clock_stop+0xc2>
    78e6:	bb24      	cbnz	r4, 7932 <nrfx_clock_stop+0x86>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    78e8:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
                       (clk_src != NRF_CLOCK_HFCLK_HIGH_ACCURACY)), 10000, 1, stopped);
    }
    else
    {
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    78ec:	03db      	lsls	r3, r3, #15
    78ee:	d520      	bpl.n	7932 <nrfx_clock_stop+0x86>
    78f0:	2001      	movs	r0, #1
    78f2:	f00d fd12 	bl	1531a <nrfx_busy_wait>
    78f6:	3d01      	subs	r5, #1
    78f8:	d1f1      	bne.n	78de <nrfx_clock_stop+0x32>
    78fa:	e01a      	b.n	7932 <nrfx_clock_stop+0x86>
    p_reg->INTENCLR = mask;
    78fc:	2301      	movs	r3, #1
    78fe:	f04f 2450 	mov.w	r4, #1342197760	; 0x50005000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7902:	2100      	movs	r1, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7904:	f242 7510 	movw	r5, #10000	; 0x2710
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7908:	4a1b      	ldr	r2, [pc, #108]	; (7978 <nrfx_clock_stop+0xcc>)
    p_reg->INTENCLR = mask;
    790a:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    790e:	6011      	str	r1, [r2, #0]
    7910:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7912:	4a1a      	ldr	r2, [pc, #104]	; (797c <nrfx_clock_stop+0xd0>)
    7914:	6013      	str	r3, [r2, #0]
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    7916:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    791a:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    791e:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    7922:	03d2      	lsls	r2, r2, #15
    7924:	d505      	bpl.n	7932 <nrfx_clock_stop+0x86>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    7926:	b123      	cbz	r3, 7932 <nrfx_clock_stop+0x86>
    7928:	2001      	movs	r0, #1
    792a:	f00d fcf6 	bl	1531a <nrfx_busy_wait>
    792e:	3d01      	subs	r5, #1
    7930:	d1f1      	bne.n	7916 <nrfx_clock_stop+0x6a>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    7932:	bd70      	pop	{r4, r5, r6, pc}
    p_reg->INTENCLR = mask;
    7934:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7938:	f44f 7200 	mov.w	r2, #512	; 0x200
    793c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7940:	2200      	movs	r2, #0
    7942:	f503 7392 	add.w	r3, r3, #292	; 0x124
    7946:	601a      	str	r2, [r3, #0]
    7948:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    794a:	4b0d      	ldr	r3, [pc, #52]	; (7980 <nrfx_clock_stop+0xd4>)
    794c:	e7c1      	b.n	78d2 <nrfx_clock_stop+0x26>
    p_reg->INTENCLR = mask;
    794e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7952:	f44f 7280 	mov.w	r2, #256	; 0x100
    7956:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    795a:	2200      	movs	r2, #0
    795c:	f503 7390 	add.w	r3, r3, #288	; 0x120
    7960:	601a      	str	r2, [r3, #0]
    7962:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7964:	4b07      	ldr	r3, [pc, #28]	; (7984 <nrfx_clock_stop+0xd8>)
    7966:	e7b4      	b.n	78d2 <nrfx_clock_stop+0x26>
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
    7968:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
    796c:	e7be      	b.n	78ec <nrfx_clock_stop+0x40>
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
    796e:	f8d6 3454 	ldr.w	r3, [r6, #1108]	; 0x454
    7972:	e7bb      	b.n	78ec <nrfx_clock_stop+0x40>
    7974:	5000500c 	.word	0x5000500c
    7978:	50005100 	.word	0x50005100
    797c:	50005004 	.word	0x50005004
    7980:	50005024 	.word	0x50005024
    7984:	5000501c 	.word	0x5000501c

00007988 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    7988:	4b26      	ldr	r3, [pc, #152]	; (7a24 <nrfx_power_clock_irq_handler+0x9c>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    798a:	b510      	push	{r4, lr}
    798c:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    798e:	b152      	cbz	r2, 79a6 <nrfx_power_clock_irq_handler+0x1e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7990:	2000      	movs	r0, #0
    7992:	6018      	str	r0, [r3, #0]
    7994:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    7996:	2201      	movs	r2, #1
    7998:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    799c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    79a0:	4b21      	ldr	r3, [pc, #132]	; (7a28 <nrfx_power_clock_irq_handler+0xa0>)
    79a2:	681b      	ldr	r3, [r3, #0]
    79a4:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    79a6:	4b21      	ldr	r3, [pc, #132]	; (7a2c <nrfx_power_clock_irq_handler+0xa4>)
    79a8:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    79aa:	b18a      	cbz	r2, 79d0 <nrfx_power_clock_irq_handler+0x48>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    79ac:	2200      	movs	r2, #0
    79ae:	601a      	str	r2, [r3, #0]
    79b0:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    79b2:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    79b6:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    79ba:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    79be:	f002 0203 	and.w	r2, r2, #3
    79c2:	2a01      	cmp	r2, #1
    79c4:	f04f 0102 	mov.w	r1, #2
    79c8:	d124      	bne.n	7a14 <nrfx_power_clock_irq_handler+0x8c>
    p_reg->LFCLKSRC = (uint32_t)(source);
    79ca:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    79ce:	609a      	str	r2, [r3, #8]
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    79d0:	4b17      	ldr	r3, [pc, #92]	; (7a30 <nrfx_power_clock_irq_handler+0xa8>)
    79d2:	681a      	ldr	r2, [r3, #0]
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_CAL_DONE);
    }
#endif // NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)

#if NRF_CLOCK_HAS_HFCLKAUDIO
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED))
    79d4:	b162      	cbz	r2, 79f0 <nrfx_power_clock_irq_handler+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    79d6:	2200      	movs	r2, #0
    79d8:	601a      	str	r2, [r3, #0]
    79da:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    79dc:	f44f 7280 	mov.w	r2, #256	; 0x100
    79e0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    79e4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLKAUDIO_STARTED);
    79e8:	4b0f      	ldr	r3, [pc, #60]	; (7a28 <nrfx_power_clock_irq_handler+0xa0>)
    79ea:	2004      	movs	r0, #4
    79ec:	681b      	ldr	r3, [r3, #0]
    79ee:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    79f0:	4b10      	ldr	r3, [pc, #64]	; (7a34 <nrfx_power_clock_irq_handler+0xac>)
    79f2:	681a      	ldr	r2, [r3, #0]
    }
#endif

#if NRF_CLOCK_HAS_HFCLK192M
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED))
    79f4:	b1aa      	cbz	r2, 7a22 <nrfx_power_clock_irq_handler+0x9a>
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    79f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    79fa:	2200      	movs	r2, #0
    79fc:	601a      	str	r2, [r3, #0]
    79fe:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    7a00:	f44f 7200 	mov.w	r2, #512	; 0x200
    7a04:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    7a08:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    7a0c:	4b06      	ldr	r3, [pc, #24]	; (7a28 <nrfx_power_clock_irq_handler+0xa0>)
    7a0e:	2005      	movs	r0, #5
    7a10:	681b      	ldr	r3, [r3, #0]
    7a12:	4718      	bx	r3
    7a14:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    7a18:	4b03      	ldr	r3, [pc, #12]	; (7a28 <nrfx_power_clock_irq_handler+0xa0>)
    7a1a:	2001      	movs	r0, #1
    7a1c:	681b      	ldr	r3, [r3, #0]
    7a1e:	4798      	blx	r3
    7a20:	e7d6      	b.n	79d0 <nrfx_power_clock_irq_handler+0x48>
}
    7a22:	bd10      	pop	{r4, pc}
    7a24:	50005100 	.word	0x50005100
    7a28:	20025bf8 	.word	0x20025bf8
    7a2c:	50005104 	.word	0x50005104
    7a30:	50005120 	.word	0x50005120
    7a34:	50005124 	.word	0x50005124

00007a38 <nrfx_dppi_channel_alloc>:
nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
    nrfx_err_t err_code;

    // Get mask of available DPPI channels
    uint32_t remaining_channels = DPPI_AVAILABLE_CHANNELS_MASK & ~(m_allocated_channels);
    7a38:	4a0a      	ldr	r2, [pc, #40]	; (7a64 <nrfx_dppi_channel_alloc+0x2c>)
{
    7a3a:	b570      	push	{r4, r5, r6, lr}
    uint32_t remaining_channels = DPPI_AVAILABLE_CHANNELS_MASK & ~(m_allocated_channels);
    7a3c:	6814      	ldr	r4, [r2, #0]
    uint8_t channel = 0;

    if (!remaining_channels)
    7a3e:	43e6      	mvns	r6, r4
    7a40:	d00e      	beq.n	7a60 <nrfx_dppi_channel_alloc+0x28>
    7a42:	2300      	movs	r3, #0
    7a44:	b2d9      	uxtb	r1, r3
        NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }

    // Find first free channel
    while (!(remaining_channels & DPPI_BIT_SET(channel)))
    7a46:	fa26 f501 	lsr.w	r5, r6, r1
    7a4a:	07ed      	lsls	r5, r5, #31
    7a4c:	f103 0301 	add.w	r3, r3, #1
    7a50:	d5f8      	bpl.n	7a44 <nrfx_dppi_channel_alloc+0xc>
    {
        channel++;
    }

    m_allocated_channels |= DPPI_BIT_SET(channel);
    7a52:	2301      	movs	r3, #1
    7a54:	408b      	lsls	r3, r1
    7a56:	4323      	orrs	r3, r4
    *p_channel = channel;
    7a58:	7001      	strb	r1, [r0, #0]

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Allocated channel: %d.", channel);
    return err_code;
    7a5a:	4803      	ldr	r0, [pc, #12]	; (7a68 <nrfx_dppi_channel_alloc+0x30>)
    m_allocated_channels |= DPPI_BIT_SET(channel);
    7a5c:	6013      	str	r3, [r2, #0]
}
    7a5e:	bd70      	pop	{r4, r5, r6, pc}
        return err_code;
    7a60:	4802      	ldr	r0, [pc, #8]	; (7a6c <nrfx_dppi_channel_alloc+0x34>)
    7a62:	e7fc      	b.n	7a5e <nrfx_dppi_channel_alloc+0x26>
    7a64:	20025c00 	.word	0x20025c00
    7a68:	0bad0000 	.word	0x0bad0000
    7a6c:	0bad0002 	.word	0x0bad0002

00007a70 <nrfx_gpiote_channel_free>:
    return m_cb.allocated_channels_mask & (1UL << index);
}

static bool is_app_channel(uint8_t index)
{
    return NRFX_GPIOTE_APP_CHANNELS_MASK & (1UL << index);
    7a70:	2301      	movs	r3, #1
    7a72:	fa03 f000 	lsl.w	r0, r3, r0

nrfx_err_t nrfx_gpiote_channel_free(uint8_t channel)
{
    nrfx_err_t err_code = NRFX_SUCCESS;

    if (!is_app_channel(channel))
    7a76:	f010 0fff 	tst.w	r0, #255	; 0xff
    7a7a:	d012      	beq.n	7aa2 <nrfx_gpiote_channel_free+0x32>
	__asm__ volatile(
    7a7c:	f04f 0320 	mov.w	r3, #32
    7a80:	f3ef 8111 	mrs	r1, BASEPRI
    7a84:	f383 8811 	msr	BASEPRI, r3
    7a88:	f3bf 8f6f 	isb	sy
    m_cb.allocated_channels_mask &= ~(1UL << index);
    7a8c:	4a06      	ldr	r2, [pc, #24]	; (7aa8 <nrfx_gpiote_channel_free+0x38>)
    7a8e:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    7a90:	ea23 0000 	bic.w	r0, r3, r0
    7a94:	65d0      	str	r0, [r2, #92]	; 0x5c
	__asm__ volatile(
    7a96:	f381 8811 	msr	BASEPRI, r1
    7a9a:	f3bf 8f6f 	isb	sy
    7a9e:	4803      	ldr	r0, [pc, #12]	; (7aac <nrfx_gpiote_channel_free+0x3c>)
    7aa0:	4770      	bx	lr
    {
        err_code = NRFX_ERROR_INVALID_PARAM;
    7aa2:	4803      	ldr	r0, [pc, #12]	; (7ab0 <nrfx_gpiote_channel_free+0x40>)
        NRFX_CRITICAL_SECTION_EXIT();
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    7aa4:	4770      	bx	lr
    7aa6:	bf00      	nop
    7aa8:	20025c04 	.word	0x20025c04
    7aac:	0bad0000 	.word	0x0bad0000
    7ab0:	0bad0004 	.word	0x0bad0004

00007ab4 <nrfx_gpiote_channel_alloc>:

nrfx_err_t nrfx_gpiote_channel_alloc(uint8_t * p_channel)
{
    7ab4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    uint32_t mask = NRFX_GPIOTE_APP_CHANNELS_MASK;
    7ab8:	22ff      	movs	r2, #255	; 0xff
{
    7aba:	2400      	movs	r4, #0
    return m_cb.allocated_channels_mask & (1UL << index);
    7abc:	2601      	movs	r6, #1
{
    7abe:	4605      	mov	r5, r0
    return m_cb.allocated_channels_mask & (1UL << index);
    7ac0:	f8df e058 	ldr.w	lr, [pc, #88]	; 7b1c <nrfx_gpiote_channel_alloc+0x68>
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    7ac4:	4814      	ldr	r0, [pc, #80]	; (7b18 <nrfx_gpiote_channel_alloc+0x64>)
        NRFX_CRITICAL_SECTION_ENTER();
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
        {
            channel_allocated_set(ch_idx);
            *p_channel = ch_idx;
            err_code = NRFX_SUCCESS;
    7ac6:	f8df 8058 	ldr.w	r8, [pc, #88]	; 7b20 <nrfx_gpiote_channel_alloc+0x6c>
    7aca:	b2e3      	uxtb	r3, r4
	__asm__ volatile(
    7acc:	f04f 0120 	mov.w	r1, #32
    7ad0:	f3ef 8c11 	mrs	ip, BASEPRI
    7ad4:	f381 8811 	msr	BASEPRI, r1
    7ad8:	f3bf 8f6f 	isb	sy
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
    7adc:	fa22 f103 	lsr.w	r1, r2, r3
    7ae0:	07c9      	lsls	r1, r1, #31
    7ae2:	d50a      	bpl.n	7afa <nrfx_gpiote_channel_alloc+0x46>
    return m_cb.allocated_channels_mask & (1UL << index);
    7ae4:	f8de 105c 	ldr.w	r1, [lr, #92]	; 0x5c
    7ae8:	fa06 f703 	lsl.w	r7, r6, r3
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
    7aec:	4239      	tst	r1, r7
            err_code = NRFX_SUCCESS;
    7aee:	bf01      	itttt	eq
    7af0:	4640      	moveq	r0, r8
    m_cb.allocated_channels_mask |= (1UL << index);
    7af2:	4339      	orreq	r1, r7
    7af4:	f8ce 105c 	streq.w	r1, [lr, #92]	; 0x5c
            *p_channel = ch_idx;
    7af8:	702b      	strbeq	r3, [r5, #0]
	__asm__ volatile(
    7afa:	f38c 8811 	msr	BASEPRI, ip
    7afe:	f3bf 8f6f 	isb	sy
        }
        NRFX_CRITICAL_SECTION_EXIT();

        if (err_code == NRFX_SUCCESS)
    7b02:	4540      	cmp	r0, r8
    7b04:	d005      	beq.n	7b12 <nrfx_gpiote_channel_alloc+0x5e>
        {
            NRFX_LOG_INFO("Allocated channel: %d.", ch_idx);
            break;
        }

        mask &= ~(1UL << ch_idx);
    7b06:	fa06 f303 	lsl.w	r3, r6, r3
    for (uint8_t ch_idx = 0; mask != 0; ch_idx++)
    7b0a:	439a      	bics	r2, r3
    7b0c:	f104 0401 	add.w	r4, r4, #1
    7b10:	d1db      	bne.n	7aca <nrfx_gpiote_channel_alloc+0x16>
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    7b12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7b16:	bf00      	nop
    7b18:	0bad0002 	.word	0x0bad0002
    7b1c:	20025c04 	.word	0x20025c04
    7b20:	0bad0000 	.word	0x0bad0000

00007b24 <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
    7b24:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    7b26:	4c08      	ldr	r4, [pc, #32]	; (7b48 <nrfx_ipc_init+0x24>)
{
    7b28:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    7b2a:	7923      	ldrb	r3, [r4, #4]
{
    7b2c:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    7b2e:	b943      	cbnz	r3, 7b42 <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
    7b30:	202a      	movs	r0, #42	; 0x2a
    7b32:	f7fa fe33 	bl	279c <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
    7b36:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
    7b38:	4804      	ldr	r0, [pc, #16]	; (7b4c <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
    7b3a:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
    7b3c:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
    7b3e:	60a5      	str	r5, [r4, #8]
}
    7b40:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
    7b42:	4803      	ldr	r0, [pc, #12]	; (7b50 <nrfx_ipc_init+0x2c>)
    7b44:	e7fc      	b.n	7b40 <nrfx_ipc_init+0x1c>
    7b46:	bf00      	nop
    7b48:	20025c64 	.word	0x20025c64
    7b4c:	0bad0000 	.word	0x0bad0000
    7b50:	0bad000c 	.word	0x0bad000c

00007b54 <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
    7b54:	2300      	movs	r3, #0
{
    7b56:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
    7b58:	4a0d      	ldr	r2, [pc, #52]	; (7b90 <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
    7b5a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    7b5e:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
    7b62:	3301      	adds	r3, #1
    7b64:	2b10      	cmp	r3, #16
    7b66:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
    7b6a:	d1f6      	bne.n	7b5a <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
    7b6c:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
    7b6e:	4a08      	ldr	r2, [pc, #32]	; (7b90 <nrfx_ipc_config_load+0x3c>)
    7b70:	f100 0140 	add.w	r1, r0, #64	; 0x40
    7b74:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
    7b78:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
    7b7c:	3301      	adds	r3, #1
    7b7e:	2b10      	cmp	r3, #16
    7b80:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
    7b84:	d1f6      	bne.n	7b74 <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
    7b86:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    p_reg->INTENSET = mask;
    7b8a:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
    7b8e:	bd30      	pop	{r4, r5, pc}
    7b90:	5002a000 	.word	0x5002a000

00007b94 <nrfx_ipc_receive_event_enable>:
}

void nrfx_ipc_receive_event_enable(uint8_t event_index)
{
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);
    nrf_ipc_int_enable(NRF_IPC, (1UL << event_index));
    7b94:	2301      	movs	r3, #1
    7b96:	4a02      	ldr	r2, [pc, #8]	; (7ba0 <nrfx_ipc_receive_event_enable+0xc>)
    7b98:	4083      	lsls	r3, r0
    7b9a:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
    7b9e:	4770      	bx	lr
    7ba0:	5002a000 	.word	0x5002a000

00007ba4 <nrfx_ipc_receive_event_disable>:

void nrfx_ipc_receive_event_disable(uint8_t event_index)
{
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);
    nrf_ipc_int_disable(NRF_IPC, (1UL << event_index));
    7ba4:	2301      	movs	r3, #1
    p_reg->INTENCLR = mask;
    7ba6:	4a02      	ldr	r2, [pc, #8]	; (7bb0 <nrfx_ipc_receive_event_disable+0xc>)
    7ba8:	4083      	lsls	r3, r0
    7baa:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
    7bae:	4770      	bx	lr
    7bb0:	5002a000 	.word	0x5002a000

00007bb4 <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
    7bb4:	4b0c      	ldr	r3, [pc, #48]	; (7be8 <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
    7bb6:	b430      	push	{r4, r5}
    7bb8:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = __CLZ(__RBIT(bitmask));
        bitmask &= ~(1UL << event_idx);
    7bbc:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
    7bbe:	4602      	mov	r2, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7bc0:	2500      	movs	r5, #0
    while (bitmask)
    7bc2:	b922      	cbnz	r2, 7bce <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
    7bc4:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
    7bc6:	4b09      	ldr	r3, [pc, #36]	; (7bec <nrfx_ipc_irq_handler+0x38>)
    7bc8:	681a      	ldr	r2, [r3, #0]
    7bca:	6899      	ldr	r1, [r3, #8]
    7bcc:	4710      	bx	r2
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
    7bce:	fa92 f3a2 	rbit	r3, r2
  return __builtin_clz(value);
    7bd2:	fab3 f383 	clz	r3, r3
        bitmask &= ~(1UL << event_idx);
    7bd6:	fa04 f103 	lsl.w	r1, r4, r3
    7bda:	ea22 0201 	bic.w	r2, r2, r1
    7bde:	4904      	ldr	r1, [pc, #16]	; (7bf0 <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
    7be0:	009b      	lsls	r3, r3, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7be2:	50cd      	str	r5, [r1, r3]
}
    7be4:	e7ed      	b.n	7bc2 <nrfx_ipc_irq_handler+0xe>
    7be6:	bf00      	nop
    7be8:	5002a000 	.word	0x5002a000
    7bec:	20025c64 	.word	0x20025c64
    7bf0:	5002a100 	.word	0x5002a100

00007bf4 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
    7bf4:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
    7bf6:	f003 021f 	and.w	r2, r3, #31
    7bfa:	6002      	str	r2, [r0, #0]
}
    7bfc:	4a03      	ldr	r2, [pc, #12]	; (7c0c <nrf_gpio_pin_port_decode+0x18>)
    7bfe:	4804      	ldr	r0, [pc, #16]	; (7c10 <nrf_gpio_pin_port_decode+0x1c>)
    return pin_number >> 5;
    7c00:	095b      	lsrs	r3, r3, #5
}
    7c02:	2b01      	cmp	r3, #1
    7c04:	bf08      	it	eq
    7c06:	4610      	moveq	r0, r2
    7c08:	4770      	bx	lr
    7c0a:	bf00      	nop
    7c0c:	50842800 	.word	0x50842800
    7c10:	50842500 	.word	0x50842500

00007c14 <nrfx_spim_init>:

nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
                          nrfx_spim_config_t const * p_config,
                          nrfx_spim_evt_handler_t    handler,
                          void *                     p_context)
{
    7c14:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    7c18:	4680      	mov	r8, r0
    NRFX_ASSERT(p_config);
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    7c1a:	7904      	ldrb	r4, [r0, #4]
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    7c1c:	2024      	movs	r0, #36	; 0x24
    7c1e:	4d52      	ldr	r5, [pc, #328]	; (7d68 <nrfx_spim_init+0x154>)
    7c20:	fb00 5004 	mla	r0, r0, r4, r5
    7c24:	7f00      	ldrb	r0, [r0, #28]
    7c26:	2800      	cmp	r0, #0
    7c28:	f040 8099 	bne.w	7d5e <nrfx_spim_init+0x14a>
        return err_code;
    }

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // Check if SPIM instance supports the extended features.
    if (
    7c2c:	2c00      	cmp	r4, #0
    7c2e:	f040 8098 	bne.w	7d62 <nrfx_spim_init+0x14e>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif

    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    7c32:	f8d8 4000 	ldr.w	r4, [r8]
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
    p_cb->p_context = p_context;
    7c36:	e9c5 2300 	strd	r2, r3, [r5]
    // Configure pins used by the peripheral:
    // - SCK - output with initial value corresponding with the SPI mode used:
    //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
    //   according to the reference manual guidelines this pin and its input
    //   buffer must always be connected for the SPI to work.
    if (p_config->mode <= NRF_SPIM_MODE_1)
    7c3a:	7b0b      	ldrb	r3, [r1, #12]
    7c3c:	7808      	ldrb	r0, [r1, #0]
    7c3e:	2b01      	cmp	r3, #1
    7c40:	d87b      	bhi.n	7d3a <nrfx_spim_init+0x126>
    {
        nrf_gpio_pin_clear(p_config->sck_pin);
    7c42:	f00d fb95 	bl	15370 <nrf_gpio_pin_clear>
    }
    else
    {
        nrf_gpio_pin_set(p_config->sck_pin);
    }
    nrf_gpio_cfg(p_config->sck_pin,
    7c46:	780b      	ldrb	r3, [r1, #0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    7c48:	a801      	add	r0, sp, #4
    7c4a:	9301      	str	r3, [sp, #4]
    7c4c:	f7ff ffd2 	bl	7bf4 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    7c50:	2201      	movs	r2, #1
    7c52:	9b01      	ldr	r3, [sp, #4]
    7c54:	3380      	adds	r3, #128	; 0x80
    7c56:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
                 NRF_GPIO_PIN_INPUT_CONNECT,
                 NRF_GPIO_PIN_NOPULL,
                 NRF_GPIO_PIN_S0S1,
                 NRF_GPIO_PIN_NOSENSE);
    // - MOSI (optional) - output with initial value 0,
    if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
    7c5a:	784e      	ldrb	r6, [r1, #1]
    7c5c:	2eff      	cmp	r6, #255	; 0xff
    7c5e:	d06f      	beq.n	7d40 <nrfx_spim_init+0x12c>
    {
        mosi_pin = p_config->mosi_pin;
        nrf_gpio_pin_clear(mosi_pin);
    7c60:	4630      	mov	r0, r6
    7c62:	f00d fb85 	bl	15370 <nrf_gpio_pin_clear>
        nrf_gpio_cfg_output(mosi_pin);
    7c66:	4630      	mov	r0, r6
    7c68:	f00d fb69 	bl	1533e <nrf_gpio_cfg_output>
    else
    {
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    }
    // - MISO (optional) - input,
    if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
    7c6c:	788f      	ldrb	r7, [r1, #2]
    7c6e:	2fff      	cmp	r7, #255	; 0xff
    7c70:	d069      	beq.n	7d46 <nrfx_spim_init+0x132>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    7c72:	a801      	add	r0, sp, #4
    {
        miso_pin = p_config->miso_pin;
        nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
    7c74:	f891 900e 	ldrb.w	r9, [r1, #14]
    nrf_gpio_cfg(
    7c78:	9701      	str	r7, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    7c7a:	f7ff ffbb 	bl	7bf4 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    7c7e:	9b01      	ldr	r3, [sp, #4]
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
    7c80:	ea4f 0289 	mov.w	r2, r9, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    7c84:	3380      	adds	r3, #128	; 0x80
    7c86:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    }
    // - Slave Select (optional) - output with initial value 1 (inactive).

    // 'p_cb->ss_pin' variable is used during transfers to check if SS pin should be toggled,
    // so this field needs to be initialized even if the pin is not used.
    p_cb->ss_pin = p_config->ss_pin;
    7c8a:	78c8      	ldrb	r0, [r1, #3]

    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    7c8c:	28ff      	cmp	r0, #255	; 0xff
    p_cb->ss_pin = p_config->ss_pin;
    7c8e:	f885 0020 	strb.w	r0, [r5, #32]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    7c92:	d015      	beq.n	7cc0 <nrfx_spim_init+0xac>
    {
        if (p_config->ss_active_high)
    7c94:	790b      	ldrb	r3, [r1, #4]
    7c96:	2b00      	cmp	r3, #0
    7c98:	d058      	beq.n	7d4c <nrfx_spim_init+0x138>
        {
            nrf_gpio_pin_clear(p_config->ss_pin);
    7c9a:	f00d fb69 	bl	15370 <nrf_gpio_pin_clear>
        }
        else
        {
            nrf_gpio_pin_set(p_config->ss_pin);
        }
        nrf_gpio_cfg_output(p_config->ss_pin);
    7c9e:	78c8      	ldrb	r0, [r1, #3]
    7ca0:	f00d fb4d 	bl	1533e <nrf_gpio_cfg_output>
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (p_config->use_hw_ss)
    7ca4:	7c4a      	ldrb	r2, [r1, #17]
    7ca6:	790b      	ldrb	r3, [r1, #4]
    7ca8:	b14a      	cbz	r2, 7cbe <nrfx_spim_init+0xaa>
        {
            p_cb->use_hw_ss = p_config->use_hw_ss;
    7caa:	2201      	movs	r2, #1
    7cac:	77aa      	strb	r2, [r5, #30]
            nrf_spim_csn_configure(p_spim,
    7cae:	78c8      	ldrb	r0, [r1, #3]
    7cb0:	7c8a      	ldrb	r2, [r1, #18]
    p_reg->PSEL.CSN = pin;
    7cb2:	f8c4 0514 	str.w	r0, [r4, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
    7cb6:	f8c4 3568 	str.w	r3, [r4, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
    7cba:	f8c4 2564 	str.w	r2, [r4, #1380]	; 0x564
                                   (p_config->ss_active_high == true ?
                                        NRF_SPIM_CSN_POL_HIGH : NRF_SPIM_CSN_POL_LOW),
                                   p_config->ss_duration);
        }
#endif
        p_cb->ss_active_high = p_config->ss_active_high;
    7cbe:	77eb      	strb	r3, [r5, #31]
    }

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // - DCX (optional) - output.
    if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
    7cc0:	7bc8      	ldrb	r0, [r1, #15]
    7cc2:	28ff      	cmp	r0, #255	; 0xff
    7cc4:	d007      	beq.n	7cd6 <nrfx_spim_init+0xc2>
    {
        nrf_gpio_pin_set(p_config->dcx_pin);
    7cc6:	f00d fb47 	bl	15358 <nrf_gpio_pin_set>
        nrf_gpio_cfg_output(p_config->dcx_pin);
    7cca:	7bc8      	ldrb	r0, [r1, #15]
    7ccc:	f00d fb37 	bl	1533e <nrf_gpio_cfg_output>
        nrf_spim_dcx_pin_set(p_spim, p_config->dcx_pin);
    7cd0:	7bcb      	ldrb	r3, [r1, #15]
    p_reg->PSELDCX = dcx_pin;
    7cd2:	f8c4 356c 	str.w	r3, [r4, #1388]	; 0x56c
    }

    // Change rx delay
    nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
    7cd6:	7c0b      	ldrb	r3, [r1, #16]
    p_reg->IFTIMING.RXDELAY = rxdelay;
    7cd8:	f8c4 3560 	str.w	r3, [r4, #1376]	; 0x560
#endif


    nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
    7cdc:	780b      	ldrb	r3, [r1, #0]
    p_reg->PSEL.SCK  = sck_pin;
    7cde:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->FREQUENCY = (uint32_t)frequency;
    7ce2:	688b      	ldr	r3, [r1, #8]
    p_reg->PSEL.MOSI = mosi_pin;
    7ce4:	f8c4 650c 	str.w	r6, [r4, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
    7ce8:	f8c4 7510 	str.w	r7, [r4, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
    7cec:	f8c4 3524 	str.w	r3, [r4, #1316]	; 0x524
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    7cf0:	7b4b      	ldrb	r3, [r1, #13]
    nrf_spim_frequency_set(p_spim, p_config->frequency);
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
    7cf2:	7b0a      	ldrb	r2, [r1, #12]
    7cf4:	3b00      	subs	r3, #0
    7cf6:	bf18      	it	ne
    7cf8:	2301      	movne	r3, #1
    switch (spi_mode)
    7cfa:	2a02      	cmp	r2, #2
    7cfc:	d029      	beq.n	7d52 <nrfx_spim_init+0x13e>
    7cfe:	2a03      	cmp	r2, #3
    7d00:	d02a      	beq.n	7d58 <nrfx_spim_init+0x144>
    7d02:	2a01      	cmp	r2, #1
    7d04:	d101      	bne.n	7d0a <nrfx_spim_init+0xf6>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
    7d06:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
    7d0a:	f8c4 3554 	str.w	r3, [r4, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
    7d0e:	798b      	ldrb	r3, [r1, #6]
    7d10:	f8c4 35c0 	str.w	r3, [r4, #1472]	; 0x5c0
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
    7d14:	2307      	movs	r3, #7
    7d16:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500

    nrf_spim_orc_set(p_spim, p_config->orc);

    nrf_spim_enable(p_spim);

    if (p_cb->handler)
    7d1a:	682b      	ldr	r3, [r5, #0]
    7d1c:	b12b      	cbz	r3, 7d2a <nrfx_spim_init+0x116>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
    7d1e:	f8d8 0000 	ldr.w	r0, [r8]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
    7d22:	f340 3007 	sbfx	r0, r0, #12, #8
    7d26:	f7fa fd39 	bl	279c <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
    7d2a:	2300      	movs	r3, #0
    7d2c:	776b      	strb	r3, [r5, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    7d2e:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    7d30:	480e      	ldr	r0, [pc, #56]	; (7d6c <nrfx_spim_init+0x158>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    7d32:	772b      	strb	r3, [r5, #28]
}
    7d34:	b003      	add	sp, #12
    7d36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        nrf_gpio_pin_set(p_config->sck_pin);
    7d3a:	f00d fb0d 	bl	15358 <nrf_gpio_pin_set>
    7d3e:	e782      	b.n	7c46 <nrfx_spim_init+0x32>
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    7d40:	f04f 36ff 	mov.w	r6, #4294967295
    7d44:	e792      	b.n	7c6c <nrfx_spim_init+0x58>
        miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    7d46:	f04f 37ff 	mov.w	r7, #4294967295
    7d4a:	e79e      	b.n	7c8a <nrfx_spim_init+0x76>
            nrf_gpio_pin_set(p_config->ss_pin);
    7d4c:	f00d fb04 	bl	15358 <nrf_gpio_pin_set>
    7d50:	e7a5      	b.n	7c9e <nrfx_spim_init+0x8a>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    7d52:	f043 0304 	orr.w	r3, r3, #4
        break;
    7d56:	e7d8      	b.n	7d0a <nrfx_spim_init+0xf6>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    7d58:	f043 0306 	orr.w	r3, r3, #6
        break;
    7d5c:	e7d5      	b.n	7d0a <nrfx_spim_init+0xf6>
        return err_code;
    7d5e:	4804      	ldr	r0, [pc, #16]	; (7d70 <nrfx_spim_init+0x15c>)
    7d60:	e7e8      	b.n	7d34 <nrfx_spim_init+0x120>
        return err_code;
    7d62:	4804      	ldr	r0, [pc, #16]	; (7d74 <nrfx_spim_init+0x160>)
    7d64:	e7e6      	b.n	7d34 <nrfx_spim_init+0x120>
    7d66:	bf00      	nop
    7d68:	20025c70 	.word	0x20025c70
    7d6c:	0bad0000 	.word	0x0bad0000
    7d70:	0bad0005 	.word	0x0bad0005
    7d74:	0bad0003 	.word	0x0bad0003

00007d78 <nrfx_spim_xfer>:
    NRFX_ASSERT(!(flags & NRFX_SPIM_FLAG_HOLD_XFER) ||
                (p_cb->ss_pin == NRFX_SPIM_PIN_NOT_USED));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
    7d78:	2324      	movs	r3, #36	; 0x24
{
    7d7a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    7d7e:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->transfer_in_progress)
    7d80:	4f43      	ldr	r7, [pc, #268]	; (7e90 <nrfx_spim_xfer+0x118>)
    7d82:	4373      	muls	r3, r6
{
    7d84:	4614      	mov	r4, r2
    if (p_cb->transfer_in_progress)
    7d86:	18fa      	adds	r2, r7, r3
{
    7d88:	460d      	mov	r5, r1
    if (p_cb->transfer_in_progress)
    7d8a:	7f51      	ldrb	r1, [r2, #29]
{
    7d8c:	4680      	mov	r8, r0
    if (p_cb->transfer_in_progress)
    7d8e:	2900      	cmp	r1, #0
    7d90:	d17b      	bne.n	7e8a <nrfx_spim_xfer+0x112>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
    7d92:	58fb      	ldr	r3, [r7, r3]
    7d94:	b123      	cbz	r3, 7da0 <nrfx_spim_xfer+0x28>
    7d96:	f014 0f14 	tst.w	r4, #20
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
    7d9a:	bf04      	itt	eq
    7d9c:	2301      	moveq	r3, #1
    7d9e:	7753      	strbeq	r3, [r2, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
    7da0:	f04f 0c24 	mov.w	ip, #36	; 0x24
    7da4:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    7da8:	fb0c 7c06 	mla	ip, ip, r6, r7
    7dac:	f10c 0e0c 	add.w	lr, ip, #12
    7db0:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}

    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    7db4:	f89c 0020 	ldrb.w	r0, [ip, #32]
    7db8:	28ff      	cmp	r0, #255	; 0xff
    7dba:	d007      	beq.n	7dcc <nrfx_spim_xfer+0x54>
    {
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (!p_cb->use_hw_ss)
    7dbc:	f89c 301e 	ldrb.w	r3, [ip, #30]
    7dc0:	b923      	cbnz	r3, 7dcc <nrfx_spim_xfer+0x54>
#endif
        {
            if (p_cb->ss_active_high)
    7dc2:	f89c 301f 	ldrb.w	r3, [ip, #31]
    7dc6:	b1bb      	cbz	r3, 7df8 <nrfx_spim_xfer+0x80>
            {
                nrf_gpio_pin_set(p_cb->ss_pin);
    7dc8:	f00d fac6 	bl	15358 <nrf_gpio_pin_set>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
    7dcc:	6829      	ldr	r1, [r5, #0]
    7dce:	b121      	cbz	r1, 7dda <nrfx_spim_xfer+0x62>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    7dd0:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
    7dd4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    7dd8:	d106      	bne.n	7de8 <nrfx_spim_xfer+0x70>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
    7dda:	68aa      	ldr	r2, [r5, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
    7ddc:	b17a      	cbz	r2, 7dfe <nrfx_spim_xfer+0x86>
    7dde:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
    7de2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    7de6:	d00a      	beq.n	7dfe <nrfx_spim_xfer+0x86>
        p_cb->transfer_in_progress = false;
    7de8:	2324      	movs	r3, #36	; 0x24
    7dea:	fb03 7606 	mla	r6, r3, r6, r7
    7dee:	2300      	movs	r3, #0
        return err_code;
    7df0:	4828      	ldr	r0, [pc, #160]	; (7e94 <nrfx_spim_xfer+0x11c>)
        p_cb->transfer_in_progress = false;
    7df2:	7773      	strb	r3, [r6, #29]
            }
        }
    }

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
}
    7df4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                nrf_gpio_pin_clear(p_cb->ss_pin);
    7df8:	f00d faba 	bl	15370 <nrf_gpio_pin_clear>
    7dfc:	e7e6      	b.n	7dcc <nrfx_spim_xfer+0x54>
    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
    7dfe:	f8d8 3000 	ldr.w	r3, [r8]
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
    7e02:	6868      	ldr	r0, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    7e04:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
    7e08:	68e9      	ldr	r1, [r5, #12]
    p_reg->TXD.MAXCNT = length;
    7e0a:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    7e0e:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7e12:	2200      	movs	r2, #0
    p_reg->RXD.MAXCNT = length;
    7e14:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7e18:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    7e1c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
    7e20:	f014 0201 	ands.w	r2, r4, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
    7e24:	bf18      	it	ne
    7e26:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
    7e28:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
    7e2c:	f014 0202 	ands.w	r2, r4, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
    7e30:	bf18      	it	ne
    7e32:	2201      	movne	r2, #1
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
    7e34:	f014 0108 	ands.w	r1, r4, #8
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
    7e38:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7e3c:	bf04      	itt	eq
    7e3e:	2201      	moveq	r2, #1
    7e40:	611a      	streq	r2, [r3, #16]
    if (!p_cb->handler)
    7e42:	2224      	movs	r2, #36	; 0x24
    7e44:	4372      	muls	r2, r6
    7e46:	58ba      	ldr	r2, [r7, r2]
    7e48:	b9b2      	cbnz	r2, 7e78 <nrfx_spim_xfer+0x100>
        if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
    7e4a:	b919      	cbnz	r1, 7e54 <nrfx_spim_xfer+0xdc>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    7e4c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
            while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
    7e50:	2a00      	cmp	r2, #0
    7e52:	d0fb      	beq.n	7e4c <nrfx_spim_xfer+0xd4>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    7e54:	2324      	movs	r3, #36	; 0x24
    7e56:	fb03 7606 	mla	r6, r3, r6, r7
    7e5a:	f896 0020 	ldrb.w	r0, [r6, #32]
    7e5e:	28ff      	cmp	r0, #255	; 0xff
    7e60:	d005      	beq.n	7e6e <nrfx_spim_xfer+0xf6>
            if (!p_cb->use_hw_ss)
    7e62:	7fb3      	ldrb	r3, [r6, #30]
    7e64:	b91b      	cbnz	r3, 7e6e <nrfx_spim_xfer+0xf6>
                if (p_cb->ss_active_high)
    7e66:	7ff3      	ldrb	r3, [r6, #31]
    7e68:	b11b      	cbz	r3, 7e72 <nrfx_spim_xfer+0xfa>
                    nrf_gpio_pin_clear(p_cb->ss_pin);
    7e6a:	f00d fa81 	bl	15370 <nrf_gpio_pin_clear>
    return err_code;
    7e6e:	480a      	ldr	r0, [pc, #40]	; (7e98 <nrfx_spim_xfer+0x120>)
    7e70:	e7c0      	b.n	7df4 <nrfx_spim_xfer+0x7c>
                    nrf_gpio_pin_set(p_cb->ss_pin);
    7e72:	f00d fa71 	bl	15358 <nrf_gpio_pin_set>
    7e76:	e7fa      	b.n	7e6e <nrfx_spim_xfer+0xf6>
    if (!enable)
    7e78:	2240      	movs	r2, #64	; 0x40
    7e7a:	f014 0f04 	tst.w	r4, #4
    p_reg->INTENCLR = mask;
    7e7e:	bf14      	ite	ne
    7e80:	f8c3 2308 	strne.w	r2, [r3, #776]	; 0x308
    p_reg->INTENSET = mask;
    7e84:	f8c3 2304 	streq.w	r2, [r3, #772]	; 0x304
    7e88:	e7f1      	b.n	7e6e <nrfx_spim_xfer+0xf6>
        return err_code;
    7e8a:	4804      	ldr	r0, [pc, #16]	; (7e9c <nrfx_spim_xfer+0x124>)
    7e8c:	e7b2      	b.n	7df4 <nrfx_spim_xfer+0x7c>
    7e8e:	bf00      	nop
    7e90:	20025c70 	.word	0x20025c70
    7e94:	0bad000a 	.word	0x0bad000a
    7e98:	0bad0000 	.word	0x0bad0000
    7e9c:	0bad000b 	.word	0x0bad000b

00007ea0 <nrfx_spim_4_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    7ea0:	4b10      	ldr	r3, [pc, #64]	; (7ee4 <nrfx_spim_4_irq_handler+0x44>)
}
#endif

#if NRFX_CHECK(NRFX_SPIM4_ENABLED)
void nrfx_spim_4_irq_handler(void)
{
    7ea2:	b510      	push	{r4, lr}
    7ea4:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
    7ea8:	b1da      	cbz	r2, 7ee2 <nrfx_spim_4_irq_handler+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7eaa:	2200      	movs	r2, #0
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    7eac:	490e      	ldr	r1, [pc, #56]	; (7ee8 <nrfx_spim_4_irq_handler+0x48>)
    7eae:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    7eb2:	f891 0020 	ldrb.w	r0, [r1, #32]
    7eb6:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
    7eba:	28ff      	cmp	r0, #255	; 0xff
    7ebc:	d005      	beq.n	7eca <nrfx_spim_4_irq_handler+0x2a>
        if (!p_cb->use_hw_ss)
    7ebe:	7f8b      	ldrb	r3, [r1, #30]
    7ec0:	b91b      	cbnz	r3, 7eca <nrfx_spim_4_irq_handler+0x2a>
            if (p_cb->ss_active_high)
    7ec2:	7fcb      	ldrb	r3, [r1, #31]
    7ec4:	b153      	cbz	r3, 7edc <nrfx_spim_4_irq_handler+0x3c>
                nrf_gpio_pin_clear(p_cb->ss_pin);
    7ec6:	f00d fa53 	bl	15370 <nrf_gpio_pin_clear>
    p_cb->transfer_in_progress = false;
    7eca:	2300      	movs	r3, #0
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
    7ecc:	720b      	strb	r3, [r1, #8]
    p_cb->transfer_in_progress = false;
    7ece:	774b      	strb	r3, [r1, #29]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    7ed0:	4806      	ldr	r0, [pc, #24]	; (7eec <nrfx_spim_4_irq_handler+0x4c>)
    7ed2:	e9d1 3100 	ldrd	r3, r1, [r1]
    irq_handler(NRF_SPIM4, &m_cb[NRFX_SPIM4_INST_IDX]);
}
    7ed6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    7eda:	4718      	bx	r3
                nrf_gpio_pin_set(p_cb->ss_pin);
    7edc:	f00d fa3c 	bl	15358 <nrf_gpio_pin_set>
    7ee0:	e7f3      	b.n	7eca <nrfx_spim_4_irq_handler+0x2a>
}
    7ee2:	bd10      	pop	{r4, pc}
    7ee4:	5000a000 	.word	0x5000a000
    7ee8:	20025c70 	.word	0x20025c70
    7eec:	20025c78 	.word	0x20025c78

00007ef0 <nrfx_twim_init>:
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(p_config->scl != p_config->sda);
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    7ef0:	f04f 0c34 	mov.w	ip, #52	; 0x34
{
    7ef4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    7ef8:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    7efa:	4d25      	ldr	r5, [pc, #148]	; (7f90 <nrfx_twim_init+0xa0>)
    7efc:	fb0c fc06 	mul.w	ip, ip, r6
    7f00:	eb05 040c 	add.w	r4, r5, ip
    7f04:	f894 702d 	ldrb.w	r7, [r4, #45]	; 0x2d
    7f08:	2f00      	cmp	r7, #0
    7f0a:	d13e      	bne.n	7f8a <nrfx_twim_init+0x9a>
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
    p_cb->p_context       = p_context;
    7f0c:	6063      	str	r3, [r4, #4]
    p_cb->int_mask        = 0;
    p_cb->repeated        = false;
    p_cb->busy            = false;
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
    7f0e:	7b4b      	ldrb	r3, [r1, #13]
    p_cb->int_mask        = 0;
    7f10:	60a7      	str	r7, [r4, #8]
    p_cb->repeated        = false;
    7f12:	f884 7030 	strb.w	r7, [r4, #48]	; 0x30
    p_cb->busy            = false;
    7f16:	f884 702f 	strb.w	r7, [r4, #47]	; 0x2f

    /* To secure correct signal levels on the pins used by the TWI
       master when the system is in OFF mode, and when the TWI master is
       disabled, these pins must be configured in the GPIO peripheral.
    */
    TWIM_PIN_INIT(p_config->scl);
    7f1a:	680f      	ldr	r7, [r1, #0]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
    7f1c:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
        case 1: return NRF_P1;
    7f20:	f8df 807c 	ldr.w	r8, [pc, #124]	; 7fa0 <nrfx_twim_init+0xb0>
    7f24:	4b1b      	ldr	r3, [pc, #108]	; (7f94 <nrfx_twim_init+0xa4>)
    return pin_number >> 5;
    7f26:	097c      	lsrs	r4, r7, #5
        case 1: return NRF_P1;
    7f28:	2c01      	cmp	r4, #1
    7f2a:	bf14      	ite	ne
    7f2c:	461c      	movne	r4, r3
    7f2e:	4644      	moveq	r4, r8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    7f30:	f240 6e0c 	movw	lr, #1548	; 0x60c
    p_cb->handler         = event_handler;
    7f34:	f845 200c 	str.w	r2, [r5, ip]
    *p_pin = pin_number & 0x1F;
    7f38:	f007 0c1f 	and.w	ip, r7, #31
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    7f3c:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
    7f40:	f844 e02c 	str.w	lr, [r4, ip, lsl #2]
    TWIM_PIN_INIT(p_config->sda);
    7f44:	684c      	ldr	r4, [r1, #4]

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    7f46:	6800      	ldr	r0, [r0, #0]
    return pin_number >> 5;
    7f48:	ea4f 1954 	mov.w	r9, r4, lsr #5
        case 1: return NRF_P1;
    7f4c:	f1b9 0f01 	cmp.w	r9, #1
    7f50:	bf08      	it	eq
    7f52:	4643      	moveq	r3, r8
    *p_pin = pin_number & 0x1F;
    7f54:	f004 0c1f 	and.w	ip, r4, #31
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    7f58:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
    7f5c:	f843 e02c 	str.w	lr, [r3, ip, lsl #2]
    nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
    nrf_twim_frequency_set(p_twim,
        (nrf_twim_frequency_t)p_config->frequency);
    7f60:	688b      	ldr	r3, [r1, #8]

NRF_STATIC_INLINE void nrf_twim_pins_set(NRF_TWIM_Type * p_reg,
                                         uint32_t scl_pin,
                                         uint32_t sda_pin)
{
    p_reg->PSEL.SCL = scl_pin;
    7f62:	f8c0 7508 	str.w	r7, [r0, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
    7f66:	f8c0 450c 	str.w	r4, [r0, #1292]	; 0x50c
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
    7f6a:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524

    if (p_cb->handler)
    7f6e:	b11a      	cbz	r2, 7f78 <nrfx_twim_init+0x88>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
    7f70:	f340 3007 	sbfx	r0, r0, #12, #8
    7f74:	f7fa fc12 	bl	279c <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    7f78:	2334      	movs	r3, #52	; 0x34
    7f7a:	fb03 5506 	mla	r5, r3, r6, r5
    7f7e:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
    7f80:	4805      	ldr	r0, [pc, #20]	; (7f98 <nrfx_twim_init+0xa8>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    7f82:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
    7f86:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return err_code;
    7f8a:	4804      	ldr	r0, [pc, #16]	; (7f9c <nrfx_twim_init+0xac>)
    7f8c:	e7fb      	b.n	7f86 <nrfx_twim_init+0x96>
    7f8e:	bf00      	nop
    7f90:	20025c94 	.word	0x20025c94
    7f94:	50842500 	.word	0x50842500
    7f98:	0bad0000 	.word	0x0bad0000
    7f9c:	0bad0005 	.word	0x0bad0005
    7fa0:	50842800 	.word	0x50842800

00007fa4 <nrfx_twim_enable>:
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
    7fa4:	2106      	movs	r1, #6
void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);

    nrf_twim_enable(p_instance->p_twim);
    7fa6:	6802      	ldr	r2, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    7fa8:	7903      	ldrb	r3, [r0, #4]
    7faa:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
    7fae:	2134      	movs	r1, #52	; 0x34
    7fb0:	4a03      	ldr	r2, [pc, #12]	; (7fc0 <nrfx_twim_enable+0x1c>)
    7fb2:	fb01 2303 	mla	r3, r1, r3, r2
    7fb6:	2202      	movs	r2, #2
    7fb8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
    7fbc:	4770      	bx	lr
    7fbe:	bf00      	nop
    7fc0:	20025c94 	.word	0x20025c94

00007fc4 <nrfx_twim_disable>:
void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    7fc4:	6802      	ldr	r2, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    7fc6:	7903      	ldrb	r3, [r0, #4]
    p_cb->int_mask = 0;
    7fc8:	2034      	movs	r0, #52	; 0x34
    7fca:	490a      	ldr	r1, [pc, #40]	; (7ff4 <nrfx_twim_disable+0x30>)
    7fcc:	fb00 1303 	mla	r3, r0, r3, r1
    7fd0:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
    7fd2:	4909      	ldr	r1, [pc, #36]	; (7ff8 <nrfx_twim_disable+0x34>)
    7fd4:	6098      	str	r0, [r3, #8]
    7fd6:	f8c2 1308 	str.w	r1, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
    7fda:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
    7fde:	f421 51bc 	bic.w	r1, r1, #6016	; 0x1780
    7fe2:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
    7fe6:	f8c2 0500 	str.w	r0, [r2, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    7fea:	2201      	movs	r2, #1
    7fec:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
    7ff0:	4770      	bx	lr
    7ff2:	bf00      	nop
    7ff4:	20025c94 	.word	0x20025c94
    7ff8:	019c0202 	.word	0x019c0202

00007ffc <nrfx_twim_xfer>:


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
    7ffc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    p_cb->error = false;
    8000:	2634      	movs	r6, #52	; 0x34
    8002:	2300      	movs	r3, #0
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
                                     p_xfer_desc->primary_length,
                                     p_xfer_desc->secondary_length));

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    8004:	f890 e004 	ldrb.w	lr, [r0, #4]
    p_cb->error = false;
    8008:	4fae      	ldr	r7, [pc, #696]	; (82c4 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2c4>)
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
    800a:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
    800c:	fb06 760e 	mla	r6, r6, lr, r7
    8010:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
    8014:	68cb      	ldr	r3, [r1, #12]
{
    8016:	460d      	mov	r5, r1
    8018:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
    if (!nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
    801c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
{
    8020:	4694      	mov	ip, r2
    if (!nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
    8022:	d003      	beq.n	802c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2c>
        return err_code;
    8024:	4ea8      	ldr	r6, [pc, #672]	; (82c8 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2c8>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    8026:	4630      	mov	r0, r6
    8028:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    p_reg->INTENCLR = mask;
    802c:	4ba7      	ldr	r3, [pc, #668]	; (82cc <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2cc>)
    802e:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    if (p_cb->busy)
    8032:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
    8036:	f003 0aff 	and.w	sl, r3, #255	; 0xff
    803a:	b123      	cbz	r3, 8046 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x46>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
    803c:	68b3      	ldr	r3, [r6, #8]
        return err_code;
    803e:	4ea4      	ldr	r6, [pc, #656]	; (82d0 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2d0>)
    p_reg->INTENSET = mask;
    8040:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    8044:	e7ef      	b.n	8026 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x26>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
    8046:	f012 0f14 	tst.w	r2, #20
    804a:	bf0c      	ite	eq
    804c:	2301      	moveq	r3, #1
    804e:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
    8050:	4689      	mov	r9, r1
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
    8052:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
    8056:	f106 080c 	add.w	r8, r6, #12
    805a:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
    805e:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
    8062:	f8d9 3000 	ldr.w	r3, [r9]
    p_cb->flags = flags;
    8066:	f8c6 c020 	str.w	ip, [r6, #32]
    p_cb->xfer_desc = *p_xfer_desc;
    806a:	f8c8 3000 	str.w	r3, [r8]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
    806e:	f3cc 1300 	ubfx	r3, ip, #4, #1
    8072:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
    8076:	786b      	ldrb	r3, [r5, #1]
    8078:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    807c:	f8c4 a104 	str.w	sl, [r4, #260]	; 0x104
    8080:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    8084:	f8c4 a124 	str.w	sl, [r4, #292]	; 0x124
    8088:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
    808c:	f8c4 a160 	str.w	sl, [r4, #352]	; 0x160
    8090:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
    8094:	f8c4 a148 	str.w	sl, [r4, #328]	; 0x148
    8098:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
    809c:	f01c 0301 	ands.w	r3, ip, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
    80a0:	bf18      	it	ne
    80a2:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
    80a4:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
    80a8:	f01c 0302 	ands.w	r3, ip, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
    80ac:	bf18      	it	ne
    80ae:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
    80b0:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
    80b4:	782b      	ldrb	r3, [r5, #0]
    80b6:	2b03      	cmp	r3, #3
    80b8:	f200 80b2 	bhi.w	8220 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x220>
    80bc:	e8df f003 	tbb	[pc, r3]
    80c0:	02669d81 	.word	0x02669d81
    80c4:	692a      	ldr	r2, [r5, #16]
    80c6:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
    80ca:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    80ce:	d1a9      	bne.n	8024 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x24>
    p_reg->SHORTS = mask;
    80d0:	f44f 7380 	mov.w	r3, #256	; 0x100
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    80d4:	68e9      	ldr	r1, [r5, #12]
    p_reg->SHORTS = mask;
    80d6:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
    80da:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    80dc:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    80e0:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    80e4:	2300      	movs	r3, #0
    80e6:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
    80ea:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    80ee:	2101      	movs	r1, #1
    80f0:	6221      	str	r1, [r4, #32]
    80f2:	60a1      	str	r1, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    80f4:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
    80f8:	2900      	cmp	r1, #0
    80fa:	d0fb      	beq.n	80f4 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xf4>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    80fc:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
    8100:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
    8104:	68ab      	ldr	r3, [r5, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    8106:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    810a:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
    810e:	2334      	movs	r3, #52	; 0x34
    8110:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    8114:	fb03 730e 	mla	r3, r3, lr, r7
    8118:	609a      	str	r2, [r3, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
    811a:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
    811c:	4e6d      	ldr	r6, [pc, #436]	; (82d4 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2d4>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
    811e:	f01c 0f08 	tst.w	ip, #8
    8122:	d104      	bne.n	812e <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x12e>
    8124:	782a      	ldrb	r2, [r5, #0]
    8126:	2a03      	cmp	r2, #3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8128:	bf1c      	itt	ne
    812a:	2201      	movne	r2, #1
    812c:	50e2      	strne	r2, [r4, r3]
    if (p_cb->handler)
    812e:	2334      	movs	r3, #52	; 0x34
    8130:	fb03 f30e 	mul.w	r3, r3, lr
    8134:	18fa      	adds	r2, r7, r3
    8136:	58fb      	ldr	r3, [r7, r3]
    8138:	2b00      	cmp	r3, #0
    813a:	d174      	bne.n	8226 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x226>
                transmission_finished = true;
    813c:	2501      	movs	r5, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    813e:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
    8142:	f8d4 1104 	ldr.w	r1, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
    8146:	2900      	cmp	r1, #0
    8148:	f040 8087 	bne.w	825a <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x25a>
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
    814c:	3a00      	subs	r2, #0
    814e:	bf18      	it	ne
    8150:	2201      	movne	r2, #1
    8152:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
    8156:	2900      	cmp	r1, #0
    8158:	f000 8085 	beq.w	8266 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x266>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    815c:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
    8160:	f8d4 1124 	ldr.w	r1, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8164:	f8d4 0160 	ldr.w	r0, [r4, #352]	; 0x160
    return p_reg->SHORTS;
    8168:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
    816c:	b110      	cbz	r0, 8174 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x174>
    816e:	f411 7f00 	tst.w	r1, #512	; 0x200
    8172:	d104      	bne.n	817e <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x17e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8174:	6225      	str	r5, [r4, #32]
    8176:	6165      	str	r5, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
    8178:	2800      	cmp	r0, #0
    817a:	d0e0      	beq.n	813e <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x13e>
                    transmission_finished = false;
    817c:	2200      	movs	r2, #0
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
    817e:	05c9      	lsls	r1, r1, #23
    8180:	d571      	bpl.n	8266 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x266>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8182:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    8186:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
        } while (!transmission_finished);
    818a:	e7d8      	b.n	813e <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x13e>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
    818c:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    818e:	68ea      	ldr	r2, [r5, #12]
    8190:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    8194:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    8198:	692b      	ldr	r3, [r5, #16]
    819a:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
    819e:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    81a2:	f47f af3f 	bne.w	8024 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x24>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
    81a6:	68aa      	ldr	r2, [r5, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    81a8:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
    81ac:	f44f 5384 	mov.w	r3, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
    81b0:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
    81b4:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    81b8:	2334      	movs	r3, #52	; 0x34
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    81ba:	2202      	movs	r2, #2
    81bc:	fb03 730e 	mla	r3, r3, lr, r7
    81c0:	e012      	b.n	81e8 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x1e8>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
    81c2:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    81c4:	68ea      	ldr	r2, [r5, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
    81c6:	f01c 0f20 	tst.w	ip, #32
    81ca:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    81ce:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    81d2:	f04f 0334 	mov.w	r3, #52	; 0x34
    81d6:	d00b      	beq.n	81f0 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x1f0>
    p_reg->SHORTS = mask;
    81d8:	f44f 7280 	mov.w	r2, #256	; 0x100
    81dc:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
    81e0:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    81e4:	fb03 730e 	mla	r3, r3, lr, r7
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    81e8:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    81ea:	2301      	movs	r3, #1
    81ec:	6223      	str	r3, [r4, #32]
    81ee:	e794      	b.n	811a <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x11a>
    p_reg->SHORTS = mask;
    81f0:	f44f 7200 	mov.w	r2, #512	; 0x200
    81f4:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
    81f8:	e7df      	b.n	81ba <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x1ba>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
    81fa:	686b      	ldr	r3, [r5, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    81fc:	68ea      	ldr	r2, [r5, #12]
    81fe:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    8202:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
    8206:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    820a:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    820e:	2334      	movs	r3, #52	; 0x34
    8210:	2202      	movs	r2, #2
    8212:	fb03 730e 	mla	r3, r3, lr, r7
    8216:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8218:	2301      	movs	r3, #1
    821a:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
    821c:	2300      	movs	r3, #0
    821e:	e77d      	b.n	811c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x11c>
    switch (p_xfer_desc->type)
    8220:	2308      	movs	r3, #8
    8222:	4e2d      	ldr	r6, [pc, #180]	; (82d8 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2d8>)
    8224:	e77b      	b.n	811e <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x11e>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
    8226:	f01c 0f04 	tst.w	ip, #4
            p_cb->int_mask = 0;
    822a:	bf1c      	itt	ne
    822c:	2300      	movne	r3, #0
    822e:	6093      	strne	r3, [r2, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
    8230:	f01c 0f40 	tst.w	ip, #64	; 0x40
    8234:	d106      	bne.n	8244 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x244>
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
    8236:	2334      	movs	r3, #52	; 0x34
    8238:	fb03 730e 	mla	r3, r3, lr, r7
    823c:	689a      	ldr	r2, [r3, #8]
    823e:	f042 0202 	orr.w	r2, r2, #2
    8242:	609a      	str	r2, [r3, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
    8244:	2334      	movs	r3, #52	; 0x34
    8246:	fb03 770e 	mla	r7, r3, lr, r7
    824a:	68bb      	ldr	r3, [r7, #8]
    824c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    8250:	60bb      	str	r3, [r7, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
    8252:	68bb      	ldr	r3, [r7, #8]
    p_reg->INTENSET = mask;
    8254:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
    8258:	e6e5      	b.n	8026 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    825a:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    825e:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
                transmission_finished = true;
    8262:	2201      	movs	r2, #1
    8264:	e775      	b.n	8152 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x152>
        } while (!transmission_finished);
    8266:	2a00      	cmp	r2, #0
    8268:	f43f af69 	beq.w	813e <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x13e>
        p_cb->busy = false;
    826c:	2134      	movs	r1, #52	; 0x34
    826e:	2000      	movs	r0, #0
    8270:	fb01 720e 	mla	r2, r1, lr, r7
    uint32_t error_source = p_reg->ERRORSRC;
    8274:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
    8278:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
    827c:	f882 002f 	strb.w	r0, [r2, #47]	; 0x2f
        if (errorsrc)
    8280:	b18b      	cbz	r3, 82a6 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2a6>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
    8282:	4a16      	ldr	r2, [pc, #88]	; (82dc <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2dc>)
    8284:	f013 0f01 	tst.w	r3, #1
    8288:	4e15      	ldr	r6, [pc, #84]	; (82e0 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2e0>)
    828a:	bf18      	it	ne
    828c:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    828e:	f013 0f02 	tst.w	r3, #2
    8292:	f102 0201 	add.w	r2, r2, #1
    8296:	bf18      	it	ne
    8298:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    829a:	f013 0f04 	tst.w	r3, #4
    829e:	4b11      	ldr	r3, [pc, #68]	; (82e4 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2e4>)
    82a0:	bf18      	it	ne
    82a2:	461e      	movne	r6, r3
    82a4:	e6bf      	b.n	8026 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x26>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
    82a6:	f01c 0f40 	tst.w	ip, #64	; 0x40
    82aa:	f47f aebc 	bne.w	8026 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x26>
                !xfer_completeness_check(p_twim, p_cb))
    82ae:	4620      	mov	r0, r4
    82b0:	fb0e 7101 	mla	r1, lr, r1, r7
    82b4:	f00d f868 	bl	15388 <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
    82b8:	4b09      	ldr	r3, [pc, #36]	; (82e0 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2e0>)
    82ba:	2800      	cmp	r0, #0
    82bc:	bf08      	it	eq
    82be:	461e      	moveq	r6, r3
    82c0:	e6b1      	b.n	8026 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x26>
    82c2:	bf00      	nop
    82c4:	20025c94 	.word	0x20025c94
    82c8:	0bad000a 	.word	0x0bad000a
    82cc:	019c0202 	.word	0x019c0202
    82d0:	0bad000b 	.word	0x0bad000b
    82d4:	0bad0000 	.word	0x0bad0000
    82d8:	0bad0004 	.word	0x0bad0004
    82dc:	0bae0000 	.word	0x0bae0000
    82e0:	0bad0001 	.word	0x0bad0001
    82e4:	0bae0002 	.word	0x0bae0002

000082e8 <nrfx_twim_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
    82e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    82ea:	4b5b      	ldr	r3, [pc, #364]	; (8458 <nrfx_twim_1_irq_handler+0x170>)
    82ec:	4c5b      	ldr	r4, [pc, #364]	; (845c <nrfx_twim_1_irq_handler+0x174>)
    82ee:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    82f2:	461d      	mov	r5, r3
    82f4:	b087      	sub	sp, #28
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
    82f6:	b1fa      	cbz	r2, 8338 <nrfx_twim_1_irq_handler+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    82f8:	2200      	movs	r2, #0
    82fa:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    82fe:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8302:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
    8306:	b9ba      	cbnz	r2, 8338 <nrfx_twim_1_irq_handler+0x50>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
    8308:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENCLR = mask;
    830a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
    830e:	2202      	movs	r2, #2
    8310:	60a2      	str	r2, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
    8312:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENSET = mask;
    8314:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8318:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
    831c:	b11a      	cbz	r2, 8326 <nrfx_twim_1_irq_handler+0x3e>
    return p_reg->SHORTS;
    831e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    8322:	059e      	lsls	r6, r3, #22
    8324:	d403      	bmi.n	832e <nrfx_twim_1_irq_handler+0x46>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8326:	2201      	movs	r2, #1
    8328:	4b4b      	ldr	r3, [pc, #300]	; (8458 <nrfx_twim_1_irq_handler+0x170>)
    832a:	621a      	str	r2, [r3, #32]
    832c:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
    832e:	2301      	movs	r3, #1
    8330:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
}
    8334:	b007      	add	sp, #28
    8336:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    8338:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
    833c:	2b00      	cmp	r3, #0
    833e:	d054      	beq.n	83ea <nrfx_twim_1_irq_handler+0x102>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    8340:	2300      	movs	r3, #0
    8342:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
    8346:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
    834a:	6a23      	ldr	r3, [r4, #32]
    834c:	065d      	lsls	r5, r3, #25
    834e:	d40a      	bmi.n	8366 <nrfx_twim_1_irq_handler+0x7e>
    8350:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
    8354:	b93b      	cbnz	r3, 8366 <nrfx_twim_1_irq_handler+0x7e>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
    8356:	4941      	ldr	r1, [pc, #260]	; (845c <nrfx_twim_1_irq_handler+0x174>)
    8358:	483f      	ldr	r0, [pc, #252]	; (8458 <nrfx_twim_1_irq_handler+0x170>)
    835a:	f00d f815 	bl	15388 <xfer_completeness_check>
    835e:	f080 0001 	eor.w	r0, r0, #1
    8362:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
    8366:	6a23      	ldr	r3, [r4, #32]
    8368:	f013 0704 	ands.w	r7, r3, #4
    836c:	d122      	bne.n	83b4 <nrfx_twim_1_irq_handler+0xcc>
            event.xfer_desc = p_cb->xfer_desc;
    836e:	4e3c      	ldr	r6, [pc, #240]	; (8460 <nrfx_twim_1_irq_handler+0x178>)
    8370:	ad01      	add	r5, sp, #4
    8372:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    8374:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    8376:	6833      	ldr	r3, [r6, #0]
    8378:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
    837c:	602b      	str	r3, [r5, #0]
    837e:	4b36      	ldr	r3, [pc, #216]	; (8458 <nrfx_twim_1_irq_handler+0x170>)
    8380:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
    8384:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
    8388:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
    838c:	f8d3 215c 	ldr.w	r2, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
    8390:	f1bc 0f00 	cmp.w	ip, #0
    8394:	d002      	beq.n	839c <nrfx_twim_1_irq_handler+0xb4>
    8396:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
    839a:	b15a      	cbz	r2, 83b4 <nrfx_twim_1_irq_handler+0xcc>
    p_reg->SHORTS = mask;
    839c:	2200      	movs	r2, #0
    839e:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
    83a2:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
    83a4:	4a2f      	ldr	r2, [pc, #188]	; (8464 <nrfx_twim_1_irq_handler+0x17c>)
    83a6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    83aa:	f44f 7200 	mov.w	r2, #512	; 0x200
    83ae:	4b2e      	ldr	r3, [pc, #184]	; (8468 <nrfx_twim_1_irq_handler+0x180>)
    83b0:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
    83b4:	4a28      	ldr	r2, [pc, #160]	; (8458 <nrfx_twim_1_irq_handler+0x170>)
    83b6:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
    83ba:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
    83bc:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
    83c0:	d53c      	bpl.n	843c <nrfx_twim_1_irq_handler+0x154>
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
    83c2:	2301      	movs	r3, #1
        event.type = NRFX_TWIM_EVT_DONE;
    83c4:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
    83c8:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
    83cc:	b90b      	cbnz	r3, 83d2 <nrfx_twim_1_irq_handler+0xea>
        p_cb->busy = false;
    83ce:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
    83d2:	6a23      	ldr	r3, [r4, #32]
    83d4:	075b      	lsls	r3, r3, #29
    83d6:	d503      	bpl.n	83e0 <nrfx_twim_1_irq_handler+0xf8>
    83d8:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
    83dc:	2b00      	cmp	r3, #0
    83de:	d0a9      	beq.n	8334 <nrfx_twim_1_irq_handler+0x4c>
        p_cb->handler(&event, p_cb->p_context);
    83e0:	e9d4 3100 	ldrd	r3, r1, [r4]
    83e4:	4668      	mov	r0, sp
    83e6:	4798      	blx	r3
}
    83e8:	e7a4      	b.n	8334 <nrfx_twim_1_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    83ea:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
    83ee:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
    83f2:	7b23      	ldrb	r3, [r4, #12]
    83f4:	b983      	cbnz	r3, 8418 <nrfx_twim_1_irq_handler+0x130>
            event.xfer_desc = p_cb->xfer_desc;
    83f6:	4f1a      	ldr	r7, [pc, #104]	; (8460 <nrfx_twim_1_irq_handler+0x178>)
    83f8:	ae01      	add	r6, sp, #4
    83fa:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    83fc:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    83fe:	683b      	ldr	r3, [r7, #0]
    8400:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
    8402:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
    8406:	2b00      	cmp	r3, #0
    8408:	d1d4      	bne.n	83b4 <nrfx_twim_1_irq_handler+0xcc>
    p_reg->SHORTS = mask;
    840a:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
    840e:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
    8410:	4b14      	ldr	r3, [pc, #80]	; (8464 <nrfx_twim_1_irq_handler+0x17c>)
    8412:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
    8416:	e7c8      	b.n	83aa <nrfx_twim_1_irq_handler+0xc2>
    p_reg->SHORTS = mask;
    8418:	f44f 7300 	mov.w	r3, #512	; 0x200
    841c:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
    8420:	f240 2302 	movw	r3, #514	; 0x202
    8424:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
    8426:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
    842a:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
    842e:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
    8430:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    8434:	2301      	movs	r3, #1
    8436:	60ab      	str	r3, [r5, #8]
    8438:	622b      	str	r3, [r5, #32]
            return;
    843a:	e77b      	b.n	8334 <nrfx_twim_1_irq_handler+0x4c>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
    843c:	0759      	lsls	r1, r3, #29
    843e:	d501      	bpl.n	8444 <nrfx_twim_1_irq_handler+0x15c>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
    8440:	2302      	movs	r3, #2
    8442:	e7bf      	b.n	83c4 <nrfx_twim_1_irq_handler+0xdc>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
    8444:	07da      	lsls	r2, r3, #31
    8446:	d501      	bpl.n	844c <nrfx_twim_1_irq_handler+0x164>
        event.type = NRFX_TWIM_EVT_OVERRUN;
    8448:	2303      	movs	r3, #3
    844a:	e7bb      	b.n	83c4 <nrfx_twim_1_irq_handler+0xdc>
    else if (p_cb->error)
    844c:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
    8450:	2b00      	cmp	r3, #0
    8452:	d0b7      	beq.n	83c4 <nrfx_twim_1_irq_handler+0xdc>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
    8454:	2304      	movs	r3, #4
    8456:	e7b5      	b.n	83c4 <nrfx_twim_1_irq_handler+0xdc>
    8458:	50009000 	.word	0x50009000
    845c:	20025c94 	.word	0x20025c94
    8460:	20025ca0 	.word	0x20025ca0
    8464:	019c0202 	.word	0x019c0202
    8468:	e000e100 	.word	0xe000e100

0000846c <metal_generic_dev_open>:
	return 0;
}

int metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,
			   struct metal_device **device)
{
    846c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8470:	460e      	mov	r6, r1
    8472:	4617      	mov	r7, r2
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
    8474:	4d0c      	ldr	r5, [pc, #48]	; (84a8 <metal_generic_dev_open+0x3c>)
    8476:	f855 4f18 	ldr.w	r4, [r5, #24]!
    847a:	42ac      	cmp	r4, r5
    847c:	d103      	bne.n	8486 <metal_generic_dev_open+0x1a>
			return metal_generic_dev_sys_open(dev);
		}
	}

	return -ENODEV;
}
    847e:	f06f 0012 	mvn.w	r0, #18
    8482:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (strcmp(dev->name, dev_name) == 0) {
    8486:	4631      	mov	r1, r6
    8488:	f854 0c44 	ldr.w	r0, [r4, #-68]
		dev = metal_container_of(node, struct metal_device, node);
    848c:	f1a4 0844 	sub.w	r8, r4, #68	; 0x44
		if (strcmp(dev->name, dev_name) == 0) {
    8490:	f7f7 ffde 	bl	450 <strcmp>
    8494:	b930      	cbnz	r0, 84a4 <metal_generic_dev_open+0x38>
			return metal_generic_dev_sys_open(dev);
    8496:	4640      	mov	r0, r8
			*device = dev;
    8498:	f8c7 8000 	str.w	r8, [r7]
}
    849c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			return metal_generic_dev_sys_open(dev);
    84a0:	f00d b879 	b.w	15596 <metal_generic_dev_sys_open>
	metal_list_for_each(&_metal.common.generic_device_list, node) {
    84a4:	6824      	ldr	r4, [r4, #0]
    84a6:	e7e8      	b.n	847a <metal_generic_dev_open+0xe>
    84a8:	20025cc8 	.word	0x20025cc8

000084ac <metal_bus_find>:
{
    84ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    84b0:	4607      	mov	r7, r0
    84b2:	460d      	mov	r5, r1
	metal_list_for_each(&_metal.common.bus_list, node) {
    84b4:	4e0b      	ldr	r6, [pc, #44]	; (84e4 <metal_bus_find+0x38>)
    84b6:	f856 4f08 	ldr.w	r4, [r6, #8]!
    84ba:	42b4      	cmp	r4, r6
    84bc:	d102      	bne.n	84c4 <metal_bus_find+0x18>
	return -ENOENT;
    84be:	f06f 0001 	mvn.w	r0, #1
    84c2:	e00a      	b.n	84da <metal_bus_find+0x2e>
		if (strcmp(bus->name, name) == 0 && result) {
    84c4:	4639      	mov	r1, r7
    84c6:	f854 0c24 	ldr.w	r0, [r4, #-36]
		bus = metal_container_of(node, struct metal_bus, node);
    84ca:	f1a4 0824 	sub.w	r8, r4, #36	; 0x24
		if (strcmp(bus->name, name) == 0 && result) {
    84ce:	f7f7 ffbf 	bl	450 <strcmp>
    84d2:	b920      	cbnz	r0, 84de <metal_bus_find+0x32>
    84d4:	b11d      	cbz	r5, 84de <metal_bus_find+0x32>
			*result = bus;
    84d6:	f8c5 8000 	str.w	r8, [r5]
}
    84da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	metal_list_for_each(&_metal.common.bus_list, node) {
    84de:	6824      	ldr	r4, [r4, #0]
    84e0:	e7eb      	b.n	84ba <metal_bus_find+0xe>
    84e2:	bf00      	nop
    84e4:	20025cc8 	.word	0x20025cc8

000084e8 <metal_bus_register>:
{
    84e8:	b510      	push	{r4, lr}
	if (!bus || !bus->name || !strlen(bus->name))
    84ea:	4604      	mov	r4, r0
    84ec:	b910      	cbnz	r0, 84f4 <metal_bus_register+0xc>
		return -EINVAL;
    84ee:	f06f 0015 	mvn.w	r0, #21
}
    84f2:	bd10      	pop	{r4, pc}
	if (!bus || !bus->name || !strlen(bus->name))
    84f4:	6800      	ldr	r0, [r0, #0]
    84f6:	2800      	cmp	r0, #0
    84f8:	d0f9      	beq.n	84ee <metal_bus_register+0x6>
    84fa:	f7f7 ffb3 	bl	464 <strlen>
    84fe:	2800      	cmp	r0, #0
    8500:	d0f5      	beq.n	84ee <metal_bus_register+0x6>
	if (metal_bus_find(bus->name, NULL) == 0)
    8502:	2100      	movs	r1, #0
    8504:	6820      	ldr	r0, [r4, #0]
    8506:	f7ff ffd1 	bl	84ac <metal_bus_find>
    850a:	b1c0      	cbz	r0, 853e <metal_bus_register+0x56>
	metal_list_init(&bus->devices);
    850c:	f104 031c 	add.w	r3, r4, #28
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
	list->prev = list;
	list->next = list;
    8510:	e9c4 3307 	strd	r3, r3, [r4, #28]
}

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
	new_node->prev = node->prev;
    8514:	4b0c      	ldr	r3, [pc, #48]	; (8548 <metal_bus_register+0x60>)
	metal_list_add_tail(&_metal.common.bus_list, &bus->node);
    8516:	f104 0224 	add.w	r2, r4, #36	; 0x24
    851a:	68d9      	ldr	r1, [r3, #12]
	new_node->next = node;
    851c:	f103 0008 	add.w	r0, r3, #8
	new_node->next->prev = new_node;
    8520:	60da      	str	r2, [r3, #12]
	new_node->prev = node->prev;
    8522:	62a1      	str	r1, [r4, #40]	; 0x28
	new_node->next = node;
    8524:	6260      	str	r0, [r4, #36]	; 0x24
	new_node->prev->next = new_node;
    8526:	600a      	str	r2, [r1, #0]
	metal_log(METAL_LOG_DEBUG, "registered %s bus\n", bus->name);
    8528:	781a      	ldrb	r2, [r3, #0]
    852a:	2a06      	cmp	r2, #6
    852c:	d905      	bls.n	853a <metal_bus_register+0x52>
    852e:	685b      	ldr	r3, [r3, #4]
    8530:	b143      	cbz	r3, 8544 <metal_bus_register+0x5c>
    8532:	2007      	movs	r0, #7
    8534:	6822      	ldr	r2, [r4, #0]
    8536:	4905      	ldr	r1, [pc, #20]	; (854c <metal_bus_register+0x64>)
    8538:	4798      	blx	r3
	return 0;
    853a:	2000      	movs	r0, #0
    853c:	e7d9      	b.n	84f2 <metal_bus_register+0xa>
		return -EEXIST;
    853e:	f06f 0010 	mvn.w	r0, #16
    8542:	e7d6      	b.n	84f2 <metal_bus_register+0xa>
	return 0;
    8544:	4618      	mov	r0, r3
    8546:	e7d4      	b.n	84f2 <metal_bus_register+0xa>
    8548:	20025cc8 	.word	0x20025cc8
    854c:	00043f0a 	.word	0x00043f0a

00008550 <metal_register_generic_device>:
{
    8550:	b510      	push	{r4, lr}
    8552:	4604      	mov	r4, r0
	if (!device->name || !strlen(device->name) ||
    8554:	6800      	ldr	r0, [r0, #0]
    8556:	b910      	cbnz	r0, 855e <metal_register_generic_device+0xe>
		return -EINVAL;
    8558:	f06f 0015 	mvn.w	r0, #21
}
    855c:	bd10      	pop	{r4, pc}
	if (!device->name || !strlen(device->name) ||
    855e:	f7f7 ff81 	bl	464 <strlen>
    8562:	2800      	cmp	r0, #0
    8564:	d0f8      	beq.n	8558 <metal_register_generic_device+0x8>
    8566:	68a3      	ldr	r3, [r4, #8]
    8568:	2b01      	cmp	r3, #1
    856a:	d8f5      	bhi.n	8558 <metal_register_generic_device+0x8>
	device->bus = &metal_generic_bus;
    856c:	4b06      	ldr	r3, [pc, #24]	; (8588 <metal_register_generic_device+0x38>)
	metal_list_add_tail(&_metal.common.generic_device_list,
    856e:	f104 0144 	add.w	r1, r4, #68	; 0x44
	device->bus = &metal_generic_bus;
    8572:	6063      	str	r3, [r4, #4]
	new_node->prev = node->prev;
    8574:	4b05      	ldr	r3, [pc, #20]	; (858c <metal_register_generic_device+0x3c>)
    8576:	69da      	ldr	r2, [r3, #28]
	new_node->next = node;
    8578:	f103 0018 	add.w	r0, r3, #24
    857c:	6460      	str	r0, [r4, #68]	; 0x44
	new_node->prev = node->prev;
    857e:	64a2      	str	r2, [r4, #72]	; 0x48
	new_node->next->prev = new_node;
    8580:	61d9      	str	r1, [r3, #28]
	return 0;
    8582:	2000      	movs	r0, #0
	new_node->prev->next = new_node;
    8584:	6011      	str	r1, [r2, #0]
}
    8586:	e7e9      	b.n	855c <metal_register_generic_device+0xc>
    8588:	20000480 	.word	0x20000480
    858c:	20025cc8 	.word	0x20025cc8

00008590 <metal_init>:

int metal_init(const struct metal_init_params *params)
{
	int error = 0;

	memset(&_metal, 0, sizeof(_metal));
    8590:	4b0e      	ldr	r3, [pc, #56]	; (85cc <metal_init+0x3c>)
{
    8592:	b510      	push	{r4, lr}
    8594:	4604      	mov	r4, r0
	memset(&_metal, 0, sizeof(_metal));
    8596:	2220      	movs	r2, #32
    8598:	2100      	movs	r1, #0
    859a:	4618      	mov	r0, r3
    859c:	f015 f9ee 	bl	1d97c <memset>

	_metal.common.log_handler   = params->log_handler;
    85a0:	6822      	ldr	r2, [r4, #0]
    85a2:	6042      	str	r2, [r0, #4]
	_metal.common.log_level     = params->log_level;
    85a4:	4602      	mov	r2, r0
    85a6:	7921      	ldrb	r1, [r4, #4]
    85a8:	f802 1b08 	strb.w	r1, [r2], #8
	list->next = list;
    85ac:	e9c0 2202 	strd	r2, r2, [r0, #8]
	list->prev = list;
    85b0:	f100 0210 	add.w	r2, r0, #16
	list->next = list;
    85b4:	e9c0 2204 	strd	r2, r2, [r0, #16]
	list->prev = list;
    85b8:	f100 0218 	add.w	r2, r0, #24
	list->next = list;
    85bc:	e9c0 2206 	strd	r2, r2, [r0, #24]

	metal_list_init(&_metal.common.bus_list);
	metal_list_init(&_metal.common.generic_shmem_list);
	metal_list_init(&_metal.common.generic_device_list);

	error = metal_sys_init(params);
    85c0:	4620      	mov	r0, r4
	if (error)
		return error;

	return error;
}
    85c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	error = metal_sys_init(params);
    85c6:	f000 b803 	b.w	85d0 <metal_sys_init>
    85ca:	bf00      	nop
    85cc:	20025cc8 	.word	0x20025cc8

000085d0 <metal_sys_init>:
#include <metal/utilities.h>

struct metal_state _metal;

int metal_sys_init(const struct metal_init_params *params)
{
    85d0:	b508      	push	{r3, lr}
	metal_bus_register(&metal_generic_bus);
    85d2:	4802      	ldr	r0, [pc, #8]	; (85dc <metal_sys_init+0xc>)
    85d4:	f7ff ff88 	bl	84e8 <metal_bus_register>
	return 0;
}
    85d8:	2000      	movs	r0, #0
    85da:	bd08      	pop	{r3, pc}
    85dc:	20000480 	.word	0x20000480

000085e0 <metal_zephyr_log_handler>:
	"metal: debug:     ",
};

void metal_zephyr_log_handler(enum metal_log_level level,
			      const char *format, ...)
{
    85e0:	b40e      	push	{r1, r2, r3}
	va_list args;

	if (level <= METAL_LOG_EMERGENCY || level > METAL_LOG_DEBUG)
    85e2:	1e43      	subs	r3, r0, #1
		level = METAL_LOG_EMERGENCY;
    85e4:	2b06      	cmp	r3, #6
{
    85e6:	b533      	push	{r0, r1, r4, r5, lr}
		level = METAL_LOG_EMERGENCY;
    85e8:	bf88      	it	hi
    85ea:	2000      	movhi	r0, #0
	printk("%s", level_strs[level]);
    85ec:	4b09      	ldr	r3, [pc, #36]	; (8614 <metal_zephyr_log_handler+0x34>)
{
    85ee:	ac05      	add	r4, sp, #20
    85f0:	f854 5b04 	ldr.w	r5, [r4], #4
	printk("%s", level_strs[level]);
    85f4:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
    85f8:	4807      	ldr	r0, [pc, #28]	; (8618 <metal_zephyr_log_handler+0x38>)
    85fa:	f009 f9a1 	bl	11940 <printk>

	va_start(args, format);
	vprintk(format, args);
    85fe:	4621      	mov	r1, r4
    8600:	4628      	mov	r0, r5
	va_start(args, format);
    8602:	9401      	str	r4, [sp, #4]
	vprintk(format, args);
    8604:	f7f8 fbfe 	bl	e04 <vprintk>
	va_end(args);
}
    8608:	b002      	add	sp, #8
    860a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    860e:	b003      	add	sp, #12
    8610:	4770      	bx	lr
    8612:	bf00      	nop
    8614:	0001f13c 	.word	0x0001f13c
    8618:	00043f1d 	.word	0x00043f1d

0000861c <indev_reset_check>:
 * @param proc pointer to an input device 'proc'
 * @return true if indev query should be immediately truncated.
 */
static bool indev_reset_check(lv_indev_proc_t * proc)
{
    if(proc->reset_query) {
    861c:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
    8620:	0783      	lsls	r3, r0, #30
        indev_obj_act = NULL;
    8622:	bf44      	itt	mi
    8624:	2200      	movmi	r2, #0
    8626:	4b03      	ldrmi	r3, [pc, #12]	; (8634 <indev_reset_check+0x18>)
    }

    return proc->reset_query ? true : false;
}
    8628:	f3c0 0040 	ubfx	r0, r0, #1, #1
        indev_obj_act = NULL;
    862c:	bf48      	it	mi
    862e:	601a      	strmi	r2, [r3, #0]
}
    8630:	4770      	bx	lr
    8632:	bf00      	nop
    8634:	20025cec 	.word	0x20025cec

00008638 <indev_proc_reset_query_handler>:
    if(indev->proc.reset_query) {
    8638:	f890 1054 	ldrb.w	r1, [r0, #84]	; 0x54
    863c:	078b      	lsls	r3, r1, #30
    863e:	d518      	bpl.n	8672 <indev_proc_reset_query_handler+0x3a>
        indev->proc.types.pointer.drag_sum.x        = 0;
    8640:	2300      	movs	r3, #0
        indev->proc.types.pointer.drag_limit_out    = 0;
    8642:	f890 204a 	ldrb.w	r2, [r0, #74]	; 0x4a
        indev->proc.types.pointer.drag_throw_vect.x = 0;
    8646:	e9c0 330c 	strd	r3, r3, [r0, #48]	; 0x30
        indev->proc.types.pointer.drag_limit_out    = 0;
    864a:	f022 021f 	bic.w	r2, r2, #31
    864e:	f042 020c 	orr.w	r2, r2, #12
    8652:	f880 204a 	strb.w	r2, [r0, #74]	; 0x4a
        indev->proc.types.pointer.last_obj          = NULL;
    8656:	e9c0 330e 	strd	r3, r3, [r0, #56]	; 0x38
        indev_obj_act                               = NULL;
    865a:	4a06      	ldr	r2, [pc, #24]	; (8674 <indev_proc_reset_query_handler+0x3c>)
        indev->proc.longpr_rep_timestamp            = 0;
    865c:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
        indev->proc.long_pr_sent                    = 0;
    8660:	f021 0103 	bic.w	r1, r1, #3
        indev->proc.types.pointer.gesture_sum.x     = 0;
    8664:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
        indev->proc.types.pointer.gesture_sum.y     = 0;
    8668:	f8a0 3048 	strh.w	r3, [r0, #72]	; 0x48
        indev->proc.long_pr_sent                    = 0;
    866c:	f880 1054 	strb.w	r1, [r0, #84]	; 0x54
        indev_obj_act                               = NULL;
    8670:	6013      	str	r3, [r2, #0]
}
    8672:	4770      	bx	lr
    8674:	20025cec 	.word	0x20025cec

00008678 <indev_drag_throw.part.0>:
static void indev_drag_throw(lv_indev_proc_t * proc)
    8678:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    867c:	4604      	mov	r4, r0
    lv_obj_t * drag_obj = get_dragged_obj(proc->types.pointer.last_obj);
    867e:	69c0      	ldr	r0, [r0, #28]
    8680:	f00c ffa7 	bl	155d2 <get_dragged_obj>
    if(drag_obj == NULL) return;
    8684:	4605      	mov	r5, r0
    8686:	b1b8      	cbz	r0, 86b8 <indev_drag_throw.part.0+0x40>
    if(lv_obj_get_drag_throw(drag_obj) == false) {
    8688:	f00d faa6 	bl	15bd8 <lv_obj_get_drag_throw>
    868c:	4f4e      	ldr	r7, [pc, #312]	; (87c8 <indev_drag_throw.part.0+0x150>)
    868e:	b9b0      	cbnz	r0, 86be <indev_drag_throw.part.0+0x46>
        proc->types.pointer.drag_in_prog = 0;
    8690:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
    8694:	683a      	ldr	r2, [r7, #0]
        proc->types.pointer.drag_in_prog = 0;
    8696:	f360 0341 	bfi	r3, r0, #1, #1
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
    869a:	2113      	movs	r1, #19
        proc->types.pointer.drag_in_prog = 0;
    869c:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
    86a0:	4628      	mov	r0, r5
    86a2:	69eb      	ldr	r3, [r5, #28]
    86a4:	4798      	blx	r3
        if(indev_reset_check(proc)) return;
    86a6:	4620      	mov	r0, r4
    86a8:	f7ff ffb8 	bl	861c <indev_reset_check>
    86ac:	4602      	mov	r2, r0
    86ae:	b918      	cbnz	r0, 86b8 <indev_drag_throw.part.0+0x40>
        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);
    86b0:	2109      	movs	r1, #9
    86b2:	4628      	mov	r0, r5
    86b4:	f00d f823 	bl	156fe <lv_event_send>
}
    86b8:	b004      	add	sp, #16
    86ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
    86be:	4628      	mov	r0, r5
    86c0:	f00d fa85 	bl	15bce <lv_obj_get_drag_dir>
    86c4:	4680      	mov	r8, r0
        proc->types.pointer.drag_throw_vect.x * (100 - indev_act->driver.drag_throw) / 100;
    86c6:	2064      	movs	r0, #100	; 0x64
    86c8:	683a      	ldr	r2, [r7, #0]
    86ca:	7e51      	ldrb	r1, [r2, #25]
    86cc:	f1c1 0364 	rsb	r3, r1, #100	; 0x64
    86d0:	f9b4 1014 	ldrsh.w	r1, [r4, #20]
    86d4:	4359      	muls	r1, r3
    86d6:	fb91 f1f0 	sdiv	r1, r1, r0
    proc->types.pointer.drag_throw_vect.x =
    86da:	82a1      	strh	r1, [r4, #20]
        proc->types.pointer.drag_throw_vect.y * (100 - indev_act->driver.drag_throw) / 100;
    86dc:	7e53      	ldrb	r3, [r2, #25]
    86de:	1ac1      	subs	r1, r0, r3
    86e0:	f9b4 3016 	ldrsh.w	r3, [r4, #22]
    86e4:	434b      	muls	r3, r1
    86e6:	fb93 f3f0 	sdiv	r3, r3, r0
    proc->types.pointer.drag_throw_vect.y =
    86ea:	82e3      	strh	r3, [r4, #22]
    if(proc->types.pointer.drag_throw_vect.x != 0 || proc->types.pointer.drag_throw_vect.y != 0) {
    86ec:	6961      	ldr	r1, [r4, #20]
    86ee:	2900      	cmp	r1, #0
    86f0:	d062      	beq.n	87b8 <indev_drag_throw.part.0+0x140>
        lv_obj_get_coords(drag_obj, &coords_ori);
    86f2:	4669      	mov	r1, sp
    86f4:	4628      	mov	r0, r5
    86f6:	f00d f9c0 	bl	15a7a <lv_obj_get_coords>
        lv_coord_t act_x = lv_obj_get_x(drag_obj) + proc->types.pointer.drag_throw_vect.x;
    86fa:	4628      	mov	r0, r5
    86fc:	f00d f9c3 	bl	15a86 <lv_obj_get_x>
    8700:	8aa6      	ldrh	r6, [r4, #20]
    8702:	4406      	add	r6, r0
        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;
    8704:	4628      	mov	r0, r5
    8706:	f00d f9d1 	bl	15aac <lv_obj_get_y>
    870a:	8ae2      	ldrh	r2, [r4, #22]
        if(allowed_dirs == LV_DRAG_DIR_BOTH) lv_obj_set_pos(drag_obj, act_x, act_y);
    870c:	f1b8 0f03 	cmp.w	r8, #3
        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;
    8710:	4402      	add	r2, r0
        lv_coord_t act_x = lv_obj_get_x(drag_obj) + proc->types.pointer.drag_throw_vect.x;
    8712:	b236      	sxth	r6, r6
        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;
    8714:	b211      	sxth	r1, r2
        if(allowed_dirs == LV_DRAG_DIR_BOTH) lv_obj_set_pos(drag_obj, act_x, act_y);
    8716:	d138      	bne.n	878a <indev_drag_throw.part.0+0x112>
    8718:	460a      	mov	r2, r1
    871a:	4628      	mov	r0, r5
    871c:	4631      	mov	r1, r6
    871e:	f00d f8bf 	bl	158a0 <lv_obj_set_pos>
        lv_obj_get_coords(drag_obj, &coord_new);
    8722:	4628      	mov	r0, r5
    8724:	a902      	add	r1, sp, #8
    8726:	f00d f9a8 	bl	15a7a <lv_obj_get_coords>
        if((coords_ori.x1 == coord_new.x1 || proc->types.pointer.drag_throw_vect.x == 0) &&
    872a:	f9bd 2000 	ldrsh.w	r2, [sp]
    872e:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
    8732:	429a      	cmp	r2, r3
    8734:	d003      	beq.n	873e <indev_drag_throw.part.0+0xc6>
    8736:	f9b4 3014 	ldrsh.w	r3, [r4, #20]
    873a:	2b00      	cmp	r3, #0
    873c:	d1bc      	bne.n	86b8 <indev_drag_throw.part.0+0x40>
    873e:	f9bd 2002 	ldrsh.w	r2, [sp, #2]
    8742:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
    8746:	429a      	cmp	r2, r3
    8748:	d003      	beq.n	8752 <indev_drag_throw.part.0+0xda>
           (coords_ori.y1 == coord_new.y1 || proc->types.pointer.drag_throw_vect.y == 0)) {
    874a:	f9b4 3016 	ldrsh.w	r3, [r4, #22]
    874e:	2b00      	cmp	r3, #0
    8750:	d1b2      	bne.n	86b8 <indev_drag_throw.part.0+0x40>
            proc->types.pointer.drag_in_prog      = 0;
    8752:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
            drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
    8756:	683a      	ldr	r2, [r7, #0]
            proc->types.pointer.drag_in_prog      = 0;
    8758:	f36f 0341 	bfc	r3, #1, #1
    875c:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
            proc->types.pointer.vect.x            = 0;
    8760:	2300      	movs	r3, #0
    8762:	60e3      	str	r3, [r4, #12]
            proc->types.pointer.drag_throw_vect.x = 0;
    8764:	6163      	str	r3, [r4, #20]
            drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
    8766:	69eb      	ldr	r3, [r5, #28]
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
    8768:	2113      	movs	r1, #19
    876a:	4628      	mov	r0, r5
    876c:	4798      	blx	r3
        if(indev_reset_check(proc)) return;
    876e:	4620      	mov	r0, r4
    8770:	f7ff ff54 	bl	861c <indev_reset_check>
    8774:	4602      	mov	r2, r0
    8776:	2800      	cmp	r0, #0
    8778:	d19e      	bne.n	86b8 <indev_drag_throw.part.0+0x40>
        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);
    877a:	2109      	movs	r1, #9
    877c:	4628      	mov	r0, r5
    877e:	f00c ffbe 	bl	156fe <lv_event_send>
        if(indev_reset_check(proc)) return;
    8782:	4620      	mov	r0, r4
    8784:	f7ff ff4a 	bl	861c <indev_reset_check>
    8788:	e796      	b.n	86b8 <indev_drag_throw.part.0+0x40>
        else if(allowed_dirs == LV_DRAG_DIR_HOR) lv_obj_set_x(drag_obj, act_x);
    878a:	f1b8 0f01 	cmp.w	r8, #1
    878e:	d104      	bne.n	879a <indev_drag_throw.part.0+0x122>
            if(proc->types.pointer.drag_sum.x) lv_obj_set_x(drag_obj, act_x);
    8790:	4631      	mov	r1, r6
    8792:	4628      	mov	r0, r5
    8794:	f00d f992 	bl	15abc <lv_obj_set_x>
    8798:	e7c3      	b.n	8722 <indev_drag_throw.part.0+0xaa>
        else if(allowed_dirs == LV_DRAG_DIR_VER) lv_obj_set_y(drag_obj, act_y);
    879a:	f1b8 0f02 	cmp.w	r8, #2
    879e:	d103      	bne.n	87a8 <indev_drag_throw.part.0+0x130>
            else lv_obj_set_y(drag_obj, act_y);
    87a0:	4628      	mov	r0, r5
    87a2:	f00d f978 	bl	15a96 <lv_obj_set_y>
    87a6:	e7bc      	b.n	8722 <indev_drag_throw.part.0+0xaa>
        else if(allowed_dirs == LV_DRAG_DIR_ONE) {
    87a8:	f1b8 0f04 	cmp.w	r8, #4
    87ac:	d1b9      	bne.n	8722 <indev_drag_throw.part.0+0xaa>
            if(proc->types.pointer.drag_sum.x) lv_obj_set_x(drag_obj, act_x);
    87ae:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
    87b2:	2b00      	cmp	r3, #0
    87b4:	d0f4      	beq.n	87a0 <indev_drag_throw.part.0+0x128>
    87b6:	e7eb      	b.n	8790 <indev_drag_throw.part.0+0x118>
        proc->types.pointer.drag_in_prog = 0;
    87b8:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    87bc:	f361 0341 	bfi	r3, r1, #1, #1
    87c0:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
    87c4:	69eb      	ldr	r3, [r5, #28]
    87c6:	e7cf      	b.n	8768 <indev_drag_throw.part.0+0xf0>
    87c8:	20025ce8 	.word	0x20025ce8

000087cc <lv_indev_reset.part.0>:
void lv_indev_reset(lv_indev_t * indev, lv_obj_t * obj)
    87cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    87ce:	4604      	mov	r4, r0
        lv_indev_t * i = lv_indev_get_next(NULL);
    87d0:	2000      	movs	r0, #0
    87d2:	f003 ffdd 	bl	c790 <lv_indev_get_next>
            if(indev_act == i) indev_obj_act = NULL;
    87d6:	2500      	movs	r5, #0
    87d8:	4e0a      	ldr	r6, [pc, #40]	; (8804 <lv_indev_reset.part.0+0x38>)
    87da:	4f0b      	ldr	r7, [pc, #44]	; (8808 <lv_indev_reset.part.0+0x3c>)
        while(i) {
    87dc:	b900      	cbnz	r0, 87e0 <lv_indev_reset.part.0+0x14>
}
    87de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            i->proc.reset_query = 1;
    87e0:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
    87e4:	f043 0302 	orr.w	r3, r3, #2
    87e8:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
            if(indev_act == i) indev_obj_act = NULL;
    87ec:	6833      	ldr	r3, [r6, #0]
    87ee:	4298      	cmp	r0, r3
    87f0:	bf08      	it	eq
    87f2:	603d      	streq	r5, [r7, #0]
            if(obj == NULL || i->proc.types.pointer.last_pressed == obj) {
    87f4:	b114      	cbz	r4, 87fc <lv_indev_reset.part.0+0x30>
    87f6:	6c03      	ldr	r3, [r0, #64]	; 0x40
    87f8:	429c      	cmp	r4, r3
    87fa:	d100      	bne.n	87fe <lv_indev_reset.part.0+0x32>
                i->proc.types.pointer.last_pressed = NULL;
    87fc:	6405      	str	r5, [r0, #64]	; 0x40
            i = lv_indev_get_next(i);
    87fe:	f003 ffc7 	bl	c790 <lv_indev_get_next>
    8802:	e7eb      	b.n	87dc <lv_indev_reset.part.0+0x10>
    8804:	20025ce8 	.word	0x20025ce8
    8808:	20025cec 	.word	0x20025cec

0000880c <indev_proc_release>:
    if(proc->wait_until_release != 0) {
    880c:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
{
    8810:	b570      	push	{r4, r5, r6, lr}
    if(proc->wait_until_release != 0) {
    8812:	071a      	lsls	r2, r3, #28
{
    8814:	4604      	mov	r4, r0
    if(proc->wait_until_release != 0) {
    8816:	d508      	bpl.n	882a <indev_proc_release+0x1e>
        proc->types.pointer.act_obj  = NULL;
    8818:	2200      	movs	r2, #0
        proc->types.pointer.last_obj = NULL;
    881a:	e9c0 2206 	strd	r2, r2, [r0, #24]
        proc->longpr_rep_timestamp   = 0;
    881e:	e9c0 220b 	strd	r2, r2, [r0, #44]	; 0x2c
        proc->wait_until_release     = 0;
    8822:	f362 03c3 	bfi	r3, r2, #3, #1
    8826:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    indev_obj_act = proc->types.pointer.act_obj;
    882a:	69a0      	ldr	r0, [r4, #24]
    882c:	4d4b      	ldr	r5, [pc, #300]	; (895c <indev_proc_release+0x150>)
    882e:	6028      	str	r0, [r5, #0]
    if(indev_obj_act) {
    8830:	b338      	cbz	r0, 8882 <indev_proc_release+0x76>
        if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_PRESS_LOST)) {
    8832:	2110      	movs	r1, #16
    8834:	f00d f9e1 	bl	15bfa <lv_obj_is_protected>
    8838:	4b49      	ldr	r3, [pc, #292]	; (8960 <indev_proc_release+0x154>)
    883a:	2800      	cmp	r0, #0
    883c:	d04d      	beq.n	88da <indev_proc_release+0xce>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, indev_act);
    883e:	6828      	ldr	r0, [r5, #0]
    8840:	210e      	movs	r1, #14
    8842:	69c6      	ldr	r6, [r0, #28]
    8844:	681a      	ldr	r2, [r3, #0]
    8846:	47b0      	blx	r6
            if(indev_reset_check(proc)) return;
    8848:	4620      	mov	r0, r4
    884a:	f7ff fee7 	bl	861c <indev_reset_check>
    884e:	2800      	cmp	r0, #0
    8850:	d142      	bne.n	88d8 <indev_proc_release+0xcc>
            if(proc->types.pointer.drag_in_prog == 0) {
    8852:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    8856:	079e      	lsls	r6, r3, #30
    8858:	d525      	bpl.n	88a6 <indev_proc_release+0x9a>
            lv_event_send(indev_obj_act, LV_EVENT_RELEASED, NULL);
    885a:	2200      	movs	r2, #0
    885c:	2107      	movs	r1, #7
    885e:	6828      	ldr	r0, [r5, #0]
    8860:	f00c ff4d 	bl	156fe <lv_event_send>
            if(indev_reset_check(proc)) return;
    8864:	4620      	mov	r0, r4
    8866:	f7ff fed9 	bl	861c <indev_reset_check>
    886a:	2800      	cmp	r0, #0
    886c:	d134      	bne.n	88d8 <indev_proc_release+0xcc>
        lv_obj_t * drag_obj = get_dragged_obj(indev_obj_act);
    886e:	6828      	ldr	r0, [r5, #0]
    8870:	f00c feaf 	bl	155d2 <get_dragged_obj>
        if(drag_obj) {
    8874:	4605      	mov	r5, r0
    8876:	2800      	cmp	r0, #0
    8878:	d152      	bne.n	8920 <indev_proc_release+0x114>
        proc->types.pointer.act_obj = NULL;
    887a:	2300      	movs	r3, #0
        proc->longpr_rep_timestamp  = 0;
    887c:	e9c4 330b 	strd	r3, r3, [r4, #44]	; 0x2c
        proc->types.pointer.act_obj = NULL;
    8880:	61a3      	str	r3, [r4, #24]
    if(proc->types.pointer.last_obj != NULL && proc->reset_query == 0) {
    8882:	69e3      	ldr	r3, [r4, #28]
    8884:	b343      	cbz	r3, 88d8 <indev_proc_release+0xcc>
    8886:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    888a:	079a      	lsls	r2, r3, #30
    888c:	d424      	bmi.n	88d8 <indev_proc_release+0xcc>
    if(proc->types.pointer.drag_in_prog == 0) return;
    888e:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    8892:	079b      	lsls	r3, r3, #30
    8894:	d502      	bpl.n	889c <indev_proc_release+0x90>
    8896:	4620      	mov	r0, r4
    8898:	f7ff feee 	bl	8678 <indev_drag_throw.part.0>
        if(indev_reset_check(proc)) return;
    889c:	4620      	mov	r0, r4
}
    889e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        if(indev_reset_check(proc)) return;
    88a2:	f7ff bebb 	b.w	861c <indev_reset_check>
                if(proc->long_pr_sent == 0) {
    88a6:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
    88aa:	f012 0201 	ands.w	r2, r2, #1
    88ae:	d00a      	beq.n	88c6 <indev_proc_release+0xba>
                lv_event_send(indev_obj_act, LV_EVENT_CLICKED, NULL);
    88b0:	2200      	movs	r2, #0
                lv_event_send(indev_obj_act, LV_EVENT_CLICKED, NULL);
    88b2:	2106      	movs	r1, #6
    88b4:	6828      	ldr	r0, [r5, #0]
    88b6:	f00c ff22 	bl	156fe <lv_event_send>
                if(indev_reset_check(proc)) return;
    88ba:	4620      	mov	r0, r4
    88bc:	f7ff feae 	bl	861c <indev_reset_check>
    88c0:	2800      	cmp	r0, #0
    88c2:	d0ca      	beq.n	885a <indev_proc_release+0x4e>
    88c4:	e008      	b.n	88d8 <indev_proc_release+0xcc>
                    lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
    88c6:	2103      	movs	r1, #3
    88c8:	6828      	ldr	r0, [r5, #0]
    88ca:	f00c ff18 	bl	156fe <lv_event_send>
                    if(indev_reset_check(proc)) return;
    88ce:	4620      	mov	r0, r4
    88d0:	f7ff fea4 	bl	861c <indev_reset_check>
    88d4:	2800      	cmp	r0, #0
    88d6:	d0eb      	beq.n	88b0 <indev_proc_release+0xa4>
}
    88d8:	bd70      	pop	{r4, r5, r6, pc}
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, indev_act);
    88da:	6828      	ldr	r0, [r5, #0]
    88dc:	210e      	movs	r1, #14
    88de:	69c6      	ldr	r6, [r0, #28]
    88e0:	681a      	ldr	r2, [r3, #0]
    88e2:	47b0      	blx	r6
            if(indev_reset_check(proc)) return;
    88e4:	4620      	mov	r0, r4
    88e6:	f7ff fe99 	bl	861c <indev_reset_check>
    88ea:	2800      	cmp	r0, #0
    88ec:	d1f4      	bne.n	88d8 <indev_proc_release+0xcc>
            if(proc->long_pr_sent == 0 && proc->types.pointer.drag_in_prog == 0) {
    88ee:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    88f2:	07d8      	lsls	r0, r3, #31
    88f4:	d505      	bpl.n	8902 <indev_proc_release+0xf6>
            if(proc->types.pointer.drag_in_prog == 0) {
    88f6:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
    88fa:	f012 0202 	ands.w	r2, r2, #2
    88fe:	d0d8      	beq.n	88b2 <indev_proc_release+0xa6>
    8900:	e7ab      	b.n	885a <indev_proc_release+0x4e>
            if(proc->long_pr_sent == 0 && proc->types.pointer.drag_in_prog == 0) {
    8902:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
    8906:	f012 0202 	ands.w	r2, r2, #2
    890a:	d1a6      	bne.n	885a <indev_proc_release+0x4e>
                lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
    890c:	2103      	movs	r1, #3
    890e:	6828      	ldr	r0, [r5, #0]
    8910:	f00c fef5 	bl	156fe <lv_event_send>
                if(indev_reset_check(proc)) return;
    8914:	4620      	mov	r0, r4
    8916:	f7ff fe81 	bl	861c <indev_reset_check>
    891a:	2800      	cmp	r0, #0
    891c:	d0eb      	beq.n	88f6 <indev_proc_release+0xea>
    891e:	e7db      	b.n	88d8 <indev_proc_release+0xcc>
            if(lv_obj_get_drag_throw(drag_obj) && proc->types.pointer.drag_in_prog) {
    8920:	f00d f95a 	bl	15bd8 <lv_obj_get_drag_throw>
    8924:	2800      	cmp	r0, #0
    8926:	d0a8      	beq.n	887a <indev_proc_release+0x6e>
    8928:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    892c:	0799      	lsls	r1, r3, #30
    892e:	d5a4      	bpl.n	887a <indev_proc_release+0x6e>
                if(drag_obj->signal_cb) drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_THROW_BEGIN, NULL);
    8930:	69eb      	ldr	r3, [r5, #28]
    8932:	b11b      	cbz	r3, 893c <indev_proc_release+0x130>
    8934:	2200      	movs	r2, #0
    8936:	2112      	movs	r1, #18
    8938:	4628      	mov	r0, r5
    893a:	4798      	blx	r3
                if(indev_reset_check(proc)) return;
    893c:	4620      	mov	r0, r4
    893e:	f7ff fe6d 	bl	861c <indev_reset_check>
    8942:	4602      	mov	r2, r0
    8944:	2800      	cmp	r0, #0
    8946:	d1c7      	bne.n	88d8 <indev_proc_release+0xcc>
                lv_event_send(drag_obj, LV_EVENT_DRAG_THROW_BEGIN, NULL);
    8948:	210a      	movs	r1, #10
    894a:	4628      	mov	r0, r5
    894c:	f00c fed7 	bl	156fe <lv_event_send>
                if(indev_reset_check(proc)) return;
    8950:	4620      	mov	r0, r4
    8952:	f7ff fe63 	bl	861c <indev_reset_check>
    8956:	2800      	cmp	r0, #0
    8958:	d08f      	beq.n	887a <indev_proc_release+0x6e>
    895a:	e7bd      	b.n	88d8 <indev_proc_release+0xcc>
    895c:	20025cec 	.word	0x20025cec
    8960:	20025ce8 	.word	0x20025ce8

00008964 <lv_indev_get_act>:
}
    8964:	4b01      	ldr	r3, [pc, #4]	; (896c <lv_indev_get_act+0x8>)
    8966:	6818      	ldr	r0, [r3, #0]
    8968:	4770      	bx	lr
    896a:	bf00      	nop
    896c:	20025ce8 	.word	0x20025ce8

00008970 <lv_indev_reset>:
{
    8970:	4603      	mov	r3, r0
    8972:	4608      	mov	r0, r1
    if(indev) {
    8974:	b19b      	cbz	r3, 899e <lv_indev_reset+0x2e>
        indev->proc.reset_query = 1;
    8976:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
    897a:	f042 0202 	orr.w	r2, r2, #2
    897e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
        if(indev_act == indev) indev_obj_act = NULL;
    8982:	4a08      	ldr	r2, [pc, #32]	; (89a4 <lv_indev_reset+0x34>)
    8984:	6812      	ldr	r2, [r2, #0]
    8986:	429a      	cmp	r2, r3
    8988:	bf02      	ittt	eq
    898a:	2100      	moveq	r1, #0
    898c:	4a06      	ldreq	r2, [pc, #24]	; (89a8 <lv_indev_reset+0x38>)
    898e:	6011      	streq	r1, [r2, #0]
        if(obj == NULL || indev->proc.types.pointer.last_pressed == obj) {
    8990:	b110      	cbz	r0, 8998 <lv_indev_reset+0x28>
    8992:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    8994:	4282      	cmp	r2, r0
    8996:	d104      	bne.n	89a2 <lv_indev_reset+0x32>
            indev->proc.types.pointer.last_pressed = NULL;
    8998:	2200      	movs	r2, #0
    899a:	641a      	str	r2, [r3, #64]	; 0x40
    899c:	4770      	bx	lr
    899e:	f7ff bf15 	b.w	87cc <lv_indev_reset.part.0>
}
    89a2:	4770      	bx	lr
    89a4:	20025ce8 	.word	0x20025ce8
    89a8:	20025cec 	.word	0x20025cec

000089ac <indev_proc_press>:
{
    89ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    89b0:	4604      	mov	r4, r0
    if(proc->wait_until_release != 0) return;
    89b2:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    indev_obj_act = proc->types.pointer.act_obj;
    89b6:	6980      	ldr	r0, [r0, #24]
    89b8:	4d8f      	ldr	r5, [pc, #572]	; (8bf8 <indev_proc_press+0x24c>)
    if(proc->wait_until_release != 0) return;
    89ba:	071a      	lsls	r2, r3, #28
{
    89bc:	b085      	sub	sp, #20
    indev_obj_act = proc->types.pointer.act_obj;
    89be:	6028      	str	r0, [r5, #0]
    if(proc->wait_until_release != 0) return;
    89c0:	f100 819a 	bmi.w	8cf8 <indev_proc_press+0x34c>
    lv_disp_t * disp = indev_act->driver.disp;
    89c4:	4b8d      	ldr	r3, [pc, #564]	; (8bfc <indev_proc_press+0x250>)
    89c6:	681a      	ldr	r2, [r3, #0]
    89c8:	4698      	mov	r8, r3
    89ca:	6916      	ldr	r6, [r2, #16]
    if(indev_obj_act == NULL) {
    89cc:	bb18      	cbnz	r0, 8a16 <indev_proc_press+0x6a>
        indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_sys(disp), &proc->types.pointer.act_point);
    89ce:	4630      	mov	r0, r6
    89d0:	1d27      	adds	r7, r4, #4
    89d2:	f00c fdf7 	bl	155c4 <lv_disp_get_layer_sys>
    89d6:	4639      	mov	r1, r7
    89d8:	f00c fe1d 	bl	15616 <lv_indev_search_obj>
    89dc:	6028      	str	r0, [r5, #0]
        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_layer_top(disp),
    89de:	b970      	cbnz	r0, 89fe <indev_proc_press+0x52>
    89e0:	4630      	mov	r0, r6
    89e2:	f00c fde8 	bl	155b6 <lv_disp_get_layer_top>
    89e6:	4639      	mov	r1, r7
    89e8:	f00c fe15 	bl	15616 <lv_indev_search_obj>
    89ec:	6028      	str	r0, [r5, #0]
        if(indev_obj_act == NULL) indev_obj_act = lv_indev_search_obj(lv_disp_get_scr_act(disp),
    89ee:	b930      	cbnz	r0, 89fe <indev_proc_press+0x52>
    89f0:	4630      	mov	r0, r6
    89f2:	f00c fdd2 	bl	1559a <lv_disp_get_scr_act>
    89f6:	4639      	mov	r1, r7
    89f8:	f00c fe0d 	bl	15616 <lv_indev_search_obj>
    89fc:	6028      	str	r0, [r5, #0]
    if(new_obj_searched && proc->types.pointer.last_obj) {
    89fe:	69e3      	ldr	r3, [r4, #28]
    8a00:	b193      	cbz	r3, 8a28 <indev_proc_press+0x7c>
        proc->types.pointer.drag_throw_vect.x = 0;
    8a02:	2300      	movs	r3, #0
    8a04:	6163      	str	r3, [r4, #20]
    if(proc->types.pointer.drag_in_prog == 0) return;
    8a06:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    8a0a:	079f      	lsls	r7, r3, #30
    8a0c:	d50c      	bpl.n	8a28 <indev_proc_press+0x7c>
    8a0e:	4620      	mov	r0, r4
    8a10:	f7ff fe32 	bl	8678 <indev_drag_throw.part.0>
    8a14:	e008      	b.n	8a28 <indev_proc_press+0x7c>
    else if(proc->types.pointer.drag_in_prog == 0 &&
    8a16:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    8a1a:	079b      	lsls	r3, r3, #30
    8a1c:	d404      	bmi.n	8a28 <indev_proc_press+0x7c>
            lv_obj_is_protected(indev_obj_act, LV_PROTECT_PRESS_LOST) == false) {
    8a1e:	2110      	movs	r1, #16
    8a20:	f00d f8eb 	bl	15bfa <lv_obj_is_protected>
    else if(proc->types.pointer.drag_in_prog == 0 &&
    8a24:	2800      	cmp	r0, #0
    8a26:	d0d2      	beq.n	89ce <indev_proc_press+0x22>
    if(indev_obj_act && (lv_obj_get_state(indev_obj_act, LV_OBJ_PART_MAIN) & LV_STATE_DISABLED)) {
    8a28:	6828      	ldr	r0, [r5, #0]
    8a2a:	b130      	cbz	r0, 8a3a <indev_proc_press+0x8e>
    8a2c:	2100      	movs	r1, #0
    8a2e:	f00d f8eb 	bl	15c08 <lv_obj_get_state>
    8a32:	0686      	lsls	r6, r0, #26
        indev_obj_act = proc->types.pointer.act_obj;
    8a34:	bf44      	itt	mi
    8a36:	69a3      	ldrmi	r3, [r4, #24]
    8a38:	602b      	strmi	r3, [r5, #0]
    if(indev_obj_act != proc->types.pointer.act_obj) {
    8a3a:	69a6      	ldr	r6, [r4, #24]
    8a3c:	682b      	ldr	r3, [r5, #0]
    8a3e:	429e      	cmp	r6, r3
    8a40:	f040 80de 	bne.w	8c00 <indev_proc_press+0x254>
    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;
    8a44:	8923      	ldrh	r3, [r4, #8]
    8a46:	88a0      	ldrh	r0, [r4, #4]
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
    8a48:	88e1      	ldrh	r1, [r4, #6]
    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;
    8a4a:	1ac0      	subs	r0, r0, r3
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
    8a4c:	8963      	ldrh	r3, [r4, #10]
    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
    8a4e:	f9b4 2014 	ldrsh.w	r2, [r4, #20]
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
    8a52:	1ac9      	subs	r1, r1, r3
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
    8a54:	f9b4 3016 	ldrsh.w	r3, [r4, #22]
    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
    8a58:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    8a5c:	10d7      	asrs	r7, r2, #3
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
    8a5e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    8a62:	10de      	asrs	r6, r3, #3
    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;
    8a64:	b200      	sxth	r0, r0
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
    8a66:	b209      	sxth	r1, r1
    if(proc->types.pointer.drag_throw_vect.x < 0)
    8a68:	2f00      	cmp	r7, #0
    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
    8a6a:	463a      	mov	r2, r7
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
    8a6c:	4633      	mov	r3, r6
    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;
    8a6e:	81a0      	strh	r0, [r4, #12]
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
    8a70:	81e1      	strh	r1, [r4, #14]
    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
    8a72:	82a7      	strh	r7, [r4, #20]
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
    8a74:	82e6      	strh	r6, [r4, #22]
    if(proc->types.pointer.drag_throw_vect.x < 0)
    8a76:	f280 8163 	bge.w	8d40 <indev_proc_press+0x394>
        proc->types.pointer.drag_throw_vect.x++;
    8a7a:	3201      	adds	r2, #1
        proc->types.pointer.drag_throw_vect.x--;
    8a7c:	82a2      	strh	r2, [r4, #20]
    if(proc->types.pointer.drag_throw_vect.y < 0)
    8a7e:	2e00      	cmp	r6, #0
    8a80:	f280 8162 	bge.w	8d48 <indev_proc_press+0x39c>
        proc->types.pointer.drag_throw_vect.y++;
    8a84:	3301      	adds	r3, #1
        proc->types.pointer.drag_throw_vect.y--;
    8a86:	82e3      	strh	r3, [r4, #22]
    proc->types.pointer.drag_throw_vect.x += (proc->types.pointer.vect.x * 4) >> 3;
    8a88:	8aa3      	ldrh	r3, [r4, #20]
    8a8a:	eb03 0060 	add.w	r0, r3, r0, asr #1
    proc->types.pointer.drag_throw_vect.y += (proc->types.pointer.vect.y * 4) >> 3;
    8a8e:	8ae3      	ldrh	r3, [r4, #22]
    proc->types.pointer.drag_throw_vect.x += (proc->types.pointer.vect.x * 4) >> 3;
    8a90:	82a0      	strh	r0, [r4, #20]
    if(indev_obj_act != NULL) {
    8a92:	6828      	ldr	r0, [r5, #0]
    proc->types.pointer.drag_throw_vect.y += (proc->types.pointer.vect.y * 4) >> 3;
    8a94:	eb03 0161 	add.w	r1, r3, r1, asr #1
    8a98:	82e1      	strh	r1, [r4, #22]
    if(indev_obj_act != NULL) {
    8a9a:	2800      	cmp	r0, #0
    8a9c:	f000 812c 	beq.w	8cf8 <indev_proc_press+0x34c>
        indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_PRESSING, indev_act);
    8aa0:	f8d8 2000 	ldr.w	r2, [r8]
    8aa4:	210c      	movs	r1, #12
    8aa6:	69c3      	ldr	r3, [r0, #28]
    8aa8:	4798      	blx	r3
        if(indev_reset_check(proc)) return;
    8aaa:	4620      	mov	r0, r4
    8aac:	f7ff fdb6 	bl	861c <indev_reset_check>
    8ab0:	4602      	mov	r2, r0
    8ab2:	2800      	cmp	r0, #0
    8ab4:	f040 8120 	bne.w	8cf8 <indev_proc_press+0x34c>
        lv_event_send(indev_obj_act, LV_EVENT_PRESSING, NULL);
    8ab8:	2101      	movs	r1, #1
    8aba:	6828      	ldr	r0, [r5, #0]
    8abc:	f00c fe1f 	bl	156fe <lv_event_send>
        if(indev_reset_check(proc)) return;
    8ac0:	4620      	mov	r0, r4
    8ac2:	f7ff fdab 	bl	861c <indev_reset_check>
    8ac6:	4681      	mov	r9, r0
    8ac8:	2800      	cmp	r0, #0
    8aca:	f040 8115 	bne.w	8cf8 <indev_proc_press+0x34c>
        if(indev_act->proc.wait_until_release) return;
    8ace:	f8d8 3000 	ldr.w	r3, [r8]
    8ad2:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    8ad6:	0719      	lsls	r1, r3, #28
    8ad8:	f100 810e 	bmi.w	8cf8 <indev_proc_press+0x34c>
    lv_obj_t * drag_obj    = get_dragged_obj(proc->types.pointer.act_obj);
    8adc:	69a0      	ldr	r0, [r4, #24]
    8ade:	f00c fd78 	bl	155d2 <get_dragged_obj>
    if(drag_obj == NULL) return;
    8ae2:	4606      	mov	r6, r0
    8ae4:	2800      	cmp	r0, #0
    8ae6:	f000 81bc 	beq.w	8e62 <indev_proc_press+0x4b6>
    if(lv_obj_get_drag(drag_obj) == false) return;
    8aea:	f00d f86b 	bl	15bc4 <lv_obj_get_drag>
    8aee:	4682      	mov	sl, r0
    8af0:	2800      	cmp	r0, #0
    8af2:	f000 81b6 	beq.w	8e62 <indev_proc_press+0x4b6>
    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
    8af6:	4630      	mov	r0, r6
    8af8:	f00d f869 	bl	15bce <lv_obj_get_drag_dir>
    if(proc->types.pointer.drag_limit_out == 0) {
    8afc:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
    8b00:	4607      	mov	r7, r0
    if(proc->types.pointer.drag_limit_out == 0) {
    8b02:	07da      	lsls	r2, r3, #31
    8b04:	d440      	bmi.n	8b88 <indev_proc_press+0x1dc>
        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;
    8b06:	8a22      	ldrh	r2, [r4, #16]
    8b08:	89a3      	ldrh	r3, [r4, #12]
        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;
    8b0a:	89e1      	ldrh	r1, [r4, #14]
        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;
    8b0c:	441a      	add	r2, r3
        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;
    8b0e:	8a63      	ldrh	r3, [r4, #18]
        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;
    8b10:	b212      	sxth	r2, r2
        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;
    8b12:	440b      	add	r3, r1
    8b14:	b21b      	sxth	r3, r3
        if(allowed_dirs == LV_DRAG_DIR_HOR || allowed_dirs == LV_DRAG_DIR_BOTH) {
    8b16:	2801      	cmp	r0, #1
        proc->types.pointer.drag_sum.x += proc->types.pointer.vect.x;
    8b18:	8222      	strh	r2, [r4, #16]
        proc->types.pointer.drag_sum.y += proc->types.pointer.vect.y;
    8b1a:	8263      	strh	r3, [r4, #18]
        if(allowed_dirs == LV_DRAG_DIR_HOR || allowed_dirs == LV_DRAG_DIR_BOTH) {
    8b1c:	d013      	beq.n	8b46 <indev_proc_press+0x19a>
        if(allowed_dirs == LV_DRAG_DIR_VER || allowed_dirs == LV_DRAG_DIR_BOTH) {
    8b1e:	1e81      	subs	r1, r0, #2
    8b20:	b2c9      	uxtb	r1, r1
    8b22:	2901      	cmp	r1, #1
    8b24:	f240 82a4 	bls.w	9070 <indev_proc_press+0x6c4>
        if(allowed_dirs == LV_DRAG_DIR_ONE) {
    8b28:	2804      	cmp	r0, #4
    8b2a:	f040 819a 	bne.w	8e62 <indev_proc_press+0x4b6>
            if(LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y)) {
    8b2e:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
    8b32:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
    8b36:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
    8b3a:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
    8b3e:	b280      	uxth	r0, r0
    8b40:	b289      	uxth	r1, r1
    8b42:	4288      	cmp	r0, r1
    8b44:	d90c      	bls.n	8b60 <indev_proc_press+0x1b4>
        if((hor_en && LV_MATH_ABS(proc->types.pointer.drag_sum.x) >= indev_act->driver.drag_limit) ||
    8b46:	f8d8 1000 	ldr.w	r1, [r8]
    8b4a:	2a00      	cmp	r2, #0
    8b4c:	bfb8      	it	lt
    8b4e:	4252      	neglt	r2, r2
    8b50:	7e09      	ldrb	r1, [r1, #24]
    8b52:	b292      	uxth	r2, r2
    8b54:	4291      	cmp	r1, r2
    8b56:	d90d      	bls.n	8b74 <indev_proc_press+0x1c8>
    8b58:	f1b9 0f00 	cmp.w	r9, #0
    8b5c:	f000 8181 	beq.w	8e62 <indev_proc_press+0x4b6>
           (ver_en && LV_MATH_ABS(proc->types.pointer.drag_sum.y) >= indev_act->driver.drag_limit)) {
    8b60:	f8d8 2000 	ldr.w	r2, [r8]
    8b64:	2b00      	cmp	r3, #0
    8b66:	bfb8      	it	lt
    8b68:	425b      	neglt	r3, r3
    8b6a:	7e12      	ldrb	r2, [r2, #24]
    8b6c:	b29b      	uxth	r3, r3
    8b6e:	429a      	cmp	r2, r3
    8b70:	f200 8177 	bhi.w	8e62 <indev_proc_press+0x4b6>
            proc->types.pointer.drag_limit_out = 1;
    8b74:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    8b78:	f043 0301 	orr.w	r3, r3, #1
    8b7c:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
    if(proc->types.pointer.drag_limit_out != 0) {
    8b80:	07db      	lsls	r3, r3, #31
    8b82:	f140 816e 	bpl.w	8e62 <indev_proc_press+0x4b6>
            drag_just_started                   = true;
    8b86:	46d1      	mov	r9, sl
        if(proc->types.pointer.vect.x != 0 || proc->types.pointer.vect.y != 0) {
    8b88:	68e3      	ldr	r3, [r4, #12]
    8b8a:	2b00      	cmp	r3, #0
    8b8c:	f000 8169 	beq.w	8e62 <indev_proc_press+0x4b6>
            lv_coord_t prev_x     = drag_obj->coords.x1;
    8b90:	f9b6 3010 	ldrsh.w	r3, [r6, #16]
            lv_coord_t prev_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
    8b94:	4630      	mov	r0, r6
            lv_coord_t prev_x     = drag_obj->coords.x1;
    8b96:	9300      	str	r3, [sp, #0]
            lv_coord_t prev_y     = drag_obj->coords.y1;
    8b98:	f9b6 3012 	ldrsh.w	r3, [r6, #18]
    8b9c:	9301      	str	r3, [sp, #4]
            lv_coord_t prev_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
    8b9e:	f00c ff49 	bl	15a34 <lv_obj_get_parent>
    8ba2:	f00c ff95 	bl	15ad0 <lv_obj_get_width>
    8ba6:	9002      	str	r0, [sp, #8]
            lv_coord_t prev_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
    8ba8:	4630      	mov	r0, r6
    8baa:	f00c ff43 	bl	15a34 <lv_obj_get_parent>
    8bae:	f00c ff95 	bl	15adc <lv_obj_get_height>
    8bb2:	4683      	mov	fp, r0
            lv_coord_t act_x = lv_obj_get_x(drag_obj);
    8bb4:	4630      	mov	r0, r6
    8bb6:	f00c ff66 	bl	15a86 <lv_obj_get_x>
    8bba:	4682      	mov	sl, r0
            lv_coord_t act_y = lv_obj_get_y(drag_obj);
    8bbc:	4630      	mov	r0, r6
    8bbe:	f00c ff75 	bl	15aac <lv_obj_get_y>
            if(allowed_dirs == LV_DRAG_DIR_BOTH) {
    8bc2:	2f03      	cmp	r7, #3
            lv_coord_t act_y = lv_obj_get_y(drag_obj);
    8bc4:	4602      	mov	r2, r0
            if(allowed_dirs == LV_DRAG_DIR_BOTH) {
    8bc6:	f040 80c3 	bne.w	8d50 <indev_proc_press+0x3a4>
                if(drag_just_started) {
    8bca:	f1b9 0f00 	cmp.w	r9, #0
    8bce:	d00d      	beq.n	8bec <indev_proc_press+0x240>
                    act_x += proc->types.pointer.drag_sum.x;
    8bd0:	8a20      	ldrh	r0, [r4, #16]
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
    8bd2:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
                    act_x += proc->types.pointer.drag_sum.x;
    8bd6:	eb0a 0100 	add.w	r1, sl, r0
                    act_y += proc->types.pointer.drag_sum.y;
    8bda:	8a60      	ldrh	r0, [r4, #18]
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
    8bdc:	f367 0384 	bfi	r3, r7, #2, #3
                    act_y += proc->types.pointer.drag_sum.y;
    8be0:	4402      	add	r2, r0
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_BOTH;
    8be2:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
                    act_x += proc->types.pointer.drag_sum.x;
    8be6:	fa0f fa81 	sxth.w	sl, r1
                    act_y += proc->types.pointer.drag_sum.y;
    8bea:	b212      	sxth	r2, r2
                act_x += proc->types.pointer.vect.x;
    8bec:	89a0      	ldrh	r0, [r4, #12]
    8bee:	eb0a 0100 	add.w	r1, sl, r0
    8bf2:	fa0f fa81 	sxth.w	sl, r1
    8bf6:	e0d0      	b.n	8d9a <indev_proc_press+0x3ee>
    8bf8:	20025cec 	.word	0x20025cec
    8bfc:	20025ce8 	.word	0x20025ce8
        proc->types.pointer.last_point.x = proc->types.pointer.act_point.x;
    8c00:	6863      	ldr	r3, [r4, #4]
    8c02:	60a3      	str	r3, [r4, #8]
        if(proc->types.pointer.act_obj != NULL) {
    8c04:	2e00      	cmp	r6, #0
    8c06:	d163      	bne.n	8cd0 <indev_proc_press+0x324>
        proc->types.pointer.act_obj  = indev_obj_act; /*Save the pressed object*/
    8c08:	682b      	ldr	r3, [r5, #0]
        proc->types.pointer.last_obj = indev_obj_act;
    8c0a:	e9c4 3306 	strd	r3, r3, [r4, #24]
        if(indev_obj_act != NULL) {
    8c0e:	2b00      	cmp	r3, #0
    8c10:	f43f af18 	beq.w	8a44 <indev_proc_press+0x98>
            proc->types.pointer.gesture_sum.x  = 0;
    8c14:	2600      	movs	r6, #0
            proc->pr_timestamp                 = lv_tick_get();
    8c16:	f011 ffac 	bl	1ab72 <lv_tick_get>
            proc->types.pointer.drag_limit_out = 0;
    8c1a:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
            proc->long_pr_sent                 = 0;
    8c1e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
            proc->types.pointer.drag_limit_out = 0;
    8c22:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
            proc->types.pointer.drag_sum.x     = 0;
    8c26:	e9c4 6603 	strd	r6, r6, [r4, #12]
            proc->pr_timestamp                 = lv_tick_get();
    8c2a:	62e0      	str	r0, [r4, #44]	; 0x2c
            proc->long_pr_sent                 = 0;
    8c2c:	f36f 0300 	bfc	r3, #0, #1
            proc->types.pointer.drag_limit_out = 0;
    8c30:	f042 020c 	orr.w	r2, r2, #12
            lv_obj_t * i        = indev_obj_act;
    8c34:	6828      	ldr	r0, [r5, #0]
            proc->long_pr_sent                 = 0;
    8c36:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
            proc->types.pointer.gesture_sum.x  = 0;
    8c3a:	84e6      	strh	r6, [r4, #38]	; 0x26
            proc->types.pointer.gesture_sum.y  = 0;
    8c3c:	8526      	strh	r6, [r4, #40]	; 0x28
            proc->types.pointer.drag_limit_out = 0;
    8c3e:	f884 202a 	strb.w	r2, [r4, #42]	; 0x2a
            while(i != NULL) {
    8c42:	2800      	cmp	r0, #0
    8c44:	d15b      	bne.n	8cfe <indev_proc_press+0x352>
            if(last_top != NULL) {
    8c46:	b116      	cbz	r6, 8c4e <indev_proc_press+0x2a2>
                lv_obj_move_foreground(last_top);
    8c48:	4630      	mov	r0, r6
    8c4a:	f00c fe0c 	bl	15866 <lv_obj_move_foreground>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_PRESSED, indev_act);
    8c4e:	6828      	ldr	r0, [r5, #0]
    8c50:	f8d8 2000 	ldr.w	r2, [r8]
    8c54:	210b      	movs	r1, #11
    8c56:	69c3      	ldr	r3, [r0, #28]
    8c58:	4798      	blx	r3
            if(indev_reset_check(proc)) return;
    8c5a:	4620      	mov	r0, r4
    8c5c:	f7ff fcde 	bl	861c <indev_reset_check>
    8c60:	4602      	mov	r2, r0
    8c62:	2800      	cmp	r0, #0
    8c64:	d148      	bne.n	8cf8 <indev_proc_press+0x34c>
            lv_event_send(indev_obj_act, LV_EVENT_PRESSED, NULL);
    8c66:	4601      	mov	r1, r0
    8c68:	6828      	ldr	r0, [r5, #0]
    8c6a:	f00c fd48 	bl	156fe <lv_event_send>
            if(indev_reset_check(proc)) return;
    8c6e:	4620      	mov	r0, r4
    8c70:	f7ff fcd4 	bl	861c <indev_reset_check>
    8c74:	2800      	cmp	r0, #0
    8c76:	d13f      	bne.n	8cf8 <indev_proc_press+0x34c>
            if(indev_act->proc.wait_until_release) return;
    8c78:	f8d8 7000 	ldr.w	r7, [r8]
    8c7c:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
    8c80:	0718      	lsls	r0, r3, #28
    8c82:	d439      	bmi.n	8cf8 <indev_proc_press+0x34c>
    lv_obj_t * obj_to_focus = lv_obj_get_focused_obj(indev_obj_act);
    8c84:	6828      	ldr	r0, [r5, #0]
    8c86:	f00d fed2 	bl	16a2e <lv_obj_get_focused_obj>
    if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_CLICK_FOCUS) == false &&
    8c8a:	2120      	movs	r1, #32
    lv_obj_t * obj_to_focus = lv_obj_get_focused_obj(indev_obj_act);
    8c8c:	4606      	mov	r6, r0
    if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_CLICK_FOCUS) == false &&
    8c8e:	6828      	ldr	r0, [r5, #0]
    8c90:	f00c ffb3 	bl	15bfa <lv_obj_is_protected>
    8c94:	4602      	mov	r2, r0
    8c96:	2800      	cmp	r0, #0
    8c98:	d14b      	bne.n	8d32 <indev_proc_press+0x386>
       proc->types.pointer.last_pressed != obj_to_focus) {
    8c9a:	6c38      	ldr	r0, [r7, #64]	; 0x40
    if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_CLICK_FOCUS) == false &&
    8c9c:	4286      	cmp	r6, r0
    8c9e:	d048      	beq.n	8d32 <indev_proc_press+0x386>
            indev_click_focus(&indev_act->proc);
    8ca0:	f107 0920 	add.w	r9, r7, #32
        if(proc->types.pointer.last_pressed) {
    8ca4:	bba0      	cbnz	r0, 8d10 <indev_proc_press+0x364>
        lv_signal_send(obj_to_focus, LV_SIGNAL_FOCUS, NULL);
    8ca6:	2200      	movs	r2, #0
    8ca8:	2116      	movs	r1, #22
    8caa:	4630      	mov	r0, r6
    8cac:	f00c fd36 	bl	1571c <lv_signal_send>
        if(indev_reset_check(proc)) return;
    8cb0:	4648      	mov	r0, r9
    8cb2:	f7ff fcb3 	bl	861c <indev_reset_check>
    8cb6:	4602      	mov	r2, r0
    8cb8:	2800      	cmp	r0, #0
    8cba:	d13a      	bne.n	8d32 <indev_proc_press+0x386>
        lv_event_send(obj_to_focus, LV_EVENT_FOCUSED, NULL);
    8cbc:	210d      	movs	r1, #13
    8cbe:	4630      	mov	r0, r6
    8cc0:	f00c fd1d 	bl	156fe <lv_event_send>
        if(indev_reset_check(proc)) return;
    8cc4:	4648      	mov	r0, r9
    8cc6:	f7ff fca9 	bl	861c <indev_reset_check>
    8cca:	bb90      	cbnz	r0, 8d32 <indev_proc_press+0x386>
        proc->types.pointer.last_pressed = obj_to_focus;
    8ccc:	643e      	str	r6, [r7, #64]	; 0x40
    8cce:	e030      	b.n	8d32 <indev_proc_press+0x386>
            last_obj->signal_cb(last_obj, LV_SIGNAL_PRESS_LOST, indev_act);
    8cd0:	f8d8 2000 	ldr.w	r2, [r8]
    8cd4:	210d      	movs	r1, #13
    8cd6:	69f3      	ldr	r3, [r6, #28]
    8cd8:	4630      	mov	r0, r6
    8cda:	4798      	blx	r3
            if(indev_reset_check(proc)) return;
    8cdc:	4620      	mov	r0, r4
    8cde:	f7ff fc9d 	bl	861c <indev_reset_check>
    8ce2:	4602      	mov	r2, r0
    8ce4:	b940      	cbnz	r0, 8cf8 <indev_proc_press+0x34c>
            lv_event_send(last_obj, LV_EVENT_PRESS_LOST, NULL);
    8ce6:	2102      	movs	r1, #2
    8ce8:	4630      	mov	r0, r6
    8cea:	f00c fd08 	bl	156fe <lv_event_send>
            if(indev_reset_check(proc)) return;
    8cee:	4620      	mov	r0, r4
    8cf0:	f7ff fc94 	bl	861c <indev_reset_check>
    8cf4:	2800      	cmp	r0, #0
    8cf6:	d087      	beq.n	8c08 <indev_proc_press+0x25c>
}
    8cf8:	b005      	add	sp, #20
    8cfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if(i->top) last_top = i;
    8cfe:	f890 3032 	ldrb.w	r3, [r0, #50]	; 0x32
    8d02:	f013 0f20 	tst.w	r3, #32
    8d06:	bf18      	it	ne
    8d08:	4606      	movne	r6, r0
                i = lv_obj_get_parent(i);
    8d0a:	f00c fe93 	bl	15a34 <lv_obj_get_parent>
    8d0e:	e798      	b.n	8c42 <indev_proc_press+0x296>
            lv_signal_send(proc->types.pointer.last_pressed, LV_SIGNAL_DEFOCUS, NULL);
    8d10:	2117      	movs	r1, #23
    8d12:	f00c fd03 	bl	1571c <lv_signal_send>
            if(indev_reset_check(proc)) return;
    8d16:	4648      	mov	r0, r9
    8d18:	f7ff fc80 	bl	861c <indev_reset_check>
    8d1c:	4602      	mov	r2, r0
    8d1e:	b940      	cbnz	r0, 8d32 <indev_proc_press+0x386>
            lv_event_send(proc->types.pointer.last_pressed, LV_EVENT_DEFOCUSED, NULL);
    8d20:	210e      	movs	r1, #14
    8d22:	6c38      	ldr	r0, [r7, #64]	; 0x40
    8d24:	f00c fceb 	bl	156fe <lv_event_send>
            if(indev_reset_check(proc)) return;
    8d28:	4648      	mov	r0, r9
    8d2a:	f7ff fc77 	bl	861c <indev_reset_check>
    8d2e:	2800      	cmp	r0, #0
    8d30:	d0b9      	beq.n	8ca6 <indev_proc_press+0x2fa>
            if(indev_reset_check(proc)) return;
    8d32:	4620      	mov	r0, r4
    8d34:	f7ff fc72 	bl	861c <indev_reset_check>
    8d38:	2800      	cmp	r0, #0
    8d3a:	f43f ae83 	beq.w	8a44 <indev_proc_press+0x98>
    8d3e:	e7db      	b.n	8cf8 <indev_proc_press+0x34c>
    else if(proc->types.pointer.drag_throw_vect.x > 0)
    8d40:	f43f ae9d 	beq.w	8a7e <indev_proc_press+0xd2>
        proc->types.pointer.drag_throw_vect.x--;
    8d44:	1e7a      	subs	r2, r7, #1
    8d46:	e699      	b.n	8a7c <indev_proc_press+0xd0>
    else if(proc->types.pointer.drag_throw_vect.y > 0)
    8d48:	f43f ae9e 	beq.w	8a88 <indev_proc_press+0xdc>
        proc->types.pointer.drag_throw_vect.y--;
    8d4c:	3b01      	subs	r3, #1
    8d4e:	e69a      	b.n	8a86 <indev_proc_press+0xda>
            else if(allowed_dirs == LV_DRAG_DIR_HOR) {
    8d50:	2f01      	cmp	r7, #1
    8d52:	d111      	bne.n	8d78 <indev_proc_press+0x3cc>
                if(drag_just_started) {
    8d54:	f1b9 0f00 	cmp.w	r9, #0
    8d58:	f43f af48 	beq.w	8bec <indev_proc_press+0x240>
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;
    8d5c:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
                    act_x += proc->types.pointer.drag_sum.x;
    8d60:	8a20      	ldrh	r0, [r4, #16]
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;
    8d62:	f367 0384 	bfi	r3, r7, #2, #3
    8d66:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
                    proc->types.pointer.drag_sum.y = 0;
    8d6a:	2300      	movs	r3, #0
                    act_x += proc->types.pointer.drag_sum.x;
    8d6c:	eb0a 0100 	add.w	r1, sl, r0
                    proc->types.pointer.drag_sum.y = 0;
    8d70:	8263      	strh	r3, [r4, #18]
                    act_x += proc->types.pointer.drag_sum.x;
    8d72:	fa0f fa81 	sxth.w	sl, r1
    8d76:	e739      	b.n	8bec <indev_proc_press+0x240>
            else if(allowed_dirs == LV_DRAG_DIR_VER) {
    8d78:	2f02      	cmp	r7, #2
    8d7a:	f040 812e 	bne.w	8fda <indev_proc_press+0x62e>
                if(drag_just_started) {
    8d7e:	f1b9 0f00 	cmp.w	r9, #0
    8d82:	d00a      	beq.n	8d9a <indev_proc_press+0x3ee>
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;
    8d84:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
                    act_y += proc->types.pointer.drag_sum.y;
    8d88:	8a60      	ldrh	r0, [r4, #18]
                    proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;
    8d8a:	f367 0384 	bfi	r3, r7, #2, #3
    8d8e:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
                    proc->types.pointer.drag_sum.x = 0;
    8d92:	2300      	movs	r3, #0
                    act_y += proc->types.pointer.drag_sum.y;
    8d94:	4402      	add	r2, r0
                    proc->types.pointer.drag_sum.x = 0;
    8d96:	8223      	strh	r3, [r4, #16]
                    act_y += proc->types.pointer.drag_sum.y;
    8d98:	b212      	sxth	r2, r2
            if(allowed_dirs == LV_DRAG_DIR_VER ||
    8d9a:	1ebb      	subs	r3, r7, #2
    8d9c:	b2db      	uxtb	r3, r3
    8d9e:	2b01      	cmp	r3, #1
    8da0:	d90f      	bls.n	8dc2 <indev_proc_press+0x416>
               allowed_dirs == LV_DRAG_DIR_BOTH ||
    8da2:	2f04      	cmp	r7, #4
    8da4:	d110      	bne.n	8dc8 <indev_proc_press+0x41c>
                LV_MATH_ABS(proc->types.pointer.drag_sum.x) < LV_MATH_ABS(proc->types.pointer.drag_sum.y))) {
    8da6:	f9b4 0010 	ldrsh.w	r0, [r4, #16]
    8daa:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
    8dae:	2800      	cmp	r0, #0
    8db0:	bfb8      	it	lt
    8db2:	4240      	neglt	r0, r0
    8db4:	2b00      	cmp	r3, #0
    8db6:	bfb8      	it	lt
    8db8:	425b      	neglt	r3, r3
               (allowed_dirs == LV_DRAG_DIR_ONE &&
    8dba:	b280      	uxth	r0, r0
    8dbc:	b29b      	uxth	r3, r3
    8dbe:	4298      	cmp	r0, r3
    8dc0:	d202      	bcs.n	8dc8 <indev_proc_press+0x41c>
                act_y += proc->types.pointer.vect.y;
    8dc2:	89e0      	ldrh	r0, [r4, #14]
    8dc4:	4402      	add	r2, r0
    8dc6:	b212      	sxth	r2, r2
                lv_disp_get_inv_buf_size(indev_act->driver.disp); /*Get the number of currently invalidated areas*/
    8dc8:	f8d8 3000 	ldr.w	r3, [r8]
    8dcc:	9203      	str	r2, [sp, #12]
    8dce:	6918      	ldr	r0, [r3, #16]
    8dd0:	f011 fe7a 	bl	1aac8 <lv_disp_get_inv_buf_size>
            lv_obj_set_pos(drag_obj, act_x, act_y);
    8dd4:	9a03      	ldr	r2, [sp, #12]
                lv_disp_get_inv_buf_size(indev_act->driver.disp); /*Get the number of currently invalidated areas*/
    8dd6:	4607      	mov	r7, r0
            lv_obj_set_pos(drag_obj, act_x, act_y);
    8dd8:	4651      	mov	r1, sl
    8dda:	4630      	mov	r0, r6
    8ddc:	f00c fd60 	bl	158a0 <lv_obj_set_pos>
            proc->types.pointer.drag_in_prog = 1;
    8de0:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
            if(drag_obj->coords.x1 == prev_x && drag_obj->coords.y1 == prev_y) {
    8de4:	9a00      	ldr	r2, [sp, #0]
            proc->types.pointer.drag_in_prog = 1;
    8de6:	f043 0302 	orr.w	r3, r3, #2
    8dea:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
            if(drag_obj->coords.x1 == prev_x && drag_obj->coords.y1 == prev_y) {
    8dee:	f9b6 3010 	ldrsh.w	r3, [r6, #16]
    8df2:	4293      	cmp	r3, r2
    8df4:	d120      	bne.n	8e38 <indev_proc_press+0x48c>
    8df6:	f9b6 3012 	ldrsh.w	r3, [r6, #18]
    8dfa:	9a01      	ldr	r2, [sp, #4]
    8dfc:	4293      	cmp	r3, r2
    8dfe:	d11b      	bne.n	8e38 <indev_proc_press+0x48c>
                lv_coord_t act_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
    8e00:	4630      	mov	r0, r6
    8e02:	f00c fe17 	bl	15a34 <lv_obj_get_parent>
    8e06:	f00c fe63 	bl	15ad0 <lv_obj_get_width>
    8e0a:	4682      	mov	sl, r0
                lv_coord_t act_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
    8e0c:	4630      	mov	r0, r6
    8e0e:	f00c fe11 	bl	15a34 <lv_obj_get_parent>
    8e12:	f00c fe63 	bl	15adc <lv_obj_get_height>
                if(act_par_w == prev_par_w && act_par_h == prev_par_h) {
    8e16:	9b02      	ldr	r3, [sp, #8]
    8e18:	4553      	cmp	r3, sl
    8e1a:	d10d      	bne.n	8e38 <indev_proc_press+0x48c>
    8e1c:	4583      	cmp	fp, r0
    8e1e:	d10b      	bne.n	8e38 <indev_proc_press+0x48c>
                    uint16_t new_inv_buf_size = lv_disp_get_inv_buf_size(indev_act->driver.disp);
    8e20:	f8d8 3000 	ldr.w	r3, [r8]
    8e24:	6918      	ldr	r0, [r3, #16]
    8e26:	f011 fe4f 	bl	1aac8 <lv_disp_get_inv_buf_size>
                    _lv_disp_pop_from_inv_buf(indev_act->driver.disp, new_inv_buf_size - inv_buf_size);
    8e2a:	f8d8 3000 	ldr.w	r3, [r8]
    8e2e:	1bc1      	subs	r1, r0, r7
    8e30:	b289      	uxth	r1, r1
    8e32:	6918      	ldr	r0, [r3, #16]
    8e34:	f011 fe4d 	bl	1aad2 <_lv_disp_pop_from_inv_buf>
            if(drag_just_started) {
    8e38:	f1b9 0f00 	cmp.w	r9, #0
    8e3c:	d011      	beq.n	8e62 <indev_proc_press+0x4b6>
                drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_BEGIN, indev_act);
    8e3e:	f8d8 2000 	ldr.w	r2, [r8]
    8e42:	2111      	movs	r1, #17
    8e44:	69f3      	ldr	r3, [r6, #28]
    8e46:	4630      	mov	r0, r6
    8e48:	4798      	blx	r3
                if(indev_reset_check(proc)) return;
    8e4a:	4620      	mov	r0, r4
    8e4c:	f7ff fbe6 	bl	861c <indev_reset_check>
    8e50:	4602      	mov	r2, r0
    8e52:	b930      	cbnz	r0, 8e62 <indev_proc_press+0x4b6>
                lv_event_send(drag_obj, LV_EVENT_DRAG_BEGIN, NULL);
    8e54:	2108      	movs	r1, #8
    8e56:	4630      	mov	r0, r6
    8e58:	f00c fc51 	bl	156fe <lv_event_send>
                if(indev_reset_check(proc)) return;
    8e5c:	4620      	mov	r0, r4
    8e5e:	f7ff fbdd 	bl	861c <indev_reset_check>
    if(proc->types.pointer.gesture_sent) return;
    8e62:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    8e66:	0698      	lsls	r0, r3, #26
    8e68:	d456      	bmi.n	8f18 <indev_proc_press+0x56c>
    lv_obj_t * gesture_obj = proc->types.pointer.act_obj;
    8e6a:	69a6      	ldr	r6, [r4, #24]
    while(gesture_obj && lv_obj_get_gesture_parent(gesture_obj)) {
    8e6c:	2e00      	cmp	r6, #0
    8e6e:	d053      	beq.n	8f18 <indev_proc_press+0x56c>
    8e70:	4630      	mov	r0, r6
    8e72:	f00c febb 	bl	15bec <lv_obj_get_gesture_parent>
    8e76:	2800      	cmp	r0, #0
    8e78:	f040 80f0 	bne.w	905c <indev_proc_press+0x6b0>
    if((LV_MATH_ABS(proc->types.pointer.vect.x) < indev_act->driver.gesture_min_velocity) &&
    8e7c:	4a7f      	ldr	r2, [pc, #508]	; (907c <indev_proc_press+0x6d0>)
    8e7e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    8e82:	6812      	ldr	r2, [r2, #0]
    8e84:	ea83 77e3 	eor.w	r7, r3, r3, asr #31
    8e88:	7e91      	ldrb	r1, [r2, #26]
    8e8a:	eba7 77e3 	sub.w	r7, r7, r3, asr #31
    8e8e:	b2bf      	uxth	r7, r7
    8e90:	428f      	cmp	r7, r1
    8e92:	f9b4 c00e 	ldrsh.w	ip, [r4, #14]
    8e96:	d208      	bcs.n	8eaa <indev_proc_press+0x4fe>
       (LV_MATH_ABS(proc->types.pointer.vect.y) < indev_act->driver.gesture_min_velocity)) {
    8e98:	ea8c 77ec 	eor.w	r7, ip, ip, asr #31
    8e9c:	eba7 77ec 	sub.w	r7, r7, ip, asr #31
    if((LV_MATH_ABS(proc->types.pointer.vect.x) < indev_act->driver.gesture_min_velocity) &&
    8ea0:	b2bf      	uxth	r7, r7
    8ea2:	42b9      	cmp	r1, r7
        proc->types.pointer.gesture_sum.x = 0;
    8ea4:	bf84      	itt	hi
    8ea6:	84e0      	strhhi	r0, [r4, #38]	; 0x26
        proc->types.pointer.gesture_sum.y = 0;
    8ea8:	8520      	strhhi	r0, [r4, #40]	; 0x28
    proc->types.pointer.gesture_sum.x += proc->types.pointer.vect.x;
    8eaa:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
    8eac:	440b      	add	r3, r1
    proc->types.pointer.gesture_sum.y += proc->types.pointer.vect.y;
    8eae:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    proc->types.pointer.gesture_sum.x += proc->types.pointer.vect.x;
    8eb0:	b21b      	sxth	r3, r3
    proc->types.pointer.gesture_sum.y += proc->types.pointer.vect.y;
    8eb2:	4461      	add	r1, ip
    8eb4:	b209      	sxth	r1, r1
    proc->types.pointer.gesture_sum.x += proc->types.pointer.vect.x;
    8eb6:	84e3      	strh	r3, [r4, #38]	; 0x26
    proc->types.pointer.gesture_sum.y += proc->types.pointer.vect.y;
    8eb8:	8521      	strh	r1, [r4, #40]	; 0x28
    if((LV_MATH_ABS(proc->types.pointer.gesture_sum.x) > indev_act->driver.gesture_limit) ||
    8eba:	ea83 77e3 	eor.w	r7, r3, r3, asr #31
    8ebe:	f892 c01b 	ldrb.w	ip, [r2, #27]
    8ec2:	eba7 77e3 	sub.w	r7, r7, r3, asr #31
    8ec6:	b2bf      	uxth	r7, r7
    8ec8:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
    8ecc:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
    8ed0:	4567      	cmp	r7, ip
    8ed2:	b280      	uxth	r0, r0
    8ed4:	d801      	bhi.n	8eda <indev_proc_press+0x52e>
    8ed6:	4584      	cmp	ip, r0
    8ed8:	d21e      	bcs.n	8f18 <indev_proc_press+0x56c>
        proc->types.pointer.gesture_sent = 1;
    8eda:	f894 c02a 	ldrb.w	ip, [r4, #42]	; 0x2a
        if(LV_MATH_ABS(proc->types.pointer.gesture_sum.x) > LV_MATH_ABS(proc->types.pointer.gesture_sum.y)) {
    8ede:	4287      	cmp	r7, r0
        proc->types.pointer.gesture_sent = 1;
    8ee0:	f04c 0c20 	orr.w	ip, ip, #32
    8ee4:	f884 c02a 	strb.w	ip, [r4, #42]	; 0x2a
        if(LV_MATH_ABS(proc->types.pointer.gesture_sum.x) > LV_MATH_ABS(proc->types.pointer.gesture_sum.y)) {
    8ee8:	f240 80bd 	bls.w	9066 <indev_proc_press+0x6ba>
            if(proc->types.pointer.gesture_sum.x > 0)
    8eec:	2b00      	cmp	r3, #0
                proc->types.pointer.gesture_dir = LV_GESTURE_DIR_RIGHT;
    8eee:	bfcc      	ite	gt
    8ef0:	2303      	movgt	r3, #3
                proc->types.pointer.gesture_dir = LV_GESTURE_DIR_LEFT;
    8ef2:	2302      	movle	r3, #2
        gesture_obj->signal_cb(gesture_obj, LV_SIGNAL_GESTURE, indev_act);
    8ef4:	2114      	movs	r1, #20
                proc->types.pointer.gesture_dir = LV_GESTURE_DIR_TOP;
    8ef6:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
        gesture_obj->signal_cb(gesture_obj, LV_SIGNAL_GESTURE, indev_act);
    8efa:	4630      	mov	r0, r6
    8efc:	69f3      	ldr	r3, [r6, #28]
    8efe:	4798      	blx	r3
        if(indev_reset_check(proc)) return;
    8f00:	4620      	mov	r0, r4
    8f02:	f7ff fb8b 	bl	861c <indev_reset_check>
    8f06:	4602      	mov	r2, r0
    8f08:	b930      	cbnz	r0, 8f18 <indev_proc_press+0x56c>
        lv_event_send(gesture_obj, LV_EVENT_GESTURE, NULL);
    8f0a:	210b      	movs	r1, #11
    8f0c:	4630      	mov	r0, r6
    8f0e:	f00c fbf6 	bl	156fe <lv_event_send>
        if(indev_reset_check(proc)) return;
    8f12:	4620      	mov	r0, r4
    8f14:	f7ff fb82 	bl	861c <indev_reset_check>
        if(indev_reset_check(proc)) return;
    8f18:	4620      	mov	r0, r4
    8f1a:	f7ff fb7f 	bl	861c <indev_reset_check>
    8f1e:	2800      	cmp	r0, #0
    8f20:	f47f aeea 	bne.w	8cf8 <indev_proc_press+0x34c>
        if(proc->types.pointer.drag_in_prog == 0 && proc->long_pr_sent == 0) {
    8f24:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    8f28:	0799      	lsls	r1, r3, #30
    8f2a:	f53f aee5 	bmi.w	8cf8 <indev_proc_press+0x34c>
    8f2e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    8f32:	4e52      	ldr	r6, [pc, #328]	; (907c <indev_proc_press+0x6d0>)
    8f34:	f013 0f01 	tst.w	r3, #1
    8f38:	d12e      	bne.n	8f98 <indev_proc_press+0x5ec>
            if(lv_tick_elaps(proc->pr_timestamp) > indev_act->driver.long_press_time) {
    8f3a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    8f3c:	f011 fe26 	bl	1ab8c <lv_tick_elaps>
    8f40:	6832      	ldr	r2, [r6, #0]
    8f42:	8b93      	ldrh	r3, [r2, #28]
    8f44:	4298      	cmp	r0, r3
    8f46:	d91d      	bls.n	8f84 <indev_proc_press+0x5d8>
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS, indev_act);
    8f48:	6828      	ldr	r0, [r5, #0]
    8f4a:	210f      	movs	r1, #15
    8f4c:	69c3      	ldr	r3, [r0, #28]
    8f4e:	4798      	blx	r3
                if(indev_reset_check(proc)) return;
    8f50:	4620      	mov	r0, r4
    8f52:	f7ff fb63 	bl	861c <indev_reset_check>
    8f56:	4602      	mov	r2, r0
    8f58:	2800      	cmp	r0, #0
    8f5a:	f47f aecd 	bne.w	8cf8 <indev_proc_press+0x34c>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED, NULL);
    8f5e:	2104      	movs	r1, #4
    8f60:	6828      	ldr	r0, [r5, #0]
    8f62:	f00c fbcc 	bl	156fe <lv_event_send>
                if(indev_reset_check(proc)) return;
    8f66:	4620      	mov	r0, r4
    8f68:	f7ff fb58 	bl	861c <indev_reset_check>
    8f6c:	2800      	cmp	r0, #0
    8f6e:	f47f aec3 	bne.w	8cf8 <indev_proc_press+0x34c>
                proc->long_pr_sent = 1;
    8f72:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    8f76:	f043 0301 	orr.w	r3, r3, #1
    8f7a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
                proc->longpr_rep_timestamp = lv_tick_get();
    8f7e:	f011 fdf8 	bl	1ab72 <lv_tick_get>
    8f82:	6320      	str	r0, [r4, #48]	; 0x30
        if(proc->types.pointer.drag_in_prog == 0 && proc->long_pr_sent == 1) {
    8f84:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
    8f88:	079b      	lsls	r3, r3, #30
    8f8a:	f53f aeb5 	bmi.w	8cf8 <indev_proc_press+0x34c>
    8f8e:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
    8f92:	07da      	lsls	r2, r3, #31
    8f94:	f57f aeb0 	bpl.w	8cf8 <indev_proc_press+0x34c>
            if(lv_tick_elaps(proc->longpr_rep_timestamp) > indev_act->driver.long_press_rep_time) {
    8f98:	6b20      	ldr	r0, [r4, #48]	; 0x30
    8f9a:	f011 fdf7 	bl	1ab8c <lv_tick_elaps>
    8f9e:	6832      	ldr	r2, [r6, #0]
    8fa0:	8bd3      	ldrh	r3, [r2, #30]
    8fa2:	4298      	cmp	r0, r3
    8fa4:	f67f aea8 	bls.w	8cf8 <indev_proc_press+0x34c>
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS_REP, indev_act);
    8fa8:	6828      	ldr	r0, [r5, #0]
    8faa:	2110      	movs	r1, #16
    8fac:	69c3      	ldr	r3, [r0, #28]
    8fae:	4798      	blx	r3
                if(indev_reset_check(proc)) return;
    8fb0:	4620      	mov	r0, r4
    8fb2:	f7ff fb33 	bl	861c <indev_reset_check>
    8fb6:	4602      	mov	r2, r0
    8fb8:	2800      	cmp	r0, #0
    8fba:	f47f ae9d 	bne.w	8cf8 <indev_proc_press+0x34c>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED_REPEAT, NULL);
    8fbe:	2105      	movs	r1, #5
    8fc0:	6828      	ldr	r0, [r5, #0]
    8fc2:	f00c fb9c 	bl	156fe <lv_event_send>
                if(indev_reset_check(proc)) return;
    8fc6:	4620      	mov	r0, r4
    8fc8:	f7ff fb28 	bl	861c <indev_reset_check>
    8fcc:	2800      	cmp	r0, #0
    8fce:	f47f ae93 	bne.w	8cf8 <indev_proc_press+0x34c>
                proc->longpr_rep_timestamp = lv_tick_get();
    8fd2:	f011 fdce 	bl	1ab72 <lv_tick_get>
    8fd6:	6320      	str	r0, [r4, #48]	; 0x30
    8fd8:	e68e      	b.n	8cf8 <indev_proc_press+0x34c>
            else if(allowed_dirs == LV_DRAG_DIR_ONE) {
    8fda:	2f04      	cmp	r7, #4
    8fdc:	f47f aedd 	bne.w	8d9a <indev_proc_press+0x3ee>
                if(drag_just_started) {
    8fe0:	f1b9 0f00 	cmp.w	r9, #0
    8fe4:	d01e      	beq.n	9024 <indev_proc_press+0x678>
                    if(LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y)) {
    8fe6:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
    8fea:	f9b4 0012 	ldrsh.w	r0, [r4, #18]
    8fee:	ea83 7ee3 	eor.w	lr, r3, r3, asr #31
    8ff2:	ea80 7ce0 	eor.w	ip, r0, r0, asr #31
    8ff6:	ebae 7ee3 	sub.w	lr, lr, r3, asr #31
    8ffa:	ebac 7ce0 	sub.w	ip, ip, r0, asr #31
    8ffe:	fa1f fc8c 	uxth.w	ip, ip
    9002:	fa1f fe8e 	uxth.w	lr, lr
    9006:	45e6      	cmp	lr, ip
    9008:	f894 c02a 	ldrb.w	ip, [r4, #42]	; 0x2a
    900c:	d91a      	bls.n	9044 <indev_proc_press+0x698>
                        proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;
    900e:	2001      	movs	r0, #1
    9010:	f360 0c84 	bfi	ip, r0, #2, #3
                        proc->types.pointer.drag_sum.y = 0;
    9014:	2000      	movs	r0, #0
                        act_x += proc->types.pointer.drag_sum.x;
    9016:	eb0a 0103 	add.w	r1, sl, r3
                        proc->types.pointer.drag_dir = LV_DRAG_DIR_HOR;
    901a:	f884 c02a 	strb.w	ip, [r4, #42]	; 0x2a
                        proc->types.pointer.drag_sum.y = 0;
    901e:	8260      	strh	r0, [r4, #18]
                        act_x += proc->types.pointer.drag_sum.x;
    9020:	fa0f fa81 	sxth.w	sl, r1
                LV_MATH_ABS(proc->types.pointer.drag_sum.x) > LV_MATH_ABS(proc->types.pointer.drag_sum.y))) {
    9024:	f9b4 0010 	ldrsh.w	r0, [r4, #16]
    9028:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
    902c:	2800      	cmp	r0, #0
    902e:	bfb8      	it	lt
    9030:	4240      	neglt	r0, r0
    9032:	2b00      	cmp	r3, #0
    9034:	bfb8      	it	lt
    9036:	425b      	neglt	r3, r3
               (allowed_dirs == LV_DRAG_DIR_ONE &&
    9038:	b280      	uxth	r0, r0
    903a:	b29b      	uxth	r3, r3
    903c:	4298      	cmp	r0, r3
    903e:	f63f add5 	bhi.w	8bec <indev_proc_press+0x240>
    9042:	e6aa      	b.n	8d9a <indev_proc_press+0x3ee>
                        proc->types.pointer.drag_dir = LV_DRAG_DIR_VER;
    9044:	4663      	mov	r3, ip
    9046:	f04f 0c02 	mov.w	ip, #2
    904a:	f36c 0384 	bfi	r3, ip, #2, #3
    904e:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
                        proc->types.pointer.drag_sum.x = 0;
    9052:	2300      	movs	r3, #0
                        act_y += proc->types.pointer.drag_sum.y;
    9054:	4402      	add	r2, r0
                        proc->types.pointer.drag_sum.x = 0;
    9056:	8223      	strh	r3, [r4, #16]
                        act_y += proc->types.pointer.drag_sum.y;
    9058:	b212      	sxth	r2, r2
    905a:	e7e3      	b.n	9024 <indev_proc_press+0x678>
        gesture_obj = lv_obj_get_parent(gesture_obj);
    905c:	4630      	mov	r0, r6
    905e:	f00c fce9 	bl	15a34 <lv_obj_get_parent>
    9062:	4606      	mov	r6, r0
    9064:	e702      	b.n	8e6c <indev_proc_press+0x4c0>
            if(proc->types.pointer.gesture_sum.y > 0)
    9066:	2900      	cmp	r1, #0
                proc->types.pointer.gesture_dir = LV_GESTURE_DIR_BOTTOM;
    9068:	bfcc      	ite	gt
    906a:	2301      	movgt	r3, #1
                proc->types.pointer.gesture_dir = LV_GESTURE_DIR_TOP;
    906c:	2300      	movle	r3, #0
    906e:	e741      	b.n	8ef4 <indev_proc_press+0x548>
        if((hor_en && LV_MATH_ABS(proc->types.pointer.drag_sum.x) >= indev_act->driver.drag_limit) ||
    9070:	2803      	cmp	r0, #3
    9072:	f47f ad75 	bne.w	8b60 <indev_proc_press+0x1b4>
                ver_en = true;
    9076:	46d1      	mov	r9, sl
    9078:	e565      	b.n	8b46 <indev_proc_press+0x19a>
    907a:	bf00      	nop
    907c:	20025ce8 	.word	0x20025ce8

00009080 <_lv_indev_read_task>:
{
    9080:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    indev_act = task->user_data;
    9084:	68c0      	ldr	r0, [r0, #12]
    9086:	4d35      	ldr	r5, [pc, #212]	; (915c <_lv_indev_read_task+0xdc>)
    if(indev_act->driver.disp == NULL) return; /*Not assigned to any displays*/
    9088:	6903      	ldr	r3, [r0, #16]
    indev_act = task->user_data;
    908a:	6028      	str	r0, [r5, #0]
    if(indev_act->driver.disp == NULL) return; /*Not assigned to any displays*/
    908c:	2b00      	cmp	r3, #0
    908e:	d048      	beq.n	9122 <_lv_indev_read_task+0xa2>
    indev_proc_reset_query_handler(indev_act);
    9090:	f7ff fad2 	bl	8638 <indev_proc_reset_query_handler>
    if(indev_act->proc.disabled) return;
    9094:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
    9098:	075b      	lsls	r3, r3, #29
    909a:	d442      	bmi.n	9122 <_lv_indev_read_task+0xa2>
        indev_obj_act = NULL;
    909c:	4f30      	ldr	r7, [pc, #192]	; (9160 <_lv_indev_read_task+0xe0>)
    909e:	46b8      	mov	r8, r7
        more_to_read = _lv_indev_read(indev_act, &data);
    90a0:	4669      	mov	r1, sp
    90a2:	6828      	ldr	r0, [r5, #0]
    90a4:	f011 fd42 	bl	1ab2c <_lv_indev_read>
    90a8:	4606      	mov	r6, r0
        indev_proc_reset_query_handler(indev_act);
    90aa:	6828      	ldr	r0, [r5, #0]
    90ac:	f7ff fac4 	bl	8638 <indev_proc_reset_query_handler>
        indev_obj_act = NULL;
    90b0:	2300      	movs	r3, #0
    90b2:	603b      	str	r3, [r7, #0]
        indev_act->proc.state = data.state;
    90b4:	f89d 300e 	ldrb.w	r3, [sp, #14]
        if(indev_act->proc.state == LV_INDEV_STATE_PR) {
    90b8:	2b01      	cmp	r3, #1
        indev_act->proc.state = data.state;
    90ba:	f880 3020 	strb.w	r3, [r0, #32]
        if(indev_act->proc.state == LV_INDEV_STATE_PR) {
    90be:	d105      	bne.n	90cc <_lv_indev_read_task+0x4c>
            indev_act->driver.disp->last_activity_time = lv_tick_get();
    90c0:	6904      	ldr	r4, [r0, #16]
    90c2:	f011 fd56 	bl	1ab72 <lv_tick_get>
    90c6:	f8c4 0180 	str.w	r0, [r4, #384]	; 0x180
    90ca:	e006      	b.n	90da <_lv_indev_read_task+0x5a>
        else if(indev_act->driver.type == LV_INDEV_TYPE_ENCODER && data.enc_diff) {
    90cc:	7803      	ldrb	r3, [r0, #0]
    90ce:	2b04      	cmp	r3, #4
    90d0:	d103      	bne.n	90da <_lv_indev_read_task+0x5a>
    90d2:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
    90d6:	2b00      	cmp	r3, #0
    90d8:	d1f2      	bne.n	90c0 <_lv_indev_read_task+0x40>
        if(indev_act->driver.type == LV_INDEV_TYPE_POINTER) {
    90da:	682c      	ldr	r4, [r5, #0]
    90dc:	7823      	ldrb	r3, [r4, #0]
    90de:	2b01      	cmp	r3, #1
    90e0:	d122      	bne.n	9128 <_lv_indev_read_task+0xa8>
    if(i->cursor != NULL &&
    90e2:	6da0      	ldr	r0, [r4, #88]	; 0x58
    90e4:	b148      	cbz	r0, 90fa <_lv_indev_read_task+0x7a>
    90e6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    90e8:	9b00      	ldr	r3, [sp, #0]
    90ea:	429a      	cmp	r2, r3
    90ec:	d005      	beq.n	90fa <_lv_indev_read_task+0x7a>
        lv_obj_set_pos(i->cursor, data->point.x, data->point.y);
    90ee:	f9bd 2002 	ldrsh.w	r2, [sp, #2]
    90f2:	f9bd 1000 	ldrsh.w	r1, [sp]
    90f6:	f00c fbd3 	bl	158a0 <lv_obj_set_pos>
    i->proc.types.pointer.act_point.x = data->point.x;
    90fa:	9b00      	ldr	r3, [sp, #0]
    90fc:	f104 0020 	add.w	r0, r4, #32
    9100:	6263      	str	r3, [r4, #36]	; 0x24
    if(i->proc.state == LV_INDEV_STATE_PR) {
    9102:	f894 3020 	ldrb.w	r3, [r4, #32]
       i->proc.types.pointer.last_point.y == i->proc.types.pointer.act_point.y && data->state == LV_INDEV_STATE_PR) {
    9106:	2b01      	cmp	r3, #1
    9108:	d125      	bne.n	9156 <_lv_indev_read_task+0xd6>
        indev_proc_press(&i->proc);
    910a:	f7ff fc4f 	bl	89ac <indev_proc_press>
    i->proc.types.pointer.last_point.x = i->proc.types.pointer.act_point.x;
    910e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    9110:	62a3      	str	r3, [r4, #40]	; 0x28
        indev_proc_reset_query_handler(indev_act);
    9112:	6828      	ldr	r0, [r5, #0]
    9114:	f7ff fa90 	bl	8638 <indev_proc_reset_query_handler>
    } while(more_to_read);
    9118:	2e00      	cmp	r6, #0
    911a:	d1c1      	bne.n	90a0 <_lv_indev_read_task+0x20>
    indev_act     = NULL;
    911c:	602e      	str	r6, [r5, #0]
    indev_obj_act = NULL;
    911e:	f8c8 6000 	str.w	r6, [r8]
}
    9122:	b004      	add	sp, #16
    9124:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        else if(indev_act->driver.type == LV_INDEV_TYPE_KEYPAD) {
    9128:	2b03      	cmp	r3, #3
    912a:	d1f2      	bne.n	9112 <_lv_indev_read_task+0x92>
    if(i->btn_points == NULL) {
    912c:	6e23      	ldr	r3, [r4, #96]	; 0x60
    912e:	2b00      	cmp	r3, #0
    9130:	d0ef      	beq.n	9112 <_lv_indev_read_task+0x92>
    i->proc.types.pointer.act_point.x = i->btn_points[data->btn_id].x;
    9132:	9a02      	ldr	r2, [sp, #8]
    9134:	f104 0020 	add.w	r0, r4, #32
    9138:	eb03 0182 	add.w	r1, r3, r2, lsl #2
    913c:	f933 3022 	ldrsh.w	r3, [r3, r2, lsl #2]
    9140:	84a3      	strh	r3, [r4, #36]	; 0x24
    i->proc.types.pointer.act_point.y = i->btn_points[data->btn_id].y;
    9142:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
    9146:	84e3      	strh	r3, [r4, #38]	; 0x26
    if(i->proc.types.pointer.last_point.x == i->proc.types.pointer.act_point.x &&
    9148:	e9d4 3209 	ldrd	r3, r2, [r4, #36]	; 0x24
    914c:	429a      	cmp	r2, r3
    914e:	d102      	bne.n	9156 <_lv_indev_read_task+0xd6>
       i->proc.types.pointer.last_point.y == i->proc.types.pointer.act_point.y && data->state == LV_INDEV_STATE_PR) {
    9150:	f89d 300e 	ldrb.w	r3, [sp, #14]
    9154:	e7d7      	b.n	9106 <_lv_indev_read_task+0x86>
        indev_proc_release(&i->proc);
    9156:	f7ff fb59 	bl	880c <indev_proc_release>
    915a:	e7d8      	b.n	910e <_lv_indev_read_task+0x8e>
    915c:	20025ce8 	.word	0x20025ce8
    9160:	20025cec 	.word	0x20025cec

00009164 <style_prop_is_cacheble>:
}

static bool style_prop_is_cacheble(lv_style_property_t prop)
{

    switch(prop) {
    9164:	2872      	cmp	r0, #114	; 0x72
    9166:	d867      	bhi.n	9238 <style_prop_is_cacheble+0xd4>
    9168:	2853      	cmp	r0, #83	; 0x53
    916a:	d816      	bhi.n	919a <style_prop_is_cacheble+0x36>
    916c:	2833      	cmp	r0, #51	; 0x33
    916e:	d85b      	bhi.n	9228 <style_prop_is_cacheble+0xc4>
    9170:	281f      	cmp	r0, #31
    9172:	d81c      	bhi.n	91ae <style_prop_is_cacheble+0x4a>
    9174:	3801      	subs	r0, #1
    9176:	b283      	uxth	r3, r0
    9178:	2b17      	cmp	r3, #23
    917a:	d920      	bls.n	91be <style_prop_is_cacheble+0x5a>
    917c:	2000      	movs	r0, #0
    917e:	4770      	bx	lr
    9180:	2301      	movs	r3, #1
    9182:	f500 40ff 	add.w	r0, r0, #32640	; 0x7f80
    9186:	b280      	uxth	r0, r0
    9188:	fa03 f000 	lsl.w	r0, r3, r0
    918c:	f244 030b 	movw	r3, #16395	; 0x400b
    9190:	4218      	tst	r0, r3
        case LV_STYLE_OUTLINE_BLEND_MODE:
        case LV_STYLE_PATTERN_BLEND_MODE:
        case LV_STYLE_SHADOW_BLEND_MODE:
        case LV_STYLE_TEXT_BLEND_MODE:
        case LV_STYLE_VALUE_BLEND_MODE:
            return true;
    9192:	bf14      	ite	ne
    9194:	2001      	movne	r0, #1
    9196:	2000      	moveq	r0, #0
    9198:	4770      	bx	lr
    919a:	2301      	movs	r3, #1
    919c:	3854      	subs	r0, #84	; 0x54
    919e:	b280      	uxth	r0, r0
    91a0:	4083      	lsls	r3, r0
    91a2:	4835      	ldr	r0, [pc, #212]	; (9278 <style_prop_is_cacheble+0x114>)
    91a4:	4018      	ands	r0, r3
    91a6:	3800      	subs	r0, #0
    91a8:	bf18      	it	ne
    91aa:	2001      	movne	r0, #1
    91ac:	4770      	bx	lr
    91ae:	2301      	movs	r3, #1
    91b0:	3820      	subs	r0, #32
    91b2:	b280      	uxth	r0, r0
    91b4:	fa03 f000 	lsl.w	r0, r3, r0
    91b8:	f503 2371 	add.w	r3, r3, #987136	; 0xf1000
    91bc:	e7e8      	b.n	9190 <style_prop_is_cacheble+0x2c>
    91be:	2817      	cmp	r0, #23
    91c0:	d8dc      	bhi.n	917c <style_prop_is_cacheble+0x18>
    91c2:	a301      	add	r3, pc, #4	; (adr r3, 91c8 <style_prop_is_cacheble+0x64>)
    91c4:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
    91c8:	00009273 	.word	0x00009273
    91cc:	00009273 	.word	0x00009273
    91d0:	0000917d 	.word	0x0000917d
    91d4:	00009273 	.word	0x00009273
    91d8:	00009273 	.word	0x00009273
    91dc:	00009273 	.word	0x00009273
    91e0:	00009273 	.word	0x00009273
    91e4:	0000917d 	.word	0x0000917d
    91e8:	0000917d 	.word	0x0000917d
    91ec:	0000917d 	.word	0x0000917d
    91f0:	0000917d 	.word	0x0000917d
    91f4:	0000917d 	.word	0x0000917d
    91f8:	0000917d 	.word	0x0000917d
    91fc:	0000917d 	.word	0x0000917d
    9200:	0000917d 	.word	0x0000917d
    9204:	00009273 	.word	0x00009273
    9208:	00009273 	.word	0x00009273
    920c:	00009273 	.word	0x00009273
    9210:	00009273 	.word	0x00009273
    9214:	0000917d 	.word	0x0000917d
    9218:	00009273 	.word	0x00009273
    921c:	00009273 	.word	0x00009273
    9220:	00009273 	.word	0x00009273
    9224:	00009273 	.word	0x00009273
    switch(prop) {
    9228:	3840      	subs	r0, #64	; 0x40
    922a:	b280      	uxth	r0, r0
    922c:	2810      	cmp	r0, #16
    922e:	d8a5      	bhi.n	917c <style_prop_is_cacheble+0x18>
    9230:	2301      	movs	r3, #1
    9232:	4083      	lsls	r3, r0
    9234:	4811      	ldr	r0, [pc, #68]	; (927c <style_prop_is_cacheble+0x118>)
    9236:	e7b5      	b.n	91a4 <style_prop_is_cacheble+0x40>
    9238:	f248 038e 	movw	r3, #32910	; 0x808e
    923c:	4298      	cmp	r0, r3
    923e:	d811      	bhi.n	9264 <style_prop_is_cacheble+0x100>
    9240:	f248 037f 	movw	r3, #32895	; 0x807f
    9244:	4298      	cmp	r0, r3
    9246:	d89b      	bhi.n	9180 <style_prop_is_cacheble+0x1c>
    9248:	28ff      	cmp	r0, #255	; 0xff
    924a:	d012      	beq.n	9272 <style_prop_is_cacheble+0x10e>
    924c:	d806      	bhi.n	925c <style_prop_is_cacheble+0xf8>
    924e:	287f      	cmp	r0, #127	; 0x7f
    9250:	d00f      	beq.n	9272 <style_prop_is_cacheble+0x10e>
            return true;
    9252:	2891      	cmp	r0, #145	; 0x91
    9254:	bf14      	ite	ne
    9256:	2000      	movne	r0, #0
    9258:	2001      	moveq	r0, #1
    925a:	4770      	bx	lr
    925c:	f248 030c 	movw	r3, #32780	; 0x800c
    9260:	4298      	cmp	r0, r3
    9262:	e7f7      	b.n	9254 <style_prop_is_cacheble+0xf0>
    switch(prop) {
    9264:	f248 03a0 	movw	r3, #32928	; 0x80a0
    9268:	4298      	cmp	r0, r3
    926a:	d002      	beq.n	9272 <style_prop_is_cacheble+0x10e>
            return true;
    926c:	f248 03ad 	movw	r3, #32941	; 0x80ad
    9270:	e7f6      	b.n	9260 <style_prop_is_cacheble+0xfc>
    9272:	2001      	movs	r0, #1
            break;
        default:
            return false;
    }
}
    9274:	4770      	bx	lr
    9276:	bf00      	nop
    9278:	44001001 	.word	0x44001001
    927c:	00010005 	.word	0x00010005

00009280 <lv_init>:
{
    9280:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if(lv_initialized) {
    9282:	4c17      	ldr	r4, [pc, #92]	; (92e0 <lv_init+0x60>)
    9284:	7823      	ldrb	r3, [r4, #0]
    9286:	bb43      	cbnz	r3, 92da <lv_init+0x5a>
    _lv_mem_init();
    9288:	f012 f8cf 	bl	1b42a <_lv_mem_init>
    _lv_task_core_init();
    928c:	f003 fce4 	bl	cc58 <_lv_task_core_init>
    _lv_anim_core_init();
    9290:	f003 fb52 	bl	c938 <_lv_anim_core_init>
    _lv_ll_init(&LV_GC_ROOT(_lv_obj_style_trans_ll), sizeof(lv_style_trans_t));
    9294:	2110      	movs	r1, #16
    9296:	4813      	ldr	r0, [pc, #76]	; (92e4 <lv_init+0x64>)
    9298:	f011 ff78 	bl	1b18c <_lv_ll_init>
    _lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
    929c:	f44f 71c2 	mov.w	r1, #388	; 0x184
    92a0:	4811      	ldr	r0, [pc, #68]	; (92e8 <lv_init+0x68>)
    92a2:	f011 ff73 	bl	1b18c <_lv_ll_init>
    _lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
    92a6:	2164      	movs	r1, #100	; 0x64
    92a8:	4810      	ldr	r0, [pc, #64]	; (92ec <lv_init+0x6c>)
    92aa:	f011 ff6f 	bl	1b18c <_lv_ll_init>
    lv_theme_t * th = LV_THEME_DEFAULT_INIT(LV_THEME_DEFAULT_COLOR_PRIMARY, LV_THEME_DEFAULT_COLOR_SECONDARY,
    92ae:	4b10      	ldr	r3, [pc, #64]	; (92f0 <lv_init+0x70>)
    92b0:	4910      	ldr	r1, [pc, #64]	; (92f4 <lv_init+0x74>)
    92b2:	e9cd 3301 	strd	r3, r3, [sp, #4]
    92b6:	9300      	str	r3, [sp, #0]
    92b8:	2202      	movs	r2, #2
    92ba:	4608      	mov	r0, r1
    92bc:	f004 f92e 	bl	d51c <lv_theme_material_init>
    lv_theme_set_act(th);
    92c0:	f004 f8b6 	bl	d430 <lv_theme_set_act>
    _lv_refr_init();
    92c4:	f00d fc5e 	bl	16b84 <_lv_refr_init>
    _lv_indev_init();
    92c8:	f00c f995 	bl	155f6 <_lv_indev_init>
    _lv_img_decoder_init();
    92cc:	f003 f914 	bl	c4f8 <_lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
    92d0:	2001      	movs	r0, #1
    92d2:	f002 ff03 	bl	c0dc <lv_img_cache_set_size>
    lv_initialized = true;
    92d6:	2301      	movs	r3, #1
    92d8:	7023      	strb	r3, [r4, #0]
}
    92da:	b004      	add	sp, #16
    92dc:	bd10      	pop	{r4, pc}
    92de:	bf00      	nop
    92e0:	20029f4f 	.word	0x20029f4f
    92e4:	20025e48 	.word	0x20025e48
    92e8:	20025d1c 	.word	0x20025d1c
    92ec:	20025dbc 	.word	0x20025dbc
    92f0:	200004f4 	.word	0x200004f4
    92f4:	ffff0000 	.word	0xffff0000

000092f8 <lv_event_send_func>:
{
    92f8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    92fc:	461e      	mov	r6, r3
    event_temp_data.deleted = false;
    92fe:	2300      	movs	r3, #0
    9300:	4f1d      	ldr	r7, [pc, #116]	; (9378 <lv_event_send_func+0x80>)
    9302:	f88d 3008 	strb.w	r3, [sp, #8]
        event_temp_data.prev = event_temp_data_head;
    9306:	683b      	ldr	r3, [r7, #0]
    const void * event_act_data_save = event_act_data;
    9308:	f8df a070 	ldr.w	sl, [pc, #112]	; 937c <lv_event_send_func+0x84>
        event_temp_data.prev = event_temp_data_head;
    930c:	9303      	str	r3, [sp, #12]
    event_temp_data_head = &event_temp_data;
    930e:	ab01      	add	r3, sp, #4
    const void * event_act_data_save = event_act_data;
    9310:	f8da 9000 	ldr.w	r9, [sl]
{
    9314:	4680      	mov	r8, r0
    9316:	460c      	mov	r4, r1
    9318:	4615      	mov	r5, r2
    event_temp_data.obj     = obj;
    931a:	9101      	str	r1, [sp, #4]
    event_temp_data_head = &event_temp_data;
    931c:	603b      	str	r3, [r7, #0]
    event_act_data                   = data;
    931e:	f8ca 6000 	str.w	r6, [sl]
    lv_indev_t * indev_act = lv_indev_get_act();
    9322:	f7ff fb1f 	bl	8964 <lv_indev_get_act>
    if(indev_act) {
    9326:	b118      	cbz	r0, 9330 <lv_event_send_func+0x38>
        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);
    9328:	6883      	ldr	r3, [r0, #8]
    932a:	b10b      	cbz	r3, 9330 <lv_event_send_func+0x38>
    932c:	4629      	mov	r1, r5
    932e:	4798      	blx	r3
    if(event_xcb) event_xcb(obj, event);
    9330:	f1b8 0f00 	cmp.w	r8, #0
    9334:	d002      	beq.n	933c <lv_event_send_func+0x44>
    9336:	4629      	mov	r1, r5
    9338:	4620      	mov	r0, r4
    933a:	47c0      	blx	r8
    event_temp_data_head = event_temp_data_head->prev;
    933c:	683b      	ldr	r3, [r7, #0]
    event_act_data = event_act_data_save;
    933e:	f8ca 9000 	str.w	r9, [sl]
    event_temp_data_head = event_temp_data_head->prev;
    9342:	689b      	ldr	r3, [r3, #8]
    9344:	603b      	str	r3, [r7, #0]
    if(event_temp_data.deleted) {
    9346:	f89d 3008 	ldrb.w	r3, [sp, #8]
    934a:	b983      	cbnz	r3, 936e <lv_event_send_func+0x76>
    if(obj) {
    934c:	b18c      	cbz	r4, 9372 <lv_event_send_func+0x7a>
        if(obj->parent_event && obj->parent) {
    934e:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
    9352:	065a      	lsls	r2, r3, #25
    9354:	d50d      	bpl.n	9372 <lv_event_send_func+0x7a>
    9356:	6820      	ldr	r0, [r4, #0]
    9358:	b158      	cbz	r0, 9372 <lv_event_send_func+0x7a>
            lv_res_t res = lv_event_send(obj->parent, event, data);
    935a:	4632      	mov	r2, r6
    935c:	4629      	mov	r1, r5
    935e:	f00c f9ce 	bl	156fe <lv_event_send>
        return LV_RES_INV;
    9362:	1e43      	subs	r3, r0, #1
    9364:	4258      	negs	r0, r3
    9366:	4158      	adcs	r0, r3
}
    9368:	b004      	add	sp, #16
    936a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return LV_RES_INV;
    936e:	2000      	movs	r0, #0
    9370:	e7fa      	b.n	9368 <lv_event_send_func+0x70>
    return LV_RES_OK;
    9372:	2001      	movs	r0, #1
    9374:	e7f8      	b.n	9368 <lv_event_send_func+0x70>
    9376:	bf00      	nop
    9378:	20025cf4 	.word	0x20025cf4
    937c:	20025cf0 	.word	0x20025cf0

00009380 <lv_obj_get_disp>:
{
    9380:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(obj->parent == NULL)
    9382:	6803      	ldr	r3, [r0, #0]
{
    9384:	4605      	mov	r5, r0
    if(obj->parent == NULL)
    9386:	b123      	cbz	r3, 9392 <lv_obj_get_disp+0x12>
    return obj->parent;
    9388:	462b      	mov	r3, r5
    938a:	682d      	ldr	r5, [r5, #0]
    } while(par != NULL);
    938c:	2d00      	cmp	r5, #0
    938e:	d1fb      	bne.n	9388 <lv_obj_get_disp+0x8>
    9390:	461d      	mov	r5, r3
    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {
    9392:	480d      	ldr	r0, [pc, #52]	; (93c8 <lv_obj_get_disp+0x48>)
    9394:	f011 ff39 	bl	1b20a <_lv_ll_get_head>
    9398:	4604      	mov	r4, r0
    939a:	4f0b      	ldr	r7, [pc, #44]	; (93c8 <lv_obj_get_disp+0x48>)
    939c:	b90c      	cbnz	r4, 93a2 <lv_obj_get_disp+0x22>
}
    939e:	4620      	mov	r0, r4
    93a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        _LV_LL_READ(d->scr_ll, s) {
    93a2:	f104 0634 	add.w	r6, r4, #52	; 0x34
    93a6:	4630      	mov	r0, r6
    93a8:	f011 ff2f 	bl	1b20a <_lv_ll_get_head>
    93ac:	4601      	mov	r1, r0
    93ae:	b928      	cbnz	r0, 93bc <lv_obj_get_disp+0x3c>
    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {
    93b0:	4621      	mov	r1, r4
    93b2:	4638      	mov	r0, r7
    93b4:	f011 ff2f 	bl	1b216 <_lv_ll_get_next>
    93b8:	4604      	mov	r4, r0
    93ba:	e7ef      	b.n	939c <lv_obj_get_disp+0x1c>
            if(s == scr) return d;
    93bc:	428d      	cmp	r5, r1
    93be:	d0ee      	beq.n	939e <lv_obj_get_disp+0x1e>
        _LV_LL_READ(d->scr_ll, s) {
    93c0:	4630      	mov	r0, r6
    93c2:	f011 ff28 	bl	1b216 <_lv_ll_get_next>
    93c6:	e7f1      	b.n	93ac <lv_obj_get_disp+0x2c>
    93c8:	20025d1c 	.word	0x20025d1c

000093cc <lv_obj_create>:
{
    93cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    93d0:	460d      	mov	r5, r1
    if(parent == NULL) {
    93d2:	4606      	mov	r6, r0
    93d4:	2800      	cmp	r0, #0
    93d6:	d15c      	bne.n	9492 <lv_obj_create+0xc6>
        lv_disp_t * disp = lv_disp_get_default();
    93d8:	f003 f8c6 	bl	c568 <lv_disp_get_default>
        if(!disp) {
    93dc:	b918      	cbnz	r0, 93e6 <lv_obj_create+0x1a>
            return NULL;
    93de:	2400      	movs	r4, #0
}
    93e0:	4620      	mov	r0, r4
    93e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        new_obj = _lv_ll_ins_head(&disp->scr_ll);
    93e6:	3034      	adds	r0, #52	; 0x34
    93e8:	f011 fed8 	bl	1b19c <_lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
    93ec:	4604      	mov	r4, r0
    93ee:	2800      	cmp	r0, #0
    93f0:	d0f5      	beq.n	93de <lv_obj_create+0x12>
        _lv_memset_00(new_obj, sizeof(lv_obj_t));
    93f2:	213c      	movs	r1, #60	; 0x3c
    93f4:	f00c f95c 	bl	156b0 <_lv_memset_00>
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
    93f8:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
    93fc:	4630      	mov	r0, r6
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
    93fe:	f366 1346 	bfi	r3, r6, #5, #2
    9402:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
        new_obj->signal_cb = lv_obj_signal;
    9406:	4b9e      	ldr	r3, [pc, #632]	; (9680 <lv_obj_create+0x2b4>)
        new_obj->event_cb = NULL;
    9408:	61a6      	str	r6, [r4, #24]
        new_obj->signal_cb = lv_obj_signal;
    940a:	61e3      	str	r3, [r4, #28]
        new_obj->design_cb = lv_obj_design;
    940c:	4b9d      	ldr	r3, [pc, #628]	; (9684 <lv_obj_create+0x2b8>)
        new_obj->coords.x1    = 0;
    940e:	6126      	str	r6, [r4, #16]
        new_obj->design_cb = lv_obj_design;
    9410:	6223      	str	r3, [r4, #32]
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
    9412:	f003 f8af 	bl	c574 <lv_disp_get_hor_res>
    9416:	3801      	subs	r0, #1
    9418:	82a0      	strh	r0, [r4, #20]
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
    941a:	4630      	mov	r0, r6
    941c:	f003 f8bc 	bl	c598 <lv_disp_get_ver_res>
    9420:	3801      	subs	r0, #1
    9422:	82e0      	strh	r0, [r4, #22]
    new_obj->ext_draw_pad = 0;
    9424:	f04f 0800 	mov.w	r8, #0
    _lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
    9428:	213c      	movs	r1, #60	; 0x3c
    942a:	1d20      	adds	r0, r4, #4
    _lv_memset_00(&new_obj->user_data, sizeof(lv_obj_user_data_t));
    942c:	f104 0738 	add.w	r7, r4, #56	; 0x38
    _lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
    9430:	f011 feac 	bl	1b18c <_lv_ll_init>
    _lv_memset_00(&new_obj->user_data, sizeof(lv_obj_user_data_t));
    9434:	4638      	mov	r0, r7
    new_obj->ext_draw_pad = 0;
    9436:	f8a4 8030 	strh.w	r8, [r4, #48]	; 0x30
    _lv_memset_00(&new_obj->user_data, sizeof(lv_obj_user_data_t));
    943a:	2104      	movs	r1, #4
    943c:	f00c f938 	bl	156b0 <_lv_memset_00>
    new_obj->gesture_parent = parent ? 1 : 0;
    9440:	ebb6 0208 	subs.w	r2, r6, r8
    9444:	bf18      	it	ne
    9446:	2201      	movne	r2, #1
    new_obj->click        = 1;
    9448:	f640 4301 	movw	r3, #3073	; 0xc01
    944c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    9450:	8e62      	ldrh	r2, [r4, #50]	; 0x32
    new_obj->protect      = LV_PROTECT_NONE;
    9452:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34
    new_obj->click        = 1;
    9456:	f422 52ff 	bic.w	r2, r2, #8160	; 0x1fe0
    945a:	f022 021f 	bic.w	r2, r2, #31
    945e:	4313      	orrs	r3, r2
    new_obj->ext_attr = NULL;
    9460:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
    lv_style_list_init(&new_obj->style_list);
    9464:	f104 0828 	add.w	r8, r4, #40	; 0x28
    9468:	4640      	mov	r0, r8
    new_obj->click        = 1;
    946a:	8663      	strh	r3, [r4, #50]	; 0x32
    lv_style_list_init(&new_obj->style_list);
    946c:	f00d fc6a 	bl	16d44 <lv_style_list_init>
    if(copy == NULL) {
    9470:	2d00      	cmp	r5, #0
    9472:	d166      	bne.n	9542 <lv_obj_create+0x176>
        if(parent != NULL) lv_theme_apply(new_obj, LV_THEME_OBJ);
    9474:	2e00      	cmp	r6, #0
    9476:	d05f      	beq.n	9538 <lv_obj_create+0x16c>
    9478:	2102      	movs	r1, #2
    947a:	4620      	mov	r0, r4
    947c:	f003 ffde 	bl	d43c <lv_theme_apply>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
    9480:	4622      	mov	r2, r4
    9482:	2101      	movs	r1, #1
    9484:	4630      	mov	r0, r6
    9486:	69f3      	ldr	r3, [r6, #28]
    9488:	4798      	blx	r3
        lv_obj_invalidate(new_obj);
    948a:	4620      	mov	r0, r4
    948c:	f00c f9c8 	bl	15820 <lv_obj_invalidate>
    9490:	e7a6      	b.n	93e0 <lv_obj_create+0x14>
        new_obj = _lv_ll_ins_head(&parent->child_ll);
    9492:	3004      	adds	r0, #4
    9494:	f011 fe82 	bl	1b19c <_lv_ll_ins_head>
        if(new_obj == NULL) return NULL;
    9498:	4604      	mov	r4, r0
    949a:	2800      	cmp	r0, #0
    949c:	d09f      	beq.n	93de <lv_obj_create+0x12>
        new_obj->event_cb = NULL;
    949e:	f04f 0900 	mov.w	r9, #0
        _lv_memset_00(new_obj, sizeof(lv_obj_t));
    94a2:	213c      	movs	r1, #60	; 0x3c
    94a4:	f00c f904 	bl	156b0 <_lv_memset_00>
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
    94a8:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    94ac:	4648      	mov	r0, r9
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
    94ae:	f36f 1346 	bfc	r3, #5, #2
    94b2:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
        new_obj->signal_cb = lv_obj_signal;
    94b6:	4b72      	ldr	r3, [pc, #456]	; (9680 <lv_obj_create+0x2b4>)
        new_obj->parent = parent;
    94b8:	6026      	str	r6, [r4, #0]
        new_obj->signal_cb = lv_obj_signal;
    94ba:	61e3      	str	r3, [r4, #28]
        new_obj->design_cb = lv_obj_design;
    94bc:	4b71      	ldr	r3, [pc, #452]	; (9684 <lv_obj_create+0x2b8>)
        new_obj->event_cb = NULL;
    94be:	f8c4 9018 	str.w	r9, [r4, #24]
        new_obj->design_cb = lv_obj_design;
    94c2:	6223      	str	r3, [r4, #32]
        new_obj->coords.y1    = parent->coords.y1;
    94c4:	f9b6 3012 	ldrsh.w	r3, [r6, #18]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    94c8:	2732      	movs	r7, #50	; 0x32
        new_obj->coords.y1    = parent->coords.y1;
    94ca:	8263      	strh	r3, [r4, #18]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    94cc:	f04f 0a50 	mov.w	sl, #80	; 0x50
    94d0:	f9b6 8012 	ldrsh.w	r8, [r6, #18]
    94d4:	f003 f870 	bl	c5b8 <lv_disp_get_dpi>
    94d8:	fb00 a007 	mla	r0, r0, r7, sl
    94dc:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    94e0:	db26      	blt.n	9530 <lv_obj_create+0x164>
    94e2:	4648      	mov	r0, r9
    94e4:	f003 f868 	bl	c5b8 <lv_disp_get_dpi>
    94e8:	fb00 a707 	mla	r7, r0, r7, sl
    94ec:	20a0      	movs	r0, #160	; 0xa0
    94ee:	fb97 f7f0 	sdiv	r7, r7, r0
    94f2:	b23f      	sxth	r7, r7
            new_obj->coords.x1    = parent->coords.x1;
    94f4:	f9b6 3010 	ldrsh.w	r3, [r6, #16]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    94f8:	4447      	add	r7, r8
    94fa:	82e7      	strh	r7, [r4, #22]
            new_obj->coords.x1    = parent->coords.x1;
    94fc:	8223      	strh	r3, [r4, #16]
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
    94fe:	2000      	movs	r0, #0
    9500:	2764      	movs	r7, #100	; 0x64
    9502:	f04f 0950 	mov.w	r9, #80	; 0x50
    9506:	f9b6 8010 	ldrsh.w	r8, [r6, #16]
    950a:	f003 f855 	bl	c5b8 <lv_disp_get_dpi>
    950e:	fb00 9007 	mla	r0, r0, r7, r9
    9512:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    9516:	db0d      	blt.n	9534 <lv_obj_create+0x168>
    9518:	2000      	movs	r0, #0
    951a:	f003 f84d 	bl	c5b8 <lv_disp_get_dpi>
    951e:	fb00 9707 	mla	r7, r0, r7, r9
    9522:	20a0      	movs	r0, #160	; 0xa0
    9524:	fb97 f7f0 	sdiv	r7, r7, r0
    9528:	b23f      	sxth	r7, r7
    952a:	4447      	add	r7, r8
    952c:	82a7      	strh	r7, [r4, #20]
    952e:	e779      	b.n	9424 <lv_obj_create+0x58>
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
    9530:	2701      	movs	r7, #1
    9532:	e7df      	b.n	94f4 <lv_obj_create+0x128>
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
    9534:	2701      	movs	r7, #1
    9536:	e7f8      	b.n	952a <lv_obj_create+0x15e>
        else  lv_theme_apply(new_obj, LV_THEME_SCR);
    9538:	2101      	movs	r1, #1
    953a:	4620      	mov	r0, r4
    953c:	f003 ff7e 	bl	d43c <lv_theme_apply>
    if(parent != NULL) {
    9540:	e74e      	b.n	93e0 <lv_obj_create+0x14>
        lv_style_list_copy(&new_obj->style_list, &copy->style_list);
    9542:	4640      	mov	r0, r8
    9544:	f105 0128 	add.w	r1, r5, #40	; 0x28
    9548:	f00d fe93 	bl	17272 <lv_style_list_copy>
        lv_area_copy(&new_obj->coords, &copy->coords);
    954c:	f105 0110 	add.w	r1, r5, #16
    9550:	f104 0010 	add.w	r0, r4, #16
    9554:	f00c f8b2 	bl	156bc <lv_area_copy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
    9558:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
        _lv_memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
    955c:	2204      	movs	r2, #4
        new_obj->ext_draw_pad = copy->ext_draw_pad;
    955e:	8623      	strh	r3, [r4, #48]	; 0x30
        _lv_memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
    9560:	4638      	mov	r0, r7
    9562:	f105 0138 	add.w	r1, r5, #56	; 0x38
    9566:	f00c f8a7 	bl	156b8 <_lv_memcpy>
        new_obj->base_dir = copy->base_dir;
    956a:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
    956e:	f894 2033 	ldrb.w	r2, [r4, #51]	; 0x33
    9572:	f3c3 1341 	ubfx	r3, r3, #5, #2
    9576:	f363 1246 	bfi	r2, r3, #5, #2
    957a:	f884 2033 	strb.w	r2, [r4, #51]	; 0x33
        new_obj->event_cb = copy->event_cb;
    957e:	69ab      	ldr	r3, [r5, #24]
        new_obj->adv_hittest  = copy->adv_hittest;
    9580:	f894 2032 	ldrb.w	r2, [r4, #50]	; 0x32
        new_obj->event_cb = copy->event_cb;
    9584:	61a3      	str	r3, [r4, #24]
        new_obj->adv_hittest  = copy->adv_hittest;
    9586:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
    958a:	09db      	lsrs	r3, r3, #7
    958c:	f363 12c7 	bfi	r2, r3, #7, #1
    9590:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
        new_obj->click        = copy->click;
    9594:	f895 2032 	ldrb.w	r2, [r5, #50]	; 0x32
    9598:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
    959c:	f362 0300 	bfi	r3, r2, #0, #1
    95a0:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
        new_obj->drag         = copy->drag;
    95a4:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
    95a8:	f894 2032 	ldrb.w	r2, [r4, #50]	; 0x32
    95ac:	f3c3 0340 	ubfx	r3, r3, #1, #1
    95b0:	f363 0241 	bfi	r2, r3, #1, #1
    95b4:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
        new_obj->drag_dir     = copy->drag_dir;
    95b8:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
    95bc:	f894 2033 	ldrb.w	r2, [r4, #51]	; 0x33
    95c0:	f3c3 0382 	ubfx	r3, r3, #2, #3
    95c4:	f363 0284 	bfi	r2, r3, #2, #3
    95c8:	f884 2033 	strb.w	r2, [r4, #51]	; 0x33
        new_obj->drag_throw   = copy->drag_throw;
    95cc:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
    95d0:	f894 2032 	ldrb.w	r2, [r4, #50]	; 0x32
    95d4:	f3c3 0380 	ubfx	r3, r3, #2, #1
    95d8:	f363 0282 	bfi	r2, r3, #2, #1
    95dc:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
        new_obj->drag_parent  = copy->drag_parent;
    95e0:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
    95e4:	b2d2      	uxtb	r2, r2
    95e6:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    95ea:	f363 02c3 	bfi	r2, r3, #3, #1
    95ee:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
        new_obj->hidden       = copy->hidden;
    95f2:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
    95f6:	b2d2      	uxtb	r2, r2
    95f8:	f3c3 1300 	ubfx	r3, r3, #4, #1
    95fc:	f363 1204 	bfi	r2, r3, #4, #1
    9600:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
        new_obj->top          = copy->top;
    9604:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
    9608:	b2d2      	uxtb	r2, r2
    960a:	f3c3 1340 	ubfx	r3, r3, #5, #1
    960e:	f363 1245 	bfi	r2, r3, #5, #1
    9612:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
        new_obj->parent_event = copy->parent_event;
    9616:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
    961a:	b2d2      	uxtb	r2, r2
    961c:	f3c3 1380 	ubfx	r3, r3, #6, #1
    9620:	f363 1286 	bfi	r2, r3, #6, #1
    9624:	f884 2032 	strb.w	r2, [r4, #50]	; 0x32
        new_obj->protect      = copy->protect;
    9628:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
    962c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        new_obj->gesture_parent = copy->gesture_parent;
    9630:	f895 2033 	ldrb.w	r2, [r5, #51]	; 0x33
    9634:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
    9638:	f362 0300 	bfi	r3, r2, #0, #1
    963c:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
        new_obj->focus_parent = copy->focus_parent;
    9640:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
    9644:	f894 2033 	ldrb.w	r2, [r4, #51]	; 0x33
    9648:	f3c3 0340 	ubfx	r3, r3, #1, #1
    964c:	f363 0241 	bfi	r2, r3, #1, #1
    9650:	f884 2033 	strb.w	r2, [r4, #51]	; 0x33
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
    9654:	682b      	ldr	r3, [r5, #0]
    9656:	b173      	cbz	r3, 9676 <lv_obj_create+0x2aa>
    9658:	2e00      	cmp	r6, #0
    965a:	f43f aec1 	beq.w	93e0 <lv_obj_create+0x14>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
    965e:	4628      	mov	r0, r5
    9660:	f00c fa11 	bl	15a86 <lv_obj_get_x>
    9664:	4601      	mov	r1, r0
    9666:	4628      	mov	r0, r5
    9668:	f00c fa20 	bl	15aac <lv_obj_get_y>
    966c:	4602      	mov	r2, r0
    966e:	4620      	mov	r0, r4
    9670:	f00c f916 	bl	158a0 <lv_obj_set_pos>
    if(parent != NULL) {
    9674:	e704      	b.n	9480 <lv_obj_create+0xb4>
    9676:	2e00      	cmp	r6, #0
    9678:	f47f af02 	bne.w	9480 <lv_obj_create+0xb4>
    967c:	e6b0      	b.n	93e0 <lv_obj_create+0x14>
    967e:	bf00      	nop
    9680:	0000a391 	.word	0x0000a391
    9684:	00016287 	.word	0x00016287

00009688 <trans_del>:
{
    9688:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    968c:	4607      	mov	r7, r0
    tr = _lv_ll_get_tail(&LV_GC_ROOT(_lv_obj_style_trans_ll));
    968e:	481a      	ldr	r0, [pc, #104]	; (96f8 <trans_del+0x70>)
{
    9690:	460d      	mov	r5, r1
    9692:	4616      	mov	r6, r2
    9694:	4698      	mov	r8, r3
    tr = _lv_ll_get_tail(&LV_GC_ROOT(_lv_obj_style_trans_ll));
    9696:	f011 fdbb 	bl	1b210 <_lv_ll_get_tail>
    969a:	4604      	mov	r4, r0
        tr_prev = _lv_ll_get_prev(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);
    969c:	f8df a058 	ldr.w	sl, [pc, #88]	; 96f8 <trans_del+0x70>
    while(tr != NULL) {
    96a0:	b90c      	cbnz	r4, 96a6 <trans_del+0x1e>
}
    96a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if(tr == tr_limit) break;
    96a6:	4544      	cmp	r4, r8
    96a8:	d0fb      	beq.n	96a2 <trans_del+0x1a>
        tr_prev = _lv_ll_get_prev(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);
    96aa:	4621      	mov	r1, r4
    96ac:	4650      	mov	r0, sl
    96ae:	f011 fdb7 	bl	1b220 <_lv_ll_get_prev>
    96b2:	4681      	mov	r9, r0
        if(tr->obj == obj && (part == tr->part || part == 0xFF) && (prop == tr->prop || prop == 0xFF)) {
    96b4:	6820      	ldr	r0, [r4, #0]
    96b6:	42b8      	cmp	r0, r7
    96b8:	d11b      	bne.n	96f2 <trans_del+0x6a>
    96ba:	79a1      	ldrb	r1, [r4, #6]
    96bc:	42a9      	cmp	r1, r5
    96be:	d001      	beq.n	96c4 <trans_del+0x3c>
    96c0:	2dff      	cmp	r5, #255	; 0xff
    96c2:	d116      	bne.n	96f2 <trans_del+0x6a>
    96c4:	88a3      	ldrh	r3, [r4, #4]
    96c6:	42b3      	cmp	r3, r6
    96c8:	d001      	beq.n	96ce <trans_del+0x46>
    96ca:	2eff      	cmp	r6, #255	; 0xff
    96cc:	d111      	bne.n	96f2 <trans_del+0x6a>
            lv_style_list_t * list = lv_obj_get_style_list(tr->obj, tr->part);
    96ce:	f00c fa0d 	bl	15aec <lv_obj_get_style_list>
            lv_style_t * style_trans = _lv_style_list_get_transition_style(list);
    96d2:	f00d fd9a 	bl	1720a <_lv_style_list_get_transition_style>
            lv_style_remove_prop(style_trans, tr->prop);
    96d6:	88a1      	ldrh	r1, [r4, #4]
    96d8:	f00d fbf4 	bl	16ec4 <lv_style_remove_prop>
            lv_anim_del(tr, NULL);
    96dc:	2100      	movs	r1, #0
    96de:	4620      	mov	r0, r4
    96e0:	f003 f968 	bl	c9b4 <lv_anim_del>
            _lv_ll_remove(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);
    96e4:	4650      	mov	r0, sl
    96e6:	4621      	mov	r1, r4
    96e8:	f011 fdd0 	bl	1b28c <_lv_ll_remove>
            lv_mem_free(tr);
    96ec:	4620      	mov	r0, r4
    96ee:	f003 f9e7 	bl	cac0 <lv_mem_free>
{
    96f2:	464c      	mov	r4, r9
    96f4:	e7d4      	b.n	96a0 <trans_del+0x18>
    96f6:	bf00      	nop
    96f8:	20025e48 	.word	0x20025e48

000096fc <obj_del_core>:
{
    96fc:	b570      	push	{r4, r5, r6, lr}
    96fe:	4604      	mov	r4, r0
    lv_event_send(obj, LV_EVENT_DELETE, NULL);
    9700:	2200      	movs	r2, #0
    9702:	2115      	movs	r1, #21
    9704:	f00b fffb 	bl	156fe <lv_event_send>
    lv_anim_del(obj, NULL);
    9708:	2100      	movs	r1, #0
    970a:	4620      	mov	r0, r4
    970c:	f003 f952 	bl	c9b4 <lv_anim_del>
    trans_del(obj, 0xFF, 0xFF, NULL);
    9710:	22ff      	movs	r2, #255	; 0xff
    9712:	2300      	movs	r3, #0
    9714:	4611      	mov	r1, r2
    9716:	4620      	mov	r0, r4
    9718:	f7ff ffb6 	bl	9688 <trans_del>
    i = _lv_ll_get_head(&(obj->child_ll));
    971c:	1d25      	adds	r5, r4, #4
        i = _lv_ll_get_head(&(obj->child_ll));
    971e:	4628      	mov	r0, r5
    9720:	f011 fd73 	bl	1b20a <_lv_ll_get_head>
    while(i != NULL) {
    9724:	b9f8      	cbnz	r0, 9766 <obj_del_core+0x6a>
    lv_event_temp_data_t * t = event_temp_data_head;
    9726:	4b1e      	ldr	r3, [pc, #120]	; (97a0 <obj_del_core+0xa4>)
    9728:	681e      	ldr	r6, [r3, #0]
        if(t->obj == obj) t->deleted = true;
    972a:	2301      	movs	r3, #1
    while(t) {
    972c:	b9f6      	cbnz	r6, 976c <obj_del_core+0x70>
    lv_indev_t * indev = lv_indev_get_next(NULL);
    972e:	4630      	mov	r0, r6
        indev = lv_indev_get_next(indev);
    9730:	f003 f82e 	bl	c790 <lv_indev_get_next>
    9734:	4605      	mov	r5, r0
    while(indev) {
    9736:	b9f8      	cbnz	r0, 9778 <obj_del_core+0x7c>
    obj->signal_cb(obj, LV_SIGNAL_CLEANUP, NULL);
    9738:	4602      	mov	r2, r0
    973a:	4601      	mov	r1, r0
    973c:	69e3      	ldr	r3, [r4, #28]
    973e:	4620      	mov	r0, r4
    9740:	4798      	blx	r3
    return obj->parent;
    9742:	6820      	ldr	r0, [r4, #0]
    if(par == NULL) { /*It is a screen*/
    9744:	bb40      	cbnz	r0, 9798 <obj_del_core+0x9c>
        lv_disp_t * d = lv_obj_get_disp(obj);
    9746:	4620      	mov	r0, r4
    9748:	f7ff fe1a 	bl	9380 <lv_obj_get_disp>
        _lv_ll_remove(&d->scr_ll, obj);
    974c:	4621      	mov	r1, r4
    974e:	3034      	adds	r0, #52	; 0x34
        _lv_ll_remove(&(par->child_ll), obj);
    9750:	f011 fd9c 	bl	1b28c <_lv_ll_remove>
    if(obj->ext_attr != NULL) lv_mem_free(obj->ext_attr);
    9754:	6a60      	ldr	r0, [r4, #36]	; 0x24
    9756:	b108      	cbz	r0, 975c <obj_del_core+0x60>
    9758:	f003 f9b2 	bl	cac0 <lv_mem_free>
    lv_mem_free(obj); /*Free the object itself*/
    975c:	4620      	mov	r0, r4
}
    975e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_mem_free(obj); /*Free the object itself*/
    9762:	f003 b9ad 	b.w	cac0 <lv_mem_free>
        obj_del_core(i);
    9766:	f7ff ffc9 	bl	96fc <obj_del_core>
    976a:	e7d8      	b.n	971e <obj_del_core+0x22>
        if(t->obj == obj) t->deleted = true;
    976c:	6832      	ldr	r2, [r6, #0]
    976e:	4294      	cmp	r4, r2
    9770:	bf08      	it	eq
    9772:	7133      	strbeq	r3, [r6, #4]
        t = t->prev;
    9774:	68b6      	ldr	r6, [r6, #8]
    9776:	e7d9      	b.n	972c <obj_del_core+0x30>
        if(indev->proc.types.pointer.act_obj == obj || indev->proc.types.pointer.last_obj == obj) {
    9778:	6bab      	ldr	r3, [r5, #56]	; 0x38
    977a:	42a3      	cmp	r3, r4
    977c:	d002      	beq.n	9784 <obj_del_core+0x88>
    977e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    9780:	42a3      	cmp	r3, r4
    9782:	d103      	bne.n	978c <obj_del_core+0x90>
            lv_indev_reset(indev, obj);
    9784:	4621      	mov	r1, r4
    9786:	4628      	mov	r0, r5
    9788:	f7ff f8f2 	bl	8970 <lv_indev_reset>
        if(indev->proc.types.pointer.last_pressed == obj) {
    978c:	6c2b      	ldr	r3, [r5, #64]	; 0x40
        indev = lv_indev_get_next(indev);
    978e:	4628      	mov	r0, r5
        if(indev->proc.types.pointer.last_pressed == obj) {
    9790:	42a3      	cmp	r3, r4
            indev->proc.types.pointer.last_pressed = NULL;
    9792:	bf08      	it	eq
    9794:	642e      	streq	r6, [r5, #64]	; 0x40
        indev = lv_indev_get_next(indev);
    9796:	e7cb      	b.n	9730 <obj_del_core+0x34>
        _lv_ll_remove(&(par->child_ll), obj);
    9798:	4621      	mov	r1, r4
    979a:	3004      	adds	r0, #4
    979c:	e7d8      	b.n	9750 <obj_del_core+0x54>
    979e:	bf00      	nop
    97a0:	20025cf4 	.word	0x20025cf4

000097a4 <trans_anim_ready_cb>:
{
    97a4:	b570      	push	{r4, r5, r6, lr}
    lv_style_trans_t * tr = a->var;
    97a6:	6804      	ldr	r4, [r0, #0]
    _LV_LL_READ(LV_GC_ROOT(_lv_obj_style_trans_ll), tr_i) {
    97a8:	4816      	ldr	r0, [pc, #88]	; (9804 <trans_anim_ready_cb+0x60>)
    97aa:	f011 fd2e 	bl	1b20a <_lv_ll_get_head>
    bool running = false;
    97ae:	2500      	movs	r5, #0
    _LV_LL_READ(LV_GC_ROOT(_lv_obj_style_trans_ll), tr_i) {
    97b0:	4601      	mov	r1, r0
    97b2:	4e14      	ldr	r6, [pc, #80]	; (9804 <trans_anim_ready_cb+0x60>)
    97b4:	b991      	cbnz	r1, 97dc <trans_anim_ready_cb+0x38>
    if(!running) {
    97b6:	b945      	cbnz	r5, 97ca <trans_anim_ready_cb+0x26>
        lv_style_list_t * list = lv_obj_get_style_list(tr->obj, tr->part);
    97b8:	79a1      	ldrb	r1, [r4, #6]
    97ba:	6820      	ldr	r0, [r4, #0]
    97bc:	f00c f996 	bl	15aec <lv_obj_get_style_list>
        lv_style_t * style_trans = _lv_style_list_get_transition_style(list);
    97c0:	f00d fd23 	bl	1720a <_lv_style_list_get_transition_style>
        lv_style_remove_prop(style_trans, tr->prop);
    97c4:	88a1      	ldrh	r1, [r4, #4]
    97c6:	f00d fb7d 	bl	16ec4 <lv_style_remove_prop>
    _lv_ll_remove(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);
    97ca:	4621      	mov	r1, r4
    97cc:	480d      	ldr	r0, [pc, #52]	; (9804 <trans_anim_ready_cb+0x60>)
    97ce:	f011 fd5d 	bl	1b28c <_lv_ll_remove>
    lv_mem_free(tr);
    97d2:	4620      	mov	r0, r4
}
    97d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_mem_free(tr);
    97d8:	f003 b972 	b.w	cac0 <lv_mem_free>
        if(tr_i != tr && tr_i->obj == tr->obj && tr_i->part == tr->part && tr_i->prop == tr->prop) {
    97dc:	42a1      	cmp	r1, r4
    97de:	d00c      	beq.n	97fa <trans_anim_ready_cb+0x56>
    97e0:	680a      	ldr	r2, [r1, #0]
    97e2:	6823      	ldr	r3, [r4, #0]
    97e4:	429a      	cmp	r2, r3
    97e6:	d108      	bne.n	97fa <trans_anim_ready_cb+0x56>
    97e8:	684b      	ldr	r3, [r1, #4]
    97ea:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
    97ee:	6863      	ldr	r3, [r4, #4]
    97f0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
            running = true;
    97f4:	429a      	cmp	r2, r3
    97f6:	bf08      	it	eq
    97f8:	2501      	moveq	r5, #1
    _LV_LL_READ(LV_GC_ROOT(_lv_obj_style_trans_ll), tr_i) {
    97fa:	4630      	mov	r0, r6
    97fc:	f011 fd0b 	bl	1b216 <_lv_ll_get_next>
    9800:	4601      	mov	r1, r0
    9802:	e7d7      	b.n	97b4 <trans_anim_ready_cb+0x10>
    9804:	20025e48 	.word	0x20025e48

00009808 <_lv_obj_get_style_int>:
{
    9808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    980c:	4606      	mov	r6, r0
    980e:	468b      	mov	fp, r1
    9810:	4617      	mov	r7, r2
    while(parent) {
    9812:	4615      	mov	r5, r2
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
    9814:	f248 0982 	movw	r9, #32898	; 0x8082
    9818:	f248 0a83 	movw	sl, #32899	; 0x8083
{
    981c:	b085      	sub	sp, #20
    attr = prop_ori >> 8;
    981e:	ea4f 2812 	mov.w	r8, r2, lsr #8
    while(parent) {
    9822:	2e00      	cmp	r6, #0
    9824:	f000 80ae 	beq.w	9984 <_lv_obj_get_style_int+0x17c>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
    9828:	4659      	mov	r1, fp
    982a:	4630      	mov	r0, r6
    982c:	f00c f95e 	bl	15aec <lv_obj_get_style_list>
        if(!list->ignore_cache && list->style_cnt > 0) {
    9830:	7942      	ldrb	r2, [r0, #5]
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
    9832:	4604      	mov	r4, r0
        if(!list->ignore_cache && list->style_cnt > 0) {
    9834:	0711      	lsls	r1, r2, #28
    9836:	d414      	bmi.n	9862 <_lv_obj_get_style_int+0x5a>
    9838:	7901      	ldrb	r1, [r0, #4]
    983a:	068b      	lsls	r3, r1, #26
    983c:	d011      	beq.n	9862 <_lv_obj_get_style_int+0x5a>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
    983e:	f012 0f04 	tst.w	r2, #4
    9842:	f425 42fe 	bic.w	r2, r5, #32512	; 0x7f00
    9846:	d105      	bne.n	9854 <_lv_obj_get_style_int+0x4c>
    9848:	4659      	mov	r1, fp
    984a:	4630      	mov	r0, r6
    984c:	9201      	str	r2, [sp, #4]
    984e:	f000 f8d7 	bl	9a00 <update_style_cache>
    9852:	9a01      	ldr	r2, [sp, #4]
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
    9854:	2a33      	cmp	r2, #51	; 0x33
    9856:	dc68      	bgt.n	992a <_lv_obj_get_style_int+0x122>
    9858:	2a2f      	cmp	r2, #47	; 0x2f
    985a:	dc20      	bgt.n	989e <_lv_obj_get_style_int+0x96>
    985c:	2a18      	cmp	r2, #24
    985e:	dc61      	bgt.n	9924 <_lv_obj_get_style_int+0x11c>
    9860:	bb52      	cbnz	r2, 98b8 <_lv_obj_get_style_int+0xb0>
        lv_state_t state = lv_obj_get_state(parent, part);
    9862:	4659      	mov	r1, fp
    9864:	4630      	mov	r0, r6
    9866:	f00c f9cf 	bl	15c08 <lv_obj_get_state>
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
    986a:	eb07 2500 	add.w	r5, r7, r0, lsl #8
    986e:	b2ad      	uxth	r5, r5
        res = _lv_style_list_get_int(list, prop, &value_act);
    9870:	4629      	mov	r1, r5
    9872:	4620      	mov	r0, r4
    9874:	f10d 020e 	add.w	r2, sp, #14
    9878:	f00d fd8d 	bl	17396 <_lv_style_list_get_int>
        if(res == LV_RES_OK) return value_act;
    987c:	2801      	cmp	r0, #1
    987e:	f040 80a6 	bne.w	99ce <_lv_obj_get_style_int+0x1c6>
    9882:	f9bd 000e 	ldrsh.w	r0, [sp, #14]
}
    9886:	b005      	add	sp, #20
    9888:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    988c:	f1a2 0154 	sub.w	r1, r2, #84	; 0x54
    9890:	2201      	movs	r2, #1
    9892:	4b5a      	ldr	r3, [pc, #360]	; (99fc <_lv_obj_get_style_int+0x1f4>)
    9894:	408a      	lsls	r2, r1
    9896:	421a      	tst	r2, r3
    9898:	d0e3      	beq.n	9862 <_lv_obj_get_style_int+0x5a>
                    if(list->blend_mode_all_normal) def = true;
    989a:	79a2      	ldrb	r2, [r4, #6]
    989c:	e08c      	b.n	99b8 <_lv_obj_get_style_int+0x1b0>
    989e:	3a31      	subs	r2, #49	; 0x31
    98a0:	2a02      	cmp	r2, #2
    98a2:	d87d      	bhi.n	99a0 <_lv_obj_get_style_int+0x198>
    98a4:	a301      	add	r3, pc, #4	; (adr r3, 98ac <_lv_obj_get_style_int+0xa4>)
    98a6:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
    98aa:	bf00      	nop
    98ac:	000099a5 	.word	0x000099a5
    98b0:	0000989b 	.word	0x0000989b
    98b4:	000099a9 	.word	0x000099a9
    98b8:	3a01      	subs	r2, #1
    98ba:	2a17      	cmp	r2, #23
    98bc:	d8d1      	bhi.n	9862 <_lv_obj_get_style_int+0x5a>
    98be:	a301      	add	r3, pc, #4	; (adr r3, 98c4 <_lv_obj_get_style_int+0xbc>)
    98c0:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
    98c4:	000099af 	.word	0x000099af
    98c8:	00009973 	.word	0x00009973
    98cc:	00009863 	.word	0x00009863
    98d0:	0000997b 	.word	0x0000997b
    98d4:	0000997b 	.word	0x0000997b
    98d8:	0000997b 	.word	0x0000997b
    98dc:	0000997b 	.word	0x0000997b
    98e0:	00009863 	.word	0x00009863
    98e4:	00009863 	.word	0x00009863
    98e8:	00009863 	.word	0x00009863
    98ec:	00009863 	.word	0x00009863
    98f0:	00009863 	.word	0x00009863
    98f4:	00009863 	.word	0x00009863
    98f8:	00009863 	.word	0x00009863
    98fc:	00009863 	.word	0x00009863
    9900:	000099bf 	.word	0x000099bf
    9904:	000099bf 	.word	0x000099bf
    9908:	000099bf 	.word	0x000099bf
    990c:	000099bf 	.word	0x000099bf
    9910:	00009863 	.word	0x00009863
    9914:	000099c3 	.word	0x000099c3
    9918:	000099c3 	.word	0x000099c3
    991c:	000099c3 	.word	0x000099c3
    9920:	000099c3 	.word	0x000099c3
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
    9924:	2a20      	cmp	r2, #32
    9926:	d0b8      	beq.n	989a <_lv_obj_get_style_int+0x92>
    9928:	e79b      	b.n	9862 <_lv_obj_get_style_int+0x5a>
    992a:	2a72      	cmp	r2, #114	; 0x72
    992c:	dc0b      	bgt.n	9946 <_lv_obj_get_style_int+0x13e>
    992e:	2a53      	cmp	r2, #83	; 0x53
    9930:	dcac      	bgt.n	988c <_lv_obj_get_style_int+0x84>
    9932:	2a42      	cmp	r2, #66	; 0x42
    9934:	d0b1      	beq.n	989a <_lv_obj_get_style_int+0x92>
    9936:	2a50      	cmp	r2, #80	; 0x50
    9938:	d03d      	beq.n	99b6 <_lv_obj_get_style_int+0x1ae>
    993a:	2a40      	cmp	r2, #64	; 0x40
    993c:	d191      	bne.n	9862 <_lv_obj_get_style_int+0x5a>
                    if(list->outline_width_zero) def = true;
    993e:	79e2      	ldrb	r2, [r4, #7]
                    if(list->pad_all_zero) def = true;
    9940:	f012 0f01 	tst.w	r2, #1
    9944:	e00c      	b.n	9960 <_lv_obj_get_style_int+0x158>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
    9946:	454a      	cmp	r2, r9
    9948:	d03f      	beq.n	99ca <_lv_obj_get_style_int+0x1c2>
    994a:	dc0c      	bgt.n	9966 <_lv_obj_get_style_int+0x15e>
    994c:	2a91      	cmp	r2, #145	; 0x91
    994e:	d0a4      	beq.n	989a <_lv_obj_get_style_int+0x92>
    9950:	f5a2 4200 	sub.w	r2, r2, #32768	; 0x8000
    9954:	3a80      	subs	r2, #128	; 0x80
    9956:	2a01      	cmp	r2, #1
    9958:	d883      	bhi.n	9862 <_lv_obj_get_style_int+0x5a>
                    if(list->text_space_zero) def = true;
    995a:	79e2      	ldrb	r2, [r4, #7]
                    if(list->border_width_zero) def = true;
    995c:	f012 0f20 	tst.w	r2, #32
                    if(list->text_decor_none) def = true;
    9960:	f43f af7f 	beq.w	9862 <_lv_obj_get_style_int+0x5a>
    9964:	e00e      	b.n	9984 <_lv_obj_get_style_int+0x17c>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
    9966:	4552      	cmp	r2, sl
    9968:	d097      	beq.n	989a <_lv_obj_get_style_int+0x92>
    996a:	f248 01a0 	movw	r1, #32928	; 0x80a0
    996e:	428a      	cmp	r2, r1
    9970:	e7d9      	b.n	9926 <_lv_obj_get_style_int+0x11e>
                    if(list->clip_corner_off) def = true;
    9972:	7962      	ldrb	r2, [r4, #5]
                    if(list->text_decor_none) def = true;
    9974:	f012 0f40 	tst.w	r2, #64	; 0x40
    9978:	e7f2      	b.n	9960 <_lv_obj_get_style_int+0x158>
                    if(list->transform_all_zero) def = true;
    997a:	f994 2005 	ldrsb.w	r2, [r4, #5]
                    if(list->border_post_off) def = true;
    997e:	2a00      	cmp	r2, #0
    9980:	f6bf af6f 	bge.w	9862 <_lv_obj_get_style_int+0x5a>
    prop = prop & (~LV_STYLE_STATE_MASK);
    9984:	f425 45fe 	bic.w	r5, r5, #32512	; 0x7f00
    switch(prop) {
    9988:	2d22      	cmp	r5, #34	; 0x22
    prop = prop & (~LV_STYLE_STATE_MASK);
    998a:	b2ab      	uxth	r3, r5
    switch(prop) {
    998c:	d030      	beq.n	99f0 <_lv_obj_get_style_int+0x1e8>
    998e:	d828      	bhi.n	99e2 <_lv_obj_get_style_int+0x1da>
    9990:	2b03      	cmp	r3, #3
    9992:	d02f      	beq.n	99f4 <_lv_obj_get_style_int+0x1ec>
            return LV_IMG_ZOOM_NONE;
    9994:	2b07      	cmp	r3, #7
    9996:	bf14      	ite	ne
    9998:	2000      	movne	r0, #0
    999a:	f44f 7080 	moveq.w	r0, #256	; 0x100
    999e:	e772      	b.n	9886 <_lv_obj_get_style_int+0x7e>
                    if(list->border_width_zero) def = true;
    99a0:	79a2      	ldrb	r2, [r4, #6]
    99a2:	e7db      	b.n	995c <_lv_obj_get_style_int+0x154>
                    if(list->border_side_full) def = true;
    99a4:	79a2      	ldrb	r2, [r4, #6]
    99a6:	e7e5      	b.n	9974 <_lv_obj_get_style_int+0x16c>
                    if(list->border_post_off) def = true;
    99a8:	f994 2006 	ldrsb.w	r2, [r4, #6]
    99ac:	e7e7      	b.n	997e <_lv_obj_get_style_int+0x176>
                    if(list->radius_zero) def = true;
    99ae:	7962      	ldrb	r2, [r4, #5]
    99b0:	f012 0f10 	tst.w	r2, #16
    99b4:	e7d4      	b.n	9960 <_lv_obj_get_style_int+0x158>
                    if(list->shadow_width_zero) def = true;
    99b6:	79e2      	ldrb	r2, [r4, #7]
                    if(list->blend_mode_all_normal) def = true;
    99b8:	f012 0f04 	tst.w	r2, #4
    99bc:	e7d0      	b.n	9960 <_lv_obj_get_style_int+0x158>
                    if(list->pad_all_zero) def = true;
    99be:	79a2      	ldrb	r2, [r4, #6]
    99c0:	e7be      	b.n	9940 <_lv_obj_get_style_int+0x138>
                    if(list->margin_all_zero) def = true;
    99c2:	79a2      	ldrb	r2, [r4, #6]
    99c4:	f012 0f02 	tst.w	r2, #2
    99c8:	e7ca      	b.n	9960 <_lv_obj_get_style_int+0x158>
                    if(list->text_decor_none) def = true;
    99ca:	79e2      	ldrb	r2, [r4, #7]
    99cc:	e7d2      	b.n	9974 <_lv_obj_get_style_int+0x16c>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
    99ce:	f018 0f80 	tst.w	r8, #128	; 0x80
    99d2:	d0d7      	beq.n	9984 <_lv_obj_get_style_int+0x17c>
        if(part != LV_OBJ_PART_MAIN) {
    99d4:	f1bb 0f00 	cmp.w	fp, #0
    99d8:	d100      	bne.n	99dc <_lv_obj_get_style_int+0x1d4>
    return obj->parent;
    99da:	6836      	ldr	r6, [r6, #0]
{
    99dc:	f04f 0b00 	mov.w	fp, #0
    99e0:	e71f      	b.n	9822 <_lv_obj_get_style_int+0x1a>
    switch(prop) {
    99e2:	2b31      	cmp	r3, #49	; 0x31
    99e4:	d008      	beq.n	99f8 <_lv_obj_get_style_int+0x1f0>
            return LV_DPI / 8;
    99e6:	2bc0      	cmp	r3, #192	; 0xc0
    99e8:	bf14      	ite	ne
    99ea:	2000      	movne	r0, #0
    99ec:	2010      	moveq	r0, #16
    99ee:	e74a      	b.n	9886 <_lv_obj_get_style_int+0x7e>
            return 255;
    99f0:	20ff      	movs	r0, #255	; 0xff
    99f2:	e748      	b.n	9886 <_lv_obj_get_style_int+0x7e>
    switch(prop) {
    99f4:	2006      	movs	r0, #6
    99f6:	e746      	b.n	9886 <_lv_obj_get_style_int+0x7e>
            return LV_BORDER_SIDE_FULL;
    99f8:	200f      	movs	r0, #15
    99fa:	e744      	b.n	9886 <_lv_obj_get_style_int+0x7e>
    99fc:	40001001 	.word	0x40001001

00009a00 <update_style_cache>:
 * @param obj pointer to an obejct
 * @param part the part of the object
 * @param prop the property which triggered the update
 */
static void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop)
{
    9a00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9a02:	4605      	mov	r5, r0
    if(style_prop_is_cacheble(prop) == false) return;
    9a04:	4610      	mov	r0, r2
{
    9a06:	460e      	mov	r6, r1
    if(style_prop_is_cacheble(prop) == false) return;
    9a08:	f7ff fbac 	bl	9164 <style_prop_is_cacheble>
    9a0c:	2800      	cmp	r0, #0
    9a0e:	f000 80fe 	beq.w	9c0e <update_style_cache+0x20e>

    lv_style_list_t * list = lv_obj_get_style_list(obj, part);
    9a12:	4628      	mov	r0, r5
    9a14:	f00c f86a 	bl	15aec <lv_obj_get_style_list>

    bool ignore_cache_ori = list->ignore_cache;
    9a18:	7943      	ldrb	r3, [r0, #5]
    lv_style_list_t * list = lv_obj_get_style_list(obj, part);
    9a1a:	4604      	mov	r4, r0
    bool ignore_cache_ori = list->ignore_cache;
    9a1c:	f3c3 07c0 	ubfx	r7, r3, #3, #1
    list->ignore_cache = 1;
    9a20:	f023 0328 	bic.w	r3, r3, #40	; 0x28
    9a24:	f043 0328 	orr.w	r3, r3, #40	; 0x28
    9a28:	7143      	strb	r3, [r0, #5]
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
    9a2a:	f248 0282 	movw	r2, #32898	; 0x8082
    9a2e:	4631      	mov	r1, r6
    9a30:	4628      	mov	r0, r5
    9a32:	f7ff fee9 	bl	9808 <_lv_obj_get_style_int>
#if LV_USE_OPA_SCALE
    list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;
#else
    list->opa_scale_cover    = 1;
#endif
    list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;
    9a36:	b2c0      	uxtb	r0, r0
    9a38:	fab0 f080 	clz	r0, r0
    9a3c:	79e3      	ldrb	r3, [r4, #7]
    9a3e:	0940      	lsrs	r0, r0, #5
    9a40:	f360 1386 	bfi	r3, r0, #6, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
    9a44:	f248 028e 	movw	r2, #32910	; 0x808e
    9a48:	4631      	mov	r1, r6
    9a4a:	71e3      	strb	r3, [r4, #7]
    9a4c:	4628      	mov	r0, r5
    9a4e:	f000 f931 	bl	9cb4 <_lv_obj_get_style_ptr>
    list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == LV_THEME_DEFAULT_FONT_NORMAL ? 1 : 0;

    list->text_space_zero = 1;
    9a52:	4b96      	ldr	r3, [pc, #600]	; (9cac <update_style_cache+0x2ac>)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
    9a54:	f248 0280 	movw	r2, #32896	; 0x8080
    9a58:	4283      	cmp	r3, r0
    9a5a:	bf0c      	ite	eq
    9a5c:	23a0      	moveq	r3, #160	; 0xa0
    9a5e:	2320      	movne	r3, #32
    9a60:	79e0      	ldrb	r0, [r4, #7]
    9a62:	4631      	mov	r1, r6
    9a64:	f000 005f 	and.w	r0, r0, #95	; 0x5f
    9a68:	4303      	orrs	r3, r0
    9a6a:	71e3      	strb	r3, [r4, #7]
    9a6c:	4628      	mov	r0, r5
    9a6e:	f7ff fecb 	bl	9808 <_lv_obj_get_style_int>
    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
    9a72:	2800      	cmp	r0, #0
    9a74:	f000 80cc 	beq.w	9c10 <update_style_cache+0x210>
       lv_obj_get_style_text_line_space(obj, part) != 0) {
        list->text_space_zero = 0;
    9a78:	79e3      	ldrb	r3, [r4, #7]
    9a7a:	f36f 1345 	bfc	r3, #5, #1
    9a7e:	71e3      	strb	r3, [r4, #7]
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
    9a80:	222c      	movs	r2, #44	; 0x2c
    9a82:	4631      	mov	r1, r6
    9a84:	4628      	mov	r0, r5
    9a86:	f00c f920 	bl	15cca <_lv_obj_get_style_opa>
    }


    lv_opa_t bg_opa = lv_obj_get_style_bg_opa(obj, part);
    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;
    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;
    9a8a:	f1a0 02ff 	sub.w	r2, r0, #255	; 0xff
    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;
    9a8e:	fab0 f080 	clz	r0, r0
    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;
    9a92:	4253      	negs	r3, r2
    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;
    9a94:	ea4f 1050 	mov.w	r0, r0, lsr #5
    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;
    9a98:	4153      	adcs	r3, r2
    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;
    9a9a:	00c0      	lsls	r0, r0, #3
    9a9c:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
    9aa0:	79a3      	ldrb	r3, [r4, #6]
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
    9aa2:	2230      	movs	r2, #48	; 0x30
    9aa4:	f023 0318 	bic.w	r3, r3, #24
    9aa8:	4318      	orrs	r0, r3
    9aaa:	4631      	mov	r1, r6
    9aac:	71a0      	strb	r0, [r4, #6]
    9aae:	4628      	mov	r0, r5
    9ab0:	f7ff feaa 	bl	9808 <_lv_obj_get_style_int>

    list->border_width_zero = lv_obj_get_style_border_width(obj, part) == 0 ? 1 : 0;
    9ab4:	fab0 f080 	clz	r0, r0
    9ab8:	79a3      	ldrb	r3, [r4, #6]
    9aba:	0940      	lsrs	r0, r0, #5
    9abc:	f360 1345 	bfi	r3, r0, #5, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_SIDE, border_side, lv_border_side_t, _int, scalar)
    9ac0:	2231      	movs	r2, #49	; 0x31
    9ac2:	4631      	mov	r1, r6
    9ac4:	71a3      	strb	r3, [r4, #6]
    9ac6:	4628      	mov	r0, r5
    9ac8:	f7ff fe9e 	bl	9808 <_lv_obj_get_style_int>
    list->border_side_full = lv_obj_get_style_border_side(obj, part) == LV_BORDER_SIDE_FULL ? 1 : 0;
    9acc:	b2c0      	uxtb	r0, r0
    9ace:	f1a0 010f 	sub.w	r1, r0, #15
    9ad2:	4248      	negs	r0, r1
    9ad4:	79a3      	ldrb	r3, [r4, #6]
    9ad6:	4148      	adcs	r0, r1
    9ad8:	f360 1386 	bfi	r3, r0, #6, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
    9adc:	2233      	movs	r2, #51	; 0x33
    9ade:	4631      	mov	r1, r6
    9ae0:	71a3      	strb	r3, [r4, #6]
    9ae2:	4628      	mov	r0, r5
    9ae4:	f7ff fe90 	bl	9808 <_lv_obj_get_style_int>
    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;
    9ae8:	fab0 f080 	clz	r0, r0
    9aec:	79a3      	ldrb	r3, [r4, #6]
    9aee:	0940      	lsrs	r0, r0, #5
    9af0:	f360 13c7 	bfi	r3, r0, #7, #1
    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;
    9af4:	4631      	mov	r1, r6
    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;
    9af6:	71a3      	strb	r3, [r4, #6]
    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;
    9af8:	4628      	mov	r0, r5
    9afa:	f00c f8ca 	bl	15c92 <lv_obj_get_style_clip_corner>
    9afe:	7963      	ldrb	r3, [r4, #5]
    9b00:	f080 0001 	eor.w	r0, r0, #1
    9b04:	f360 1386 	bfi	r3, r0, #6, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
    9b08:	f248 02ad 	movw	r2, #32941	; 0x80ad
    9b0c:	4631      	mov	r1, r6
    9b0e:	7163      	strb	r3, [r4, #5]
    9b10:	4628      	mov	r0, r5
    9b12:	f00c f8da 	bl	15cca <_lv_obj_get_style_opa>
    list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;
    9b16:	fab0 f080 	clz	r0, r0
    9b1a:	79e3      	ldrb	r3, [r4, #7]
    9b1c:	0940      	lsrs	r0, r0, #5
    9b1e:	f360 1304 	bfi	r3, r0, #4, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_WIDTH, outline_width, lv_style_int_t, _int, scalar)
    9b22:	2240      	movs	r2, #64	; 0x40
    9b24:	4631      	mov	r1, r6
    9b26:	71e3      	strb	r3, [r4, #7]
    9b28:	4628      	mov	r0, r5
    9b2a:	f7ff fe6d 	bl	9808 <_lv_obj_get_style_int>
    list->outline_width_zero    = lv_obj_get_style_outline_width(obj, part) == 0 ? 1 : 0;
    9b2e:	fab0 f080 	clz	r0, r0
    9b32:	79e3      	ldrb	r3, [r4, #7]
    9b34:	0940      	lsrs	r0, r0, #5
    9b36:	f360 0300 	bfi	r3, r0, #0, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_IMAGE, pattern_image, const void *, _ptr, scalar)
    9b3a:	226e      	movs	r2, #110	; 0x6e
    9b3c:	4631      	mov	r1, r6
    9b3e:	71e3      	strb	r3, [r4, #7]
    9b40:	4628      	mov	r0, r5
    9b42:	f000 f8b7 	bl	9cb4 <_lv_obj_get_style_ptr>
    list->pattern_img_null    = lv_obj_get_style_pattern_image(obj, part) == NULL ? 1 : 0;
    9b46:	fab0 f080 	clz	r0, r0
    9b4a:	79e3      	ldrb	r3, [r4, #7]
    9b4c:	0940      	lsrs	r0, r0, #5
    9b4e:	f360 0341 	bfi	r3, r0, #1, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
    9b52:	2201      	movs	r2, #1
    9b54:	4631      	mov	r1, r6
    9b56:	71e3      	strb	r3, [r4, #7]
    9b58:	4628      	mov	r0, r5
    9b5a:	f7ff fe55 	bl	9808 <_lv_obj_get_style_int>
    list->radius_zero    = lv_obj_get_style_radius(obj, part) == 0 ? 1 : 0;
    9b5e:	fab0 f080 	clz	r0, r0
    9b62:	7963      	ldrb	r3, [r4, #5]
    9b64:	0940      	lsrs	r0, r0, #5
    9b66:	f360 1304 	bfi	r3, r0, #4, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
    9b6a:	2250      	movs	r2, #80	; 0x50
    9b6c:	4631      	mov	r1, r6
    9b6e:	7163      	strb	r3, [r4, #5]
    9b70:	4628      	mov	r0, r5
    9b72:	f7ff fe49 	bl	9808 <_lv_obj_get_style_int>
    list->shadow_width_zero    = lv_obj_get_style_shadow_width(obj, part) == 0 ? 1 : 0;
    9b76:	fab0 f080 	clz	r0, r0
    9b7a:	79e3      	ldrb	r3, [r4, #7]
    9b7c:	0940      	lsrs	r0, r0, #5
    9b7e:	f360 0382 	bfi	r3, r0, #2, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
    9b82:	227f      	movs	r2, #127	; 0x7f
    9b84:	4631      	mov	r1, r6
    9b86:	71e3      	strb	r3, [r4, #7]
    9b88:	4628      	mov	r0, r5
    9b8a:	f000 f893 	bl	9cb4 <_lv_obj_get_style_ptr>
    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;
    9b8e:	fab0 f080 	clz	r0, r0


    list->transform_all_zero  = 1;
    9b92:	6863      	ldr	r3, [r4, #4]
    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;
    9b94:	0940      	lsrs	r0, r0, #5
    list->transform_all_zero  = 1;
    9b96:	06c0      	lsls	r0, r0, #27
    9b98:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
    9b9c:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
    9ba0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    9ba4:	4318      	orrs	r0, r3
    9ba6:	6060      	str	r0, [r4, #4]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
    9ba8:	2206      	movs	r2, #6
    9baa:	4631      	mov	r1, r6
    9bac:	4628      	mov	r0, r5
    9bae:	f7ff fe2b 	bl	9808 <_lv_obj_get_style_int>
    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||
    9bb2:	2800      	cmp	r0, #0
    9bb4:	d036      	beq.n	9c24 <update_style_cache+0x224>
       lv_obj_get_style_transform_width(obj, part) != 0 ||
       lv_obj_get_style_transform_height(obj, part) != 0 ||
       lv_obj_get_style_transform_zoom(obj, part) != LV_IMG_ZOOM_NONE) {
        list->transform_all_zero  = 0;
    9bb6:	7963      	ldrb	r3, [r4, #5]
    9bb8:	f36f 13c7 	bfc	r3, #7, #1
    9bbc:	7163      	strb	r3, [r4, #5]
    }

    list->pad_all_zero  = 1;
    9bbe:	79a3      	ldrb	r3, [r4, #6]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    9bc0:	2210      	movs	r2, #16
    9bc2:	f043 0301 	orr.w	r3, r3, #1
    9bc6:	4631      	mov	r1, r6
    9bc8:	4628      	mov	r0, r5
    9bca:	71a3      	strb	r3, [r4, #6]
    9bcc:	f7ff fe1c 	bl	9808 <_lv_obj_get_style_int>
    if(lv_obj_get_style_pad_top(obj, part) != 0 ||
    9bd0:	2800      	cmp	r0, #0
    9bd2:	d03e      	beq.n	9c52 <update_style_cache+0x252>
       lv_obj_get_style_pad_bottom(obj, part) != 0 ||
       lv_obj_get_style_pad_left(obj, part) != 0 ||
       lv_obj_get_style_pad_right(obj, part) != 0) {
        list->pad_all_zero  = 0;
    9bd4:	79a3      	ldrb	r3, [r4, #6]
    9bd6:	f36f 0300 	bfc	r3, #0, #1
    9bda:	71a3      	strb	r3, [r4, #6]
    }

    list->margin_all_zero  = 1;
    9bdc:	79a3      	ldrb	r3, [r4, #6]
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
    9bde:	2215      	movs	r2, #21
    9be0:	f043 0302 	orr.w	r3, r3, #2
    9be4:	4631      	mov	r1, r6
    9be6:	4628      	mov	r0, r5
    9be8:	71a3      	strb	r3, [r4, #6]
    9bea:	f7ff fe0d 	bl	9808 <_lv_obj_get_style_int>
    if(lv_obj_get_style_margin_top(obj, part) != 0 ||
    9bee:	2800      	cmp	r0, #0
    9bf0:	d045      	beq.n	9c7e <update_style_cache+0x27e>
       lv_obj_get_style_margin_bottom(obj, part) != 0 ||
       lv_obj_get_style_margin_left(obj, part) != 0 ||
       lv_obj_get_style_margin_right(obj, part) != 0) {
        list->margin_all_zero  = 0;
    9bf2:	79a3      	ldrb	r3, [r4, #6]
    9bf4:	f36f 0341 	bfc	r3, #1, #1
    9bf8:	71a3      	strb	r3, [r4, #6]
       lv_obj_get_style_shadow_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL) {
        list->blend_mode_all_normal = 0;
    }
#endif
    list->ignore_cache = ignore_cache_ori;
    list->valid_cache = 1;
    9bfa:	4b2d      	ldr	r3, [pc, #180]	; (9cb0 <update_style_cache+0x2b0>)
    9bfc:	ea43 27c7 	orr.w	r7, r3, r7, lsl #11
    9c00:	6863      	ldr	r3, [r4, #4]
    9c02:	f423 2381 	bic.w	r3, r3, #264192	; 0x40800
    9c06:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    9c0a:	431f      	orrs	r7, r3
    9c0c:	6067      	str	r7, [r4, #4]
}
    9c0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
    9c10:	f248 0281 	movw	r2, #32897	; 0x8081
    9c14:	4631      	mov	r1, r6
    9c16:	4628      	mov	r0, r5
    9c18:	f7ff fdf6 	bl	9808 <_lv_obj_get_style_int>
    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
    9c1c:	2800      	cmp	r0, #0
    9c1e:	f47f af2b 	bne.w	9a78 <update_style_cache+0x78>
    9c22:	e72d      	b.n	9a80 <update_style_cache+0x80>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
    9c24:	2204      	movs	r2, #4
    9c26:	4631      	mov	r1, r6
    9c28:	4628      	mov	r0, r5
    9c2a:	f7ff fded 	bl	9808 <_lv_obj_get_style_int>
    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||
    9c2e:	2800      	cmp	r0, #0
    9c30:	d1c1      	bne.n	9bb6 <update_style_cache+0x1b6>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
    9c32:	2205      	movs	r2, #5
    9c34:	4631      	mov	r1, r6
    9c36:	4628      	mov	r0, r5
    9c38:	f7ff fde6 	bl	9808 <_lv_obj_get_style_int>
       lv_obj_get_style_transform_width(obj, part) != 0 ||
    9c3c:	2800      	cmp	r0, #0
    9c3e:	d1ba      	bne.n	9bb6 <update_style_cache+0x1b6>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
    9c40:	2207      	movs	r2, #7
    9c42:	4631      	mov	r1, r6
    9c44:	4628      	mov	r0, r5
    9c46:	f7ff fddf 	bl	9808 <_lv_obj_get_style_int>
       lv_obj_get_style_transform_height(obj, part) != 0 ||
    9c4a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    9c4e:	d1b2      	bne.n	9bb6 <update_style_cache+0x1b6>
    9c50:	e7b5      	b.n	9bbe <update_style_cache+0x1be>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    9c52:	2211      	movs	r2, #17
    9c54:	4631      	mov	r1, r6
    9c56:	4628      	mov	r0, r5
    9c58:	f7ff fdd6 	bl	9808 <_lv_obj_get_style_int>
    if(lv_obj_get_style_pad_top(obj, part) != 0 ||
    9c5c:	2800      	cmp	r0, #0
    9c5e:	d1b9      	bne.n	9bd4 <update_style_cache+0x1d4>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    9c60:	2212      	movs	r2, #18
    9c62:	4631      	mov	r1, r6
    9c64:	4628      	mov	r0, r5
    9c66:	f7ff fdcf 	bl	9808 <_lv_obj_get_style_int>
       lv_obj_get_style_pad_bottom(obj, part) != 0 ||
    9c6a:	2800      	cmp	r0, #0
    9c6c:	d1b2      	bne.n	9bd4 <update_style_cache+0x1d4>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    9c6e:	2213      	movs	r2, #19
    9c70:	4631      	mov	r1, r6
    9c72:	4628      	mov	r0, r5
    9c74:	f7ff fdc8 	bl	9808 <_lv_obj_get_style_int>
       lv_obj_get_style_pad_left(obj, part) != 0 ||
    9c78:	2800      	cmp	r0, #0
    9c7a:	d1ab      	bne.n	9bd4 <update_style_cache+0x1d4>
    9c7c:	e7ae      	b.n	9bdc <update_style_cache+0x1dc>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
    9c7e:	2216      	movs	r2, #22
    9c80:	4631      	mov	r1, r6
    9c82:	4628      	mov	r0, r5
    9c84:	f7ff fdc0 	bl	9808 <_lv_obj_get_style_int>
    if(lv_obj_get_style_margin_top(obj, part) != 0 ||
    9c88:	2800      	cmp	r0, #0
    9c8a:	d1b2      	bne.n	9bf2 <update_style_cache+0x1f2>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
    9c8c:	2217      	movs	r2, #23
    9c8e:	4631      	mov	r1, r6
    9c90:	4628      	mov	r0, r5
    9c92:	f7ff fdb9 	bl	9808 <_lv_obj_get_style_int>
       lv_obj_get_style_margin_bottom(obj, part) != 0 ||
    9c96:	2800      	cmp	r0, #0
    9c98:	d1ab      	bne.n	9bf2 <update_style_cache+0x1f2>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
    9c9a:	2218      	movs	r2, #24
    9c9c:	4631      	mov	r1, r6
    9c9e:	4628      	mov	r0, r5
    9ca0:	f7ff fdb2 	bl	9808 <_lv_obj_get_style_int>
       lv_obj_get_style_margin_left(obj, part) != 0 ||
    9ca4:	2800      	cmp	r0, #0
    9ca6:	d1a4      	bne.n	9bf2 <update_style_cache+0x1f2>
    9ca8:	e7a7      	b.n	9bfa <update_style_cache+0x1fa>
    9caa:	bf00      	nop
    9cac:	200004f4 	.word	0x200004f4
    9cb0:	00040400 	.word	0x00040400

00009cb4 <_lv_obj_get_style_ptr>:
{
    9cb4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9cb8:	4606      	mov	r6, r0
    9cba:	468b      	mov	fp, r1
    9cbc:	4690      	mov	r8, r2
    while(parent) {
    9cbe:	4614      	mov	r4, r2
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
    9cc0:	f248 098e 	movw	r9, #32910	; 0x808e
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
    9cc4:	f342 2a07 	sbfx	sl, r2, #8, #8
    while(parent) {
    9cc8:	b316      	cbz	r6, 9d10 <_lv_obj_get_style_ptr+0x5c>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
    9cca:	4659      	mov	r1, fp
    9ccc:	4630      	mov	r0, r6
    9cce:	f00b ff0d 	bl	15aec <lv_obj_get_style_list>
        if(!list->ignore_cache && list->style_cnt > 0) {
    9cd2:	7943      	ldrb	r3, [r0, #5]
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
    9cd4:	4607      	mov	r7, r0
        if(!list->ignore_cache && list->style_cnt > 0) {
    9cd6:	0719      	lsls	r1, r3, #28
    9cd8:	d42c      	bmi.n	9d34 <_lv_obj_get_style_ptr+0x80>
    9cda:	7902      	ldrb	r2, [r0, #4]
    9cdc:	0692      	lsls	r2, r2, #26
    9cde:	d029      	beq.n	9d34 <_lv_obj_get_style_ptr+0x80>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
    9ce0:	f013 0f04 	tst.w	r3, #4
    9ce4:	f424 45fe 	bic.w	r5, r4, #32512	; 0x7f00
    9ce8:	d104      	bne.n	9cf4 <_lv_obj_get_style_ptr+0x40>
    9cea:	462a      	mov	r2, r5
    9cec:	4659      	mov	r1, fp
    9cee:	4630      	mov	r0, r6
    9cf0:	f7ff fe86 	bl	9a00 <update_style_cache>
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
    9cf4:	2d7f      	cmp	r5, #127	; 0x7f
    9cf6:	d007      	beq.n	9d08 <_lv_obj_get_style_ptr+0x54>
    9cf8:	454d      	cmp	r5, r9
    9cfa:	d017      	beq.n	9d2c <_lv_obj_get_style_ptr+0x78>
    9cfc:	2d6e      	cmp	r5, #110	; 0x6e
    9cfe:	d119      	bne.n	9d34 <_lv_obj_get_style_ptr+0x80>
                    if(list->pattern_img_null) def = true;
    9d00:	79fb      	ldrb	r3, [r7, #7]
    9d02:	f013 0f02 	tst.w	r3, #2
    9d06:	e002      	b.n	9d0e <_lv_obj_get_style_ptr+0x5a>
                    if(list->value_txt_str) def = true;
    9d08:	79fb      	ldrb	r3, [r7, #7]
    9d0a:	f013 0f08 	tst.w	r3, #8
                    if(list->pattern_img_null) def = true;
    9d0e:	d011      	beq.n	9d34 <_lv_obj_get_style_ptr+0x80>
    prop = prop & (~LV_STYLE_STATE_MASK);
    9d10:	f424 44fe 	bic.w	r4, r4, #32512	; 0x7f00
    switch(prop) {
    9d14:	2cbe      	cmp	r4, #190	; 0xbe
    prop = prop & (~LV_STYLE_STATE_MASK);
    9d16:	b2a3      	uxth	r3, r4
    switch(prop) {
    9d18:	d028      	beq.n	9d6c <_lv_obj_get_style_ptr+0xb8>
    9d1a:	f248 028e 	movw	r2, #32910	; 0x808e
    9d1e:	4293      	cmp	r3, r2
    9d20:	d001      	beq.n	9d26 <_lv_obj_get_style_ptr+0x72>
    9d22:	2b7e      	cmp	r3, #126	; 0x7e
    9d24:	d124      	bne.n	9d70 <_lv_obj_get_style_ptr+0xbc>
            return lv_theme_get_font_normal();
    9d26:	f003 fba7 	bl	d478 <lv_theme_get_font_normal>
    9d2a:	e012      	b.n	9d52 <_lv_obj_get_style_ptr+0x9e>
                    if(list->text_font_normal) def = true;
    9d2c:	f997 3007 	ldrsb.w	r3, [r7, #7]
    9d30:	2b00      	cmp	r3, #0
    9d32:	dbed      	blt.n	9d10 <_lv_obj_get_style_ptr+0x5c>
        lv_state_t state = lv_obj_get_state(parent, part);
    9d34:	4659      	mov	r1, fp
    9d36:	4630      	mov	r0, r6
    9d38:	f00b ff66 	bl	15c08 <lv_obj_get_state>
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
    9d3c:	eb08 2400 	add.w	r4, r8, r0, lsl #8
    9d40:	b2a4      	uxth	r4, r4
        res = _lv_style_list_get_ptr(list, prop, &value_act);
    9d42:	4621      	mov	r1, r4
    9d44:	4638      	mov	r0, r7
    9d46:	aa01      	add	r2, sp, #4
    9d48:	f00d fbe7 	bl	1751a <_lv_style_list_get_ptr>
        if(res == LV_RES_OK)  return value_act;
    9d4c:	2801      	cmp	r0, #1
    9d4e:	d103      	bne.n	9d58 <_lv_obj_get_style_ptr+0xa4>
    9d50:	9801      	ldr	r0, [sp, #4]
}
    9d52:	b003      	add	sp, #12
    9d54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
    9d58:	f1ba 0f00 	cmp.w	sl, #0
    9d5c:	dad8      	bge.n	9d10 <_lv_obj_get_style_ptr+0x5c>
        if(part != LV_OBJ_PART_MAIN) {
    9d5e:	f1bb 0f00 	cmp.w	fp, #0
    9d62:	d100      	bne.n	9d66 <_lv_obj_get_style_ptr+0xb2>
    return obj->parent;
    9d64:	6836      	ldr	r6, [r6, #0]
{
    9d66:	f04f 0b00 	mov.w	fp, #0
    9d6a:	e7ad      	b.n	9cc8 <_lv_obj_get_style_ptr+0x14>
            return &lv_anim_path_def;
    9d6c:	4801      	ldr	r0, [pc, #4]	; (9d74 <_lv_obj_get_style_ptr+0xc0>)
    9d6e:	e7f0      	b.n	9d52 <_lv_obj_get_style_ptr+0x9e>
    switch(prop) {
    9d70:	2000      	movs	r0, #0
    9d72:	e7ee      	b.n	9d52 <_lv_obj_get_style_ptr+0x9e>
    9d74:	0001f15c 	.word	0x0001f15c

00009d78 <lv_obj_refresh_style>:
{
    9d78:	b538      	push	{r3, r4, r5, lr}
    9d7a:	4614      	mov	r4, r2
    9d7c:	4605      	mov	r5, r0
    invalidate_style_cache(obj, part, prop);
    9d7e:	f00c f8a9 	bl	15ed4 <invalidate_style_cache>
    switch(prop) {
    9d82:	2c7f      	cmp	r4, #127	; 0x7f
    9d84:	d857      	bhi.n	9e36 <lv_obj_refresh_style+0xbe>
    9d86:	2c6f      	cmp	r4, #111	; 0x6f
    9d88:	d81b      	bhi.n	9dc2 <lv_obj_refresh_style+0x4a>
    9d8a:	2c5c      	cmp	r4, #92	; 0x5c
    9d8c:	d849      	bhi.n	9e22 <lv_obj_refresh_style+0xaa>
    9d8e:	2c3f      	cmp	r4, #63	; 0x3f
    9d90:	d83e      	bhi.n	9e10 <lv_obj_refresh_style+0x98>
    9d92:	2c07      	cmp	r4, #7
    9d94:	d84a      	bhi.n	9e2c <lv_obj_refresh_style+0xb4>
    9d96:	2c01      	cmp	r4, #1
    9d98:	d943      	bls.n	9e22 <lv_obj_refresh_style+0xaa>
        lv_obj_invalidate(obj);
    9d9a:	4628      	mov	r0, r5
    9d9c:	f00b fd40 	bl	15820 <lv_obj_invalidate>
        obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
    9da0:	2200      	movs	r2, #0
    9da2:	2104      	movs	r1, #4
    9da4:	4628      	mov	r0, r5
    9da6:	69eb      	ldr	r3, [r5, #28]
    9da8:	4798      	blx	r3
        switch(prop) {
    9daa:	2c18      	cmp	r4, #24
    9dac:	d854      	bhi.n	9e58 <lv_obj_refresh_style+0xe0>
    9dae:	2c14      	cmp	r4, #20
    9db0:	d954      	bls.n	9e5c <lv_obj_refresh_style+0xe4>
                if(obj->parent) obj->parent->signal_cb(obj->parent, LV_SIGNAL_CHILD_CHG, NULL);
    9db2:	6828      	ldr	r0, [r5, #0]
    9db4:	2800      	cmp	r0, #0
    9db6:	d051      	beq.n	9e5c <lv_obj_refresh_style+0xe4>
    9db8:	2200      	movs	r2, #0
    9dba:	2101      	movs	r1, #1
    9dbc:	69c3      	ldr	r3, [r0, #28]
    9dbe:	4798      	blx	r3
    9dc0:	e04c      	b.n	9e5c <lv_obj_refresh_style+0xe4>
    9dc2:	f1a4 0370 	sub.w	r3, r4, #112	; 0x70
    9dc6:	2b0f      	cmp	r3, #15
    9dc8:	d82b      	bhi.n	9e22 <lv_obj_refresh_style+0xaa>
    9dca:	a201      	add	r2, pc, #4	; (adr r2, 9dd0 <lv_obj_refresh_style+0x58>)
    9dcc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    9dd0:	00009d9b 	.word	0x00009d9b
    9dd4:	00009d9b 	.word	0x00009d9b
    9dd8:	00009e23 	.word	0x00009e23
    9ddc:	00009d9b 	.word	0x00009d9b
    9de0:	00009d9b 	.word	0x00009d9b
    9de4:	00009d9b 	.word	0x00009d9b
    9de8:	00009e23 	.word	0x00009e23
    9dec:	00009e23 	.word	0x00009e23
    9df0:	00009e23 	.word	0x00009e23
    9df4:	00009e23 	.word	0x00009e23
    9df8:	00009e23 	.word	0x00009e23
    9dfc:	00009e23 	.word	0x00009e23
    9e00:	00009d9b 	.word	0x00009d9b
    9e04:	00009e23 	.word	0x00009e23
    9e08:	00009d9b 	.word	0x00009d9b
    9e0c:	00009d9b 	.word	0x00009d9b
    9e10:	f1a4 0240 	sub.w	r2, r4, #64	; 0x40
    9e14:	b293      	uxth	r3, r2
    9e16:	2201      	movs	r2, #1
    9e18:	409a      	lsls	r2, r3
    9e1a:	4b17      	ldr	r3, [pc, #92]	; (9e78 <lv_obj_refresh_style+0x100>)
    9e1c:	4013      	ands	r3, r2
    9e1e:	2b00      	cmp	r3, #0
    9e20:	d1bb      	bne.n	9d9a <lv_obj_refresh_style+0x22>
        lv_obj_invalidate(obj);
    9e22:	4628      	mov	r0, r5
}
    9e24:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        lv_obj_invalidate(obj);
    9e28:	f00b bcfa 	b.w	15820 <lv_obj_invalidate>
    switch(prop) {
    9e2c:	f1a4 0310 	sub.w	r3, r4, #16
    9e30:	2b08      	cmp	r3, #8
    9e32:	d8f6      	bhi.n	9e22 <lv_obj_refresh_style+0xaa>
    9e34:	e7b1      	b.n	9d9a <lv_obj_refresh_style+0x22>
    9e36:	f248 0381 	movw	r3, #32897	; 0x8081
    9e3a:	429c      	cmp	r4, r3
    9e3c:	d808      	bhi.n	9e50 <lv_obj_refresh_style+0xd8>
    9e3e:	f248 037f 	movw	r3, #32895	; 0x807f
    9e42:	429c      	cmp	r4, r3
    9e44:	d8a9      	bhi.n	9d9a <lv_obj_refresh_style+0x22>
    9e46:	2c90      	cmp	r4, #144	; 0x90
    9e48:	d0a7      	beq.n	9d9a <lv_obj_refresh_style+0x22>
    9e4a:	2cff      	cmp	r4, #255	; 0xff
    9e4c:	d1e9      	bne.n	9e22 <lv_obj_refresh_style+0xaa>
    9e4e:	e7a4      	b.n	9d9a <lv_obj_refresh_style+0x22>
    9e50:	f248 038e 	movw	r3, #32910	; 0x808e
    9e54:	429c      	cmp	r4, r3
    9e56:	e7f9      	b.n	9e4c <lv_obj_refresh_style+0xd4>
        switch(prop) {
    9e58:	2cff      	cmp	r4, #255	; 0xff
    9e5a:	d0aa      	beq.n	9db2 <lv_obj_refresh_style+0x3a>
        lv_obj_invalidate(obj);
    9e5c:	4628      	mov	r0, r5
    9e5e:	f00b fcdf 	bl	15820 <lv_obj_invalidate>
        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);
    9e62:	2cff      	cmp	r4, #255	; 0xff
    9e64:	d001      	beq.n	9e6a <lv_obj_refresh_style+0xf2>
    9e66:	0423      	lsls	r3, r4, #16
    9e68:	d504      	bpl.n	9e74 <lv_obj_refresh_style+0xfc>
    9e6a:	4628      	mov	r0, r5
}
    9e6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);
    9e70:	f00b bde8 	b.w	15a44 <refresh_children_style>
}
    9e74:	bd38      	pop	{r3, r4, r5, pc}
    9e76:	bf00      	nop
    9e78:	100f1003 	.word	0x100f1003

00009e7c <lv_obj_set_state>:
{
    9e7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(obj->state == new_state) return;
    9e80:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
{
    9e84:	b0fb      	sub	sp, #492	; 0x1ec
    if(obj->state == new_state) return;
    9e86:	428b      	cmp	r3, r1
{
    9e88:	4604      	mov	r4, r0
    9e8a:	468b      	mov	fp, r1
    if(obj->state == new_state) return;
    9e8c:	9301      	str	r3, [sp, #4]
    9e8e:	f000 80bc 	beq.w	a00a <lv_obj_set_state+0x18e>
    9e92:	2500      	movs	r5, #0
    style_snapshot_res_t cmp_res = STYLE_COMPARE_SAME;
    9e94:	462e      	mov	r6, r5
    9e96:	b2ef      	uxtb	r7, r5
        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);
    9e98:	4639      	mov	r1, r7
    9e9a:	4620      	mov	r0, r4
    9e9c:	f00b fe26 	bl	15aec <lv_obj_get_style_list>
        if(style_list == NULL) break;   /*No more style lists*/
    9ea0:	2800      	cmp	r0, #0
    9ea2:	f000 8097 	beq.w	9fd4 <lv_obj_set_state+0x158>
        obj->state = prev_state;
    9ea6:	9b01      	ldr	r3, [sp, #4]
        style_snapshot(obj, part, &shot_pre);
    9ea8:	4639      	mov	r1, r7
    9eaa:	4620      	mov	r0, r4
        obj->state = prev_state;
    9eac:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        style_snapshot(obj, part, &shot_pre);
    9eb0:	aa0c      	add	r2, sp, #48	; 0x30
    9eb2:	f00c fbbe 	bl	16632 <style_snapshot>
        style_snapshot(obj, part, &shot_post);
    9eb6:	4639      	mov	r1, r7
    9eb8:	4620      	mov	r0, r4
    9eba:	aa43      	add	r2, sp, #268	; 0x10c
        obj->state = new_state;
    9ebc:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        style_snapshot(obj, part, &shot_post);
    9ec0:	f00c fbb7 	bl	16632 <style_snapshot>
    list->skip_trans = trans_ori;
}

static style_snapshot_res_t style_snapshot_compare(style_snapshot_t * shot1, style_snapshot_t * shot2)
{
    if(memcmp(shot1, shot2, sizeof(style_snapshot_t)) == 0) return STYLE_COMPARE_SAME;
    9ec4:	22dc      	movs	r2, #220	; 0xdc
    9ec6:	a943      	add	r1, sp, #268	; 0x10c
    9ec8:	a80c      	add	r0, sp, #48	; 0x30
    9eca:	f013 fd3c 	bl	1d946 <memcmp>
    9ece:	2800      	cmp	r0, #0
    9ed0:	d07c      	beq.n	9fcc <lv_obj_set_state+0x150>


    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;
    9ed2:	f9bd 20dc 	ldrsh.w	r2, [sp, #220]	; 0xdc
    9ed6:	f9bd 31b8 	ldrsh.w	r3, [sp, #440]	; 0x1b8
    9eda:	429a      	cmp	r2, r3
    9edc:	f040 8098 	bne.w	a010 <lv_obj_set_state+0x194>
    if(shot1->pad_bottom != shot2->pad_bottom) return STYLE_COMPARE_DIFF;
    9ee0:	f9bd 20de 	ldrsh.w	r2, [sp, #222]	; 0xde
    9ee4:	f9bd 31ba 	ldrsh.w	r3, [sp, #442]	; 0x1ba
    9ee8:	429a      	cmp	r2, r3
    9eea:	f040 8091 	bne.w	a010 <lv_obj_set_state+0x194>
    if(shot1->pad_left != shot2->pad_right) return STYLE_COMPARE_DIFF;
    9eee:	f9bd 21bc 	ldrsh.w	r2, [sp, #444]	; 0x1bc
    9ef2:	f9bd 30e2 	ldrsh.w	r3, [sp, #226]	; 0xe2
    9ef6:	4293      	cmp	r3, r2
    9ef8:	f040 808a 	bne.w	a010 <lv_obj_set_state+0x194>
    if(shot1->pad_right != shot2->pad_right) return STYLE_COMPARE_DIFF;
    9efc:	f9bd 20e0 	ldrsh.w	r2, [sp, #224]	; 0xe0
    9f00:	429a      	cmp	r2, r3
    9f02:	f040 8085 	bne.w	a010 <lv_obj_set_state+0x194>
    if(shot1->pad_top != shot2->pad_top) return STYLE_COMPARE_DIFF;
    if(shot1->pad_inner != shot2->pad_inner) return STYLE_COMPARE_DIFF;
    9f06:	f9bd 20e4 	ldrsh.w	r2, [sp, #228]	; 0xe4
    9f0a:	f9bd 31c0 	ldrsh.w	r3, [sp, #448]	; 0x1c0
    9f0e:	429a      	cmp	r2, r3
    9f10:	d17e      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;
    9f12:	f9bd 20e6 	ldrsh.w	r2, [sp, #230]	; 0xe6
    9f16:	f9bd 31c2 	ldrsh.w	r3, [sp, #450]	; 0x1c2
    9f1a:	429a      	cmp	r2, r3
    9f1c:	d178      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->margin_bottom != shot2->margin_bottom) return STYLE_COMPARE_DIFF;
    9f1e:	f9bd 20e8 	ldrsh.w	r2, [sp, #232]	; 0xe8
    9f22:	f9bd 31c4 	ldrsh.w	r3, [sp, #452]	; 0x1c4
    9f26:	429a      	cmp	r2, r3
    9f28:	d172      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->margin_left != shot2->margin_right) return STYLE_COMPARE_DIFF;
    9f2a:	f9bd 31c8 	ldrsh.w	r3, [sp, #456]	; 0x1c8
    9f2e:	f9bd 20ea 	ldrsh.w	r2, [sp, #234]	; 0xea
    9f32:	429a      	cmp	r2, r3
    9f34:	d16c      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->margin_right != shot2->margin_right) return STYLE_COMPARE_DIFF;
    9f36:	f9bd 20ec 	ldrsh.w	r2, [sp, #236]	; 0xec
    9f3a:	429a      	cmp	r2, r3
    9f3c:	d168      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->margin_top != shot2->margin_top) return STYLE_COMPARE_DIFF;
    if(shot1->transform_width != shot2->transform_width) return STYLE_COMPARE_DIFF;
    9f3e:	f9bd 20f0 	ldrsh.w	r2, [sp, #240]	; 0xf0
    9f42:	f9bd 31cc 	ldrsh.w	r3, [sp, #460]	; 0x1cc
    9f46:	429a      	cmp	r2, r3
    9f48:	d162      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->transform_height != shot2->transform_height) return STYLE_COMPARE_DIFF;
    9f4a:	f9bd 20f2 	ldrsh.w	r2, [sp, #242]	; 0xf2
    9f4e:	f9bd 31ce 	ldrsh.w	r3, [sp, #462]	; 0x1ce
    9f52:	429a      	cmp	r2, r3
    9f54:	d15c      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->transform_angle != shot2->transform_angle) return STYLE_COMPARE_DIFF;
    9f56:	f9bd 20f4 	ldrsh.w	r2, [sp, #244]	; 0xf4
    9f5a:	f9bd 31d0 	ldrsh.w	r3, [sp, #464]	; 0x1d0
    9f5e:	429a      	cmp	r2, r3
    9f60:	d156      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->transform_zoom != shot2->transform_zoom) return STYLE_COMPARE_DIFF;
    9f62:	f9bd 20f6 	ldrsh.w	r2, [sp, #246]	; 0xf6
    9f66:	f9bd 31d2 	ldrsh.w	r3, [sp, #466]	; 0x1d2
    9f6a:	429a      	cmp	r2, r3
    9f6c:	d150      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->rect.outline_width != shot2->rect.outline_width) return STYLE_COMPARE_DIFF;
    9f6e:	f9bd 2054 	ldrsh.w	r2, [sp, #84]	; 0x54
    9f72:	f9bd 3130 	ldrsh.w	r3, [sp, #304]	; 0x130
    9f76:	429a      	cmp	r2, r3
    9f78:	d14a      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->rect.outline_pad != shot2->rect.outline_pad) return STYLE_COMPARE_DIFF;
    9f7a:	f9bd 2056 	ldrsh.w	r2, [sp, #86]	; 0x56
    9f7e:	f9bd 3132 	ldrsh.w	r3, [sp, #306]	; 0x132
    9f82:	429a      	cmp	r2, r3
    9f84:	d144      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;
    9f86:	9a20      	ldr	r2, [sp, #128]	; 0x80
    9f88:	9b57      	ldr	r3, [sp, #348]	; 0x15c
    9f8a:	429a      	cmp	r2, r3
    9f8c:	d140      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->rect.value_align != shot2->rect.value_align) return STYLE_COMPARE_DIFF;
    9f8e:	f89d 2094 	ldrb.w	r2, [sp, #148]	; 0x94
    9f92:	f89d 3170 	ldrb.w	r3, [sp, #368]	; 0x170
    9f96:	429a      	cmp	r2, r3
    9f98:	d13a      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->rect.value_font != shot2->rect.value_font) return STYLE_COMPARE_DIFF;
    if(shot1->rect.shadow_spread != shot2->rect.shadow_spread) return STYLE_COMPARE_DIFF;
    9f9a:	f9bd 2066 	ldrsh.w	r2, [sp, #102]	; 0x66
    9f9e:	f9bd 3142 	ldrsh.w	r3, [sp, #322]	; 0x142
    9fa2:	429a      	cmp	r2, r3
    9fa4:	d134      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->rect.shadow_width != shot2->rect.shadow_width) return STYLE_COMPARE_DIFF;
    9fa6:	f9bd 2060 	ldrsh.w	r2, [sp, #96]	; 0x60
    9faa:	f9bd 313c 	ldrsh.w	r3, [sp, #316]	; 0x13c
    9fae:	429a      	cmp	r2, r3
    9fb0:	d12e      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->rect.shadow_ofs_x != shot2->rect.shadow_ofs_x) return STYLE_COMPARE_DIFF;
    9fb2:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
    9fb6:	f9bd 313e 	ldrsh.w	r3, [sp, #318]	; 0x13e
    9fba:	429a      	cmp	r2, r3
    9fbc:	d128      	bne.n	a010 <lv_obj_set_state+0x194>
    if(shot1->rect.shadow_ofs_y != shot2->rect.shadow_ofs_y) return STYLE_COMPARE_DIFF;
    9fbe:	f9bd 2064 	ldrsh.w	r2, [sp, #100]	; 0x64
    9fc2:	f9bd 3140 	ldrsh.w	r3, [sp, #320]	; 0x140
    9fc6:	429a      	cmp	r2, r3
    9fc8:	d122      	bne.n	a010 <lv_obj_set_state+0x194>
            cmp_res = STYLE_COMPARE_VISUAL_DIFF;
    9fca:	2601      	movs	r6, #1
    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
    9fcc:	3501      	adds	r5, #1
    9fce:	2d40      	cmp	r5, #64	; 0x40
    9fd0:	f47f af61 	bne.w	9e96 <lv_obj_set_state+0x1a>
    obj->state = new_state;
    9fd4:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
    if(cmp_res == STYLE_COMPARE_SAME) {
    9fd8:	b1be      	cbz	r6, a00a <lv_obj_set_state+0x18e>
    9fda:	2300      	movs	r3, #0
    9fdc:	9303      	str	r3, [sp, #12]
    9fde:	f89d 500c 	ldrb.w	r5, [sp, #12]
        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);
    9fe2:	4620      	mov	r0, r4
    9fe4:	4629      	mov	r1, r5
    9fe6:	f00b fd81 	bl	15aec <lv_obj_get_style_list>
        if(style_list == NULL) break;   /*No more style lists*/
    9fea:	9005      	str	r0, [sp, #20]
    9fec:	b140      	cbz	r0, a000 <lv_obj_set_state+0x184>
        if(style_list->ignore_trans) continue;
    9fee:	7947      	ldrb	r7, [r0, #5]
    9ff0:	f017 0702 	ands.w	r7, r7, #2
    9ff4:	d00e      	beq.n	a014 <lv_obj_set_state+0x198>
    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {
    9ff6:	9b03      	ldr	r3, [sp, #12]
    9ff8:	3301      	adds	r3, #1
    9ffa:	2b40      	cmp	r3, #64	; 0x40
    9ffc:	9303      	str	r3, [sp, #12]
    9ffe:	d1ee      	bne.n	9fde <lv_obj_set_state+0x162>
    if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {
    a000:	2e01      	cmp	r6, #1
    a002:	d102      	bne.n	a00a <lv_obj_set_state+0x18e>
        lv_obj_invalidate(obj);
    a004:	4620      	mov	r0, r4
    a006:	f00b fc0b 	bl	15820 <lv_obj_invalidate>
}
    a00a:	b07b      	add	sp, #492	; 0x1ec
    a00c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            cmp_res = STYLE_COMPARE_DIFF;
    a010:	2602      	movs	r6, #2
    a012:	e7df      	b.n	9fd4 <lv_obj_set_state+0x158>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
    a014:	22b0      	movs	r2, #176	; 0xb0
    a016:	4629      	mov	r1, r5
    a018:	4620      	mov	r0, r4
    a01a:	f7ff fbf5 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_DELAY, transition_delay, lv_style_int_t, _int, scalar)
    a01e:	22b1      	movs	r2, #177	; 0xb1
    a020:	4629      	mov	r1, r5
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
    a022:	9008      	str	r0, [sp, #32]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_DELAY, transition_delay, lv_style_int_t, _int, scalar)
    a024:	4620      	mov	r0, r4
    a026:	f7ff fbef 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, lv_anim_path_t *, _ptr, scalar)
    a02a:	22be      	movs	r2, #190	; 0xbe
    a02c:	4629      	mov	r1, r5
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_DELAY, transition_delay, lv_style_int_t, _int, scalar)
    a02e:	9007      	str	r0, [sp, #28]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, lv_anim_path_t *, _ptr, scalar)
    a030:	4620      	mov	r0, r4
    a032:	f7ff fe3f 	bl	9cb4 <_lv_obj_get_style_ptr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_1, transition_prop_1, lv_style_int_t, _int, scalar)
    a036:	22b2      	movs	r2, #178	; 0xb2
    a038:	4629      	mov	r1, r5
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, lv_anim_path_t *, _ptr, scalar)
    a03a:	9006      	str	r0, [sp, #24]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_1, transition_prop_1, lv_style_int_t, _int, scalar)
    a03c:	4620      	mov	r0, r4
    a03e:	f7ff fbe3 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_2, transition_prop_2, lv_style_int_t, _int, scalar)
    a042:	22b3      	movs	r2, #179	; 0xb3
    a044:	4629      	mov	r1, r5
        props[0] = lv_obj_get_style_transition_prop_1(obj, part);
    a046:	f8ad 0030 	strh.w	r0, [sp, #48]	; 0x30
    a04a:	4620      	mov	r0, r4
    a04c:	f7ff fbdc 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_3, transition_prop_3, lv_style_int_t, _int, scalar)
    a050:	22b4      	movs	r2, #180	; 0xb4
    a052:	4629      	mov	r1, r5
        props[1] = lv_obj_get_style_transition_prop_2(obj, part);
    a054:	f8ad 0032 	strh.w	r0, [sp, #50]	; 0x32
    a058:	4620      	mov	r0, r4
    a05a:	f7ff fbd5 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_4, transition_prop_4, lv_style_int_t, _int, scalar)
    a05e:	22b5      	movs	r2, #181	; 0xb5
    a060:	4629      	mov	r1, r5
        props[2] = lv_obj_get_style_transition_prop_3(obj, part);
    a062:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
    a066:	4620      	mov	r0, r4
    a068:	f7ff fbce 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_5, transition_prop_5, lv_style_int_t, _int, scalar)
    a06c:	22b6      	movs	r2, #182	; 0xb6
    a06e:	4629      	mov	r1, r5
        props[3] = lv_obj_get_style_transition_prop_4(obj, part);
    a070:	f8ad 0036 	strh.w	r0, [sp, #54]	; 0x36
    a074:	4620      	mov	r0, r4
    a076:	f7ff fbc7 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_6, transition_prop_6, lv_style_int_t, _int, scalar)
    a07a:	22b7      	movs	r2, #183	; 0xb7
        props[4] = lv_obj_get_style_transition_prop_5(obj, part);
    a07c:	f8ad 0038 	strh.w	r0, [sp, #56]	; 0x38
    a080:	4629      	mov	r1, r5
    a082:	4620      	mov	r0, r4
    a084:	f7ff fbc0 	bl	9808 <_lv_obj_get_style_int>
        props[5] = lv_obj_get_style_transition_prop_6(obj, part);
    a088:	9704      	str	r7, [sp, #16]
    a08a:	f8ad 003a 	strh.w	r0, [sp, #58]	; 0x3a
            if(props[i] != 0) {
    a08e:	9a04      	ldr	r2, [sp, #16]
    a090:	ab0c      	add	r3, sp, #48	; 0x30
    a092:	f833 7012 	ldrh.w	r7, [r3, r2, lsl #1]
    a096:	2f00      	cmp	r7, #0
    a098:	f000 8099 	beq.w	a1ce <lv_obj_set_state+0x352>
                _lv_style_list_add_trans_style(style_list);
    a09c:	9805      	ldr	r0, [sp, #20]
    a09e:	f00d f958 	bl	17352 <_lv_style_list_add_trans_style>
    lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);
    a0a2:	4629      	mov	r1, r5
    a0a4:	4620      	mov	r0, r4
    a0a6:	f00b fd21 	bl	15aec <lv_obj_get_style_list>
    a0aa:	4680      	mov	r8, r0
    lv_style_t * style_trans = _lv_style_list_get_transition_style(style_list);
    a0ac:	f00d f8ad 	bl	1720a <_lv_style_list_get_transition_style>
    bool cahche_ori = style_list->ignore_cache;
    a0b0:	f898 3005 	ldrb.w	r3, [r8, #5]
    lv_style_t * style_trans = _lv_style_list_get_transition_style(style_list);
    a0b4:	4682      	mov	sl, r0
    bool cahche_ori = style_list->ignore_cache;
    a0b6:	f3c3 02c0 	ubfx	r2, r3, #3, #1
    a0ba:	9202      	str	r2, [sp, #8]
    if((prop & 0xF) < LV_STYLE_ID_COLOR) { /*Int*/
    a0bc:	f007 020f 	and.w	r2, r7, #15
    a0c0:	2a08      	cmp	r2, #8
    a0c2:	f200 8094 	bhi.w	a1ee <lv_obj_set_state+0x372>
        style_list->skip_trans = 1;
    a0c6:	f023 0309 	bic.w	r3, r3, #9
    a0ca:	f043 0309 	orr.w	r3, r3, #9
    a0ce:	f888 3005 	strb.w	r3, [r8, #5]
        obj->state = prev_state;
    a0d2:	9b01      	ldr	r3, [sp, #4]
        lv_style_int_t int1 = _lv_obj_get_style_int(obj, part, prop);
    a0d4:	463a      	mov	r2, r7
        obj->state = prev_state;
    a0d6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        lv_style_int_t int1 = _lv_obj_get_style_int(obj, part, prop);
    a0da:	4629      	mov	r1, r5
    a0dc:	4620      	mov	r0, r4
    a0de:	f7ff fb93 	bl	9808 <_lv_obj_get_style_int>
        lv_style_int_t int2 =  _lv_obj_get_style_int(obj, part, prop);
    a0e2:	463a      	mov	r2, r7
        lv_style_int_t int1 = _lv_obj_get_style_int(obj, part, prop);
    a0e4:	9009      	str	r0, [sp, #36]	; 0x24
        lv_style_int_t int2 =  _lv_obj_get_style_int(obj, part, prop);
    a0e6:	4629      	mov	r1, r5
    a0e8:	4620      	mov	r0, r4
        obj->state = new_state;
    a0ea:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        lv_style_int_t int2 =  _lv_obj_get_style_int(obj, part, prop);
    a0ee:	f7ff fb8b 	bl	9808 <_lv_obj_get_style_int>
        style_list->skip_trans = 0;
    a0f2:	f898 2005 	ldrb.w	r2, [r8, #5]
        style_list->ignore_cache = cahche_ori;
    a0f6:	9b02      	ldr	r3, [sp, #8]
    a0f8:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    a0fc:	f363 02c3 	bfi	r2, r3, #3, #1
    a100:	f888 2005 	strb.w	r2, [r8, #5]
        if(int1 == int2)  return NULL;
    a104:	9b09      	ldr	r3, [sp, #36]	; 0x24
        lv_style_int_t int2 =  _lv_obj_get_style_int(obj, part, prop);
    a106:	4681      	mov	r9, r0
        if(int1 == int2)  return NULL;
    a108:	4283      	cmp	r3, r0
    a10a:	d060      	beq.n	a1ce <lv_obj_set_state+0x352>
        obj->state = prev_state;
    a10c:	9b01      	ldr	r3, [sp, #4]
        int1 = _lv_obj_get_style_int(obj, part, prop);
    a10e:	463a      	mov	r2, r7
    a110:	4629      	mov	r1, r5
        obj->state = prev_state;
    a112:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        int1 = _lv_obj_get_style_int(obj, part, prop);
    a116:	4620      	mov	r0, r4
    a118:	f7ff fb76 	bl	9808 <_lv_obj_get_style_int>
        _lv_style_set_int(style_trans, prop, int1);   /*Be sure `trans_style` has a valid value */
    a11c:	4639      	mov	r1, r7
    a11e:	4602      	mov	r2, r0
        int1 = _lv_obj_get_style_int(obj, part, prop);
    a120:	4680      	mov	r8, r0
        obj->state = new_state;
    a122:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        _lv_style_set_int(style_trans, prop, int1);   /*Be sure `trans_style` has a valid value */
    a126:	4650      	mov	r0, sl
    a128:	f00c fef4 	bl	16f14 <_lv_style_set_int>
        if(prop == LV_STYLE_RADIUS) {
    a12c:	2f01      	cmp	r7, #1
    a12e:	d11c      	bne.n	a16a <lv_obj_set_state+0x2ee>
            if(int1 == LV_RADIUS_CIRCLE || int2 == LV_RADIUS_CIRCLE) {
    a130:	f647 73ff 	movw	r3, #32767	; 0x7fff
    a134:	4598      	cmp	r8, r3
    a136:	d001      	beq.n	a13c <lv_obj_set_state+0x2c0>
    a138:	4599      	cmp	r9, r3
    a13a:	d116      	bne.n	a16a <lv_obj_set_state+0x2ee>
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a13c:	8aa3      	ldrh	r3, [r4, #20]
    a13e:	8a22      	ldrh	r2, [r4, #16]
    a140:	3301      	adds	r3, #1
    a142:	1a9b      	subs	r3, r3, r2
                lv_coord_t whalf = lv_obj_get_width(obj) / 2;
    a144:	f3c3 32c0 	ubfx	r2, r3, #15, #1
    a148:	fa02 f383 	sxtah	r3, r2, r3
                if(int1 == LV_RADIUS_CIRCLE) int1 = LV_MATH_MIN(whalf + 1, hhalf + 1);
    a14c:	f647 72ff 	movw	r2, #32767	; 0x7fff
                lv_coord_t whalf = lv_obj_get_width(obj) / 2;
    a150:	105b      	asrs	r3, r3, #1
                if(int1 == LV_RADIUS_CIRCLE) int1 = LV_MATH_MIN(whalf + 1, hhalf + 1);
    a152:	4590      	cmp	r8, r2
    a154:	bf04      	itt	eq
    a156:	f103 0801 	addeq.w	r8, r3, #1
    a15a:	fa0f f888 	sxtheq.w	r8, r8
                if(int2 == LV_RADIUS_CIRCLE) int2 = LV_MATH_MIN(whalf + 1, hhalf + 1);
    a15e:	4591      	cmp	r9, r2
    a160:	bf04      	itt	eq
    a162:	f103 0901 	addeq.w	r9, r3, #1
    a166:	fa0f f989 	sxtheq.w	r9, r9
        tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));
    a16a:	4885      	ldr	r0, [pc, #532]	; (a380 <lv_obj_set_state+0x504>)
    a16c:	f011 f816 	bl	1b19c <_lv_ll_ins_head>
        if(tr == NULL) return NULL;
    a170:	4682      	mov	sl, r0
    a172:	b360      	cbz	r0, a1ce <lv_obj_set_state+0x352>
        tr->start_value._int = int1;
    a174:	f8a0 8008 	strh.w	r8, [r0, #8]
        tr->end_value._int = int2;
    a178:	f8a0 900c 	strh.w	r9, [r0, #12]
                    tr->prop = props[i];
    a17c:	f8aa 7004 	strh.w	r7, [sl, #4]
                    lv_anim_init(&a);
    a180:	a843      	add	r0, sp, #268	; 0x10c
                    tr->obj = obj;
    a182:	f8ca 4000 	str.w	r4, [sl]
                    tr->part = part;
    a186:	f88a 5006 	strb.w	r5, [sl, #6]
                    lv_anim_init(&a);
    a18a:	f002 fbf7 	bl	c97c <lv_anim_init>
    a->exec_cb = exec_cb;
    a18e:	4b7d      	ldr	r3, [pc, #500]	; (a384 <lv_obj_set_state+0x508>)
    a->start = start;
    a190:	2700      	movs	r7, #0
    a->exec_cb = exec_cb;
    a192:	9344      	str	r3, [sp, #272]	; 0x110
    a->start_cb = start_cb;
    a194:	4b7c      	ldr	r3, [pc, #496]	; (a388 <lv_obj_set_state+0x50c>)
    _lv_memcpy_small(&a->path, path, sizeof(lv_anim_path_t));
    a196:	2208      	movs	r2, #8
    a->start_cb = start_cb;
    a198:	9345      	str	r3, [sp, #276]	; 0x114
    a->ready_cb = ready_cb;
    a19a:	4b7c      	ldr	r3, [pc, #496]	; (a38c <lv_obj_set_state+0x510>)
    _lv_memcpy_small(&a->path, path, sizeof(lv_anim_path_t));
    a19c:	9906      	ldr	r1, [sp, #24]
    a->ready_cb = ready_cb;
    a19e:	9346      	str	r3, [sp, #280]	; 0x118
    a->end   = end;
    a1a0:	23ff      	movs	r3, #255	; 0xff
    a1a2:	934b      	str	r3, [sp, #300]	; 0x12c
    a->time     = duration;
    a1a4:	9b08      	ldr	r3, [sp, #32]
    _lv_memcpy_small(&a->path, path, sizeof(lv_anim_path_t));
    a1a6:	a847      	add	r0, sp, #284	; 0x11c
    a->time     = duration;
    a1a8:	934c      	str	r3, [sp, #304]	; 0x130
    a->act_time = -(int32_t)(delay);
    a1aa:	9b07      	ldr	r3, [sp, #28]
    a->current = start;
    a1ac:	e9cd 7749 	strd	r7, r7, [sp, #292]	; 0x124
    a->act_time = -(int32_t)(delay);
    a1b0:	425b      	negs	r3, r3
    a1b2:	934d      	str	r3, [sp, #308]	; 0x134
    a->var     = var;
    a1b4:	f8cd a10c 	str.w	sl, [sp, #268]	; 0x10c
    _lv_memcpy_small(&a->path, path, sizeof(lv_anim_path_t));
    a1b8:	f00b fa7e 	bl	156b8 <_lv_memcpy>
                    a.early_apply = 0;
    a1bc:	f89d 3146 	ldrb.w	r3, [sp, #326]	; 0x146
                    lv_anim_start(&a);
    a1c0:	a843      	add	r0, sp, #268	; 0x10c
                    a.early_apply = 0;
    a1c2:	f367 0300 	bfi	r3, r7, #0, #1
    a1c6:	f88d 3146 	strb.w	r3, [sp, #326]	; 0x146
                    lv_anim_start(&a);
    a1ca:	f002 fc1f 	bl	ca0c <lv_anim_start>
        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {
    a1ce:	9b04      	ldr	r3, [sp, #16]
    a1d0:	3301      	adds	r3, #1
    a1d2:	2b06      	cmp	r3, #6
    a1d4:	9304      	str	r3, [sp, #16]
    a1d6:	f47f af5a 	bne.w	a08e <lv_obj_set_state+0x212>
        if(cmp_res == STYLE_COMPARE_DIFF) lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
    a1da:	2e02      	cmp	r6, #2
    a1dc:	f04f 02ff 	mov.w	r2, #255	; 0xff
    a1e0:	4629      	mov	r1, r5
    a1e2:	4620      	mov	r0, r4
    a1e4:	f040 80c9 	bne.w	a37a <lv_obj_set_state+0x4fe>
    a1e8:	f7ff fdc6 	bl	9d78 <lv_obj_refresh_style>
        if(cmp_res == STYLE_COMPARE_VISUAL_DIFF) {
    a1ec:	e703      	b.n	9ff6 <lv_obj_set_state+0x17a>
    else if((prop & 0xF) < LV_STYLE_ID_OPA) { /*Color*/
    a1ee:	2a0b      	cmp	r2, #11
    a1f0:	d83d      	bhi.n	a26e <lv_obj_set_state+0x3f2>
        style_list->skip_trans = 1;
    a1f2:	f023 0309 	bic.w	r3, r3, #9
    a1f6:	f043 0309 	orr.w	r3, r3, #9
    a1fa:	f888 3005 	strb.w	r3, [r8, #5]
        obj->state = prev_state;
    a1fe:	9b01      	ldr	r3, [sp, #4]
        lv_color_t c1 = _lv_obj_get_style_color(obj, part, prop);
    a200:	463a      	mov	r2, r7
    a202:	4629      	mov	r1, r5
        obj->state = prev_state;
    a204:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        lv_color_t c1 = _lv_obj_get_style_color(obj, part, prop);
    a208:	4620      	mov	r0, r4
    a20a:	f00b fd11 	bl	15c30 <_lv_obj_get_style_color>
        lv_color_t c2 =  _lv_obj_get_style_color(obj, part, prop);
    a20e:	463a      	mov	r2, r7
        lv_color_t c1 = _lv_obj_get_style_color(obj, part, prop);
    a210:	4681      	mov	r9, r0
        lv_color_t c2 =  _lv_obj_get_style_color(obj, part, prop);
    a212:	4629      	mov	r1, r5
    a214:	4620      	mov	r0, r4
        obj->state = new_state;
    a216:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        lv_color_t c2 =  _lv_obj_get_style_color(obj, part, prop);
    a21a:	f00b fd09 	bl	15c30 <_lv_obj_get_style_color>
        style_list->skip_trans = 0;
    a21e:	f898 2005 	ldrb.w	r2, [r8, #5]
        style_list->ignore_cache = cahche_ori;
    a222:	9902      	ldr	r1, [sp, #8]
    a224:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    a228:	f361 02c3 	bfi	r2, r1, #3, #1
        if(c1.full == c2.full) return NULL;
    a22c:	4581      	cmp	r9, r0
        style_list->ignore_cache = cahche_ori;
    a22e:	f888 2005 	strb.w	r2, [r8, #5]
        if(c1.full == c2.full) return NULL;
    a232:	9002      	str	r0, [sp, #8]
    a234:	d0cb      	beq.n	a1ce <lv_obj_set_state+0x352>
        obj->state = prev_state;
    a236:	9b01      	ldr	r3, [sp, #4]
        c1 = _lv_obj_get_style_color(obj, part, prop);
    a238:	463a      	mov	r2, r7
        obj->state = prev_state;
    a23a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        c1 = _lv_obj_get_style_color(obj, part, prop);
    a23e:	4629      	mov	r1, r5
    a240:	4620      	mov	r0, r4
    a242:	f00b fcf5 	bl	15c30 <_lv_obj_get_style_color>
        _lv_style_set_color(style_trans, prop, c1);    /*Be sure `trans_style` has a valid value */
    a246:	4639      	mov	r1, r7
    a248:	4602      	mov	r2, r0
        c1 = _lv_obj_get_style_color(obj, part, prop);
    a24a:	4681      	mov	r9, r0
        obj->state = new_state;
    a24c:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        _lv_style_set_color(style_trans, prop, c1);    /*Be sure `trans_style` has a valid value */
    a250:	4650      	mov	r0, sl
    a252:	f00c fea3 	bl	16f9c <_lv_style_set_color>
        tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));
    a256:	484a      	ldr	r0, [pc, #296]	; (a380 <lv_obj_set_state+0x504>)
    a258:	f010 ffa0 	bl	1b19c <_lv_ll_ins_head>
        if(tr == NULL) return NULL;
    a25c:	4682      	mov	sl, r0
    a25e:	2800      	cmp	r0, #0
    a260:	d0b5      	beq.n	a1ce <lv_obj_set_state+0x352>
        tr->end_value._color = c2;
    a262:	9b02      	ldr	r3, [sp, #8]
        tr->start_value._color = c1;
    a264:	f8c0 9008 	str.w	r9, [r0, #8]
        tr->end_value._ptr = p2;
    a268:	f8ca 300c 	str.w	r3, [sl, #12]
    a26c:	e786      	b.n	a17c <lv_obj_set_state+0x300>
    else if((prop & 0xF) < LV_STYLE_ID_PTR) { /*Opa*/
    a26e:	2a0d      	cmp	r2, #13
    a270:	d83e      	bhi.n	a2f0 <lv_obj_set_state+0x474>
        style_list->skip_trans = 1;
    a272:	f023 0309 	bic.w	r3, r3, #9
    a276:	f043 0309 	orr.w	r3, r3, #9
    a27a:	f888 3005 	strb.w	r3, [r8, #5]
        obj->state = prev_state;
    a27e:	9b01      	ldr	r3, [sp, #4]
        lv_opa_t o1 = _lv_obj_get_style_opa(obj, part, prop);
    a280:	463a      	mov	r2, r7
        obj->state = prev_state;
    a282:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        lv_opa_t o1 = _lv_obj_get_style_opa(obj, part, prop);
    a286:	4629      	mov	r1, r5
    a288:	4620      	mov	r0, r4
    a28a:	f00b fd1e 	bl	15cca <_lv_obj_get_style_opa>
        lv_opa_t o2 =  _lv_obj_get_style_opa(obj, part, prop);
    a28e:	463a      	mov	r2, r7
        lv_opa_t o1 = _lv_obj_get_style_opa(obj, part, prop);
    a290:	9009      	str	r0, [sp, #36]	; 0x24
        lv_opa_t o2 =  _lv_obj_get_style_opa(obj, part, prop);
    a292:	4629      	mov	r1, r5
    a294:	4620      	mov	r0, r4
        obj->state = new_state;
    a296:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        lv_opa_t o2 =  _lv_obj_get_style_opa(obj, part, prop);
    a29a:	f00b fd16 	bl	15cca <_lv_obj_get_style_opa>
        style_list->skip_trans = 0;
    a29e:	f898 2005 	ldrb.w	r2, [r8, #5]
        style_list->ignore_cache = cahche_ori;
    a2a2:	9b02      	ldr	r3, [sp, #8]
    a2a4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    a2a8:	f363 02c3 	bfi	r2, r3, #3, #1
    a2ac:	f888 2005 	strb.w	r2, [r8, #5]
        if(o1 == o2) return NULL;
    a2b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
        lv_opa_t o2 =  _lv_obj_get_style_opa(obj, part, prop);
    a2b2:	4681      	mov	r9, r0
        if(o1 == o2) return NULL;
    a2b4:	4283      	cmp	r3, r0
    a2b6:	d08a      	beq.n	a1ce <lv_obj_set_state+0x352>
        obj->state = prev_state;
    a2b8:	9b01      	ldr	r3, [sp, #4]
        o1 = _lv_obj_get_style_opa(obj, part, prop);
    a2ba:	463a      	mov	r2, r7
        obj->state = prev_state;
    a2bc:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        o1 = _lv_obj_get_style_opa(obj, part, prop);
    a2c0:	4629      	mov	r1, r5
    a2c2:	4620      	mov	r0, r4
    a2c4:	f00b fd01 	bl	15cca <_lv_obj_get_style_opa>
        _lv_style_set_opa(style_trans, prop, o1);   /*Be sure `trans_style` has a valid value */
    a2c8:	4639      	mov	r1, r7
    a2ca:	4602      	mov	r2, r0
        o1 = _lv_obj_get_style_opa(obj, part, prop);
    a2cc:	4680      	mov	r8, r0
        obj->state = new_state;
    a2ce:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        _lv_style_set_opa(style_trans, prop, o1);   /*Be sure `trans_style` has a valid value */
    a2d2:	4650      	mov	r0, sl
    a2d4:	f00c fea6 	bl	17024 <_lv_style_set_opa>
        tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));
    a2d8:	4829      	ldr	r0, [pc, #164]	; (a380 <lv_obj_set_state+0x504>)
    a2da:	f010 ff5f 	bl	1b19c <_lv_ll_ins_head>
        if(tr == NULL) return NULL;
    a2de:	4682      	mov	sl, r0
    a2e0:	2800      	cmp	r0, #0
    a2e2:	f43f af74 	beq.w	a1ce <lv_obj_set_state+0x352>
        tr->start_value._opa = o1;
    a2e6:	f880 8008 	strb.w	r8, [r0, #8]
        tr->end_value._opa = o2;
    a2ea:	f880 900c 	strb.w	r9, [r0, #12]
    a2ee:	e745      	b.n	a17c <lv_obj_set_state+0x300>
        obj->state = prev_state;
    a2f0:	9b01      	ldr	r3, [sp, #4]
        const void * p1 = _lv_obj_get_style_ptr(obj, part, prop);
    a2f2:	463a      	mov	r2, r7
        obj->state = prev_state;
    a2f4:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        style_list->skip_trans = 1;
    a2f8:	f898 3005 	ldrb.w	r3, [r8, #5]
        const void * p1 = _lv_obj_get_style_ptr(obj, part, prop);
    a2fc:	4629      	mov	r1, r5
        style_list->skip_trans = 1;
    a2fe:	f023 0309 	bic.w	r3, r3, #9
    a302:	f043 0309 	orr.w	r3, r3, #9
    a306:	f888 3005 	strb.w	r3, [r8, #5]
        const void * p1 = _lv_obj_get_style_ptr(obj, part, prop);
    a30a:	4620      	mov	r0, r4
    a30c:	f7ff fcd2 	bl	9cb4 <_lv_obj_get_style_ptr>
        const void * p2 = _lv_obj_get_style_ptr(obj, part, prop);
    a310:	463a      	mov	r2, r7
    a312:	4629      	mov	r1, r5
        const void * p1 = _lv_obj_get_style_ptr(obj, part, prop);
    a314:	900b      	str	r0, [sp, #44]	; 0x2c
        obj->state = new_state;
    a316:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        const void * p2 = _lv_obj_get_style_ptr(obj, part, prop);
    a31a:	4620      	mov	r0, r4
    a31c:	f7ff fcca 	bl	9cb4 <_lv_obj_get_style_ptr>
    a320:	9043      	str	r0, [sp, #268]	; 0x10c
        style_list->skip_trans = 0;
    a322:	f898 3005 	ldrb.w	r3, [r8, #5]
        style_list->ignore_cache = cahche_ori;
    a326:	9a02      	ldr	r2, [sp, #8]
    a328:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    a32c:	f362 03c3 	bfi	r3, r2, #3, #1
    a330:	f888 3005 	strb.w	r3, [r8, #5]
        if(memcmp(&p1, &p2, sizeof(const void *)) == 0)  return NULL;
    a334:	2204      	movs	r2, #4
    a336:	a943      	add	r1, sp, #268	; 0x10c
    a338:	a80b      	add	r0, sp, #44	; 0x2c
    a33a:	f013 fb04 	bl	1d946 <memcmp>
    a33e:	2800      	cmp	r0, #0
    a340:	f43f af45 	beq.w	a1ce <lv_obj_set_state+0x352>
        obj->state = prev_state;
    a344:	9b01      	ldr	r3, [sp, #4]
        p1 = _lv_obj_get_style_ptr(obj, part, prop);
    a346:	463a      	mov	r2, r7
        obj->state = prev_state;
    a348:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        p1 = _lv_obj_get_style_ptr(obj, part, prop);
    a34c:	4629      	mov	r1, r5
    a34e:	4620      	mov	r0, r4
    a350:	f7ff fcb0 	bl	9cb4 <_lv_obj_get_style_ptr>
        _lv_style_set_ptr(style_trans, prop, p1);   /*Be sure `trans_style` has a valid value */
    a354:	4639      	mov	r1, r7
        p1 = _lv_obj_get_style_ptr(obj, part, prop);
    a356:	4602      	mov	r2, r0
    a358:	900b      	str	r0, [sp, #44]	; 0x2c
        obj->state = new_state;
    a35a:	f884 b035 	strb.w	fp, [r4, #53]	; 0x35
        _lv_style_set_ptr(style_trans, prop, p1);   /*Be sure `trans_style` has a valid value */
    a35e:	4650      	mov	r0, sl
    a360:	f00c fea6 	bl	170b0 <_lv_style_set_ptr>
        tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));
    a364:	4806      	ldr	r0, [pc, #24]	; (a380 <lv_obj_set_state+0x504>)
    a366:	f010 ff19 	bl	1b19c <_lv_ll_ins_head>
        if(tr == NULL) return NULL;
    a36a:	4682      	mov	sl, r0
    a36c:	2800      	cmp	r0, #0
    a36e:	f43f af2e 	beq.w	a1ce <lv_obj_set_state+0x352>
        tr->start_value._ptr = p1;
    a372:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a374:	6083      	str	r3, [r0, #8]
        tr->end_value._ptr = p2;
    a376:	9b43      	ldr	r3, [sp, #268]	; 0x10c
    a378:	e776      	b.n	a268 <lv_obj_set_state+0x3ec>
            invalidate_style_cache(obj, part, LV_STYLE_PROP_ALL);
    a37a:	f00b fdab 	bl	15ed4 <invalidate_style_cache>
    a37e:	e63a      	b.n	9ff6 <lv_obj_set_state+0x17a>
    a380:	20025e48 	.word	0x20025e48
    a384:	0001604b 	.word	0x0001604b
    a388:	00015d95 	.word	0x00015d95
    a38c:	000097a5 	.word	0x000097a5

0000a390 <lv_obj_signal>:
    if(sign == LV_SIGNAL_GET_STYLE) {
    a390:	2908      	cmp	r1, #8
{
    a392:	b510      	push	{r4, lr}
    a394:	4604      	mov	r4, r0
    if(sign == LV_SIGNAL_GET_STYLE) {
    a396:	d108      	bne.n	a3aa <lv_obj_signal+0x1a>
        if(info->part == LV_OBJ_PART_MAIN) info->result = &obj->style_list;
    a398:	7813      	ldrb	r3, [r2, #0]
    a39a:	b91b      	cbnz	r3, a3a4 <lv_obj_signal+0x14>
    a39c:	3428      	adds	r4, #40	; 0x28
    a39e:	6054      	str	r4, [r2, #4]
    a3a0:	2001      	movs	r0, #1
    a3a2:	e011      	b.n	a3c8 <lv_obj_signal+0x38>
        else info->result = NULL;
    a3a4:	2300      	movs	r3, #0
    a3a6:	6053      	str	r3, [r2, #4]
    a3a8:	e7fa      	b.n	a3a0 <lv_obj_signal+0x10>
    else if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    a3aa:	2907      	cmp	r1, #7
    a3ac:	d105      	bne.n	a3ba <lv_obj_signal+0x2a>
}
    a3ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    else if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    a3b2:	4610      	mov	r0, r2
    a3b4:	491f      	ldr	r1, [pc, #124]	; (a434 <lv_obj_signal+0xa4>)
    a3b6:	f00b bedb 	b.w	16170 <lv_obj_handle_get_type_signal>
    if(sign == LV_SIGNAL_CHILD_CHG) {
    a3ba:	2901      	cmp	r1, #1
    a3bc:	d105      	bne.n	a3ca <lv_obj_signal+0x3a>
    return (obj->protect & prot) == 0 ? false : true;
    a3be:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
    a3c2:	43c0      	mvns	r0, r0
    a3c4:	f000 0001 	and.w	r0, r0, #1
}
    a3c8:	bd10      	pop	{r4, pc}
    else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
    a3ca:	2906      	cmp	r1, #6
    a3cc:	d109      	bne.n	a3e2 <lv_obj_signal+0x52>
        lv_coord_t d = lv_obj_get_draw_rect_ext_pad_size(obj, LV_OBJ_PART_MAIN);
    a3ce:	2100      	movs	r1, #0
    a3d0:	f00c fa36 	bl	16840 <lv_obj_get_draw_rect_ext_pad_size>
        obj->ext_draw_pad = LV_MATH_MAX(obj->ext_draw_pad, d);
    a3d4:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	; 0x30
    a3d8:	4283      	cmp	r3, r0
    a3da:	bfb8      	it	lt
    a3dc:	4603      	movlt	r3, r0
    a3de:	8623      	strh	r3, [r4, #48]	; 0x30
    a3e0:	e7de      	b.n	a3a0 <lv_obj_signal+0x10>
    else if(sign == LV_SIGNAL_STYLE_CHG) {
    a3e2:	2904      	cmp	r1, #4
    a3e4:	d102      	bne.n	a3ec <lv_obj_signal+0x5c>
        lv_obj_refresh_ext_draw_pad(obj);
    a3e6:	f00b f9a9 	bl	1573c <lv_obj_refresh_ext_draw_pad>
    a3ea:	e7d9      	b.n	a3a0 <lv_obj_signal+0x10>
    else if(sign == LV_SIGNAL_PRESSED) {
    a3ec:	290b      	cmp	r1, #11
    a3ee:	d103      	bne.n	a3f8 <lv_obj_signal+0x68>
        lv_obj_add_state(obj, LV_STATE_PRESSED);
    a3f0:	2110      	movs	r1, #16
    a3f2:	f00c fa11 	bl	16818 <lv_obj_add_state>
    a3f6:	e7d3      	b.n	a3a0 <lv_obj_signal+0x10>
    else if(sign == LV_SIGNAL_RELEASED || sign == LV_SIGNAL_PRESS_LOST) {
    a3f8:	f1a1 030d 	sub.w	r3, r1, #13
    a3fc:	2b01      	cmp	r3, #1
    a3fe:	d803      	bhi.n	a408 <lv_obj_signal+0x78>
        lv_obj_clear_state(obj, LV_STATE_PRESSED);
    a400:	2110      	movs	r1, #16
        lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);
    a402:	f00c fa13 	bl	1682c <lv_obj_clear_state>
    a406:	e7cb      	b.n	a3a0 <lv_obj_signal+0x10>
    else if(sign == LV_SIGNAL_FOCUS) {
    a408:	2916      	cmp	r1, #22
    a40a:	d108      	bne.n	a41e <lv_obj_signal+0x8e>
            obj = lv_obj_get_focused_obj(obj);
    a40c:	f00c fb0f 	bl	16a2e <lv_obj_get_focused_obj>
    a410:	4604      	mov	r4, r0
            lv_obj_add_state(obj, LV_STATE_FOCUSED);
    a412:	2102      	movs	r1, #2
    a414:	f00c fa00 	bl	16818 <lv_obj_add_state>
            lv_obj_clear_state(obj, LV_STATE_EDITED);
    a418:	2104      	movs	r1, #4
    a41a:	4620      	mov	r0, r4
    a41c:	e7f1      	b.n	a402 <lv_obj_signal+0x72>
    else if(sign == LV_SIGNAL_DEFOCUS) {
    a41e:	2917      	cmp	r1, #23
    a420:	d103      	bne.n	a42a <lv_obj_signal+0x9a>
        obj = lv_obj_get_focused_obj(obj);
    a422:	f00c fb04 	bl	16a2e <lv_obj_get_focused_obj>
        lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);
    a426:	2106      	movs	r1, #6
    a428:	e7eb      	b.n	a402 <lv_obj_signal+0x72>
    else if(sign == LV_SIGNAL_CLEANUP) {
    a42a:	2900      	cmp	r1, #0
    a42c:	d1b8      	bne.n	a3a0 <lv_obj_signal+0x10>
        lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);
    a42e:	f00b fb8f 	bl	15b50 <lv_obj_clean_style_list>
    a432:	e7b5      	b.n	a3a0 <lv_obj_signal+0x10>
    a434:	00043fb8 	.word	0x00043fb8

0000a438 <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
    a438:	b538      	push	{r3, r4, r5, lr}
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    a43a:	4d19      	ldr	r5, [pc, #100]	; (a4a0 <lv_refr_vdb_flush+0x68>)
    a43c:	6828      	ldr	r0, [r5, #0]
    a43e:	f010 fb41 	bl	1aac4 <lv_disp_get_buf>
    a442:	4604      	mov	r4, r0

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
    a444:	6828      	ldr	r0, [r5, #0]
    a446:	f010 fb56 	bl	1aaf6 <lv_disp_is_double_buf>
    a44a:	b958      	cbnz	r0, a464 <lv_refr_vdb_flush+0x2c>
        while(vdb->flushing) {
            if(disp_refr->driver.wait_cb) disp_refr->driver.wait_cb(&disp_refr->driver);
        }
    }

    vdb->flushing = 1;
    a44c:	2301      	movs	r3, #1

    if(disp_refr->driver.buffer->last_area && disp_refr->driver.buffer->last_part) vdb->flushing_last = 1;
    a44e:	682d      	ldr	r5, [r5, #0]
    vdb->flushing = 1;
    a450:	61a3      	str	r3, [r4, #24]
    if(disp_refr->driver.buffer->last_area && disp_refr->driver.buffer->last_part) vdb->flushing_last = 1;
    a452:	686a      	ldr	r2, [r5, #4]
    a454:	6a11      	ldr	r1, [r2, #32]
    a456:	07c9      	lsls	r1, r1, #31
    a458:	d409      	bmi.n	a46e <lv_refr_vdb_flush+0x36>
    else vdb->flushing_last = 0;
    a45a:	2300      	movs	r3, #0
    a45c:	e00a      	b.n	a474 <lv_refr_vdb_flush+0x3c>
            if(disp_refr->driver.wait_cb) disp_refr->driver.wait_cb(&disp_refr->driver);
    a45e:	69c3      	ldr	r3, [r0, #28]
    a460:	b10b      	cbz	r3, a466 <lv_refr_vdb_flush+0x2e>
    a462:	4798      	blx	r3
    a464:	6828      	ldr	r0, [r5, #0]
        while(vdb->flushing) {
    a466:	69a3      	ldr	r3, [r4, #24]
    a468:	2b00      	cmp	r3, #0
    a46a:	d1f8      	bne.n	a45e <lv_refr_vdb_flush+0x26>
    a46c:	e7ee      	b.n	a44c <lv_refr_vdb_flush+0x14>
    if(disp_refr->driver.buffer->last_area && disp_refr->driver.buffer->last_part) vdb->flushing_last = 1;
    a46e:	6a12      	ldr	r2, [r2, #32]
    a470:	0792      	lsls	r2, r2, #30
    a472:	d5f2      	bpl.n	a45a <lv_refr_vdb_flush+0x22>
    else vdb->flushing_last = 0;
    a474:	61e3      	str	r3, [r4, #28]

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
    if(disp->driver.gpu_wait_cb) disp->driver.gpu_wait_cb(&disp->driver);
    a476:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    a478:	b10b      	cbz	r3, a47e <lv_refr_vdb_flush+0x46>
    a47a:	4628      	mov	r0, r5
    a47c:	4798      	blx	r3

    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
    a47e:	68eb      	ldr	r3, [r5, #12]
    a480:	b123      	cbz	r3, a48c <lv_refr_vdb_flush+0x54>
    a482:	4628      	mov	r0, r5
    a484:	68a2      	ldr	r2, [r4, #8]
    a486:	f104 0110 	add.w	r1, r4, #16
    a48a:	4798      	blx	r3

    if(vdb->buf1 && vdb->buf2) {
    a48c:	6823      	ldr	r3, [r4, #0]
    a48e:	b133      	cbz	r3, a49e <lv_refr_vdb_flush+0x66>
    a490:	6862      	ldr	r2, [r4, #4]
    a492:	b122      	cbz	r2, a49e <lv_refr_vdb_flush+0x66>
        if(vdb->buf_act == vdb->buf1)
    a494:	68a1      	ldr	r1, [r4, #8]
            vdb->buf_act = vdb->buf2;
    a496:	428b      	cmp	r3, r1
    a498:	bf08      	it	eq
    a49a:	4613      	moveq	r3, r2
    a49c:	60a3      	str	r3, [r4, #8]
        else
            vdb->buf_act = vdb->buf1;
    }
}
    a49e:	bd38      	pop	{r3, r4, r5, pc}
    a4a0:	20025cf8 	.word	0x20025cf8

0000a4a4 <lv_refr_obj_and_children>:
{
    a4a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a4a6:	460e      	mov	r6, r1
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
    a4a8:	4604      	mov	r4, r0
    a4aa:	b928      	cbnz	r0, a4b8 <lv_refr_obj_and_children+0x14>
    a4ac:	4b13      	ldr	r3, [pc, #76]	; (a4fc <lv_refr_obj_and_children+0x58>)
    a4ae:	6818      	ldr	r0, [r3, #0]
    a4b0:	f00b f873 	bl	1559a <lv_disp_get_scr_act>
    if(top_p == NULL) return;  /*Shouldn't happen*/
    a4b4:	4604      	mov	r4, r0
    a4b6:	b140      	cbz	r0, a4ca <lv_refr_obj_and_children+0x26>
    lv_refr_obj(top_p, mask_p);
    a4b8:	4620      	mov	r0, r4
    a4ba:	4631      	mov	r1, r6
    a4bc:	f00c faef 	bl	16a9e <lv_refr_obj>
    par = lv_obj_get_parent(top_p);
    a4c0:	4620      	mov	r0, r4
    a4c2:	f00b fab7 	bl	15a34 <lv_obj_get_parent>
        par = lv_obj_get_parent(par);
    a4c6:	4605      	mov	r5, r0
    while(par != NULL) {
    a4c8:	b900      	cbnz	r0, a4cc <lv_refr_obj_and_children+0x28>
}
    a4ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        lv_obj_t * i = _lv_ll_get_prev(&(par->child_ll), border_p);
    a4cc:	1d2f      	adds	r7, r5, #4
            i = _lv_ll_get_prev(&(par->child_ll), i);
    a4ce:	4621      	mov	r1, r4
    a4d0:	4638      	mov	r0, r7
    a4d2:	f010 fea5 	bl	1b220 <_lv_ll_get_prev>
    a4d6:	4604      	mov	r4, r0
        while(i != NULL) {
    a4d8:	b950      	cbnz	r0, a4f0 <lv_refr_obj_and_children+0x4c>
        if(par->design_cb) par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
    a4da:	6a2b      	ldr	r3, [r5, #32]
    a4dc:	b11b      	cbz	r3, a4e6 <lv_refr_obj_and_children+0x42>
    a4de:	2201      	movs	r2, #1
    a4e0:	4631      	mov	r1, r6
    a4e2:	4628      	mov	r0, r5
    a4e4:	4798      	blx	r3
        par = lv_obj_get_parent(par);
    a4e6:	4628      	mov	r0, r5
    a4e8:	f00b faa4 	bl	15a34 <lv_obj_get_parent>
    a4ec:	462c      	mov	r4, r5
    a4ee:	e7ea      	b.n	a4c6 <lv_refr_obj_and_children+0x22>
            lv_refr_obj(i, mask_p);
    a4f0:	4631      	mov	r1, r6
    a4f2:	4620      	mov	r0, r4
    a4f4:	f00c fad3 	bl	16a9e <lv_refr_obj>
    a4f8:	e7e9      	b.n	a4ce <lv_refr_obj_and_children+0x2a>
    a4fa:	bf00      	nop
    a4fc:	20025cf8 	.word	0x20025cf8

0000a500 <lv_refr_area_part>:
{
    a500:	b570      	push	{r4, r5, r6, lr}
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    a502:	4c46      	ldr	r4, [pc, #280]	; (a61c <lv_refr_area_part+0x11c>)
{
    a504:	b0a2      	sub	sp, #136	; 0x88
    a506:	4606      	mov	r6, r0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    a508:	6820      	ldr	r0, [r4, #0]
    a50a:	f010 fadb 	bl	1aac4 <lv_disp_get_buf>
    a50e:	4605      	mov	r5, r0
    if(lv_disp_is_double_buf(disp_refr) == false) {
    a510:	6820      	ldr	r0, [r4, #0]
    a512:	f010 faf0 	bl	1aaf6 <lv_disp_is_double_buf>
    a516:	b1b0      	cbz	r0, a546 <lv_refr_area_part+0x46>
    _lv_area_intersect(&start_mask, area_p, &vdb->area);
    a518:	4631      	mov	r1, r6
    a51a:	f105 0210 	add.w	r2, r5, #16
    a51e:	a804      	add	r0, sp, #16
    a520:	f010 fbbc 	bl	1ac9c <_lv_area_intersect>
    top_act_scr = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
    a524:	6820      	ldr	r0, [r4, #0]
    a526:	f00b f838 	bl	1559a <lv_disp_get_scr_act>
    a52a:	4601      	mov	r1, r0
    a52c:	a804      	add	r0, sp, #16
    a52e:	f00c fa88 	bl	16a42 <lv_refr_get_top_obj>
    if(disp_refr->prev_scr) {
    a532:	6823      	ldr	r3, [r4, #0]
    top_act_scr = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
    a534:	4606      	mov	r6, r0
    if(disp_refr->prev_scr) {
    a536:	6c5d      	ldr	r5, [r3, #68]	; 0x44
    a538:	b955      	cbnz	r5, a550 <lv_refr_area_part+0x50>
    if(top_act_scr == NULL && top_prev_scr == NULL) {
    a53a:	2800      	cmp	r0, #0
    a53c:	d13a      	bne.n	a5b4 <lv_refr_area_part+0xb4>
    a53e:	e00e      	b.n	a55e <lv_refr_area_part+0x5e>
            if(disp_refr->driver.wait_cb) disp_refr->driver.wait_cb(&disp_refr->driver);
    a540:	69c3      	ldr	r3, [r0, #28]
    a542:	b10b      	cbz	r3, a548 <lv_refr_area_part+0x48>
    a544:	4798      	blx	r3
    a546:	6820      	ldr	r0, [r4, #0]
        while(vdb->flushing) {
    a548:	69ab      	ldr	r3, [r5, #24]
    a54a:	2b00      	cmp	r3, #0
    a54c:	d1f8      	bne.n	a540 <lv_refr_area_part+0x40>
    a54e:	e7e3      	b.n	a518 <lv_refr_area_part+0x18>
        top_prev_scr = lv_refr_get_top_obj(&start_mask, disp_refr->prev_scr);
    a550:	4629      	mov	r1, r5
    a552:	a804      	add	r0, sp, #16
    a554:	f00c fa75 	bl	16a42 <lv_refr_get_top_obj>
    a558:	4605      	mov	r5, r0
    if(top_act_scr == NULL && top_prev_scr == NULL) {
    a55a:	bb5e      	cbnz	r6, a5b4 <lv_refr_area_part+0xb4>
    a55c:	bb50      	cbnz	r0, a5b4 <lv_refr_area_part+0xb4>
        if(disp_refr->bg_img) {
    a55e:	6823      	ldr	r3, [r4, #0]
            lv_draw_img_dsc_init(&dsc);
    a560:	a808      	add	r0, sp, #32
        if(disp_refr->bg_img) {
    a562:	6d9d      	ldr	r5, [r3, #88]	; 0x58
    a564:	2d00      	cmp	r5, #0
    a566:	d049      	beq.n	a5fc <lv_refr_area_part+0xfc>
            lv_draw_img_dsc_init(&dsc);
    a568:	f00d ffc1 	bl	184ee <lv_draw_img_dsc_init>
            dsc.opa = disp_refr->bg_opa;
    a56c:	6823      	ldr	r3, [r4, #0]
            res = lv_img_decoder_get_info(disp_refr->bg_img, &header);
    a56e:	a903      	add	r1, sp, #12
            dsc.opa = disp_refr->bg_opa;
    a570:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
    a574:	f88d 2020 	strb.w	r2, [sp, #32]
            res = lv_img_decoder_get_info(disp_refr->bg_img, &header);
    a578:	6d98      	ldr	r0, [r3, #88]	; 0x58
    a57a:	f001 ff45 	bl	c408 <lv_img_decoder_get_info>
            if(res == LV_RES_OK) {
    a57e:	2801      	cmp	r0, #1
    a580:	d117      	bne.n	a5b2 <lv_refr_area_part+0xb2>
                lv_area_set(&a, 0, 0, header.w - 1, header.h - 1);
    a582:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    a586:	9b03      	ldr	r3, [sp, #12]
    a588:	f3c2 124a 	ubfx	r2, r2, #5, #11
    a58c:	3a01      	subs	r2, #1
    a58e:	b212      	sxth	r2, r2
    a590:	9200      	str	r2, [sp, #0]
    a592:	2200      	movs	r2, #0
    a594:	f3c3 238a 	ubfx	r3, r3, #10, #11
    a598:	3b01      	subs	r3, #1
    a59a:	4611      	mov	r1, r2
    a59c:	b21b      	sxth	r3, r3
    a59e:	a806      	add	r0, sp, #24
    a5a0:	f010 fb62 	bl	1ac68 <lv_area_set>
                lv_draw_img(&a, &start_mask, disp_refr->bg_img, &dsc);
    a5a4:	6822      	ldr	r2, [r4, #0]
    a5a6:	ab08      	add	r3, sp, #32
    a5a8:	6d92      	ldr	r2, [r2, #88]	; 0x58
    a5aa:	a904      	add	r1, sp, #16
    a5ac:	a806      	add	r0, sp, #24
    a5ae:	f000 fa61 	bl	aa74 <lv_draw_img>
            }
    a5b2:	2500      	movs	r5, #0
    if(disp_refr->prev_scr) {
    a5b4:	6823      	ldr	r3, [r4, #0]
    a5b6:	6c58      	ldr	r0, [r3, #68]	; 0x44
    a5b8:	b128      	cbz	r0, a5c6 <lv_refr_area_part+0xc6>
        lv_refr_obj_and_children(top_prev_scr, &start_mask);
    a5ba:	2d00      	cmp	r5, #0
    a5bc:	bf18      	it	ne
    a5be:	4628      	movne	r0, r5
    a5c0:	a904      	add	r1, sp, #16
    a5c2:	f7ff ff6f 	bl	a4a4 <lv_refr_obj_and_children>
    if(top_act_scr == NULL) {
    a5c6:	b90e      	cbnz	r6, a5cc <lv_refr_area_part+0xcc>
        top_act_scr = disp_refr->act_scr;
    a5c8:	6823      	ldr	r3, [r4, #0]
    a5ca:	6c1e      	ldr	r6, [r3, #64]	; 0x40
    lv_refr_obj_and_children(top_act_scr, &start_mask);
    a5cc:	a904      	add	r1, sp, #16
    a5ce:	4630      	mov	r0, r6
    a5d0:	f7ff ff68 	bl	a4a4 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
    a5d4:	6820      	ldr	r0, [r4, #0]
    a5d6:	f00a ffee 	bl	155b6 <lv_disp_get_layer_top>
    a5da:	a904      	add	r1, sp, #16
    a5dc:	f7ff ff62 	bl	a4a4 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
    a5e0:	6820      	ldr	r0, [r4, #0]
    a5e2:	f00a ffef 	bl	155c4 <lv_disp_get_layer_sys>
    a5e6:	a904      	add	r1, sp, #16
    a5e8:	f7ff ff5c 	bl	a4a4 <lv_refr_obj_and_children>
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
    a5ec:	6820      	ldr	r0, [r4, #0]
    a5ee:	f010 fa8a 	bl	1ab06 <lv_disp_is_true_double_buf>
    a5f2:	b908      	cbnz	r0, a5f8 <lv_refr_area_part+0xf8>
        lv_refr_vdb_flush();
    a5f4:	f7ff ff20 	bl	a438 <lv_refr_vdb_flush>
}
    a5f8:	b022      	add	sp, #136	; 0x88
    a5fa:	bd70      	pop	{r4, r5, r6, pc}
            lv_draw_rect_dsc_init(&dsc);
    a5fc:	f001 fc8e 	bl	bf1c <lv_draw_rect_dsc_init>
            dsc.bg_color = disp_refr->bg_color;
    a600:	6823      	ldr	r3, [r4, #0]
            lv_draw_rect(&start_mask, &start_mask, &dsc);
    a602:	a904      	add	r1, sp, #16
            dsc.bg_color = disp_refr->bg_color;
    a604:	6d5a      	ldr	r2, [r3, #84]	; 0x54
            lv_draw_rect(&start_mask, &start_mask, &dsc);
    a606:	4608      	mov	r0, r1
            dsc.bg_color = disp_refr->bg_color;
    a608:	9209      	str	r2, [sp, #36]	; 0x24
            dsc.bg_opa = disp_refr->bg_opa;
    a60a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
            lv_draw_rect(&start_mask, &start_mask, &dsc);
    a60e:	aa08      	add	r2, sp, #32
            dsc.bg_opa = disp_refr->bg_opa;
    a610:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
            lv_draw_rect(&start_mask, &start_mask, &dsc);
    a614:	f00e fcef 	bl	18ff6 <lv_draw_rect>
    a618:	e7cc      	b.n	a5b4 <lv_refr_area_part+0xb4>
    a61a:	bf00      	nop
    a61c:	20025cf8 	.word	0x20025cf8

0000a620 <_lv_refr_get_disp_refreshing>:
}
    a620:	4b01      	ldr	r3, [pc, #4]	; (a628 <_lv_refr_get_disp_refreshing+0x8>)
    a622:	6818      	ldr	r0, [r3, #0]
    a624:	4770      	bx	lr
    a626:	bf00      	nop
    a628:	20025cf8 	.word	0x20025cf8

0000a62c <_lv_disp_refr_task>:
{
    a62c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a630:	4605      	mov	r5, r0
    a632:	b089      	sub	sp, #36	; 0x24
    uint32_t start = lv_tick_get();
    a634:	f010 fa9d 	bl	1ab72 <lv_tick_get>
    disp_refr = task->user_data;
    a638:	4c95      	ldr	r4, [pc, #596]	; (a890 <_lv_disp_refr_task+0x264>)
    a63a:	68eb      	ldr	r3, [r5, #12]
    lv_task_set_prio(task, LV_TASK_PRIO_OFF);
    a63c:	2100      	movs	r1, #0
    uint32_t start = lv_tick_get();
    a63e:	9003      	str	r0, [sp, #12]
    lv_task_set_prio(task, LV_TASK_PRIO_OFF);
    a640:	4628      	mov	r0, r5
    disp_refr = task->user_data;
    a642:	6023      	str	r3, [r4, #0]
    lv_task_set_prio(task, LV_TASK_PRIO_OFF);
    a644:	f002 fc64 	bl	cf10 <lv_task_set_prio>
    if(disp_refr->act_scr == NULL) {
    a648:	6823      	ldr	r3, [r4, #0]
    a64a:	6c19      	ldr	r1, [r3, #64]	; 0x40
    a64c:	2900      	cmp	r1, #0
    a64e:	f040 80b7 	bne.w	a7c0 <_lv_disp_refr_task+0x194>
        disp_refr->inv_p = 0;
    a652:	f8b3 217e 	ldrh.w	r2, [r3, #382]	; 0x17e
    a656:	f361 0209 	bfi	r2, r1, #0, #10
    a65a:	f8a3 217e 	strh.w	r2, [r3, #382]	; 0x17e
}
    a65e:	b009      	add	sp, #36	; 0x24
    a660:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
    a664:	4433      	add	r3, r6
    a666:	f893 515e 	ldrb.w	r5, [r3, #350]	; 0x15e
    a66a:	2d00      	cmp	r5, #0
    a66c:	d069      	beq.n	a742 <_lv_disp_refr_task+0x116>
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
    a66e:	3601      	adds	r6, #1
    a670:	6823      	ldr	r3, [r4, #0]
    a672:	f8b3 217e 	ldrh.w	r2, [r3, #382]	; 0x17e
    a676:	f3c2 0709 	ubfx	r7, r2, #0, #10
    a67a:	42be      	cmp	r6, r7
    a67c:	d3f2      	bcc.n	a664 <_lv_disp_refr_task+0x38>
    px_num = 0;
    a67e:	2000      	movs	r0, #0
    a680:	4984      	ldr	r1, [pc, #528]	; (a894 <_lv_disp_refr_task+0x268>)
    a682:	6008      	str	r0, [r1, #0]
    if(disp_refr->inv_p == 0) return;
    a684:	2f00      	cmp	r7, #0
    a686:	f040 809d 	bne.w	a7c4 <_lv_disp_refr_task+0x198>
    if(disp_refr->inv_p != 0) {
    a68a:	4f81      	ldr	r7, [pc, #516]	; (a890 <_lv_disp_refr_task+0x264>)
    a68c:	6838      	ldr	r0, [r7, #0]
    a68e:	f8b0 317e 	ldrh.w	r3, [r0, #382]	; 0x17e
    a692:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a696:	2b00      	cmp	r3, #0
    a698:	d04e      	beq.n	a738 <_lv_disp_refr_task+0x10c>
        if(lv_disp_is_true_double_buf(disp_refr)) {
    a69a:	f010 fa34 	bl	1ab06 <lv_disp_is_true_double_buf>
    a69e:	b378      	cbz	r0, a700 <_lv_disp_refr_task+0xd4>
            if(disp_refr->driver.set_px_cb) {
    a6a0:	6838      	ldr	r0, [r7, #0]
    a6a2:	6943      	ldr	r3, [r0, #20]
    a6a4:	bb63      	cbnz	r3, a700 <_lv_disp_refr_task+0xd4>
                lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    a6a6:	f010 fa0d 	bl	1aac4 <lv_disp_get_buf>
    a6aa:	4605      	mov	r5, r0
                lv_refr_vdb_flush();
    a6ac:	f7ff fec4 	bl	a438 <lv_refr_vdb_flush>
                while(vdb->flushing);
    a6b0:	69ab      	ldr	r3, [r5, #24]
    a6b2:	2b00      	cmp	r3, #0
    a6b4:	d1fc      	bne.n	a6b0 <_lv_disp_refr_task+0x84>
                copy_buf = _lv_mem_buf_get(disp_refr->driver.hor_res * sizeof(lv_color_t));
    a6b6:	6823      	ldr	r3, [r4, #0]
                for(a = 0; a < disp_refr->inv_p; a++) {
    a6b8:	f04f 0a00 	mov.w	sl, #0
                copy_buf = _lv_mem_buf_get(disp_refr->driver.hor_res * sizeof(lv_color_t));
    a6bc:	f9b3 0000 	ldrsh.w	r0, [r3]
    a6c0:	0080      	lsls	r0, r0, #2
    a6c2:	f002 fa1b 	bl	cafc <_lv_mem_buf_get>
                uint8_t * buf_act = (uint8_t *)vdb->buf_act;
    a6c6:	68ab      	ldr	r3, [r5, #8]
                uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
    a6c8:	f8d5 b000 	ldr.w	fp, [r5]
                copy_buf = _lv_mem_buf_get(disp_refr->driver.hor_res * sizeof(lv_color_t));
    a6cc:	4606      	mov	r6, r0
                uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
    a6ce:	459b      	cmp	fp, r3
                lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    a6d0:	6838      	ldr	r0, [r7, #0]
                uint8_t * buf_act = (uint8_t *)vdb->buf_act;
    a6d2:	9301      	str	r3, [sp, #4]
                uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
    a6d4:	bf08      	it	eq
    a6d6:	f8d5 b004 	ldreq.w	fp, [r5, #4]
                lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    a6da:	f001 ff4b 	bl	c574 <lv_disp_get_hor_res>
                            start_offs += hres * sizeof(lv_color_t);
    a6de:	0083      	lsls	r3, r0, #2
                lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
    a6e0:	9002      	str	r0, [sp, #8]
                            start_offs += hres * sizeof(lv_color_t);
    a6e2:	9300      	str	r3, [sp, #0]
                for(a = 0; a < disp_refr->inv_p; a++) {
    a6e4:	683d      	ldr	r5, [r7, #0]
    a6e6:	fa1f f28a 	uxth.w	r2, sl
    a6ea:	f8b5 317e 	ldrh.w	r3, [r5, #382]	; 0x17e
    a6ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a6f2:	4293      	cmp	r3, r2
    a6f4:	f200 8179 	bhi.w	a9ea <_lv_disp_refr_task+0x3be>
                if(copy_buf) _lv_mem_buf_release(copy_buf);
    a6f8:	b116      	cbz	r6, a700 <_lv_disp_refr_task+0xd4>
    a6fa:	4630      	mov	r0, r6
    a6fc:	f002 fa60 	bl	cbc0 <_lv_mem_buf_release>
        _lv_memset_00(disp_refr->inv_areas, sizeof(disp_refr->inv_areas));
    a700:	6825      	ldr	r5, [r4, #0]
    a702:	f44f 7180 	mov.w	r1, #256	; 0x100
    a706:	f105 005e 	add.w	r0, r5, #94	; 0x5e
    a70a:	f00c fa37 	bl	16b7c <_lv_memset_00>
        _lv_memset_00(disp_refr->inv_area_joined, sizeof(disp_refr->inv_area_joined));
    a70e:	2120      	movs	r1, #32
    a710:	f505 70af 	add.w	r0, r5, #350	; 0x15e
    a714:	f00c fa32 	bl	16b7c <_lv_memset_00>
        disp_refr->inv_p = 0;
    a718:	f8b5 317e 	ldrh.w	r3, [r5, #382]	; 0x17e
        elaps = lv_tick_elaps(start);
    a71c:	9803      	ldr	r0, [sp, #12]
        disp_refr->inv_p = 0;
    a71e:	f36f 0309 	bfc	r3, #0, #10
    a722:	f8a5 317e 	strh.w	r3, [r5, #382]	; 0x17e
        elaps = lv_tick_elaps(start);
    a726:	f010 fa31 	bl	1ab8c <lv_tick_elaps>
    a72a:	4601      	mov	r1, r0
        if(disp_refr->driver.monitor_cb) {
    a72c:	6820      	ldr	r0, [r4, #0]
    a72e:	6983      	ldr	r3, [r0, #24]
    a730:	b113      	cbz	r3, a738 <_lv_disp_refr_task+0x10c>
            disp_refr->driver.monitor_cb(&disp_refr->driver, elaps, px_num);
    a732:	4a58      	ldr	r2, [pc, #352]	; (a894 <_lv_disp_refr_task+0x268>)
    a734:	6812      	ldr	r2, [r2, #0]
    a736:	4798      	blx	r3
    _lv_mem_buf_free_all();
    a738:	f002 fa6a 	bl	cc10 <_lv_mem_buf_free_all>
    _lv_font_clean_up_fmt_txt();
    a73c:	f002 fe50 	bl	d3e0 <_lv_font_clean_up_fmt_txt>
    LV_LOG_TRACE("lv_refr_task: ready");
    a740:	e78d      	b.n	a65e <_lv_disp_refr_task+0x32>
                disp_refr->inv_area_joined[join_from] = 1;
    a742:	f04f 0901 	mov.w	r9, #1
    a746:	00f7      	lsls	r7, r6, #3
    a748:	375e      	adds	r7, #94	; 0x5e
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
    a74a:	6820      	ldr	r0, [r4, #0]
    a74c:	f8b0 317e 	ldrh.w	r3, [r0, #382]	; 0x17e
    a750:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a754:	429d      	cmp	r5, r3
    a756:	d28a      	bcs.n	a66e <_lv_disp_refr_task+0x42>
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
    a758:	1943      	adds	r3, r0, r5
    a75a:	f893 315e 	ldrb.w	r3, [r3, #350]	; 0x15e
    a75e:	bb6b      	cbnz	r3, a7bc <_lv_disp_refr_task+0x190>
    a760:	42ae      	cmp	r6, r5
    a762:	d02b      	beq.n	a7bc <_lv_disp_refr_task+0x190>
            if(_lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
    a764:	ea4f 0ac5 	mov.w	sl, r5, lsl #3
    a768:	f10a 0a5e 	add.w	sl, sl, #94	; 0x5e
    a76c:	eb00 010a 	add.w	r1, r0, sl
    a770:	4438      	add	r0, r7
    a772:	f010 fb69 	bl	1ae48 <_lv_area_is_on>
    a776:	b308      	cbz	r0, a7bc <_lv_disp_refr_task+0x190>
            _lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
    a778:	6821      	ldr	r1, [r4, #0]
    a77a:	a806      	add	r0, sp, #24
    a77c:	eb01 020a 	add.w	r2, r1, sl
    a780:	4439      	add	r1, r7
    a782:	f010 fab6 	bl	1acf2 <_lv_area_join>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
    a786:	a806      	add	r0, sp, #24
    a788:	f010 fa7a 	bl	1ac80 <lv_area_get_size>
    a78c:	4683      	mov	fp, r0
    a78e:	6820      	ldr	r0, [r4, #0]
    a790:	4438      	add	r0, r7
    a792:	f010 fa75 	bl	1ac80 <lv_area_get_size>
    a796:	4680      	mov	r8, r0
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
    a798:	6820      	ldr	r0, [r4, #0]
    a79a:	4450      	add	r0, sl
    a79c:	f010 fa70 	bl	1ac80 <lv_area_get_size>
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
    a7a0:	4480      	add	r8, r0
    a7a2:	45c3      	cmp	fp, r8
    a7a4:	d20a      	bcs.n	a7bc <_lv_disp_refr_task+0x190>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
    a7a6:	f8d4 8000 	ldr.w	r8, [r4]
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
    a7aa:	2208      	movs	r2, #8
    a7ac:	eb08 0007 	add.w	r0, r8, r7
    a7b0:	a906      	add	r1, sp, #24
                disp_refr->inv_area_joined[join_from] = 1;
    a7b2:	44a8      	add	r8, r5
    a7b4:	f00c f943 	bl	16a3e <_lv_memcpy>
    a7b8:	f888 915e 	strb.w	r9, [r8, #350]	; 0x15e
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
    a7bc:	3501      	adds	r5, #1
    a7be:	e7c4      	b.n	a74a <_lv_disp_refr_task+0x11e>
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
    a7c0:	2600      	movs	r6, #0
    a7c2:	e755      	b.n	a670 <_lv_disp_refr_task+0x44>
    for(i = disp_refr->inv_p - 1; i >= 0; i--) {
    a7c4:	3f01      	subs	r7, #1
        if(disp_refr->inv_area_joined[i] == 0) {
    a7c6:	f503 72af 	add.w	r2, r3, #350	; 0x15e
    for(i = disp_refr->inv_p - 1; i >= 0; i--) {
    a7ca:	1c79      	adds	r1, r7, #1
    a7cc:	d15a      	bne.n	a884 <_lv_disp_refr_task+0x258>
    int32_t last_i = 0;
    a7ce:	2700      	movs	r7, #0
    for(i = 0; i < disp_refr->inv_p; i++) {
    a7d0:	f04f 0b00 	mov.w	fp, #0
    disp_refr->driver.buffer->last_area = 0;
    a7d4:	685b      	ldr	r3, [r3, #4]
    for(i = 0; i < disp_refr->inv_p; i++) {
    a7d6:	f8df 90b8 	ldr.w	r9, [pc, #184]	; a890 <_lv_disp_refr_task+0x264>
    disp_refr->driver.buffer->last_area = 0;
    a7da:	f893 2020 	ldrb.w	r2, [r3, #32]
    a7de:	f36f 0200 	bfc	r2, #0, #1
    a7e2:	f883 2020 	strb.w	r2, [r3, #32]
    disp_refr->driver.buffer->last_part = 0;
    a7e6:	f893 2020 	ldrb.w	r2, [r3, #32]
    a7ea:	f36f 0241 	bfc	r2, #1, #1
    a7ee:	f883 2020 	strb.w	r2, [r3, #32]
    for(i = 0; i < disp_refr->inv_p; i++) {
    a7f2:	f8d9 8000 	ldr.w	r8, [r9]
    a7f6:	f8b8 317e 	ldrh.w	r3, [r8, #382]	; 0x17e
    a7fa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    a7fe:	459b      	cmp	fp, r3
    a800:	f6bf af43 	bge.w	a68a <_lv_disp_refr_task+0x5e>
        if(disp_refr->inv_area_joined[i] == 0) {
    a804:	eb08 030b 	add.w	r3, r8, fp
    a808:	f893 315e 	ldrb.w	r3, [r3, #350]	; 0x15e
    a80c:	2b00      	cmp	r3, #0
    a80e:	f040 80a2 	bne.w	a956 <_lv_disp_refr_task+0x32a>
            if(i == last_i) disp_refr->driver.buffer->last_area = 1;
    a812:	f8d8 3004 	ldr.w	r3, [r8, #4]
    a816:	45bb      	cmp	fp, r7
    a818:	bf08      	it	eq
    a81a:	f893 2020 	ldrbeq.w	r2, [r3, #32]
    a81e:	ea4f 05cb 	mov.w	r5, fp, lsl #3
    a822:	bf04      	itt	eq
    a824:	f042 0201 	orreq.w	r2, r2, #1
    a828:	f883 2020 	strbeq.w	r2, [r3, #32]
            disp_refr->driver.buffer->last_part = 0;
    a82c:	f893 2020 	ldrb.w	r2, [r3, #32]
    if(lv_disp_is_true_double_buf(disp_refr)) {
    a830:	4640      	mov	r0, r8
            disp_refr->driver.buffer->last_part = 0;
    a832:	f36f 0241 	bfc	r2, #1, #1
    a836:	f883 2020 	strb.w	r2, [r3, #32]
            lv_refr_area(&disp_refr->inv_areas[i]);
    a83a:	f105 035e 	add.w	r3, r5, #94	; 0x5e
    a83e:	9302      	str	r3, [sp, #8]
    a840:	4443      	add	r3, r8
    a842:	9301      	str	r3, [sp, #4]
    if(lv_disp_is_true_double_buf(disp_refr)) {
    a844:	f010 f95f 	bl	1ab06 <lv_disp_is_true_double_buf>
    a848:	b330      	cbz	r0, a898 <_lv_disp_refr_task+0x26c>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    a84a:	6820      	ldr	r0, [r4, #0]
    a84c:	f010 f93a 	bl	1aac4 <lv_disp_get_buf>
        vdb->area.x1        = 0;
    a850:	2600      	movs	r6, #0
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    a852:	4605      	mov	r5, r0
        vdb->area.x1        = 0;
    a854:	8206      	strh	r6, [r0, #16]
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
    a856:	6820      	ldr	r0, [r4, #0]
    a858:	f001 fe8c 	bl	c574 <lv_disp_get_hor_res>
    a85c:	3801      	subs	r0, #1
    a85e:	82a8      	strh	r0, [r5, #20]
        vdb->area.y1        = 0;
    a860:	826e      	strh	r6, [r5, #18]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
    a862:	6820      	ldr	r0, [r4, #0]
    a864:	f001 fe98 	bl	c598 <lv_disp_get_ver_res>
        disp_refr->driver.buffer->last_part = 1;
    a868:	6823      	ldr	r3, [r4, #0]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
    a86a:	3801      	subs	r0, #1
        disp_refr->driver.buffer->last_part = 1;
    a86c:	685a      	ldr	r2, [r3, #4]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
    a86e:	82e8      	strh	r0, [r5, #22]
            disp_refr->driver.buffer->last_part = 1;
    a870:	f892 3020 	ldrb.w	r3, [r2, #32]
            lv_refr_area_part(area_p);
    a874:	9801      	ldr	r0, [sp, #4]
            disp_refr->driver.buffer->last_part = 1;
    a876:	f043 0302 	orr.w	r3, r3, #2
    a87a:	f882 3020 	strb.w	r3, [r2, #32]
            lv_refr_area_part(area_p);
    a87e:	f7ff fe3f 	bl	a500 <lv_refr_area_part>
    a882:	e05c      	b.n	a93e <_lv_disp_refr_task+0x312>
        if(disp_refr->inv_area_joined[i] == 0) {
    a884:	5dd1      	ldrb	r1, [r2, r7]
    a886:	2900      	cmp	r1, #0
    a888:	d0a2      	beq.n	a7d0 <_lv_disp_refr_task+0x1a4>
    for(i = disp_refr->inv_p - 1; i >= 0; i--) {
    a88a:	3f01      	subs	r7, #1
    a88c:	e79d      	b.n	a7ca <_lv_disp_refr_task+0x19e>
    a88e:	bf00      	nop
    a890:	20025cf8 	.word	0x20025cf8
    a894:	20025cfc 	.word	0x20025cfc
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
    a898:	6820      	ldr	r0, [r4, #0]
    a89a:	f010 f913 	bl	1aac4 <lv_disp_get_buf>
    a89e:	4445      	add	r5, r8
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a8a0:	f8b5 8062 	ldrh.w	r8, [r5, #98]	; 0x62
    a8a4:	f8b5 305e 	ldrh.w	r3, [r5, #94]	; 0x5e
    a8a8:	f108 0801 	add.w	r8, r8, #1
    a8ac:	eba8 0803 	sub.w	r8, r8, r3
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a8b0:	f9b5 3064 	ldrsh.w	r3, [r5, #100]	; 0x64
    a8b4:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60
    a8b8:	f103 0a01 	add.w	sl, r3, #1
    a8bc:	4606      	mov	r6, r0
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
    a8be:	6820      	ldr	r0, [r4, #0]
    a8c0:	9300      	str	r3, [sp, #0]
    a8c2:	ebaa 0a02 	sub.w	sl, sl, r2
    a8c6:	f001 fe67 	bl	c598 <lv_disp_get_ver_res>
        lv_coord_t y2 =
    a8ca:	9b00      	ldr	r3, [sp, #0]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    a8cc:	fa0f f888 	sxth.w	r8, r8
    a8d0:	4283      	cmp	r3, r0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    a8d2:	fa0f fa8a 	sxth.w	sl, sl
    a8d6:	db41      	blt.n	a95c <_lv_disp_refr_task+0x330>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
    a8d8:	6820      	ldr	r0, [r4, #0]
    a8da:	f001 fe5d 	bl	c598 <lv_disp_get_ver_res>
        lv_coord_t y2 =
    a8de:	1e43      	subs	r3, r0, #1
    a8e0:	b21b      	sxth	r3, r3
        int32_t max_row = (uint32_t)vdb->size / w;
    a8e2:	68f2      	ldr	r2, [r6, #12]
    a8e4:	fbb2 f8f8 	udiv	r8, r2, r8
        if(max_row > h) max_row = h;
    a8e8:	45c2      	cmp	sl, r8
    a8ea:	4652      	mov	r2, sl
    a8ec:	bfa8      	it	ge
    a8ee:	4642      	movge	r2, r8
    a8f0:	9200      	str	r2, [sp, #0]
        if(disp_refr->driver.rounder_cb) {
    a8f2:	4a59      	ldr	r2, [pc, #356]	; (aa58 <_lv_disp_refr_task+0x42c>)
    a8f4:	6812      	ldr	r2, [r2, #0]
    a8f6:	6912      	ldr	r2, [r2, #16]
    a8f8:	2a00      	cmp	r2, #0
    a8fa:	d036      	beq.n	a96a <_lv_disp_refr_task+0x33e>
            tmp.x1 = 0;
    a8fc:	2200      	movs	r2, #0
            lv_coord_t h_tmp = max_row;
    a8fe:	f9bd 8000 	ldrsh.w	r8, [sp]
            tmp.x1 = 0;
    a902:	9206      	str	r2, [sp, #24]
            tmp.x2 = 0;
    a904:	f8ad 201c 	strh.w	r2, [sp, #28]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    a908:	f8d9 0000 	ldr.w	r0, [r9]
    a90c:	46c2      	mov	sl, r8
                tmp.y2 = h_tmp - 1;
    a90e:	f108 38ff 	add.w	r8, r8, #4294967295
    a912:	fa0f f888 	sxth.w	r8, r8
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    a916:	6902      	ldr	r2, [r0, #16]
    a918:	a906      	add	r1, sp, #24
                tmp.y2 = h_tmp - 1;
    a91a:	f8ad 801e 	strh.w	r8, [sp, #30]
    a91e:	9304      	str	r3, [sp, #16]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
    a920:	4790      	blx	r2
    a922:	f9bd 101e 	ldrsh.w	r1, [sp, #30]
    a926:	f8bd 201a 	ldrh.w	r2, [sp, #26]
    a92a:	3101      	adds	r1, #1
                if(lv_area_get_height(&tmp) <= max_row) break;
    a92c:	9b00      	ldr	r3, [sp, #0]
    a92e:	1a8a      	subs	r2, r1, r2
    a930:	b212      	sxth	r2, r2
    a932:	4293      	cmp	r3, r2
    a934:	9b04      	ldr	r3, [sp, #16]
    a936:	da14      	bge.n	a962 <_lv_disp_refr_task+0x336>
            } while(h_tmp > 0);
    a938:	f1b8 0f00 	cmp.w	r8, #0
    a93c:	dce4      	bgt.n	a908 <_lv_disp_refr_task+0x2dc>
            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
    a93e:	f8d9 0000 	ldr.w	r0, [r9]
    a942:	6983      	ldr	r3, [r0, #24]
    a944:	b13b      	cbz	r3, a956 <_lv_disp_refr_task+0x32a>
    a946:	9b02      	ldr	r3, [sp, #8]
    a948:	4418      	add	r0, r3
    a94a:	f010 f999 	bl	1ac80 <lv_area_get_size>
    a94e:	4a43      	ldr	r2, [pc, #268]	; (aa5c <_lv_disp_refr_task+0x430>)
    a950:	6813      	ldr	r3, [r2, #0]
    a952:	4403      	add	r3, r0
    a954:	6013      	str	r3, [r2, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
    a956:	f10b 0b01 	add.w	fp, fp, #1
    a95a:	e74a      	b.n	a7f2 <_lv_disp_refr_task+0x1c6>
        lv_coord_t y2 =
    a95c:	f9b5 3064 	ldrsh.w	r3, [r5, #100]	; 0x64
    a960:	e7bf      	b.n	a8e2 <_lv_disp_refr_task+0x2b6>
            if(h_tmp <= 0) {
    a962:	f1ba 0f00 	cmp.w	sl, #0
    a966:	ddea      	ble.n	a93e <_lv_disp_refr_task+0x312>
                max_row = tmp.y2 + 1;
    a968:	9100      	str	r1, [sp, #0]
        lv_coord_t row_last = 0;
    a96a:	f04f 0800 	mov.w	r8, #0
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
    a96e:	9a00      	ldr	r2, [sp, #0]
    a970:	f9b5 a060 	ldrsh.w	sl, [r5, #96]	; 0x60
    a974:	3a01      	subs	r2, #1
    a976:	eb02 010a 	add.w	r1, r2, sl
    a97a:	4299      	cmp	r1, r3
    a97c:	dd0d      	ble.n	a99a <_lv_disp_refr_task+0x36e>
        if(y2 != row_last) {
    a97e:	4543      	cmp	r3, r8
    a980:	d0dd      	beq.n	a93e <_lv_disp_refr_task+0x312>
            vdb->area.x1 = area_p->x1;
    a982:	f9b5 105e 	ldrsh.w	r1, [r5, #94]	; 0x5e
    a986:	6822      	ldr	r2, [r4, #0]
    a988:	8231      	strh	r1, [r6, #16]
            vdb->area.x2 = area_p->x2;
    a98a:	f9b5 1062 	ldrsh.w	r1, [r5, #98]	; 0x62
            disp_refr->driver.buffer->last_part = 1;
    a98e:	6852      	ldr	r2, [r2, #4]
            vdb->area.x2 = area_p->x2;
    a990:	82b1      	strh	r1, [r6, #20]
            vdb->area.y1 = row;
    a992:	f8a6 a012 	strh.w	sl, [r6, #18]
            vdb->area.y2 = y2;
    a996:	82f3      	strh	r3, [r6, #22]
            disp_refr->driver.buffer->last_part = 1;
    a998:	e76a      	b.n	a870 <_lv_disp_refr_task+0x244>
            vdb->area.x1 = area_p->x1;
    a99a:	f9b5 105e 	ldrsh.w	r1, [r5, #94]	; 0x5e
    a99e:	8231      	strh	r1, [r6, #16]
            vdb->area.x2 = area_p->x2;
    a9a0:	f9b5 1062 	ldrsh.w	r1, [r5, #98]	; 0x62
            vdb->area.y1 = row;
    a9a4:	f8a6 a012 	strh.w	sl, [r6, #18]
            vdb->area.x2 = area_p->x2;
    a9a8:	82b1      	strh	r1, [r6, #20]
            vdb->area.y2 = row + max_row - 1;
    a9aa:	9900      	ldr	r1, [sp, #0]
    a9ac:	448a      	add	sl, r1
    a9ae:	fa0f fa8a 	sxth.w	sl, sl
    a9b2:	f10a 38ff 	add.w	r8, sl, #4294967295
    a9b6:	fa0f f888 	sxth.w	r8, r8
    a9ba:	4598      	cmp	r8, r3
    a9bc:	bfa8      	it	ge
    a9be:	4698      	movge	r8, r3
            if(y2 == row_last) disp_refr->driver.buffer->last_part = 1;
    a9c0:	4543      	cmp	r3, r8
            vdb->area.y2 = row + max_row - 1;
    a9c2:	f8a6 8016 	strh.w	r8, [r6, #22]
            if(y2 == row_last) disp_refr->driver.buffer->last_part = 1;
    a9c6:	d108      	bne.n	a9da <_lv_disp_refr_task+0x3ae>
    a9c8:	f8d9 1000 	ldr.w	r1, [r9]
    a9cc:	6848      	ldr	r0, [r1, #4]
    a9ce:	f890 1020 	ldrb.w	r1, [r0, #32]
    a9d2:	f041 0102 	orr.w	r1, r1, #2
    a9d6:	f880 1020 	strb.w	r1, [r0, #32]
            lv_refr_area_part(area_p);
    a9da:	9801      	ldr	r0, [sp, #4]
    a9dc:	e9cd 3204 	strd	r3, r2, [sp, #16]
    a9e0:	f7ff fd8e 	bl	a500 <lv_refr_area_part>
    a9e4:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
    a9e8:	e7c5      	b.n	a976 <_lv_disp_refr_task+0x34a>
                    if(disp_refr->inv_area_joined[a] == 0) {
    a9ea:	eb05 030a 	add.w	r3, r5, sl
    a9ee:	f893 315e 	ldrb.w	r3, [r3, #350]	; 0x15e
    a9f2:	b113      	cbz	r3, a9fa <_lv_disp_refr_task+0x3ce>
                for(a = 0; a < disp_refr->inv_p; a++) {
    a9f4:	f10a 0a01 	add.w	sl, sl, #1
    a9f8:	e674      	b.n	a6e4 <_lv_disp_refr_task+0xb8>
                        uint32_t start_offs =
    a9fa:	eb05 05ca 	add.w	r5, r5, sl, lsl #3
                            (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
    a9fe:	f9b5 305e 	ldrsh.w	r3, [r5, #94]	; 0x5e
    aa02:	9a02      	ldr	r2, [sp, #8]
    aa04:	f9b5 8060 	ldrsh.w	r8, [r5, #96]	; 0x60
    aa08:	9901      	ldr	r1, [sp, #4]
    aa0a:	fb02 3908 	mla	r9, r2, r8, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    aa0e:	f8b5 2062 	ldrh.w	r2, [r5, #98]	; 0x62
    aa12:	3201      	adds	r2, #1
    aa14:	1ad2      	subs	r2, r2, r3
                        uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
    aa16:	b212      	sxth	r2, r2
    aa18:	eb0b 0389 	add.w	r3, fp, r9, lsl #2
    aa1c:	0092      	lsls	r2, r2, #2
                        for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    aa1e:	eb01 0989 	add.w	r9, r1, r9, lsl #2
    aa22:	f9b5 1064 	ldrsh.w	r1, [r5, #100]	; 0x64
    aa26:	4541      	cmp	r1, r8
    aa28:	dbe4      	blt.n	a9f4 <_lv_disp_refr_task+0x3c8>
                            _lv_memcpy(copy_buf, buf_ina + start_offs, line_length);
    aa2a:	4619      	mov	r1, r3
    aa2c:	4630      	mov	r0, r6
    aa2e:	9305      	str	r3, [sp, #20]
    aa30:	9204      	str	r2, [sp, #16]
    aa32:	f00c f804 	bl	16a3e <_lv_memcpy>
                            _lv_memcpy(buf_act + start_offs, copy_buf, line_length);
    aa36:	4648      	mov	r0, r9
    aa38:	9a04      	ldr	r2, [sp, #16]
    aa3a:	4631      	mov	r1, r6
    aa3c:	f00b ffff 	bl	16a3e <_lv_memcpy>
                        for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
    aa40:	9b00      	ldr	r3, [sp, #0]
    aa42:	f108 0801 	add.w	r8, r8, #1
    aa46:	461a      	mov	r2, r3
    aa48:	9b05      	ldr	r3, [sp, #20]
    aa4a:	4491      	add	r9, r2
    aa4c:	4413      	add	r3, r2
    aa4e:	fa0f f888 	sxth.w	r8, r8
    aa52:	9a04      	ldr	r2, [sp, #16]
    aa54:	e7e5      	b.n	aa22 <_lv_disp_refr_task+0x3f6>
    aa56:	bf00      	nop
    aa58:	20025cf8 	.word	0x20025cf8
    aa5c:	20025cfc 	.word	0x20025cfc

0000aa60 <lv_img_cf_get_px_size>:
 */
uint8_t lv_img_cf_get_px_size(lv_img_cf_t cf)
{
    uint8_t px_size = 0;

    switch(cf) {
    aa60:	3804      	subs	r0, #4
    aa62:	b2c0      	uxtb	r0, r0
    aa64:	280a      	cmp	r0, #10
    aa66:	bf9a      	itte	ls
    aa68:	4b01      	ldrls	r3, [pc, #4]	; (aa70 <lv_img_cf_get_px_size+0x10>)
    aa6a:	5c18      	ldrbls	r0, [r3, r0]
{
    aa6c:	2000      	movhi	r0, #0
            px_size = 0;
            break;
    }

    return px_size;
}
    aa6e:	4770      	bx	lr
    aa70:	00043fc7 	.word	0x00043fc7

0000aa74 <lv_draw_img>:
{
    aa74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aa78:	4604      	mov	r4, r0
    aa7a:	460f      	mov	r7, r1
    aa7c:	461e      	mov	r6, r3
    if(src == NULL) {
    aa7e:	4610      	mov	r0, r2
{
    aa80:	b08d      	sub	sp, #52	; 0x34
    if(src == NULL) {
    aa82:	b93a      	cbnz	r2, aa94 <lv_draw_img+0x20>
        show_error(coords, mask, "No\ndata");
    aa84:	4a66      	ldr	r2, [pc, #408]	; (ac20 <lv_draw_img+0x1ac>)
    bool alpha_byte   = lv_img_cf_has_alpha(cdsc->dec_dsc.header.cf);

    if(cdsc->dec_dsc.error_msg != NULL) {
        LV_LOG_WARN("Image draw error");

        show_error(coords, clip_area, cdsc->dec_dsc.error_msg);
    aa86:	4639      	mov	r1, r7
    aa88:	4620      	mov	r0, r4
    aa8a:	f00d facb 	bl	18024 <show_error>
}
    aa8e:	b00d      	add	sp, #52	; 0x34
    aa90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(dsc->opa <= LV_OPA_MIN) return;
    aa94:	781b      	ldrb	r3, [r3, #0]
    aa96:	2b02      	cmp	r3, #2
    aa98:	d9f9      	bls.n	aa8e <lv_draw_img+0x1a>
    lv_img_cache_entry_t * cdsc = _lv_img_cache_open(src, draw_dsc->recolor);
    aa9a:	68f1      	ldr	r1, [r6, #12]
    aa9c:	f001 fa62 	bl	bf64 <_lv_img_cache_open>
    if(cdsc == NULL) return LV_RES_INV;
    aaa0:	4605      	mov	r5, r0
    aaa2:	2800      	cmp	r0, #0
    aaa4:	d0ee      	beq.n	aa84 <lv_draw_img+0x10>
    if(cdsc->dec_dsc.error_msg != NULL) {
    aaa6:	69c2      	ldr	r2, [r0, #28]
    aaa8:	2a00      	cmp	r2, #0
    aaaa:	d1ec      	bne.n	aa86 <lv_draw_img+0x12>
    bool chroma_keyed = lv_img_cf_is_chroma_keyed(cdsc->dec_dsc.header.cf);
    aaac:	7c03      	ldrb	r3, [r0, #16]
    aaae:	f003 031f 	and.w	r3, r3, #31
    aab2:	4618      	mov	r0, r3
    aab4:	f00d fd2d 	bl	18512 <lv_img_cf_is_chroma_keyed>
    aab8:	9002      	str	r0, [sp, #8]
    bool alpha_byte   = lv_img_cf_has_alpha(cdsc->dec_dsc.header.cf);
    aaba:	4618      	mov	r0, r3
    aabc:	f00d fd33 	bl	18526 <lv_img_cf_has_alpha>
    }
    /* The decoder could open the image and gave the entire uncompressed image.
     * Just draw it!*/
    else if(cdsc->dec_dsc.img_data) {
    aac0:	696b      	ldr	r3, [r5, #20]
    bool alpha_byte   = lv_img_cf_has_alpha(cdsc->dec_dsc.header.cf);
    aac2:	9003      	str	r0, [sp, #12]
    else if(cdsc->dec_dsc.img_data) {
    aac4:	2b00      	cmp	r3, #0
    aac6:	d047      	beq.n	ab58 <lv_draw_img+0xe4>
        lv_area_t map_area_rot;
        lv_area_copy(&map_area_rot, coords);
    aac8:	a808      	add	r0, sp, #32
    aaca:	4621      	mov	r1, r4
    aacc:	f00d facf 	bl	1806e <lv_area_copy>
        if(draw_dsc->angle || draw_dsc->zoom != LV_IMG_ZOOM_NONE) {
    aad0:	8873      	ldrh	r3, [r6, #2]
    aad2:	8930      	ldrh	r0, [r6, #8]
    aad4:	b913      	cbnz	r3, aadc <lv_draw_img+0x68>
    aad6:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    aada:	d02b      	beq.n	ab34 <lv_draw_img+0xc0>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    aadc:	88e2      	ldrh	r2, [r4, #6]
    aade:	8861      	ldrh	r1, [r4, #2]
    aae0:	3201      	adds	r2, #1
    aae2:	1a52      	subs	r2, r2, r1
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    aae4:	88a1      	ldrh	r1, [r4, #4]
    aae6:	f8b4 c000 	ldrh.w	ip, [r4]
    aaea:	3101      	adds	r1, #1
    aaec:	eba1 010c 	sub.w	r1, r1, ip
            int32_t w = lv_area_get_width(coords);
            int32_t h = lv_area_get_height(coords);

            _lv_img_buf_get_transformed_area(&map_area_rot, w, h, draw_dsc->angle, draw_dsc->zoom, &draw_dsc->pivot);
    aaf0:	f106 0c04 	add.w	ip, r6, #4
    aaf4:	e9cd 0c00 	strd	r0, ip, [sp]
    aaf8:	b21b      	sxth	r3, r3
    aafa:	b212      	sxth	r2, r2
    aafc:	b209      	sxth	r1, r1
    aafe:	a808      	add	r0, sp, #32
    ab00:	f00f ff1c 	bl	1a93c <_lv_img_buf_get_transformed_area>

            map_area_rot.x1 += coords->x1;
    ab04:	f9b4 2000 	ldrsh.w	r2, [r4]
    ab08:	f8bd 3020 	ldrh.w	r3, [sp, #32]
            map_area_rot.y1 += coords->y1;
    ab0c:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
            map_area_rot.x1 += coords->x1;
    ab10:	4413      	add	r3, r2
    ab12:	f8ad 3020 	strh.w	r3, [sp, #32]
            map_area_rot.y1 += coords->y1;
    ab16:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
    ab1a:	4419      	add	r1, r3
    ab1c:	f8ad 1022 	strh.w	r1, [sp, #34]	; 0x22
            map_area_rot.x2 += coords->x1;
    ab20:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
    ab24:	440a      	add	r2, r1
    ab26:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
            map_area_rot.y2 += coords->y1;
    ab2a:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
    ab2e:	4413      	add	r3, r2
    ab30:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
        }

        lv_area_t mask_com; /*Common area of mask and coords*/
        bool union_ok;
        union_ok = _lv_area_intersect(&mask_com, clip_area, &map_area_rot);
    ab34:	4639      	mov	r1, r7
    ab36:	aa08      	add	r2, sp, #32
    ab38:	a80a      	add	r0, sp, #40	; 0x28
    ab3a:	f010 f8af 	bl	1ac9c <_lv_area_intersect>
        if(union_ok == false) {
    ab3e:	2800      	cmp	r0, #0
    ab40:	d0a5      	beq.n	aa8e <lv_draw_img+0x1a>
            return LV_RES_OK; /*Out of mask. There is nothing to draw so the image is drawn
                                 successfully.*/
        }

        lv_draw_map(coords, &mask_com, cdsc->dec_dsc.img_data, draw_dsc, chroma_keyed, alpha_byte);
    ab42:	9b03      	ldr	r3, [sp, #12]
    ab44:	4620      	mov	r0, r4
    ab46:	9301      	str	r3, [sp, #4]
    ab48:	9b02      	ldr	r3, [sp, #8]
    ab4a:	a90a      	add	r1, sp, #40	; 0x28
    ab4c:	9300      	str	r3, [sp, #0]
    ab4e:	696a      	ldr	r2, [r5, #20]
    ab50:	4633      	mov	r3, r6
    ab52:	f00d fa91 	bl	18078 <lv_draw_map>
    if(res == LV_RES_INV) {
    ab56:	e79a      	b.n	aa8e <lv_draw_img+0x1a>
    }
    /* The whole uncompressed image is not available. Try to read it line-by-line*/
    else {
        lv_area_t mask_com; /*Common area of mask and coords*/
        bool union_ok;
        union_ok = _lv_area_intersect(&mask_com, clip_area, coords);
    ab58:	4622      	mov	r2, r4
    ab5a:	4639      	mov	r1, r7
    ab5c:	a806      	add	r0, sp, #24
    ab5e:	f010 f89d 	bl	1ac9c <_lv_area_intersect>
        if(union_ok == false) {
    ab62:	2800      	cmp	r0, #0
    ab64:	d093      	beq.n	aa8e <lv_draw_img+0x1a>
    ab66:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    ab6a:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    ab6e:	3301      	adds	r3, #1
    ab70:	1a9b      	subs	r3, r3, r2
    ab72:	b21b      	sxth	r3, r3
                                 successfully.*/
        }

        int32_t width = lv_area_get_width(&mask_com);

        uint8_t  * buf = _lv_mem_buf_get(lv_area_get_width(&mask_com) *
    ab74:	0098      	lsls	r0, r3, #2
    ab76:	9304      	str	r3, [sp, #16]
    ab78:	f001 ffc0 	bl	cafc <_lv_mem_buf_get>
                                         LV_IMG_PX_SIZE_ALPHA_BYTE);  /*+1 because of the possible alpha byte*/

        lv_area_t line;
        lv_area_copy(&line, &mask_com);
    ab7c:	f10d 0920 	add.w	r9, sp, #32
    ab80:	a906      	add	r1, sp, #24
        uint8_t  * buf = _lv_mem_buf_get(lv_area_get_width(&mask_com) *
    ab82:	4680      	mov	r8, r0
        lv_area_copy(&line, &mask_com);
    ab84:	4648      	mov	r0, r9
    ab86:	f00d fa72 	bl	1806e <lv_area_copy>
        lv_area_set_height(&line, 1);
    ab8a:	2101      	movs	r1, #1
    ab8c:	4648      	mov	r0, r9
    ab8e:	f010 f872 	bl	1ac76 <lv_area_set_height>
        int32_t x = mask_com.x1 - coords->x1;
    ab92:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
    ab96:	f9b4 2000 	ldrsh.w	r2, [r4]
        int32_t y = mask_com.y1 - coords->y1;
    ab9a:	f9bd b01a 	ldrsh.w	fp, [sp, #26]
    ab9e:	f9b4 a002 	ldrsh.w	sl, [r4, #2]
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
            lv_area_t mask_line;
            union_ok = _lv_area_intersect(&mask_line, clip_area, &line);
            if(union_ok == false) continue;

            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);
    aba2:	1a9b      	subs	r3, r3, r2
    aba4:	b21b      	sxth	r3, r3
        int32_t y = mask_com.y1 - coords->y1;
    aba6:	ebab 0a0a 	sub.w	sl, fp, sl
            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);
    abaa:	9305      	str	r3, [sp, #20]
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
    abac:	f9bd 301e 	ldrsh.w	r3, [sp, #30]
    abb0:	459b      	cmp	fp, r3
    abb2:	dd03      	ble.n	abbc <lv_draw_img+0x148>
            lv_draw_map(&line, &mask_line, buf, draw_dsc, chroma_keyed, alpha_byte);
            line.y1++;
            line.y2++;
            y++;
        }
        _lv_mem_buf_release(buf);
    abb4:	4640      	mov	r0, r8
    abb6:	f002 f803 	bl	cbc0 <_lv_mem_buf_release>
    if(res == LV_RES_INV) {
    abba:	e768      	b.n	aa8e <lv_draw_img+0x1a>
            union_ok = _lv_area_intersect(&mask_line, clip_area, &line);
    abbc:	464a      	mov	r2, r9
    abbe:	4639      	mov	r1, r7
    abc0:	a80a      	add	r0, sp, #40	; 0x28
    abc2:	f010 f86b 	bl	1ac9c <_lv_area_intersect>
            if(union_ok == false) continue;
    abc6:	b338      	cbz	r0, ac18 <lv_draw_img+0x1a4>
            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);
    abc8:	4628      	mov	r0, r5
    abca:	9b04      	ldr	r3, [sp, #16]
    abcc:	9905      	ldr	r1, [sp, #20]
    abce:	f8cd 8000 	str.w	r8, [sp]
    abd2:	fa0f f28a 	sxth.w	r2, sl
    abd6:	f00f ff3e 	bl	1aa56 <lv_img_decoder_read_line>
            if(read_res != LV_RES_OK) {
    abda:	2801      	cmp	r0, #1
    abdc:	d006      	beq.n	abec <lv_draw_img+0x178>
                lv_img_decoder_close(&cdsc->dec_dsc);
    abde:	4628      	mov	r0, r5
    abe0:	f00f ff49 	bl	1aa76 <lv_img_decoder_close>
                _lv_mem_buf_release(buf);
    abe4:	4640      	mov	r0, r8
    abe6:	f001 ffeb 	bl	cbc0 <_lv_mem_buf_release>
    if(res == LV_RES_INV) {
    abea:	e74b      	b.n	aa84 <lv_draw_img+0x10>
            lv_draw_map(&line, &mask_line, buf, draw_dsc, chroma_keyed, alpha_byte);
    abec:	9b03      	ldr	r3, [sp, #12]
    abee:	4642      	mov	r2, r8
    abf0:	9301      	str	r3, [sp, #4]
    abf2:	9b02      	ldr	r3, [sp, #8]
    abf4:	4648      	mov	r0, r9
    abf6:	9300      	str	r3, [sp, #0]
    abf8:	a90a      	add	r1, sp, #40	; 0x28
    abfa:	4633      	mov	r3, r6
    abfc:	f00d fa3c 	bl	18078 <lv_draw_map>
            line.y1++;
    ac00:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
            y++;
    ac04:	f10a 0a01 	add.w	sl, sl, #1
            line.y1++;
    ac08:	3301      	adds	r3, #1
    ac0a:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
            line.y2++;
    ac0e:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
    ac12:	3301      	adds	r3, #1
    ac14:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
    ac18:	f10b 0b01 	add.w	fp, fp, #1
    ac1c:	e7c6      	b.n	abac <lv_draw_img+0x138>
    ac1e:	bf00      	nop
    ac20:	00043fbf 	.word	0x00043fbf

0000ac24 <lv_draw_label_dsc_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

LV_ATTRIBUTE_FAST_MEM void lv_draw_label_dsc_init(lv_draw_label_dsc_t * dsc)
{
    ac24:	b510      	push	{r4, lr}
    _lv_memset_00(dsc, sizeof(lv_draw_label_dsc_t));
    ac26:	2124      	movs	r1, #36	; 0x24
{
    ac28:	4604      	mov	r4, r0
    _lv_memset_00(dsc, sizeof(lv_draw_label_dsc_t));
    ac2a:	f00d fcac 	bl	18586 <_lv_memset_00>
    dsc->opa = LV_OPA_COVER;
    ac2e:	23ff      	movs	r3, #255	; 0xff
    ac30:	7323      	strb	r3, [r4, #12]
    dsc->color = LV_COLOR_BLACK;
    dsc->font = LV_THEME_DEFAULT_FONT_NORMAL;
    ac32:	4b07      	ldr	r3, [pc, #28]	; (ac50 <lv_draw_label_dsc_init+0x2c>)
    ac34:	60a3      	str	r3, [r4, #8]
    dsc->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
    ac36:	f64f 73ff 	movw	r3, #65535	; 0xffff
    dsc->sel_end = LV_DRAW_LABEL_NO_TXT_SEL;
    ac3a:	e9c4 3305 	strd	r3, r3, [r4, #20]
    dsc->color = LV_COLOR_BLACK;
    ac3e:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
    ac42:	6023      	str	r3, [r4, #0]
    dsc->sel_color = LV_COLOR_BLUE;
    ac44:	33ff      	adds	r3, #255	; 0xff
    ac46:	6063      	str	r3, [r4, #4]
    dsc->bidi_dir = LV_BIDI_DIR_LTR;
    ac48:	2300      	movs	r3, #0
    ac4a:	f884 3020 	strb.w	r3, [r4, #32]
}
    ac4e:	bd10      	pop	{r4, pc}
    ac50:	200004f4 	.word	0x200004f4

0000ac54 <lv_draw_label>:
 */
LV_ATTRIBUTE_FAST_MEM void lv_draw_label(const lv_area_t * coords, const lv_area_t * mask,
                                         const lv_draw_label_dsc_t * dsc,
                                         const char * txt,
                                         lv_draw_label_hint_t * hint)
{
    ac54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ac58:	b0d3      	sub	sp, #332	; 0x14c
    ac5a:	9309      	str	r3, [sp, #36]	; 0x24

    if(dsc->opa <= LV_OPA_MIN) return;
    ac5c:	7b13      	ldrb	r3, [r2, #12]
{
    ac5e:	4688      	mov	r8, r1
    if(dsc->opa <= LV_OPA_MIN) return;
    ac60:	2b02      	cmp	r3, #2
{
    ac62:	4614      	mov	r4, r2
    ac64:	9e5c      	ldr	r6, [sp, #368]	; 0x170
    ac66:	9006      	str	r0, [sp, #24]
    if(dsc->opa <= LV_OPA_MIN) return;
    ac68:	f240 80d4 	bls.w	ae14 <lv_draw_label+0x1c0>
    const lv_font_t * font = dsc->font;
    int32_t w;

    /*No need to waste processor time if string is empty*/
    if(txt[0] == '\0')  return;
    ac6c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ac6e:	781b      	ldrb	r3, [r3, #0]
    ac70:	2b00      	cmp	r3, #0
    ac72:	f000 80cf 	beq.w	ae14 <lv_draw_label+0x1c0>
    const lv_font_t * font = dsc->font;
    ac76:	f8d2 b008 	ldr.w	fp, [r2, #8]

    lv_area_t clipped_area;
    bool clip_ok = _lv_area_intersect(&clipped_area, coords, mask);
    ac7a:	460a      	mov	r2, r1
    ac7c:	4601      	mov	r1, r0
    ac7e:	a82e      	add	r0, sp, #184	; 0xb8
    ac80:	f010 f80c 	bl	1ac9c <_lv_area_intersect>
    if(!clip_ok) return;
    ac84:	2800      	cmp	r0, #0
    ac86:	f000 80c5 	beq.w	ae14 <lv_draw_label+0x1c0>


    if((dsc->flag & LV_TXT_FLAG_EXPAND) == 0) {
    ac8a:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    ac8e:	079f      	lsls	r7, r3, #30
    ac90:	f100 80c3 	bmi.w	ae1a <lv_draw_label+0x1c6>
    ac94:	9b06      	ldr	r3, [sp, #24]
    ac96:	9a06      	ldr	r2, [sp, #24]
    ac98:	889b      	ldrh	r3, [r3, #4]
    ac9a:	8812      	ldrh	r2, [r2, #0]
    ac9c:	3301      	adds	r3, #1
    ac9e:	1a9b      	subs	r3, r3, r2
        /*Normally use the label's width as width*/
        w = lv_area_get_width(coords);
    aca0:	b21b      	sxth	r3, r3
                         dsc->flag);
        w = p.x;
    }

    int32_t line_height_font = lv_font_get_line_height(font);
    int32_t line_height = line_height_font + dsc->line_space;
    aca2:	f9b4 200e 	ldrsh.w	r2, [r4, #14]

    int32_t x_ofs = 0;
    int32_t y_ofs = 0;
    x_ofs = dsc->ofs_x;
    y_ofs = dsc->ofs_y;
    pos.y += y_ofs;
    aca6:	9906      	ldr	r1, [sp, #24]
    int32_t line_height = line_height_font + dsc->line_space;
    aca8:	9208      	str	r2, [sp, #32]
    pos.x = coords->x1;
    acaa:	9a06      	ldr	r2, [sp, #24]
    pos.y += y_ofs;
    acac:	884d      	ldrh	r5, [r1, #2]
    pos.x = coords->x1;
    acae:	f9b2 2000 	ldrsh.w	r2, [r2]
    int32_t line_height_font = lv_font_get_line_height(font);
    acb2:	f9bb a008 	ldrsh.w	sl, [fp, #8]
    pos.x = coords->x1;
    acb6:	920b      	str	r2, [sp, #44]	; 0x2c
    x_ofs = dsc->ofs_x;
    acb8:	f9b4 201c 	ldrsh.w	r2, [r4, #28]
    acbc:	9225      	str	r2, [sp, #148]	; 0x94
    y_ofs = dsc->ofs_y;
    acbe:	f9b4 201e 	ldrsh.w	r2, [r4, #30]
    pos.y += y_ofs;
    acc2:	4415      	add	r5, r2
    acc4:	b22d      	sxth	r5, r5

    uint32_t line_start     = 0;
    int32_t last_line_start = -1;

    /*Check the hint to use the cached info*/
    if(hint && y_ofs == 0 && coords->y1 < 0) {
    acc6:	2e00      	cmp	r6, #0
    acc8:	f000 80b8 	beq.w	ae3c <lv_draw_label+0x1e8>
    accc:	2a00      	cmp	r2, #0
    acce:	f040 80b7 	bne.w	ae40 <lv_draw_label+0x1ec>
    acd2:	2d00      	cmp	r5, #0
    acd4:	f280 80b5 	bge.w	ae42 <lv_draw_label+0x1ee>
        /*If the label changed too much recalculate the hint.*/
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
    acd8:	68b2      	ldr	r2, [r6, #8]
    acda:	9908      	ldr	r1, [sp, #32]
    acdc:	1b52      	subs	r2, r2, r5
    acde:	2a00      	cmp	r2, #0
    ace0:	f5c1 7100 	rsb	r1, r1, #512	; 0x200
    ace4:	bfb8      	it	lt
    ace6:	4252      	neglt	r2, r2
    ace8:	eba1 010a 	sub.w	r1, r1, sl
    acec:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
            hint->line_start = -1;
    acf0:	bfc4      	itt	gt
    acf2:	f04f 32ff 	movgt.w	r2, #4294967295
    acf6:	6032      	strgt	r2, [r6, #0]
        }
        last_line_start = hint->line_start;
    acf8:	6832      	ldr	r2, [r6, #0]
    }

    /*Use the hint if it's valid*/
    if(hint && last_line_start >= 0) {
    acfa:	2a00      	cmp	r2, #0
    acfc:	f2c0 80a0 	blt.w	ae40 <lv_draw_label+0x1ec>
        line_start = last_line_start;
    ad00:	9205      	str	r2, [sp, #20]
        pos.y += hint->y;
    ad02:	6872      	ldr	r2, [r6, #4]
    ad04:	4415      	add	r5, r2
    ad06:	b22d      	sxth	r5, r5
    }

    uint32_t line_end = line_start + _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
    ad08:	b21b      	sxth	r3, r3
    ad0a:	9f05      	ldr	r7, [sp, #20]
    ad0c:	931d      	str	r3, [sp, #116]	; 0x74
    ad0e:	9809      	ldr	r0, [sp, #36]	; 0x24
    ad10:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    ad14:	4438      	add	r0, r7
    ad16:	9300      	str	r3, [sp, #0]
    ad18:	4659      	mov	r1, fp
    ad1a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    ad1c:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
    ad20:	f002 f974 	bl	d00c <_lv_txt_get_next_line>
    ad24:	9b05      	ldr	r3, [sp, #20]
    ad26:	18c3      	adds	r3, r0, r3
    ad28:	9307      	str	r3, [sp, #28]
    /*Go the first visible line*/
    while(pos.y + line_height_font < mask->y1) {
        /*Go to next line*/
        line_start = line_end;
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
        pos.y += line_height;
    ad2a:	9b08      	ldr	r3, [sp, #32]
    ad2c:	4453      	add	r3, sl
    ad2e:	461f      	mov	r7, r3
    while(pos.y + line_height_font < mask->y1) {
    ad30:	f9b8 1002 	ldrsh.w	r1, [r8, #2]
    ad34:	eb05 020a 	add.w	r2, r5, sl
    ad38:	428a      	cmp	r2, r1
    ad3a:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
    ad3e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    while(pos.y + line_height_font < mask->y1) {
    ad40:	f2c0 8081 	blt.w	ae46 <lv_draw_label+0x1f2>

        if(txt[line_start] == '\0') return;
    }

    /*Align to middle*/
    if(dsc->flag & LV_TXT_FLAG_CENTER) {
    ad44:	9905      	ldr	r1, [sp, #20]
    ad46:	075e      	lsls	r6, r3, #29
    ad48:	eb02 0001 	add.w	r0, r2, r1
    ad4c:	f140 80a1 	bpl.w	ae92 <lv_draw_label+0x23e>
        line_width = _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
    ad50:	9907      	ldr	r1, [sp, #28]
    ad52:	9e05      	ldr	r6, [sp, #20]
    ad54:	465a      	mov	r2, fp
    ad56:	9300      	str	r3, [sp, #0]
    ad58:	1b89      	subs	r1, r1, r6
    ad5a:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
    ad5e:	f002 f903 	bl	cf68 <_lv_txt_get_width>
    ad62:	9b06      	ldr	r3, [sp, #24]
    ad64:	9a06      	ldr	r2, [sp, #24]
    ad66:	889b      	ldrh	r3, [r3, #4]
    ad68:	8812      	ldrh	r2, [r2, #0]
    ad6a:	3301      	adds	r3, #1
    ad6c:	1a9b      	subs	r3, r3, r2

        pos.x += (lv_area_get_width(coords) - line_width) / 2;
    ad6e:	b21b      	sxth	r3, r3
    ad70:	1a18      	subs	r0, r3, r0
    ad72:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ad74:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    ad78:	eb03 0060 	add.w	r0, r3, r0, asr #1
    ad7c:	b203      	sxth	r3, r0

    }
    /*Align to the right*/
    else if(dsc->flag & LV_TXT_FLAG_RIGHT) {
        line_width = _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
        pos.x += lv_area_get_width(coords) - line_width;
    ad7e:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    lv_opa_t opa = dsc->opa;
    ad80:	7b23      	ldrb	r3, [r4, #12]
    ad82:	931f      	str	r3, [sp, #124]	; 0x7c

    uint32_t sel_start = dsc->sel_start;
    ad84:	6963      	ldr	r3, [r4, #20]
    ad86:	930e      	str	r3, [sp, #56]	; 0x38
    uint32_t sel_end = dsc->sel_end;
    ad88:	69a3      	ldr	r3, [r4, #24]
    ad8a:	930f      	str	r3, [sp, #60]	; 0x3c
    if(sel_start > sel_end) {
    ad8c:	e9dd 320e 	ldrd	r3, r2, [sp, #56]	; 0x38
    ad90:	4293      	cmp	r3, r2
    ad92:	bf88      	it	hi
    ad94:	e9cd 230e 	strdhi	r2, r3, [sp, #56]	; 0x38
        sel_start = sel_end;
        sel_end = tmp;
    }
    lv_draw_line_dsc_t line_dsc;

    if((dsc->decor & LV_TEXT_DECOR_UNDERLINE) || (dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH)) {
    ad98:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    ad9c:	079a      	lsls	r2, r3, #30
    ad9e:	d016      	beq.n	adce <lv_draw_label+0x17a>
        lv_draw_line_dsc_init(&line_dsc);
    ada0:	a832      	add	r0, sp, #200	; 0xc8
    ada2:	f00d fbfc 	bl	1859e <lv_draw_line_dsc_init>
        line_dsc.color = dsc->color;
    ada6:	6823      	ldr	r3, [r4, #0]
        line_dsc.width = font->underline_thickness ? font->underline_thickness : 1;
        line_dsc.opa = dsc->opa;
        line_dsc.blend_mode = dsc->blend_mode;
    ada8:	f894 2023 	ldrb.w	r2, [r4, #35]	; 0x23
        line_dsc.color = dsc->color;
    adac:	9332      	str	r3, [sp, #200]	; 0xc8
        line_dsc.width = font->underline_thickness ? font->underline_thickness : 1;
    adae:	f99b 300e 	ldrsb.w	r3, [fp, #14]
    adb2:	2b00      	cmp	r3, #0
    adb4:	bf08      	it	eq
    adb6:	2301      	moveq	r3, #1
    adb8:	f8ad 30cc 	strh.w	r3, [sp, #204]	; 0xcc
        line_dsc.opa = dsc->opa;
    adbc:	7b23      	ldrb	r3, [r4, #12]
    adbe:	f88d 30d2 	strb.w	r3, [sp, #210]	; 0xd2
        line_dsc.blend_mode = dsc->blend_mode;
    adc2:	f89d 30d3 	ldrb.w	r3, [sp, #211]	; 0xd3
    adc6:	f362 0301 	bfi	r3, r2, #0, #2
    adca:	f88d 30d3 	strb.w	r3, [sp, #211]	; 0xd3
    lv_color_t recolor;
    int32_t letter_w;


    lv_draw_rect_dsc_t draw_dsc_sel;
    lv_draw_rect_dsc_init(&draw_dsc_sel);
    adce:	a838      	add	r0, sp, #224	; 0xe0
    add0:	f001 f8a4 	bl	bf1c <lv_draw_rect_dsc_init>
    draw_dsc_sel.bg_color = dsc->sel_color;
    add4:	6863      	ldr	r3, [r4, #4]
    add6:	9339      	str	r3, [sp, #228]	; 0xe4

    int32_t pos_x_start = pos.x;
    /*Write out all lines*/
    while(txt[line_start] != '\0') {
    add8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    adda:	2bfd      	cmp	r3, #253	; 0xfd
    addc:	bf88      	it	hi
    adde:	23ff      	movhi	r3, #255	; 0xff
    ade0:	9315      	str	r3, [sp, #84]	; 0x54
    ade2:	9b08      	ldr	r3, [sp, #32]
    ade4:	4453      	add	r3, sl
    ade6:	b29b      	uxth	r3, r3
    ade8:	9326      	str	r3, [sp, #152]	; 0x98
    adea:	b2ab      	uxth	r3, r5
    adec:	931a      	str	r3, [sp, #104]	; 0x68
    uint32_t par_start = 0;
    adee:	2300      	movs	r3, #0
    adf0:	9318      	str	r3, [sp, #96]	; 0x60
                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {
                    lv_area_t sel_coords;
                    sel_coords.x1 = pos.x;
                    sel_coords.y1 = pos.y;
                    sel_coords.x2 = pos.x + letter_w + dsc->letter_space - 1;
                    sel_coords.y2 = pos.y + line_height - 1;
    adf2:	9b08      	ldr	r3, [sp, #32]
    while(txt[line_start] != '\0') {
    adf4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
                    sel_coords.y2 = pos.y + line_height - 1;
    adf6:	1e5f      	subs	r7, r3, #1
    adf8:	eb07 030a 	add.w	r3, r7, sl
    adfc:	932b      	str	r3, [sp, #172]	; 0xac
    adfe:	f9bd 3068 	ldrsh.w	r3, [sp, #104]	; 0x68
    while(txt[line_start] != '\0') {
    ae02:	9a05      	ldr	r2, [sp, #20]
    ae04:	9319      	str	r3, [sp, #100]	; 0x64
    ae06:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ae08:	4413      	add	r3, r2
    ae0a:	9317      	str	r3, [sp, #92]	; 0x5c
    ae0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ae0e:	5c9b      	ldrb	r3, [r3, r2]
    ae10:	2b00      	cmp	r3, #0
    ae12:	d156      	bne.n	aec2 <lv_draw_label+0x26e>

        if(pos.y > mask->y2) return;
    }

    LV_ASSERT_MEM_INTEGRITY();
}
    ae14:	b053      	add	sp, #332	; 0x14c
    ae16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        _lv_txt_get_size(&p, txt, dsc->font, dsc->letter_space, dsc->line_space, LV_COORD_MAX,
    ae1a:	9302      	str	r3, [sp, #8]
    ae1c:	f647 4318 	movw	r3, #31768	; 0x7c18
    ae20:	9301      	str	r3, [sp, #4]
    ae22:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
    ae26:	68a2      	ldr	r2, [r4, #8]
    ae28:	9300      	str	r3, [sp, #0]
    ae2a:	9909      	ldr	r1, [sp, #36]	; 0x24
    ae2c:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
    ae30:	a838      	add	r0, sp, #224	; 0xe0
    ae32:	f010 fb75 	bl	1b520 <_lv_txt_get_size>
        w = p.x;
    ae36:	f9bd 30e0 	ldrsh.w	r3, [sp, #224]	; 0xe0
    ae3a:	e732      	b.n	aca2 <lv_draw_label+0x4e>
    uint32_t line_start     = 0;
    ae3c:	9605      	str	r6, [sp, #20]
    ae3e:	e763      	b.n	ad08 <lv_draw_label+0xb4>
    ae40:	2200      	movs	r2, #0
    ae42:	9205      	str	r2, [sp, #20]
    ae44:	e760      	b.n	ad08 <lv_draw_label+0xb4>
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
    ae46:	9907      	ldr	r1, [sp, #28]
    ae48:	9300      	str	r3, [sp, #0]
    ae4a:	eb02 0901 	add.w	r9, r2, r1
    ae4e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    ae50:	4659      	mov	r1, fp
    ae52:	4648      	mov	r0, r9
    ae54:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
    ae58:	f002 f8d8 	bl	d00c <_lv_txt_get_next_line>
    ae5c:	9b07      	ldr	r3, [sp, #28]
        pos.y += line_height;
    ae5e:	443d      	add	r5, r7
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
    ae60:	4418      	add	r0, r3
        pos.y += line_height;
    ae62:	b22d      	sxth	r5, r5
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
    ae64:	b16e      	cbz	r6, ae82 <lv_draw_label+0x22e>
    ae66:	f515 6f80 	cmn.w	r5, #1024	; 0x400
    ae6a:	db0a      	blt.n	ae82 <lv_draw_label+0x22e>
    ae6c:	6833      	ldr	r3, [r6, #0]
    ae6e:	2b00      	cmp	r3, #0
    ae70:	da07      	bge.n	ae82 <lv_draw_label+0x22e>
            hint->line_start = line_start;
    ae72:	9b07      	ldr	r3, [sp, #28]
    ae74:	6033      	str	r3, [r6, #0]
            hint->y          = pos.y - coords->y1;
    ae76:	9b06      	ldr	r3, [sp, #24]
    ae78:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
    ae7c:	1aea      	subs	r2, r5, r3
            hint->coord_y    = coords->y1;
    ae7e:	e9c6 2301 	strd	r2, r3, [r6, #4]
        if(txt[line_start] == '\0') return;
    ae82:	9b07      	ldr	r3, [sp, #28]
    ae84:	9305      	str	r3, [sp, #20]
    ae86:	f899 3000 	ldrb.w	r3, [r9]
    ae8a:	2b00      	cmp	r3, #0
    ae8c:	d0c2      	beq.n	ae14 <lv_draw_label+0x1c0>
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
    ae8e:	9007      	str	r0, [sp, #28]
    ae90:	e74e      	b.n	ad30 <lv_draw_label+0xdc>
    else if(dsc->flag & LV_TXT_FLAG_RIGHT) {
    ae92:	0719      	lsls	r1, r3, #28
    ae94:	f57f af74 	bpl.w	ad80 <lv_draw_label+0x12c>
        line_width = _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
    ae98:	9907      	ldr	r1, [sp, #28]
    ae9a:	9e05      	ldr	r6, [sp, #20]
    ae9c:	465a      	mov	r2, fp
    ae9e:	9300      	str	r3, [sp, #0]
    aea0:	1b89      	subs	r1, r1, r6
    aea2:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
    aea6:	f002 f85f 	bl	cf68 <_lv_txt_get_width>
        pos.x += lv_area_get_width(coords) - line_width;
    aeaa:	9b06      	ldr	r3, [sp, #24]
    aeac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    aeae:	889b      	ldrh	r3, [r3, #4]
    aeb0:	441a      	add	r2, r3
    aeb2:	4613      	mov	r3, r2
    aeb4:	9a06      	ldr	r2, [sp, #24]
    aeb6:	3301      	adds	r3, #1
    aeb8:	8812      	ldrh	r2, [r2, #0]
    aeba:	1a9b      	subs	r3, r3, r2
    aebc:	1a1b      	subs	r3, r3, r0
    aebe:	b21b      	sxth	r3, r3
    aec0:	e75d      	b.n	ad7e <lv_draw_label+0x12a>
        pos.x += x_ofs;
    aec2:	9b25      	ldr	r3, [sp, #148]	; 0x94
                    sel_coords.y2 = pos.y + line_height - 1;
    aec4:	9a2b      	ldr	r2, [sp, #172]	; 0xac
        pos.x += x_ofs;
    aec6:	441d      	add	r5, r3
    aec8:	b22b      	sxth	r3, r5
    aeca:	930c      	str	r3, [sp, #48]	; 0x30
        i         = 0;
    aecc:	2300      	movs	r3, #0
    aece:	932d      	str	r3, [sp, #180]	; 0xb4
        cmd_state = CMD_STATE_WAIT;
    aed0:	9308      	str	r3, [sp, #32]
                    sel_coords.y2 = pos.y + line_height - 1;
    aed2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    aed4:	4413      	add	r3, r2
    aed6:	932a      	str	r3, [sp, #168]	; 0xa8
        while(i < line_end - line_start) {
    aed8:	9b07      	ldr	r3, [sp, #28]
    aeda:	9a05      	ldr	r2, [sp, #20]
    aedc:	992d      	ldr	r1, [sp, #180]	; 0xb4
    aede:	1a9b      	subs	r3, r3, r2
    aee0:	428b      	cmp	r3, r1
    aee2:	d87b      	bhi.n	afdc <lv_draw_label+0x388>
        if(dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH) {
    aee4:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    aee8:	079e      	lsls	r6, r3, #30
    aeea:	d51e      	bpl.n	af2a <lv_draw_label+0x2d6>
            p1.x = pos_x_start;
    aeec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
    aeee:	f9bd 20cc 	ldrsh.w	r2, [sp, #204]	; 0xcc
            p1.x = pos_x_start;
    aef2:	f8ad 30c0 	strh.w	r3, [sp, #192]	; 0xc0
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
    aef6:	68a3      	ldr	r3, [r4, #8]
    aef8:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    aefc:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
            lv_draw_line(&p1, &p2, mask, &line_dsc);
    af00:	a830      	add	r0, sp, #192	; 0xc0
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
    af02:	eb03 71d3 	add.w	r1, r3, r3, lsr #31
    af06:	1053      	asrs	r3, r2, #1
    af08:	9a19      	ldr	r2, [sp, #100]	; 0x64
    af0a:	eb03 0361 	add.w	r3, r3, r1, asr #1
    af0e:	4413      	add	r3, r2
            p2.x = pos.x;
    af10:	9a0c      	ldr	r2, [sp, #48]	; 0x30
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
    af12:	b21b      	sxth	r3, r3
    af14:	f8ad 30c2 	strh.w	r3, [sp, #194]	; 0xc2
            p2.x = pos.x;
    af18:	f8ad 20d4 	strh.w	r2, [sp, #212]	; 0xd4
            p2.y = p1.y;
    af1c:	f8ad 30d6 	strh.w	r3, [sp, #214]	; 0xd6
            lv_draw_line(&p1, &p2, mask, &line_dsc);
    af20:	4642      	mov	r2, r8
    af22:	ab32      	add	r3, sp, #200	; 0xc8
    af24:	a935      	add	r1, sp, #212	; 0xd4
    af26:	f000 fae7 	bl	b4f8 <lv_draw_line>
        if(dsc->decor  & LV_TEXT_DECOR_UNDERLINE) {
    af2a:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    af2e:	07dd      	lsls	r5, r3, #31
    af30:	d519      	bpl.n	af66 <lv_draw_label+0x312>
            p1.x = pos_x_start;
    af32:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
    af34:	68a2      	ldr	r2, [r4, #8]
            p1.x = pos_x_start;
    af36:	f8ad 30c0 	strh.w	r3, [sp, #192]	; 0xc0
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
    af3a:	8913      	ldrh	r3, [r2, #8]
    af3c:	8952      	ldrh	r2, [r2, #10]
            lv_draw_line(&p1, &p2, mask, &line_dsc);
    af3e:	a935      	add	r1, sp, #212	; 0xd4
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
    af40:	1a9b      	subs	r3, r3, r2
    af42:	f99b 200d 	ldrsb.w	r2, [fp, #13]
            lv_draw_line(&p1, &p2, mask, &line_dsc);
    af46:	a830      	add	r0, sp, #192	; 0xc0
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
    af48:	1a9b      	subs	r3, r3, r2
    af4a:	9a19      	ldr	r2, [sp, #100]	; 0x64
    af4c:	441a      	add	r2, r3
    af4e:	b213      	sxth	r3, r2
            p2.x = pos.x;
    af50:	9a0c      	ldr	r2, [sp, #48]	; 0x30
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
    af52:	f8ad 30c2 	strh.w	r3, [sp, #194]	; 0xc2
            p2.x = pos.x;
    af56:	f8ad 20d4 	strh.w	r2, [sp, #212]	; 0xd4
            p2.y = p1.y;
    af5a:	f8ad 30d6 	strh.w	r3, [sp, #214]	; 0xd6
            lv_draw_line(&p1, &p2, mask, &line_dsc);
    af5e:	4642      	mov	r2, r8
    af60:	ab32      	add	r3, sp, #200	; 0xc8
    af62:	f000 fac9 	bl	b4f8 <lv_draw_line>
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
    af66:	9b09      	ldr	r3, [sp, #36]	; 0x24
    af68:	9a07      	ldr	r2, [sp, #28]
    af6a:	4659      	mov	r1, fp
    af6c:	189f      	adds	r7, r3, r2
    af6e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    af72:	4638      	mov	r0, r7
    af74:	9300      	str	r3, [sp, #0]
    af76:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
    af7a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    af7c:	f002 f846 	bl	d00c <_lv_txt_get_next_line>
    af80:	9b07      	ldr	r3, [sp, #28]
    af82:	4601      	mov	r1, r0
    af84:	181e      	adds	r6, r3, r0
        pos.x = coords->x1;
    af86:	9b06      	ldr	r3, [sp, #24]
    af88:	f9b3 5000 	ldrsh.w	r5, [r3]
        if(dsc->flag & LV_TXT_FLAG_CENTER) {
    af8c:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    af90:	0758      	lsls	r0, r3, #29
    af92:	f140 8232 	bpl.w	b3fa <lv_draw_label+0x7a6>
                _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
    af96:	465a      	mov	r2, fp
    af98:	9300      	str	r3, [sp, #0]
    af9a:	4638      	mov	r0, r7
    af9c:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
    afa0:	f001 ffe2 	bl	cf68 <_lv_txt_get_width>
    afa4:	9b06      	ldr	r3, [sp, #24]
    afa6:	9a06      	ldr	r2, [sp, #24]
    afa8:	889b      	ldrh	r3, [r3, #4]
    afaa:	8812      	ldrh	r2, [r2, #0]
    afac:	3301      	adds	r3, #1
    afae:	1a9b      	subs	r3, r3, r2
            pos.x += (lv_area_get_width(coords) - line_width) / 2;
    afb0:	b21b      	sxth	r3, r3
    afb2:	1a18      	subs	r0, r3, r0
    afb4:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    afb8:	eb05 0560 	add.w	r5, r5, r0, asr #1
            pos.x += lv_area_get_width(coords) - line_width;
    afbc:	b22d      	sxth	r5, r5
        if(pos.y > mask->y2) return;
    afbe:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    afc0:	9a26      	ldr	r2, [sp, #152]	; 0x98
    afc2:	4413      	add	r3, r2
    afc4:	b29a      	uxth	r2, r3
    afc6:	921a      	str	r2, [sp, #104]	; 0x68
        line_start = line_end;
    afc8:	9a07      	ldr	r2, [sp, #28]
        if(pos.y > mask->y2) return;
    afca:	b21b      	sxth	r3, r3
        line_start = line_end;
    afcc:	9205      	str	r2, [sp, #20]
        if(pos.y > mask->y2) return;
    afce:	f9b8 2006 	ldrsh.w	r2, [r8, #6]
    afd2:	429a      	cmp	r2, r3
    afd4:	f6ff af1e 	blt.w	ae14 <lv_draw_label+0x1c0>
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
    afd8:	9607      	str	r6, [sp, #28]
    afda:	e710      	b.n	adfe <lv_draw_label+0x1aa>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    afdc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    afe0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    afe2:	429a      	cmp	r2, r3
    afe4:	d024      	beq.n	b030 <lv_draw_label+0x3dc>
    afe6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    afe8:	429a      	cmp	r2, r3
    afea:	d021      	beq.n	b030 <lv_draw_label+0x3dc>
                logical_char_pos = _lv_txt_encoded_get_char_id(txt, line_start + i);
    afec:	9a05      	ldr	r2, [sp, #20]
    afee:	4bb2      	ldr	r3, [pc, #712]	; (b2b8 <lv_draw_label+0x664>)
    aff0:	9809      	ldr	r0, [sp, #36]	; 0x24
    aff2:	681b      	ldr	r3, [r3, #0]
    aff4:	4411      	add	r1, r2
    aff6:	4798      	blx	r3
    aff8:	4606      	mov	r6, r0
            uint32_t letter      = _lv_txt_encoded_next(bidi_txt, &i);
    affa:	4fb0      	ldr	r7, [pc, #704]	; (b2bc <lv_draw_label+0x668>)
    affc:	a92d      	add	r1, sp, #180	; 0xb4
    affe:	683b      	ldr	r3, [r7, #0]
    b000:	9817      	ldr	r0, [sp, #92]	; 0x5c
    b002:	4798      	blx	r3
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
    b004:	9a17      	ldr	r2, [sp, #92]	; 0x5c
            uint32_t letter      = _lv_txt_encoded_next(bidi_txt, &i);
    b006:	4605      	mov	r5, r0
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
    b008:	982d      	ldr	r0, [sp, #180]	; 0xb4
    b00a:	683b      	ldr	r3, [r7, #0]
    b00c:	4410      	add	r0, r2
    b00e:	2100      	movs	r1, #0
    b010:	4798      	blx	r3
    b012:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    b016:	4602      	mov	r2, r0
            if((dsc->flag & LV_TXT_FLAG_RECOLOR) != 0) {
    b018:	f013 0301 	ands.w	r3, r3, #1
    b01c:	f000 8093 	beq.w	b146 <lv_draw_label+0x4f2>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
    b020:	2d23      	cmp	r5, #35	; 0x23
    b022:	d10f      	bne.n	b044 <lv_draw_label+0x3f0>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
    b024:	9908      	ldr	r1, [sp, #32]
    b026:	b929      	cbnz	r1, b034 <lv_draw_label+0x3e0>
                        par_start = i;
    b028:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    b02a:	9218      	str	r2, [sp, #96]	; 0x60
                        cmd_state = CMD_STATE_WAIT;
    b02c:	9308      	str	r3, [sp, #32]
    b02e:	e753      	b.n	aed8 <lv_draw_label+0x284>
            uint32_t logical_char_pos = 0;
    b030:	2600      	movs	r6, #0
    b032:	e7e2      	b.n	affa <lv_draw_label+0x3a6>
                    else if(cmd_state == CMD_STATE_PAR) {   /*Other start char in parameter escaped cmd. char */
    b034:	9b08      	ldr	r3, [sp, #32]
    b036:	2b01      	cmp	r3, #1
    b038:	d049      	beq.n	b0ce <lv_draw_label+0x47a>
                    else if(cmd_state == CMD_STATE_IN) {   /*Command end */
    b03a:	2b02      	cmp	r3, #2
    b03c:	f040 8083 	bne.w	b146 <lv_draw_label+0x4f2>
                        cmd_state = CMD_STATE_WAIT;
    b040:	2300      	movs	r3, #0
    b042:	e7f3      	b.n	b02c <lv_draw_label+0x3d8>
                if(cmd_state == CMD_STATE_PAR) {
    b044:	9b08      	ldr	r3, [sp, #32]
    b046:	2b01      	cmp	r3, #1
    b048:	d17d      	bne.n	b146 <lv_draw_label+0x4f2>
                    if(letter == ' ') {
    b04a:	2d20      	cmp	r5, #32
    b04c:	f47f af44 	bne.w	aed8 <lv_draw_label+0x284>
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
    b050:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
    b052:	9a18      	ldr	r2, [sp, #96]	; 0x60
    b054:	1a9b      	subs	r3, r3, r2
    b056:	2b07      	cmp	r3, #7
    b058:	d137      	bne.n	b0ca <lv_draw_label+0x476>
                            _lv_memcpy_small(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
    b05a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    return memcpy(dst, src, len);
    b05c:	9918      	ldr	r1, [sp, #96]	; 0x60
    b05e:	189a      	adds	r2, r3, r2
    b060:	5858      	ldr	r0, [r3, r1]
    b062:	8893      	ldrh	r3, [r2, #4]
    b064:	f3c0 4607 	ubfx	r6, r0, #16, #8
    b068:	f3c0 6507 	ubfx	r5, r0, #24, #8
    b06c:	f3c0 2707 	ubfx	r7, r0, #8, #8
    b070:	9035      	str	r0, [sp, #212]	; 0xd4
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
    b072:	b2c0      	uxtb	r0, r0
    b074:	f8ad 30d8 	strh.w	r3, [sp, #216]	; 0xd8
    b078:	f00d fa73 	bl	18562 <hex_char_to_num>
    b07c:	4601      	mov	r1, r0
    b07e:	b2f8      	uxtb	r0, r7
    b080:	f00d fa6f 	bl	18562 <hex_char_to_num>
    b084:	eb00 1101 	add.w	r1, r0, r1, lsl #4
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
    b088:	b2f0      	uxtb	r0, r6
    b08a:	f00d fa6a 	bl	18562 <hex_char_to_num>
    b08e:	4606      	mov	r6, r0
    b090:	b2e8      	uxtb	r0, r5
    b092:	f00d fa66 	bl	18562 <hex_char_to_num>
    b096:	eb00 1506 	add.w	r5, r0, r6, lsl #4
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
    b09a:	f89d 00d8 	ldrb.w	r0, [sp, #216]	; 0xd8
    b09e:	f00d fa60 	bl	18562 <hex_char_to_num>
    b0a2:	4606      	mov	r6, r0
    b0a4:	f89d 00d9 	ldrb.w	r0, [sp, #217]	; 0xd9
    b0a8:	f00d fa5b 	bl	18562 <hex_char_to_num>
#define LV_COLOR_MAKE(r8, g8, b8) (_LV_COLOR_MAKE_TYPE_HELPER{{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
#endif

static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
    return LV_COLOR_MAKE(r, g, b);
    b0ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    b0ae:	eb00 1006 	add.w	r0, r0, r6, lsl #4
    b0b2:	f360 0307 	bfi	r3, r0, #0, #8
    b0b6:	f365 230f 	bfi	r3, r5, #8, #8
    b0ba:	f361 4317 	bfi	r3, r1, #16, #8
    b0be:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
    b0c2:	930a      	str	r3, [sp, #40]	; 0x28
                            recolor.full = dsc->color.full;
    b0c4:	9320      	str	r3, [sp, #128]	; 0x80
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
    b0c6:	2302      	movs	r3, #2
    b0c8:	e7b0      	b.n	b02c <lv_draw_label+0x3d8>
                            recolor.full = dsc->color.full;
    b0ca:	6823      	ldr	r3, [r4, #0]
    b0cc:	e7fa      	b.n	b0c4 <lv_draw_label+0x470>
            lv_color_t color = dsc->color;
    b0ce:	6823      	ldr	r3, [r4, #0]
    b0d0:	9316      	str	r3, [sp, #88]	; 0x58
                        cmd_state = CMD_STATE_WAIT;
    b0d2:	2300      	movs	r3, #0
    b0d4:	9308      	str	r3, [sp, #32]
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    b0d6:	4629      	mov	r1, r5
    b0d8:	4658      	mov	r0, fp
    b0da:	f010 faa8 	bl	1b62e <lv_font_get_glyph_width>
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    b0de:	f64f 73ff 	movw	r3, #65535	; 0xffff
    b0e2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    b0e4:	901e      	str	r0, [sp, #120]	; 0x78
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
    b0e6:	429a      	cmp	r2, r3
    b0e8:	d01c      	beq.n	b124 <lv_draw_label+0x4d0>
    b0ea:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    b0ec:	429a      	cmp	r2, r3
    b0ee:	d019      	beq.n	b124 <lv_draw_label+0x4d0>
                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {
    b0f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b0f2:	42b3      	cmp	r3, r6
    b0f4:	d816      	bhi.n	b124 <lv_draw_label+0x4d0>
    b0f6:	42b2      	cmp	r2, r6
    b0f8:	d914      	bls.n	b124 <lv_draw_label+0x4d0>
                    sel_coords.x1 = pos.x;
    b0fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
                    sel_coords.x2 = pos.x + letter_w + dsc->letter_space - 1;
    b0fc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
                    sel_coords.x1 = pos.x;
    b0fe:	f8ad 30d4 	strh.w	r3, [sp, #212]	; 0xd4
                    sel_coords.y1 = pos.y;
    b102:	9b19      	ldr	r3, [sp, #100]	; 0x64
                    lv_draw_rect(&sel_coords, mask, &draw_dsc_sel);
    b104:	4641      	mov	r1, r8
                    sel_coords.y1 = pos.y;
    b106:	f8ad 30d6 	strh.w	r3, [sp, #214]	; 0xd6
                    sel_coords.x2 = pos.x + letter_w + dsc->letter_space - 1;
    b10a:	8a23      	ldrh	r3, [r4, #16]
    b10c:	3b01      	subs	r3, #1
    b10e:	4413      	add	r3, r2
    b110:	4403      	add	r3, r0
    b112:	f8ad 30d8 	strh.w	r3, [sp, #216]	; 0xd8
                    sel_coords.y2 = pos.y + line_height - 1;
    b116:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
                    lv_draw_rect(&sel_coords, mask, &draw_dsc_sel);
    b118:	aa38      	add	r2, sp, #224	; 0xe0
    b11a:	a835      	add	r0, sp, #212	; 0xd4
                    sel_coords.y2 = pos.y + line_height - 1;
    b11c:	f8ad 30da 	strh.w	r3, [sp, #218]	; 0xda
                    lv_draw_rect(&sel_coords, mask, &draw_dsc_sel);
    b120:	f00d ff69 	bl	18ff6 <lv_draw_rect>
LV_ATTRIBUTE_FAST_MEM static void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * clip_area,
                                                 const lv_font_t * font_p,
                                                 uint32_t letter,
                                                 lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)
{
    if(opa < LV_OPA_MIN) return;
    b124:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    b126:	2b01      	cmp	r3, #1
    b128:	f200 817a 	bhi.w	b420 <lv_draw_label+0x7cc>
            if(letter_w > 0) {
    b12c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    b12e:	2b00      	cmp	r3, #0
    b130:	f43f aed2 	beq.w	aed8 <lv_draw_label+0x284>
                pos.x += letter_w + dsc->letter_space;
    b134:	8a25      	ldrh	r5, [r4, #16]
    b136:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b138:	442b      	add	r3, r5
    b13a:	461d      	mov	r5, r3
    b13c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    b13e:	441d      	add	r5, r3
    b140:	b22b      	sxth	r3, r5
    b142:	930c      	str	r3, [sp, #48]	; 0x30
    b144:	e6c8      	b.n	aed8 <lv_draw_label+0x284>
            lv_color_t color = dsc->color;
    b146:	6823      	ldr	r3, [r4, #0]
            if(cmd_state == CMD_STATE_IN) color = recolor;
    b148:	9920      	ldr	r1, [sp, #128]	; 0x80
    b14a:	9808      	ldr	r0, [sp, #32]
    b14c:	2802      	cmp	r0, #2
    b14e:	bf08      	it	eq
    b150:	460b      	moveq	r3, r1
    b152:	9316      	str	r3, [sp, #88]	; 0x58
    b154:	e7bf      	b.n	b0d6 <lv_draw_label+0x482>
    const uint8_t * bpp_opa_table_p;
    uint32_t bitmask_init;
    uint32_t bitmask;
    uint32_t bpp = g->bpp;
    uint32_t shades;
    if(bpp == 3) bpp = 4;
    b156:	2280      	movs	r2, #128	; 0x80
    b158:	2601      	movs	r6, #1
    b15a:	2302      	movs	r3, #2
    b15c:	9212      	str	r2, [sp, #72]	; 0x48
    b15e:	4a58      	ldr	r2, [pc, #352]	; (b2c0 <lv_draw_label+0x66c>)
            bpp_opa_table_p = _lv_bpp1_opa_table;
            bitmask_init  = 0x80;
            shades = 2;
            break;
        case 2:
            bpp_opa_table_p = _lv_bpp2_opa_table;
    b160:	920d      	str	r2, [sp, #52]	; 0x34
    }

    static lv_opa_t opa_table[256];
    static lv_opa_t prev_opa = LV_OPA_TRANSP;
    static uint32_t prev_bpp = 0;
    if(opa < LV_OPA_MAX) {
    b162:	9a15      	ldr	r2, [sp, #84]	; 0x54
    b164:	2afc      	cmp	r2, #252	; 0xfc
    b166:	d811      	bhi.n	b18c <lv_draw_label+0x538>
        if(prev_opa != opa || prev_bpp != bpp) {
    b168:	4a56      	ldr	r2, [pc, #344]	; (b2c4 <lv_draw_label+0x670>)
    b16a:	9915      	ldr	r1, [sp, #84]	; 0x54
    b16c:	7812      	ldrb	r2, [r2, #0]
    b16e:	428a      	cmp	r2, r1
    b170:	f040 80b4 	bne.w	b2dc <lv_draw_label+0x688>
    b174:	4a54      	ldr	r2, [pc, #336]	; (b2c8 <lv_draw_label+0x674>)
    b176:	6812      	ldr	r2, [r2, #0]
    b178:	42b2      	cmp	r2, r6
    b17a:	f040 80af 	bne.w	b2dc <lv_draw_label+0x688>
            for(i = 0; i < shades; i++) {
                opa_table[i] = bpp_opa_table_p[i] == LV_OPA_COVER ? opa : ((bpp_opa_table_p[i] * opa) >> 8);
            }
        }
        bpp_opa_table_p = opa_table;
        prev_opa = opa;
    b17e:	4b51      	ldr	r3, [pc, #324]	; (b2c4 <lv_draw_label+0x670>)
    b180:	9a15      	ldr	r2, [sp, #84]	; 0x54
    b182:	701a      	strb	r2, [r3, #0]
        prev_bpp = bpp;
    b184:	4b50      	ldr	r3, [pc, #320]	; (b2c8 <lv_draw_label+0x674>)
    b186:	601e      	str	r6, [r3, #0]
        bpp_opa_table_p = opa_table;
    b188:	4b50      	ldr	r3, [pc, #320]	; (b2cc <lv_draw_label+0x678>)
    b18a:	930d      	str	r3, [sp, #52]	; 0x34
    }

    int32_t col, row;
    int32_t box_w = g->box_w;
    b18c:	f8bd 30d6 	ldrh.w	r3, [sp, #214]	; 0xd6
    int32_t box_h = g->box_h;
    int32_t width_bit = box_w * bpp; /*Letter width in bits*/

    /* Calculate the col/row start/end on the map*/
    int32_t col_start = pos_x >= clip_area->x1 ? 0 : clip_area->x1 - pos_x;
    b190:	f9b8 7000 	ldrsh.w	r7, [r8]
    int32_t box_w = g->box_w;
    b194:	9313      	str	r3, [sp, #76]	; 0x4c
    int32_t col_end   = pos_x + box_w <= clip_area->x2 ? box_w : clip_area->x2 - pos_x + 1;
    b196:	9913      	ldr	r1, [sp, #76]	; 0x4c
    int32_t width_bit = box_w * bpp; /*Letter width in bits*/
    b198:	fb06 f503 	mul.w	r5, r6, r3
    int32_t col_end   = pos_x + box_w <= clip_area->x2 ? box_w : clip_area->x2 - pos_x + 1;
    b19c:	f9b8 3004 	ldrsh.w	r3, [r8, #4]
    int32_t col_start = pos_x >= clip_area->x1 ? 0 : clip_area->x1 - pos_x;
    b1a0:	45ba      	cmp	sl, r7
    int32_t col_end   = pos_x + box_w <= clip_area->x2 ? box_w : clip_area->x2 - pos_x + 1;
    b1a2:	4451      	add	r1, sl
    int32_t col_start = pos_x >= clip_area->x1 ? 0 : clip_area->x1 - pos_x;
    b1a4:	bfb4      	ite	lt
    b1a6:	eba7 070a 	sublt.w	r7, r7, sl
    b1aa:	2700      	movge	r7, #0
    int32_t col_end   = pos_x + box_w <= clip_area->x2 ? box_w : clip_area->x2 - pos_x + 1;
    b1ac:	4299      	cmp	r1, r3
    b1ae:	bfd2      	itee	le
    b1b0:	9b13      	ldrle	r3, [sp, #76]	; 0x4c
    b1b2:	3301      	addgt	r3, #1
    b1b4:	eba3 030a 	subgt.w	r3, r3, sl
    b1b8:	9311      	str	r3, [sp, #68]	; 0x44
    int32_t row_start = pos_y >= clip_area->y1 ? 0 : clip_area->y1 - pos_y;
    b1ba:	f9b8 3002 	ldrsh.w	r3, [r8, #2]
    int32_t box_h = g->box_h;
    b1be:	f8bd 20d8 	ldrh.w	r2, [sp, #216]	; 0xd8
    int32_t row_start = pos_y >= clip_area->y1 ? 0 : clip_area->y1 - pos_y;
    b1c2:	4599      	cmp	r9, r3
    b1c4:	bfac      	ite	ge
    b1c6:	2300      	movge	r3, #0
    b1c8:	eba3 0309 	sublt.w	r3, r3, r9
    b1cc:	9310      	str	r3, [sp, #64]	; 0x40
    int32_t row_end   = pos_y + box_h <= clip_area->y2 ? box_h : clip_area->y2 - pos_y + 1;
    b1ce:	f9b8 3006 	ldrsh.w	r3, [r8, #6]
    b1d2:	eb02 0109 	add.w	r1, r2, r9
    b1d6:	4299      	cmp	r1, r3
    b1d8:	bfc2      	ittt	gt
    b1da:	3301      	addgt	r3, #1
    b1dc:	eba3 0309 	subgt.w	r3, r3, r9
    b1e0:	9323      	strgt	r3, [sp, #140]	; 0x8c

    /*Move on the map too*/
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * bpp);
    b1e2:	fb07 f306 	mul.w	r3, r7, r6
    b1e6:	9910      	ldr	r1, [sp, #64]	; 0x40
    int32_t row_end   = pos_y + box_h <= clip_area->y2 ? box_h : clip_area->y2 - pos_y + 1;
    b1e8:	bfd8      	it	le
    b1ea:	9223      	strle	r2, [sp, #140]	; 0x8c
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * bpp);
    b1ec:	fb01 3505 	mla	r5, r1, r5, r3
    map_p += bit_ofs >> 3;
    b1f0:	eb00 03d5 	add.w	r3, r0, r5, lsr #3
    b1f4:	9314      	str	r3, [sp, #80]	; 0x50

    uint8_t letter_px;
    uint32_t col_bit;
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */

    uint32_t mask_buf_size = box_w * box_h > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : box_w * box_h;
    b1f6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
    b1f8:	f005 0507 	and.w	r5, r5, #7
    uint32_t mask_buf_size = box_w * box_h > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : box_w * box_h;
    b1fc:	4353      	muls	r3, r2
    b1fe:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
    b202:	bfa8      	it	ge
    b204:	f44f 73a0 	movge.w	r3, #320	; 0x140
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
    b208:	4618      	mov	r0, r3
    uint32_t mask_buf_size = box_w * box_h > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : box_w * box_h;
    b20a:	931b      	str	r3, [sp, #108]	; 0x6c
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
    b20c:	f001 fc76 	bl	cafc <_lv_mem_buf_get>
    int32_t mask_p = 0;

    lv_area_t fill_area;
    fill_area.x1 = col_start + pos_x;
    b210:	eb0a 0307 	add.w	r3, sl, r7
    b214:	f8ad 30c0 	strh.w	r3, [sp, #192]	; 0xc0
    fill_area.x2 = col_end  + pos_x - 1;
    b218:	9b11      	ldr	r3, [sp, #68]	; 0x44
    b21a:	f10a 3aff 	add.w	sl, sl, #4294967295
    b21e:	449a      	add	sl, r3
    fill_area.y1 = row_start + pos_y;
    b220:	9b10      	ldr	r3, [sp, #64]	; 0x40
    fill_area.x2 = col_end  + pos_x - 1;
    b222:	f8ad a0c4 	strh.w	sl, [sp, #196]	; 0xc4
    fill_area.y1 = row_start + pos_y;
    b226:	4499      	add	r9, r3
    b228:	fa0f f989 	sxth.w	r9, r9
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
    b22c:	901c      	str	r0, [sp, #112]	; 0x70
    fill_area.y1 = row_start + pos_y;
    b22e:	f8ad 90c2 	strh.w	r9, [sp, #194]	; 0xc2
    fill_area.y2 = fill_area.y1;
    b232:	f8ad 90c6 	strh.w	r9, [sp, #198]	; 0xc6

    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
    b236:	f000 fdb5 	bl	bda4 <lv_draw_mask_get_cnt>
    int32_t mask_p = 0;
    b23a:	f04f 0a00 	mov.w	sl, #0

    uint32_t col_bit_max = 8 - bpp;
    b23e:	f1c6 0308 	rsb	r3, r6, #8
    b242:	9322      	str	r3, [sp, #136]	; 0x88
    uint32_t col_bit_row_ofs = (box_w + col_start - col_end) * bpp;
    b244:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    b246:	9a11      	ldr	r2, [sp, #68]	; 0x44
    b248:	443b      	add	r3, r7
    b24a:	1a9b      	subs	r3, r3, r2
    b24c:	4373      	muls	r3, r6
    b24e:	9328      	str	r3, [sp, #160]	; 0xa0
    b250:	1bd3      	subs	r3, r2, r7
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
    b252:	9027      	str	r0, [sp, #156]	; 0x9c

    for(row = row_start ; row < row_end; row++) {
    b254:	9324      	str	r3, [sp, #144]	; 0x90
    b256:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b258:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    b25a:	4293      	cmp	r3, r2
    b25c:	db4f      	blt.n	b2fe <lv_draw_label+0x6aa>
        map_p += (col_bit >> 3);
        col_bit = col_bit & 0x7;
    }

    /*Flush the last part*/
    if(fill_area.y1 != fill_area.y2) {
    b25e:	f9bd 30c6 	ldrsh.w	r3, [sp, #198]	; 0xc6
    b262:	f9bd 20c2 	ldrsh.w	r2, [sp, #194]	; 0xc2
    b266:	429a      	cmp	r2, r3
    b268:	d00e      	beq.n	b288 <lv_draw_label+0x634>
        fill_area.y2--;
    b26a:	3b01      	subs	r3, #1
    b26c:	f8ad 30c6 	strh.w	r3, [sp, #198]	; 0xc6
        _lv_blend_fill(clip_area, &fill_area,
    b270:	9b21      	ldr	r3, [sp, #132]	; 0x84
    b272:	27ff      	movs	r7, #255	; 0xff
    b274:	9302      	str	r3, [sp, #8]
    b276:	2302      	movs	r3, #2
    b278:	4640      	mov	r0, r8
    b27a:	e9cd 3700 	strd	r3, r7, [sp]
    b27e:	9a16      	ldr	r2, [sp, #88]	; 0x58
    b280:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    b282:	a930      	add	r1, sp, #192	; 0xc0
    b284:	f00c f9aa 	bl	175dc <_lv_blend_fill>
                       color, mask_buf, LV_DRAW_MASK_RES_CHANGED, LV_OPA_COVER,
                       blend_mode);
        mask_p = 0;
    }

    _lv_mem_buf_release(mask_buf);
    b288:	981c      	ldr	r0, [sp, #112]	; 0x70
    b28a:	f001 fc99 	bl	cbc0 <_lv_mem_buf_release>
    b28e:	e74d      	b.n	b12c <lv_draw_label+0x4d8>
            bitmask_init  = 0xFF;
    b290:	22ff      	movs	r2, #255	; 0xff
            break;       /*No opa table, pixel value will be used directly*/
    b292:	2608      	movs	r6, #8
            bitmask_init  = 0xFF;
    b294:	9212      	str	r2, [sp, #72]	; 0x48
            shades = 256;
    b296:	f44f 7380 	mov.w	r3, #256	; 0x100
            bpp_opa_table_p = _lv_bpp8_opa_table;
    b29a:	4a0d      	ldr	r2, [pc, #52]	; (b2d0 <lv_draw_label+0x67c>)
    b29c:	e760      	b.n	b160 <lv_draw_label+0x50c>
            bitmask_init  = 0xF0;
    b29e:	22f0      	movs	r2, #240	; 0xf0
    if(bpp == 3) bpp = 4;
    b2a0:	2604      	movs	r6, #4
            bitmask_init  = 0xF0;
    b2a2:	9212      	str	r2, [sp, #72]	; 0x48
            shades = 16;
    b2a4:	2310      	movs	r3, #16
            bpp_opa_table_p = _lv_bpp4_opa_table;
    b2a6:	4a0b      	ldr	r2, [pc, #44]	; (b2d4 <lv_draw_label+0x680>)
    b2a8:	e75a      	b.n	b160 <lv_draw_label+0x50c>
            bitmask_init  = 0xC0;
    b2aa:	22c0      	movs	r2, #192	; 0xc0
    if(bpp == 3) bpp = 4;
    b2ac:	2602      	movs	r6, #2
            bitmask_init  = 0xC0;
    b2ae:	9212      	str	r2, [sp, #72]	; 0x48
            shades = 4;
    b2b0:	2304      	movs	r3, #4
            bpp_opa_table_p = _lv_bpp2_opa_table;
    b2b2:	4a09      	ldr	r2, [pc, #36]	; (b2d8 <lv_draw_label+0x684>)
    b2b4:	e754      	b.n	b160 <lv_draw_label+0x50c>
    b2b6:	bf00      	nop
    b2b8:	200004c0 	.word	0x200004c0
    b2bc:	200004c4 	.word	0x200004c4
    b2c0:	00043fd2 	.word	0x00043fd2
    b2c4:	2002a050 	.word	0x2002a050
    b2c8:	20025d00 	.word	0x20025d00
    b2cc:	20029f50 	.word	0x20029f50
    b2d0:	00043fe8 	.word	0x00043fe8
    b2d4:	00043fd8 	.word	0x00043fd8
    b2d8:	00043fd4 	.word	0x00043fd4
    b2dc:	990d      	ldr	r1, [sp, #52]	; 0x34
    b2de:	4d85      	ldr	r5, [pc, #532]	; (b4f4 <lv_draw_label+0x8a0>)
    b2e0:	440b      	add	r3, r1
                opa_table[i] = bpp_opa_table_p[i] == LV_OPA_COVER ? opa : ((bpp_opa_table_p[i] * opa) >> 8);
    b2e2:	f811 2b01 	ldrb.w	r2, [r1], #1
    b2e6:	2aff      	cmp	r2, #255	; 0xff
    b2e8:	bf17      	itett	ne
    b2ea:	9f15      	ldrne	r7, [sp, #84]	; 0x54
    b2ec:	9a15      	ldreq	r2, [sp, #84]	; 0x54
    b2ee:	fb12 f207 	smulbbne	r2, r2, r7
    b2f2:	0a12      	lsrne	r2, r2, #8
            for(i = 0; i < shades; i++) {
    b2f4:	428b      	cmp	r3, r1
                opa_table[i] = bpp_opa_table_p[i] == LV_OPA_COVER ? opa : ((bpp_opa_table_p[i] * opa) >> 8);
    b2f6:	f805 2b01 	strb.w	r2, [r5], #1
            for(i = 0; i < shades; i++) {
    b2fa:	d1f2      	bne.n	b2e2 <lv_draw_label+0x68e>
    b2fc:	e73f      	b.n	b17e <lv_draw_label+0x52a>
        bitmask = bitmask_init >> col_bit;
    b2fe:	9b12      	ldr	r3, [sp, #72]	; 0x48
        for(col = col_start; col < col_end; col++) {
    b300:	46be      	mov	lr, r7
        bitmask = bitmask_init >> col_bit;
    b302:	fa23 f205 	lsr.w	r2, r3, r5
        for(col = col_start; col < col_end; col++) {
    b306:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    b308:	f8cd a0a4 	str.w	sl, [sp, #164]	; 0xa4
    b30c:	eb03 090a 	add.w	r9, r3, sl
    b310:	4649      	mov	r1, r9
    b312:	9b11      	ldr	r3, [sp, #68]	; 0x44
    b314:	4573      	cmp	r3, lr
    b316:	dc39      	bgt.n	b38c <lv_draw_label+0x738>
    b318:	9b24      	ldr	r3, [sp, #144]	; 0x90
    b31a:	9a11      	ldr	r2, [sp, #68]	; 0x44
    b31c:	4297      	cmp	r7, r2
    b31e:	bfc8      	it	gt
    b320:	2300      	movgt	r3, #0
    b322:	9313      	str	r3, [sp, #76]	; 0x4c
    b324:	449a      	add	sl, r3
        if(other_mask_cnt) {
    b326:	9b27      	ldr	r3, [sp, #156]	; 0x9c
    b328:	b1b3      	cbz	r3, b358 <lv_draw_label+0x704>
    b32a:	f8bd 30c4 	ldrh.w	r3, [sp, #196]	; 0xc4
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf + mask_p_start, fill_area.x1, fill_area.y2,
    b32e:	f9bd 10c0 	ldrsh.w	r1, [sp, #192]	; 0xc0
    b332:	3301      	adds	r3, #1
    b334:	1a5b      	subs	r3, r3, r1
    b336:	4648      	mov	r0, r9
    b338:	f9bd 20c6 	ldrsh.w	r2, [sp, #198]	; 0xc6
    b33c:	b21b      	sxth	r3, r3
    b33e:	f000 fce9 	bl	bd14 <lv_draw_mask_apply>
            if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
    b342:	b948      	cbnz	r0, b358 <lv_draw_label+0x704>
    b344:	f8bd 10c4 	ldrh.w	r1, [sp, #196]	; 0xc4
    b348:	f8bd 30c0 	ldrh.w	r3, [sp, #192]	; 0xc0
    b34c:	3101      	adds	r1, #1
    b34e:	1ac9      	subs	r1, r1, r3
                _lv_memset_00(mask_buf + mask_p_start, lv_area_get_width(&fill_area));
    b350:	4648      	mov	r0, r9
    b352:	b209      	sxth	r1, r1
    b354:	f00d f917 	bl	18586 <_lv_memset_00>
        if((uint32_t) mask_p + (col_end - col_start) < mask_buf_size) {
    b358:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    b35a:	9a24      	ldr	r2, [sp, #144]	; 0x90
    b35c:	4413      	add	r3, r2
    b35e:	4699      	mov	r9, r3
    b360:	9b29      	ldr	r3, [sp, #164]	; 0xa4
    b362:	4499      	add	r9, r3
    b364:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    b366:	454b      	cmp	r3, r9
    b368:	d92f      	bls.n	b3ca <lv_draw_label+0x776>
            fill_area.y2 ++;
    b36a:	f8bd 30c6 	ldrh.w	r3, [sp, #198]	; 0xc6
    b36e:	3301      	adds	r3, #1
    b370:	f8ad 30c6 	strh.w	r3, [sp, #198]	; 0xc6
        col_bit += col_bit_row_ofs;
    b374:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b376:	441d      	add	r5, r3
        map_p += (col_bit >> 3);
    b378:	9b14      	ldr	r3, [sp, #80]	; 0x50
    b37a:	eb03 03d5 	add.w	r3, r3, r5, lsr #3
    b37e:	9314      	str	r3, [sp, #80]	; 0x50
    for(row = row_start ; row < row_end; row++) {
    b380:	9b10      	ldr	r3, [sp, #64]	; 0x40
        col_bit = col_bit & 0x7;
    b382:	f005 0507 	and.w	r5, r5, #7
    for(row = row_start ; row < row_end; row++) {
    b386:	3301      	adds	r3, #1
    b388:	9310      	str	r3, [sp, #64]	; 0x40
    b38a:	e764      	b.n	b256 <lv_draw_label+0x602>
            letter_px = (*map_p & bitmask) >> (col_bit_max - col_bit);
    b38c:	9b14      	ldr	r3, [sp, #80]	; 0x50
    b38e:	9822      	ldr	r0, [sp, #136]	; 0x88
    b390:	781b      	ldrb	r3, [r3, #0]
    b392:	eba0 0c05 	sub.w	ip, r0, r5
    b396:	4013      	ands	r3, r2
    b398:	fa23 f30c 	lsr.w	r3, r3, ip
            if(letter_px) {
    b39c:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
                mask_buf[mask_p] = bpp_opa_table_p[letter_px];
    b3a0:	bf18      	it	ne
    b3a2:	980d      	ldrne	r0, [sp, #52]	; 0x34
        for(col = col_start; col < col_end; col++) {
    b3a4:	f10e 0e01 	add.w	lr, lr, #1
                mask_buf[mask_p] = bpp_opa_table_p[letter_px];
    b3a8:	bf18      	it	ne
    b3aa:	5cc3      	ldrbne	r3, [r0, r3]
                mask_buf[mask_p] = 0;
    b3ac:	3101      	adds	r1, #1
    b3ae:	f801 3c01 	strb.w	r3, [r1, #-1]
            if(col_bit < col_bit_max) {
    b3b2:	9b22      	ldr	r3, [sp, #136]	; 0x88
    b3b4:	42ab      	cmp	r3, r5
                map_p++;
    b3b6:	bf9f      	itttt	ls
    b3b8:	9b14      	ldrls	r3, [sp, #80]	; 0x50
                col_bit = 0;
    b3ba:	2500      	movls	r5, #0
                map_p++;
    b3bc:	3301      	addls	r3, #1
                bitmask = bitmask_init;
    b3be:	9a12      	ldrls	r2, [sp, #72]	; 0x48
                col_bit += bpp;
    b3c0:	bf86      	itte	hi
    b3c2:	19ad      	addhi	r5, r5, r6
                bitmask = bitmask >> bpp;
    b3c4:	40f2      	lsrhi	r2, r6
                map_p++;
    b3c6:	9314      	strls	r3, [sp, #80]	; 0x50
        for(col = col_start; col < col_end; col++) {
    b3c8:	e7a3      	b.n	b312 <lv_draw_label+0x6be>
            _lv_blend_fill(clip_area, &fill_area,
    b3ca:	9b21      	ldr	r3, [sp, #132]	; 0x84
    b3cc:	f04f 0cff 	mov.w	ip, #255	; 0xff
    b3d0:	9302      	str	r3, [sp, #8]
    b3d2:	2302      	movs	r3, #2
    b3d4:	4640      	mov	r0, r8
    b3d6:	e9cd 3c00 	strd	r3, ip, [sp]
    b3da:	9a16      	ldr	r2, [sp, #88]	; 0x58
    b3dc:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    b3de:	a930      	add	r1, sp, #192	; 0xc0
    b3e0:	f00c f8fc 	bl	175dc <_lv_blend_fill>
            fill_area.y1 = fill_area.y2 + 1;
    b3e4:	f8bd 30c6 	ldrh.w	r3, [sp, #198]	; 0xc6
            mask_p = 0;
    b3e8:	f04f 0a00 	mov.w	sl, #0
            fill_area.y1 = fill_area.y2 + 1;
    b3ec:	3301      	adds	r3, #1
    b3ee:	b21b      	sxth	r3, r3
    b3f0:	f8ad 30c2 	strh.w	r3, [sp, #194]	; 0xc2
            fill_area.y2 = fill_area.y1;
    b3f4:	f8ad 30c6 	strh.w	r3, [sp, #198]	; 0xc6
            mask_p = 0;
    b3f8:	e7bc      	b.n	b374 <lv_draw_label+0x720>
        else if(dsc->flag & LV_TXT_FLAG_RIGHT) {
    b3fa:	071a      	lsls	r2, r3, #28
    b3fc:	f57f addf 	bpl.w	afbe <lv_draw_label+0x36a>
                _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
    b400:	9300      	str	r3, [sp, #0]
    b402:	465a      	mov	r2, fp
    b404:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
    b408:	4638      	mov	r0, r7
    b40a:	f001 fdad 	bl	cf68 <_lv_txt_get_width>
            pos.x += lv_area_get_width(coords) - line_width;
    b40e:	9b06      	ldr	r3, [sp, #24]
    b410:	889b      	ldrh	r3, [r3, #4]
    b412:	441d      	add	r5, r3
    b414:	9b06      	ldr	r3, [sp, #24]
    b416:	3501      	adds	r5, #1
    b418:	881b      	ldrh	r3, [r3, #0]
    b41a:	1aed      	subs	r5, r5, r3
    b41c:	1a2d      	subs	r5, r5, r0
    b41e:	e5cd      	b.n	afbc <lv_draw_label+0x368>
            lv_draw_letter(&pos, mask, font, letter, color, opa, dsc->blend_mode);
    b420:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
    b424:	462a      	mov	r2, r5
            lv_draw_letter(&pos, mask, font, letter, color, opa, dsc->blend_mode);
    b426:	9321      	str	r3, [sp, #132]	; 0x84
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
    b428:	4658      	mov	r0, fp
    b42a:	2300      	movs	r3, #0
    b42c:	a935      	add	r1, sp, #212	; 0xd4
    b42e:	f010 f8f9 	bl	1b624 <lv_font_get_glyph_dsc>
    if(g_ret == false)  {
    b432:	2800      	cmp	r0, #0
    b434:	f43f ae7a 	beq.w	b12c <lv_draw_label+0x4d8>
    if((g.box_h == 0) || (g.box_w == 0)) return;
    b438:	f8bd 30d8 	ldrh.w	r3, [sp, #216]	; 0xd8
    b43c:	2b00      	cmp	r3, #0
    b43e:	f43f ae75 	beq.w	b12c <lv_draw_label+0x4d8>
    b442:	f8bd 20d6 	ldrh.w	r2, [sp, #214]	; 0xd6
    b446:	2a00      	cmp	r2, #0
    b448:	f43f ae70 	beq.w	b12c <lv_draw_label+0x4d8>
    int32_t pos_x = pos_p->x + g.ofs_x;
    b44c:	990c      	ldr	r1, [sp, #48]	; 0x30
    b44e:	f9bd a0da 	ldrsh.w	sl, [sp, #218]	; 0xda
    b452:	448a      	add	sl, r1
    if(pos_x + g.box_w < clip_area->x1 ||
    b454:	f9b8 1000 	ldrsh.w	r1, [r8]
    b458:	4452      	add	r2, sl
    b45a:	428a      	cmp	r2, r1
    b45c:	f6ff ae66 	blt.w	b12c <lv_draw_label+0x4d8>
       pos_x > clip_area->x2 ||
    b460:	f9b8 2004 	ldrsh.w	r2, [r8, #4]
    if(pos_x + g.box_w < clip_area->x1 ||
    b464:	4592      	cmp	sl, r2
    b466:	f73f ae61 	bgt.w	b12c <lv_draw_label+0x4d8>
    int32_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
    b46a:	f9bd 20dc 	ldrsh.w	r2, [sp, #220]	; 0xdc
    b46e:	f9bb 9008 	ldrsh.w	r9, [fp, #8]
    b472:	441a      	add	r2, r3
    b474:	eba9 0902 	sub.w	r9, r9, r2
    b478:	f9bb 200a 	ldrsh.w	r2, [fp, #10]
    b47c:	eba9 0902 	sub.w	r9, r9, r2
    b480:	9a19      	ldr	r2, [sp, #100]	; 0x64
    b482:	4491      	add	r9, r2
       pos_y + g.box_h < clip_area->y1 ||
    b484:	f9b8 2002 	ldrsh.w	r2, [r8, #2]
    b488:	444b      	add	r3, r9
       pos_x > clip_area->x2 ||
    b48a:	4293      	cmp	r3, r2
    b48c:	f6ff ae4e 	blt.w	b12c <lv_draw_label+0x4d8>
       pos_y > clip_area->y2)  {
    b490:	f9b8 3006 	ldrsh.w	r3, [r8, #6]
       pos_y + g.box_h < clip_area->y1 ||
    b494:	4599      	cmp	r9, r3
    b496:	f73f ae49 	bgt.w	b12c <lv_draw_label+0x4d8>
    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
    b49a:	4629      	mov	r1, r5
    b49c:	4658      	mov	r0, fp
    b49e:	f010 f8bf 	bl	1b620 <lv_font_get_glyph_bitmap>
    if(map_p == NULL) {
    b4a2:	2800      	cmp	r0, #0
    b4a4:	f43f ae42 	beq.w	b12c <lv_draw_label+0x4d8>
    if(font_p->subpx) {
    b4a8:	f89b 300c 	ldrb.w	r3, [fp, #12]
    b4ac:	079b      	lsls	r3, r3, #30
    b4ae:	f47f ae3d 	bne.w	b12c <lv_draw_label+0x4d8>
    uint32_t bpp = g->bpp;
    b4b2:	f89d 30de 	ldrb.w	r3, [sp, #222]	; 0xde
        draw_letter_normal(pos_x, pos_y, &g, clip_area, map_p, color, opa, blend_mode);
    b4b6:	fa0f fa8a 	sxth.w	sl, sl
    if(bpp == 3) bpp = 4;
    b4ba:	2b03      	cmp	r3, #3
        draw_letter_normal(pos_x, pos_y, &g, clip_area, map_p, color, opa, blend_mode);
    b4bc:	fa0f f989 	sxth.w	r9, r9
    if(bpp == 3) bpp = 4;
    b4c0:	f43f aeed 	beq.w	b29e <lv_draw_label+0x64a>
    switch(bpp) {
    b4c4:	3b01      	subs	r3, #1
    b4c6:	2b07      	cmp	r3, #7
    b4c8:	f63f ae30 	bhi.w	b12c <lv_draw_label+0x4d8>
    b4cc:	a201      	add	r2, pc, #4	; (adr r2, b4d4 <lv_draw_label+0x880>)
    b4ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    b4d2:	bf00      	nop
    b4d4:	0000b157 	.word	0x0000b157
    b4d8:	0000b2ab 	.word	0x0000b2ab
    b4dc:	0000b12d 	.word	0x0000b12d
    b4e0:	0000b29f 	.word	0x0000b29f
    b4e4:	0000b12d 	.word	0x0000b12d
    b4e8:	0000b12d 	.word	0x0000b12d
    b4ec:	0000b12d 	.word	0x0000b12d
    b4f0:	0000b291 	.word	0x0000b291
    b4f4:	20029f50 	.word	0x20029f50

0000b4f8 <lv_draw_line>:
 * @param clip the line will be drawn only in this area
 * @param dsc pointer to an initialized `lv_draw_line_dsc_t` variable
 */
LV_ATTRIBUTE_FAST_MEM void lv_draw_line(const lv_point_t * point1, const lv_point_t * point2, const lv_area_t * clip,
                                        const lv_draw_line_dsc_t * dsc)
{
    b4f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b4fc:	b0cf      	sub	sp, #316	; 0x13c
    b4fe:	9206      	str	r2, [sp, #24]
    if(dsc->width == 0) return;
    b500:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
{
    b504:	469b      	mov	fp, r3
    b506:	e9cd 0104 	strd	r0, r1, [sp, #16]
    if(dsc->width == 0) return;
    b50a:	2a00      	cmp	r2, #0
    b50c:	f000 80e4 	beq.w	b6d8 <lv_draw_line+0x1e0>
    if(dsc->opa <= LV_OPA_MIN) return;
    b510:	7a9b      	ldrb	r3, [r3, #10]
    b512:	2b02      	cmp	r3, #2
    b514:	f240 80e0 	bls.w	b6d8 <lv_draw_line+0x1e0>

    if(point1->x == point2->x && point1->y == point2->y) return;
    b518:	9b05      	ldr	r3, [sp, #20]
    b51a:	f9b0 1000 	ldrsh.w	r1, [r0]
    b51e:	f9b3 5000 	ldrsh.w	r5, [r3]
    b522:	9b05      	ldr	r3, [sp, #20]
    b524:	42a9      	cmp	r1, r5
    b526:	f9b0 4002 	ldrsh.w	r4, [r0, #2]
    b52a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
    b52e:	d102      	bne.n	b536 <lv_draw_line+0x3e>
    b530:	42a3      	cmp	r3, r4
    b532:	f000 80d1 	beq.w	b6d8 <lv_draw_line+0x1e0>

    lv_area_t clip_line;
    clip_line.x1 = LV_MATH_MIN(point1->x, point2->x) - dsc->width / 2;
    b536:	42a9      	cmp	r1, r5
    b538:	460e      	mov	r6, r1
    b53a:	bfa8      	it	ge
    b53c:	462e      	movge	r6, r5
    clip_line.x2 = LV_MATH_MAX(point1->x, point2->x) + dsc->width / 2;
    b53e:	42a9      	cmp	r1, r5
    b540:	bfb8      	it	lt
    b542:	4629      	movlt	r1, r5
    clip_line.x1 = LV_MATH_MIN(point1->x, point2->x) - dsc->width / 2;
    b544:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
    b548:	42a3      	cmp	r3, r4
    clip_line.x2 = LV_MATH_MAX(point1->x, point2->x) + dsc->width / 2;
    b54a:	eb01 0162 	add.w	r1, r1, r2, asr #1
    b54e:	f8ad 1038 	strh.w	r1, [sp, #56]	; 0x38
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
    b552:	4619      	mov	r1, r3
    b554:	bfa8      	it	ge
    b556:	4621      	movge	r1, r4
    clip_line.y2 = LV_MATH_MAX(point1->y, point2->y) + dsc->width / 2;
    b558:	42a3      	cmp	r3, r4
    b55a:	bfb8      	it	lt
    b55c:	4623      	movlt	r3, r4
    clip_line.x1 = LV_MATH_MIN(point1->x, point2->x) - dsc->width / 2;
    b55e:	1050      	asrs	r0, r2, #1
    b560:	4240      	negs	r0, r0
    b562:	fa06 f680 	sxtah	r6, r6, r0
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
    b566:	fa01 f080 	sxtah	r0, r1, r0

    bool is_common;
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
    b56a:	a90d      	add	r1, sp, #52	; 0x34
    clip_line.y2 = LV_MATH_MAX(point1->y, point2->y) + dsc->width / 2;
    b56c:	eb03 0362 	add.w	r3, r3, r2, asr #1
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
    b570:	f8ad 0036 	strh.w	r0, [sp, #54]	; 0x36
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
    b574:	9a06      	ldr	r2, [sp, #24]
    b576:	4608      	mov	r0, r1
    clip_line.x1 = LV_MATH_MIN(point1->x, point2->x) - dsc->width / 2;
    b578:	f8ad 6034 	strh.w	r6, [sp, #52]	; 0x34
    clip_line.y2 = LV_MATH_MAX(point1->y, point2->y) + dsc->width / 2;
    b57c:	f8ad 303a 	strh.w	r3, [sp, #58]	; 0x3a
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
    b580:	f00f fb8c 	bl	1ac9c <_lv_area_intersect>
    if(!is_common) return;
    b584:	2800      	cmp	r0, #0
    b586:	f000 80a7 	beq.w	b6d8 <lv_draw_line+0x1e0>

    if(point1->y == point2->y) draw_line_hor(point1, point2, &clip_line, dsc);
    b58a:	9b04      	ldr	r3, [sp, #16]
    b58c:	f9b3 9002 	ldrsh.w	r9, [r3, #2]
    b590:	9b05      	ldr	r3, [sp, #20]
    b592:	f9b3 8002 	ldrsh.w	r8, [r3, #2]
    b596:	45c1      	cmp	r9, r8
    b598:	f040 813a 	bne.w	b810 <lv_draw_line+0x318>

LV_ATTRIBUTE_FAST_MEM static void draw_line_hor(const lv_point_t * point1, const lv_point_t * point2,
                                                const lv_area_t * clip,
                                                const lv_draw_line_dsc_t * dsc)
{
    lv_opa_t opa = dsc->opa;
    b59c:	f89b 500a 	ldrb.w	r5, [fp, #10]

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
    b5a0:	f7ff f83e 	bl	a620 <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    b5a4:	f00f fa8e 	bl	1aac4 <lv_disp_get_buf>

    const lv_area_t * disp_area = &vdb->area;

    int32_t w = dsc->width - 1;
    b5a8:	f9bb 6004 	ldrsh.w	r6, [fp, #4]
    int32_t w_half0 = w >> 1;
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/

    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
    b5ac:	f9bb 4008 	ldrsh.w	r4, [fp, #8]
    int32_t w = dsc->width - 1;
    b5b0:	1e73      	subs	r3, r6, #1
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
    b5b2:	f003 0601 	and.w	r6, r3, #1
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    b5b6:	4607      	mov	r7, r0
    int32_t w_half0 = w >> 1;
    b5b8:	ea4f 0863 	mov.w	r8, r3, asr #1
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
    b5bc:	eb06 0663 	add.w	r6, r6, r3, asr #1
    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
    b5c0:	b124      	cbz	r4, b5cc <lv_draw_line+0xd4>
    b5c2:	f9bb 4006 	ldrsh.w	r4, [fp, #6]
    b5c6:	3c00      	subs	r4, #0
    b5c8:	bf18      	it	ne
    b5ca:	2401      	movne	r4, #1

    bool simple_mode = true;
    if(lv_draw_mask_get_cnt()) simple_mode = false;
    b5cc:	f000 fbea 	bl	bda4 <lv_draw_mask_get_cnt>
    b5d0:	2800      	cmp	r0, #0
    b5d2:	f040 8084 	bne.w	b6de <lv_draw_line+0x1e6>
    else if(dashed) simple_mode = false;
    b5d6:	f084 0201 	eor.w	r2, r4, #1

    lv_area_t draw_area;
    draw_area.x1 = LV_MATH_MIN(point1->x, point2->x);
    b5da:	9b05      	ldr	r3, [sp, #20]
    b5dc:	9904      	ldr	r1, [sp, #16]
    b5de:	f9b3 3000 	ldrsh.w	r3, [r3]
    b5e2:	f9b1 1000 	ldrsh.w	r1, [r1]
    b5e6:	4618      	mov	r0, r3
    b5e8:	428b      	cmp	r3, r1
    b5ea:	bfa8      	it	ge
    b5ec:	4608      	movge	r0, r1
    draw_area.x2 = LV_MATH_MAX(point1->x, point2->x)  - 1;
    b5ee:	428b      	cmp	r3, r1
    b5f0:	bfb8      	it	lt
    b5f2:	460b      	movlt	r3, r1
    b5f4:	3b01      	subs	r3, #1
    b5f6:	f8ad 30a8 	strh.w	r3, [sp, #168]	; 0xa8
    draw_area.y1 = point1->y - w_half1;
    b5fa:	9b04      	ldr	r3, [sp, #16]
    draw_area.x1 = LV_MATH_MIN(point1->x, point2->x);
    b5fc:	f8ad 00a4 	strh.w	r0, [sp, #164]	; 0xa4
    draw_area.y1 = point1->y - w_half1;
    b600:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
    b604:	1b9e      	subs	r6, r3, r6
    draw_area.y2 = point1->y + w_half0;
    b606:	4498      	add	r8, r3
    draw_area.y1 = point1->y - w_half1;
    b608:	f8ad 60a6 	strh.w	r6, [sp, #166]	; 0xa6
    draw_area.y2 = point1->y + w_half0;
    b60c:	f8ad 80aa 	strh.w	r8, [sp, #170]	; 0xaa

    /*If there is no mask then simply draw a rectangle*/
    if(simple_mode) {
    b610:	2a00      	cmp	r2, #0
    b612:	d066      	beq.n	b6e2 <lv_draw_line+0x1ea>
        _lv_blend_fill(clip, &draw_area,
                       dsc->color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa,
                       dsc->blend_mode);
    b614:	f89b 300b 	ldrb.w	r3, [fp, #11]
        _lv_blend_fill(clip, &draw_area,
    b618:	f003 0303 	and.w	r3, r3, #3
    b61c:	e9cd 5301 	strd	r5, r3, [sp, #4]
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
    draw_area.y2 = LV_MATH_MAX(point1->y, point2->y) - 1;

    /*If there is no mask then simply draw a rectangle*/
    if(simple_mode) {
        _lv_blend_fill(clip, &draw_area,
    b620:	2301      	movs	r3, #1
    b622:	f8db 2000 	ldr.w	r2, [fp]
    b626:	9300      	str	r3, [sp, #0]
    b628:	a929      	add	r1, sp, #164	; 0xa4
    b62a:	2300      	movs	r3, #0
    b62c:	a80d      	add	r0, sp, #52	; 0x34
    b62e:	f00b ffd5 	bl	175dc <_lv_blend_fill>
    if(dsc->round_end || dsc->round_start) {
    b632:	f89b 300b 	ldrb.w	r3, [fp, #11]
    b636:	f013 0f0c 	tst.w	r3, #12
    b63a:	d04d      	beq.n	b6d8 <lv_draw_line+0x1e0>
        lv_draw_rect_dsc_init(&cir_dsc);
    b63c:	a834      	add	r0, sp, #208	; 0xd0
    b63e:	f000 fc6d 	bl	bf1c <lv_draw_rect_dsc_init>
        cir_dsc.bg_color = dsc->color;
    b642:	f8db 3000 	ldr.w	r3, [fp]
        int32_t r = (dsc->width >> 1);
    b646:	f9bb 5004 	ldrsh.w	r5, [fp, #4]
        cir_dsc.bg_color = dsc->color;
    b64a:	9335      	str	r3, [sp, #212]	; 0xd4
        cir_dsc.radius = LV_RADIUS_CIRCLE;
    b64c:	f647 73ff 	movw	r3, #32767	; 0x7fff
        int32_t r = (dsc->width >> 1);
    b650:	106c      	asrs	r4, r5, #1
    b652:	43ed      	mvns	r5, r5
        cir_dsc.radius = LV_RADIUS_CIRCLE;
    b654:	f8ad 30d0 	strh.w	r3, [sp, #208]	; 0xd0
        cir_dsc.bg_opa = dsc->opa;
    b658:	f89b 300a 	ldrb.w	r3, [fp, #10]
    b65c:	f005 0501 	and.w	r5, r5, #1
    b660:	f88d 30e2 	strb.w	r3, [sp, #226]	; 0xe2
        if(dsc->round_start) {
    b664:	f89b 300b 	ldrb.w	r3, [fp, #11]
    b668:	075a      	lsls	r2, r3, #29
    b66a:	d518      	bpl.n	b69e <lv_draw_line+0x1a6>
            cir_area.x1 = point1->x - r;
    b66c:	9b04      	ldr	r3, [sp, #16]
            lv_draw_rect(&cir_area, clip, &cir_dsc);
    b66e:	a829      	add	r0, sp, #164	; 0xa4
            cir_area.x1 = point1->x - r;
    b670:	f9b3 2000 	ldrsh.w	r2, [r3]
    b674:	1b13      	subs	r3, r2, r4
    b676:	f8ad 30a4 	strh.w	r3, [sp, #164]	; 0xa4
            cir_area.y1 = point1->y - r;
    b67a:	9b04      	ldr	r3, [sp, #16]
            cir_area.x2 = point1->x + r - r_corr;
    b67c:	4422      	add	r2, r4
            cir_area.y1 = point1->y - r;
    b67e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
            cir_area.x2 = point1->x + r - r_corr;
    b682:	1b52      	subs	r2, r2, r5
            cir_area.y1 = point1->y - r;
    b684:	1b19      	subs	r1, r3, r4
            cir_area.y2 = point1->y + r - r_corr ;
    b686:	4423      	add	r3, r4
            cir_area.y1 = point1->y - r;
    b688:	f8ad 10a6 	strh.w	r1, [sp, #166]	; 0xa6
            cir_area.x2 = point1->x + r - r_corr;
    b68c:	f8ad 20a8 	strh.w	r2, [sp, #168]	; 0xa8
            cir_area.y2 = point1->y + r - r_corr ;
    b690:	1b5b      	subs	r3, r3, r5
            lv_draw_rect(&cir_area, clip, &cir_dsc);
    b692:	9906      	ldr	r1, [sp, #24]
    b694:	aa34      	add	r2, sp, #208	; 0xd0
            cir_area.y2 = point1->y + r - r_corr ;
    b696:	f8ad 30aa 	strh.w	r3, [sp, #170]	; 0xaa
            lv_draw_rect(&cir_area, clip, &cir_dsc);
    b69a:	f00d fcac 	bl	18ff6 <lv_draw_rect>
        if(dsc->round_end) {
    b69e:	f89b 300b 	ldrb.w	r3, [fp, #11]
    b6a2:	071b      	lsls	r3, r3, #28
    b6a4:	d518      	bpl.n	b6d8 <lv_draw_line+0x1e0>
            cir_area.x1 = point2->x - r;
    b6a6:	9b05      	ldr	r3, [sp, #20]
            lv_draw_rect(&cir_area, clip, &cir_dsc);
    b6a8:	a829      	add	r0, sp, #164	; 0xa4
            cir_area.x1 = point2->x - r;
    b6aa:	f9b3 3000 	ldrsh.w	r3, [r3]
    b6ae:	1b1a      	subs	r2, r3, r4
    b6b0:	f8ad 20a4 	strh.w	r2, [sp, #164]	; 0xa4
            cir_area.y1 = point2->y - r;
    b6b4:	9a05      	ldr	r2, [sp, #20]
            cir_area.x2 = point2->x + r - r_corr;
    b6b6:	4423      	add	r3, r4
            cir_area.y1 = point2->y - r;
    b6b8:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
            cir_area.x2 = point2->x + r - r_corr;
    b6bc:	1b5b      	subs	r3, r3, r5
            cir_area.y1 = point2->y - r;
    b6be:	1b11      	subs	r1, r2, r4
            cir_area.y2 = point2->y + r - r_corr ;
    b6c0:	4414      	add	r4, r2
            cir_area.y1 = point2->y - r;
    b6c2:	f8ad 10a6 	strh.w	r1, [sp, #166]	; 0xa6
            cir_area.y2 = point2->y + r - r_corr ;
    b6c6:	1b64      	subs	r4, r4, r5
            lv_draw_rect(&cir_area, clip, &cir_dsc);
    b6c8:	9906      	ldr	r1, [sp, #24]
    b6ca:	aa34      	add	r2, sp, #208	; 0xd0
            cir_area.x2 = point2->x + r - r_corr;
    b6cc:	f8ad 30a8 	strh.w	r3, [sp, #168]	; 0xa8
            cir_area.y2 = point2->y + r - r_corr ;
    b6d0:	f8ad 40aa 	strh.w	r4, [sp, #170]	; 0xaa
            lv_draw_rect(&cir_area, clip, &cir_dsc);
    b6d4:	f00d fc8f 	bl	18ff6 <lv_draw_rect>
}
    b6d8:	b04f      	add	sp, #316	; 0x13c
    b6da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(lv_draw_mask_get_cnt()) simple_mode = false;
    b6de:	2200      	movs	r2, #0
    b6e0:	e77b      	b.n	b5da <lv_draw_line+0xe2>
        is_common = _lv_area_intersect(&draw_area, clip, &draw_area);
    b6e2:	aa29      	add	r2, sp, #164	; 0xa4
    b6e4:	4610      	mov	r0, r2
    b6e6:	a90d      	add	r1, sp, #52	; 0x34
    b6e8:	f00f fad8 	bl	1ac9c <_lv_area_intersect>
        if(!is_common) return;
    b6ec:	2800      	cmp	r0, #0
    b6ee:	d0a0      	beq.n	b632 <lv_draw_line+0x13a>
        draw_area.y1 -= disp_area->y1;
    b6f0:	f9b7 6012 	ldrsh.w	r6, [r7, #18]
    b6f4:	f9bd 20a6 	ldrsh.w	r2, [sp, #166]	; 0xa6
        draw_area.x1 -= disp_area->x1;
    b6f8:	f9b7 8010 	ldrsh.w	r8, [r7, #16]
        draw_area.y1 -= disp_area->y1;
    b6fc:	1b91      	subs	r1, r2, r6
    b6fe:	f8ad 10a6 	strh.w	r1, [sp, #166]	; 0xa6
        draw_area.x2 -= disp_area->x1;
    b702:	f9bd 10a8 	ldrsh.w	r1, [sp, #168]	; 0xa8
        draw_area.x1 -= disp_area->x1;
    b706:	f9bd 00a4 	ldrsh.w	r0, [sp, #164]	; 0xa4
        draw_area.x2 -= disp_area->x1;
    b70a:	eba1 0508 	sub.w	r5, r1, r8
    b70e:	f8ad 50a8 	strh.w	r5, [sp, #168]	; 0xa8
        draw_area.y2 -= disp_area->y1;
    b712:	f8bd 50aa 	ldrh.w	r5, [sp, #170]	; 0xaa
        draw_area.x1 -= disp_area->x1;
    b716:	eba0 0308 	sub.w	r3, r0, r8
        draw_area.y2 -= disp_area->y1;
    b71a:	1bad      	subs	r5, r5, r6
    b71c:	f8ad 50aa 	strh.w	r5, [sp, #170]	; 0xaa
    b720:	1c4d      	adds	r5, r1, #1
        draw_area.x1 -= disp_area->x1;
    b722:	b21b      	sxth	r3, r3
    b724:	1a2d      	subs	r5, r5, r0
    b726:	f8ad 30a4 	strh.w	r3, [sp, #164]	; 0xa4
    b72a:	b22d      	sxth	r5, r5
        fill_area.x1 = draw_area.x1 + disp_area->x1;
    b72c:	f8ad 00d0 	strh.w	r0, [sp, #208]	; 0xd0
        fill_area.x2 = draw_area.x2 + disp_area->x1;
    b730:	f8ad 10d4 	strh.w	r1, [sp, #212]	; 0xd4
        fill_area.y1 = draw_area.y1 + disp_area->y1;
    b734:	f8ad 20d2 	strh.w	r2, [sp, #210]	; 0xd2
        fill_area.y2 = fill_area.y1;
    b738:	f8ad 20d6 	strh.w	r2, [sp, #214]	; 0xd6
        if(dashed) {
    b73c:	b1dc      	cbz	r4, b776 <lv_draw_line+0x27e>
            dash_start = (vdb->area.x1 + draw_area.x1) % (dsc->dash_gap + dsc->dash_width);
    b73e:	4498      	add	r8, r3
    b740:	f9bb 2006 	ldrsh.w	r2, [fp, #6]
    b744:	f9bb 3008 	ldrsh.w	r3, [fp, #8]
    b748:	4413      	add	r3, r2
    b74a:	fb98 f2f3 	sdiv	r2, r8, r3
    b74e:	fb03 8812 	mls	r8, r3, r2, r8
    b752:	fa0f f888 	sxth.w	r8, r8
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
    b756:	4628      	mov	r0, r5
    b758:	f001 f9d0 	bl	cafc <_lv_mem_buf_get>
                    for(i = 0; i < draw_area_w; i++, dash_cnt++) {
    b75c:	f04f 0a00 	mov.w	sl, #0
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
    b760:	4606      	mov	r6, r0
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
    b762:	f9bd 90a6 	ldrsh.w	r9, [sp, #166]	; 0xa6
    b766:	f9bd 30aa 	ldrsh.w	r3, [sp, #170]	; 0xaa
    b76a:	4599      	cmp	r9, r3
    b76c:	dd05      	ble.n	b77a <lv_draw_line+0x282>
        _lv_mem_buf_release(mask_buf);
    b76e:	4630      	mov	r0, r6
                           LV_BLEND_MODE_NORMAL);

            fill_area.y1++;
            fill_area.y2++;
        }
        _lv_mem_buf_release(mask_buf);
    b770:	f001 fa26 	bl	cbc0 <_lv_mem_buf_release>
    b774:	e75d      	b.n	b632 <lv_draw_line+0x13a>
        lv_style_int_t dash_start = 0;
    b776:	46a0      	mov	r8, r4
    b778:	e7ed      	b.n	b756 <lv_draw_line+0x25e>
            _lv_memset_ff(mask_buf, draw_area_w);
    b77a:	4629      	mov	r1, r5
    b77c:	4630      	mov	r0, r6
    b77e:	f00c ff0a 	bl	18596 <_lv_memset_ff>
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
    b782:	f8bd 30a4 	ldrh.w	r3, [sp, #164]	; 0xa4
    b786:	8a7a      	ldrh	r2, [r7, #18]
    b788:	8a39      	ldrh	r1, [r7, #16]
    b78a:	444a      	add	r2, r9
    b78c:	4419      	add	r1, r3
    b78e:	b212      	sxth	r2, r2
    b790:	462b      	mov	r3, r5
    b792:	4630      	mov	r0, r6
    b794:	b209      	sxth	r1, r1
    b796:	f000 fabd 	bl	bd14 <lv_draw_mask_apply>
    b79a:	4602      	mov	r2, r0
            if(dashed) {
    b79c:	b18c      	cbz	r4, b7c2 <lv_draw_line+0x2ca>
                if(mask_res != LV_DRAW_MASK_RES_TRANSP) {
    b79e:	b180      	cbz	r0, b7c2 <lv_draw_line+0x2ca>
                    lv_style_int_t dash_cnt = dash_start;
    b7a0:	4641      	mov	r1, r8
                    for(i = 0; i < draw_area_w; i++, dash_cnt++) {
    b7a2:	2300      	movs	r3, #0
    b7a4:	e00a      	b.n	b7bc <lv_draw_line+0x2c4>
                        if(dash_cnt <= dsc->dash_width) {
    b7a6:	f9bb 2006 	ldrsh.w	r2, [fp, #6]
    b7aa:	428a      	cmp	r2, r1
    b7ac:	db26      	blt.n	b7fc <lv_draw_line+0x304>
                            i += diff;
    b7ae:	4413      	add	r3, r2
    b7b0:	1a5b      	subs	r3, r3, r1
    b7b2:	b21b      	sxth	r3, r3
                    for(i = 0; i < draw_area_w; i++, dash_cnt++) {
    b7b4:	3301      	adds	r3, #1
    b7b6:	3201      	adds	r2, #1
    b7b8:	b21b      	sxth	r3, r3
    b7ba:	b211      	sxth	r1, r2
    b7bc:	429d      	cmp	r5, r3
    b7be:	dcf2      	bgt.n	b7a6 <lv_draw_line+0x2ae>
                    mask_res = LV_DRAW_MASK_RES_CHANGED;
    b7c0:	2202      	movs	r2, #2
                           dsc->blend_mode);
    b7c2:	f89b 300b 	ldrb.w	r3, [fp, #11]
            _lv_blend_fill(clip, &fill_area,
    b7c6:	a934      	add	r1, sp, #208	; 0xd0
    b7c8:	f003 0303 	and.w	r3, r3, #3
    b7cc:	9302      	str	r3, [sp, #8]
    b7ce:	f89b 300a 	ldrb.w	r3, [fp, #10]
    b7d2:	a80d      	add	r0, sp, #52	; 0x34
    b7d4:	e9cd 2300 	strd	r2, r3, [sp]
    b7d8:	4633      	mov	r3, r6
    b7da:	f8db 2000 	ldr.w	r2, [fp]
    b7de:	f00b fefd 	bl	175dc <_lv_blend_fill>
            fill_area.y1++;
    b7e2:	f8bd 30d2 	ldrh.w	r3, [sp, #210]	; 0xd2
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
    b7e6:	f109 0901 	add.w	r9, r9, #1
            fill_area.y1++;
    b7ea:	3301      	adds	r3, #1
    b7ec:	f8ad 30d2 	strh.w	r3, [sp, #210]	; 0xd2
            fill_area.y2++;
    b7f0:	f8bd 30d6 	ldrh.w	r3, [sp, #214]	; 0xd6
    b7f4:	3301      	adds	r3, #1
    b7f6:	f8ad 30d6 	strh.w	r3, [sp, #214]	; 0xd6
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
    b7fa:	e7b4      	b.n	b766 <lv_draw_line+0x26e>
                        else if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
    b7fc:	f9bb 0008 	ldrsh.w	r0, [fp, #8]
    b800:	4402      	add	r2, r0
    b802:	4291      	cmp	r1, r2
                            mask_buf[i] = 0x00;
    b804:	bfb6      	itet	lt
    b806:	460a      	movlt	r2, r1
                            dash_cnt = 0;
    b808:	2200      	movge	r2, #0
                            mask_buf[i] = 0x00;
    b80a:	f806 a003 	strblt.w	sl, [r6, r3]
    b80e:	e7d1      	b.n	b7b4 <lv_draw_line+0x2bc>
    else if(point1->x == point2->x) draw_line_ver(point1, point2, &clip_line, dsc);
    b810:	9b04      	ldr	r3, [sp, #16]
    b812:	f9b3 7000 	ldrsh.w	r7, [r3]
    b816:	9b05      	ldr	r3, [sp, #20]
    b818:	f9b3 6000 	ldrsh.w	r6, [r3]
    b81c:	42b7      	cmp	r7, r6
    b81e:	f040 80c6 	bne.w	b9ae <lv_draw_line+0x4b6>
    lv_opa_t opa = dsc->opa;
    b822:	f89b 400a 	ldrb.w	r4, [fp, #10]
    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
    b826:	f7fe fefb 	bl	a620 <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    b82a:	f00f f94b 	bl	1aac4 <lv_disp_get_buf>
    int32_t w = dsc->width - 1;
    b82e:	f9bb 6004 	ldrsh.w	r6, [fp, #4]
    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
    b832:	f9bb 5008 	ldrsh.w	r5, [fp, #8]
    int32_t w = dsc->width - 1;
    b836:	1e73      	subs	r3, r6, #1
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
    b838:	f003 0601 	and.w	r6, r3, #1
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    b83c:	4607      	mov	r7, r0
    int32_t w_half0 = w >> 1;
    b83e:	ea4f 0863 	mov.w	r8, r3, asr #1
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
    b842:	eb06 0663 	add.w	r6, r6, r3, asr #1
    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
    b846:	b125      	cbz	r5, b852 <lv_draw_line+0x35a>
    b848:	f9bb 5006 	ldrsh.w	r5, [fp, #6]
    b84c:	3d00      	subs	r5, #0
    b84e:	bf18      	it	ne
    b850:	2501      	movne	r5, #1
    if(lv_draw_mask_get_cnt()) simple_mode = false;
    b852:	f000 faa7 	bl	bda4 <lv_draw_mask_get_cnt>
    b856:	bb20      	cbnz	r0, b8a2 <lv_draw_line+0x3aa>
    else if(dashed) simple_mode = false;
    b858:	f085 0201 	eor.w	r2, r5, #1
    draw_area.x1 = point1->x - w_half1;
    b85c:	9b04      	ldr	r3, [sp, #16]
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
    b85e:	9904      	ldr	r1, [sp, #16]
    draw_area.x1 = point1->x - w_half1;
    b860:	f9b3 3000 	ldrsh.w	r3, [r3]
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
    b864:	f9b1 1002 	ldrsh.w	r1, [r1, #2]
    draw_area.x1 = point1->x - w_half1;
    b868:	1b9e      	subs	r6, r3, r6
    draw_area.x2 = point1->x + w_half0;
    b86a:	4443      	add	r3, r8
    b86c:	f8ad 30a8 	strh.w	r3, [sp, #168]	; 0xa8
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
    b870:	9b05      	ldr	r3, [sp, #20]
    draw_area.x1 = point1->x - w_half1;
    b872:	f8ad 60a4 	strh.w	r6, [sp, #164]	; 0xa4
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
    b876:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
    b87a:	428b      	cmp	r3, r1
    b87c:	4618      	mov	r0, r3
    b87e:	bfa8      	it	ge
    b880:	4608      	movge	r0, r1
    draw_area.y2 = LV_MATH_MAX(point1->y, point2->y) - 1;
    b882:	428b      	cmp	r3, r1
    b884:	bfb8      	it	lt
    b886:	460b      	movlt	r3, r1
    b888:	3b01      	subs	r3, #1
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
    b88a:	f8ad 00a6 	strh.w	r0, [sp, #166]	; 0xa6
    draw_area.y2 = LV_MATH_MAX(point1->y, point2->y) - 1;
    b88e:	f8ad 30aa 	strh.w	r3, [sp, #170]	; 0xaa
    if(simple_mode) {
    b892:	b142      	cbz	r2, b8a6 <lv_draw_line+0x3ae>
                       dsc->blend_mode);
    b894:	f89b 300b 	ldrb.w	r3, [fp, #11]
        _lv_blend_fill(clip, &draw_area,
    b898:	f003 0303 	and.w	r3, r3, #3
    b89c:	e9cd 4301 	strd	r4, r3, [sp, #4]
    b8a0:	e6be      	b.n	b620 <lv_draw_line+0x128>
    if(lv_draw_mask_get_cnt()) simple_mode = false;
    b8a2:	2200      	movs	r2, #0
    b8a4:	e7da      	b.n	b85c <lv_draw_line+0x364>
        is_common = _lv_area_intersect(&draw_area, clip, &draw_area);
    b8a6:	aa29      	add	r2, sp, #164	; 0xa4
    b8a8:	4610      	mov	r0, r2
    b8aa:	a90d      	add	r1, sp, #52	; 0x34
    b8ac:	f00f f9f6 	bl	1ac9c <_lv_area_intersect>
        if(!is_common) return;
    b8b0:	2800      	cmp	r0, #0
    b8b2:	f43f aebe 	beq.w	b632 <lv_draw_line+0x13a>
        draw_area.x1 -= vdb->area.x1;
    b8b6:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
    b8ba:	f9bd 00a4 	ldrsh.w	r0, [sp, #164]	; 0xa4
        draw_area.y1 -= vdb->area.y1;
    b8be:	f9b7 4012 	ldrsh.w	r4, [r7, #18]
        draw_area.x1 -= vdb->area.x1;
    b8c2:	1ac2      	subs	r2, r0, r3
    b8c4:	f8ad 20a4 	strh.w	r2, [sp, #164]	; 0xa4
        draw_area.y1 -= vdb->area.y1;
    b8c8:	f9bd 20a6 	ldrsh.w	r2, [sp, #166]	; 0xa6
        fill_area.x1 = draw_area.x1 + disp_area->x1;
    b8cc:	f8ad 00d0 	strh.w	r0, [sp, #208]	; 0xd0
        draw_area.y1 -= vdb->area.y1;
    b8d0:	1b11      	subs	r1, r2, r4
    b8d2:	f8ad 10a6 	strh.w	r1, [sp, #166]	; 0xa6
        draw_area.x2 -= vdb->area.x1;
    b8d6:	f9bd 10a8 	ldrsh.w	r1, [sp, #168]	; 0xa8
        fill_area.y1 = draw_area.y1 + disp_area->y1;
    b8da:	f8ad 20d2 	strh.w	r2, [sp, #210]	; 0xd2
        draw_area.x2 -= vdb->area.x1;
    b8de:	1acb      	subs	r3, r1, r3
    b8e0:	f101 0801 	add.w	r8, r1, #1
    b8e4:	f8ad 30a8 	strh.w	r3, [sp, #168]	; 0xa8
    b8e8:	eba8 0800 	sub.w	r8, r8, r0
        draw_area.y2 -= vdb->area.y1;
    b8ec:	f8bd 30aa 	ldrh.w	r3, [sp, #170]	; 0xaa
    b8f0:	fa0f f888 	sxth.w	r8, r8
    b8f4:	1b1b      	subs	r3, r3, r4
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
    b8f6:	4640      	mov	r0, r8
        draw_area.y2 -= vdb->area.y1;
    b8f8:	f8ad 30aa 	strh.w	r3, [sp, #170]	; 0xaa
        fill_area.x2 = draw_area.x2 + disp_area->x1;
    b8fc:	f8ad 10d4 	strh.w	r1, [sp, #212]	; 0xd4
        fill_area.y2 = fill_area.y1;
    b900:	f8ad 20d6 	strh.w	r2, [sp, #214]	; 0xd6
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
    b904:	f001 f8fa 	bl	cafc <_lv_mem_buf_get>
    b908:	f9bd 60a6 	ldrsh.w	r6, [sp, #166]	; 0xa6
    b90c:	4681      	mov	r9, r0
        if(dashed) {
    b90e:	b1a5      	cbz	r5, b93a <lv_draw_line+0x442>
            dash_start = (vdb->area.y1 + draw_area.y1) % (dsc->dash_gap + dsc->dash_width);
    b910:	f9bb 4006 	ldrsh.w	r4, [fp, #6]
    b914:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
    b918:	f9bb 3008 	ldrsh.w	r3, [fp, #8]
    b91c:	4432      	add	r2, r6
    b91e:	4423      	add	r3, r4
    b920:	fb92 f4f3 	sdiv	r4, r2, r3
    b924:	fb03 2414 	mls	r4, r3, r4, r2
    b928:	b224      	sxth	r4, r4
            _lv_blend_fill(clip, &fill_area,
    b92a:	f04f 0a00 	mov.w	sl, #0
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
    b92e:	f9bd 30aa 	ldrsh.w	r3, [sp, #170]	; 0xaa
    b932:	429e      	cmp	r6, r3
    b934:	dd03      	ble.n	b93e <lv_draw_line+0x446>
        _lv_mem_buf_release(mask_buf);
    b936:	4648      	mov	r0, r9
    b938:	e71a      	b.n	b770 <lv_draw_line+0x278>
        lv_style_int_t dash_start = 0;
    b93a:	462c      	mov	r4, r5
    b93c:	e7f5      	b.n	b92a <lv_draw_line+0x432>
            _lv_memset_ff(mask_buf, draw_area_w);
    b93e:	4641      	mov	r1, r8
    b940:	4648      	mov	r0, r9
    b942:	f00c fe28 	bl	18596 <_lv_memset_ff>
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
    b946:	f8bd 30a4 	ldrh.w	r3, [sp, #164]	; 0xa4
    b94a:	8a7a      	ldrh	r2, [r7, #18]
    b94c:	8a39      	ldrh	r1, [r7, #16]
    b94e:	4432      	add	r2, r6
    b950:	4419      	add	r1, r3
    b952:	4648      	mov	r0, r9
    b954:	4643      	mov	r3, r8
    b956:	b212      	sxth	r2, r2
    b958:	b209      	sxth	r1, r1
    b95a:	f000 f9db 	bl	bd14 <lv_draw_mask_apply>
            if(dashed) {
    b95e:	b16d      	cbz	r5, b97c <lv_draw_line+0x484>
                if(mask_res != LV_DRAW_MASK_RES_TRANSP) {
    b960:	b150      	cbz	r0, b978 <lv_draw_line+0x480>
                    if(dash_cnt > dsc->dash_width) {
    b962:	f9bb 2006 	ldrsh.w	r2, [fp, #6]
                    if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
    b966:	f9bb 3008 	ldrsh.w	r3, [fp, #8]
                        mask_res = LV_DRAW_MASK_RES_TRANSP;
    b96a:	42a2      	cmp	r2, r4
    b96c:	bfb8      	it	lt
    b96e:	2000      	movlt	r0, #0
                    if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
    b970:	4413      	add	r3, r2
                        dash_cnt = 0;
    b972:	429c      	cmp	r4, r3
    b974:	bfa8      	it	ge
    b976:	2400      	movge	r4, #0
                dash_cnt ++;
    b978:	3401      	adds	r4, #1
    b97a:	b224      	sxth	r4, r4
            _lv_blend_fill(clip, &fill_area,
    b97c:	f89b 300a 	ldrb.w	r3, [fp, #10]
    b980:	f8db 2000 	ldr.w	r2, [fp]
    b984:	e9cd 0300 	strd	r0, r3, [sp]
    b988:	f8cd a008 	str.w	sl, [sp, #8]
    b98c:	464b      	mov	r3, r9
    b98e:	a934      	add	r1, sp, #208	; 0xd0
    b990:	a80d      	add	r0, sp, #52	; 0x34
    b992:	f00b fe23 	bl	175dc <_lv_blend_fill>
            fill_area.y1++;
    b996:	f8bd 30d2 	ldrh.w	r3, [sp, #210]	; 0xd2
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
    b99a:	3601      	adds	r6, #1
            fill_area.y1++;
    b99c:	3301      	adds	r3, #1
    b99e:	f8ad 30d2 	strh.w	r3, [sp, #210]	; 0xd2
            fill_area.y2++;
    b9a2:	f8bd 30d6 	ldrh.w	r3, [sp, #214]	; 0xd6
    b9a6:	3301      	adds	r3, #1
    b9a8:	f8ad 30d6 	strh.w	r3, [sp, #214]	; 0xd6
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
    b9ac:	e7bf      	b.n	b92e <lv_draw_line+0x436>
                                                 const lv_draw_line_dsc_t * dsc)
{
    /*Keep the great y in p1*/
    lv_point_t p1;
    lv_point_t p2;
    if(point1->y < point2->y) {
    b9ae:	45c1      	cmp	r9, r8
    b9b0:	db05      	blt.n	b9be <lv_draw_line+0x4c6>
    b9b2:	464b      	mov	r3, r9
    b9b4:	46c1      	mov	r9, r8
    b9b6:	4698      	mov	r8, r3
    b9b8:	463b      	mov	r3, r7
    b9ba:	4637      	mov	r7, r6
    b9bc:	461e      	mov	r6, r3
        p2.y = point1->y;
        p1.x = point2->x;
        p2.x = point1->x;
    }

    int32_t xdiff = p2.x - p1.x;
    b9be:	1bf3      	subs	r3, r6, r7
    int32_t ydiff = p2.y - p1.y;
    b9c0:	eba8 0a09 	sub.w	sl, r8, r9
    bool flat = LV_MATH_ABS(xdiff) > LV_MATH_ABS(ydiff) ? true : false;
    b9c4:	2b00      	cmp	r3, #0
    int32_t xdiff = p2.x - p1.x;
    b9c6:	9307      	str	r3, [sp, #28]
    bool flat = LV_MATH_ABS(xdiff) > LV_MATH_ABS(ydiff) ? true : false;
    b9c8:	bfb8      	it	lt
    b9ca:	425b      	neglt	r3, r3
    b9cc:	f1ba 0f00 	cmp.w	sl, #0
    b9d0:	bfb8      	it	lt
    b9d2:	f1ca 0a00 	rsblt	sl, sl, #0
        181,
    };

    int32_t w = dsc->width;
    int32_t wcorr_i = 0;
    if(flat) wcorr_i = (LV_MATH_ABS(ydiff) << 5) / LV_MATH_ABS(xdiff);
    b9d6:	4553      	cmp	r3, sl
    b9d8:	bfcb      	itete	gt
    b9da:	ea4f 124a 	movgt.w	r2, sl, lsl #5
    else wcorr_i = (LV_MATH_ABS(xdiff) << 5) / LV_MATH_ABS(ydiff);
    b9de:	015a      	lslle	r2, r3, #5
    if(flat) wcorr_i = (LV_MATH_ABS(ydiff) << 5) / LV_MATH_ABS(xdiff);
    b9e0:	fbb2 f2f3 	udivgt	r2, r2, r3
    else wcorr_i = (LV_MATH_ABS(xdiff) << 5) / LV_MATH_ABS(ydiff);
    b9e4:	fbb2 f2fa 	udivle	r2, r2, sl

    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
    b9e8:	49be      	ldr	r1, [pc, #760]	; (bce4 <lv_draw_line+0x7ec>)
    int32_t w = dsc->width;
    b9ea:	f9bb 4004 	ldrsh.w	r4, [fp, #4]
    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
    b9ee:	5c89      	ldrb	r1, [r1, r2]
    b9f0:	223f      	movs	r2, #63	; 0x3f
    b9f2:	fb14 2401 	smlabb	r4, r4, r1, r2
    int32_t w_half0 = w >> 1;
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/

    lv_area_t draw_area;
    draw_area.x1 = LV_MATH_MIN(p1.x, p2.x) - w;
    b9f6:	f344 12cf 	sbfx	r2, r4, #7, #16
    b9fa:	42be      	cmp	r6, r7
    b9fc:	bfd4      	ite	le
    b9fe:	ebc2 0106 	rsble	r1, r2, r6
    ba02:	ebc2 0107 	rsbgt	r1, r2, r7
    ba06:	f8ad 103c 	strh.w	r1, [sp, #60]	; 0x3c
    draw_area.x2 = LV_MATH_MAX(p1.x, p2.x) + w;
    ba0a:	42be      	cmp	r6, r7
    ba0c:	bfac      	ite	ge
    ba0e:	1991      	addge	r1, r2, r6
    ba10:	19d1      	addlt	r1, r2, r7
    ba12:	f8ad 1040 	strh.w	r1, [sp, #64]	; 0x40
    draw_area.y1 = LV_MATH_MIN(p1.y, p2.y) - w;
    ba16:	45c8      	cmp	r8, r9
    ba18:	bfd4      	ite	le
    ba1a:	ebc2 0108 	rsble	r1, r2, r8
    ba1e:	ebc2 0109 	rsbgt	r1, r2, r9
    draw_area.y2 = LV_MATH_MAX(p1.y, p2.y) + w;
    ba22:	45c8      	cmp	r8, r9
    ba24:	bfac      	ite	ge
    ba26:	4442      	addge	r2, r8
    ba28:	444a      	addlt	r2, r9
    draw_area.y1 = LV_MATH_MIN(p1.y, p2.y) - w;
    ba2a:	f8ad 103e 	strh.w	r1, [sp, #62]	; 0x3e

    /* Get the union of `coords` and `clip`*/
    /* `clip` is already truncated to the `vdb` size
     * in 'lv_refr_area' function */
    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);
    ba2e:	a90f      	add	r1, sp, #60	; 0x3c
    draw_area.y2 = LV_MATH_MAX(p1.y, p2.y) + w;
    ba30:	f8ad 2042 	strh.w	r2, [sp, #66]	; 0x42
    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);
    ba34:	4608      	mov	r0, r1
    ba36:	aa0d      	add	r2, sp, #52	; 0x34
    ba38:	9307      	str	r3, [sp, #28]
    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
    ba3a:	11e5      	asrs	r5, r4, #7
    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);
    ba3c:	f00f f92e 	bl	1ac9c <_lv_area_intersect>
    if(is_common == false) return;
    ba40:	2800      	cmp	r0, #0
    ba42:	f43f adf6 	beq.w	b632 <lv_draw_line+0x13a>
    lv_draw_mask_line_param_t mask_left_param;
    lv_draw_mask_line_param_t mask_right_param;
    lv_draw_mask_line_param_t mask_top_param;
    lv_draw_mask_line_param_t mask_bottom_param;

    if(flat) {
    ba46:	9b07      	ldr	r3, [sp, #28]
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
    ba48:	f005 0501 	and.w	r5, r5, #1
    ba4c:	eb05 2524 	add.w	r5, r5, r4, asr #8
    if(flat) {
    ba50:	4553      	cmp	r3, sl
    ba52:	b22d      	sxth	r5, r5
    ba54:	f344 240f 	sbfx	r4, r4, #8, #16
    ba58:	f340 80ee 	ble.w	bc38 <lv_draw_line+0x740>
        if(xdiff > 0) {
    ba5c:	eb09 0305 	add.w	r3, r9, r5
    ba60:	b21b      	sxth	r3, r3
    ba62:	9307      	str	r3, [sp, #28]
    ba64:	1bf3      	subs	r3, r6, r7
    ba66:	2b00      	cmp	r3, #0
    ba68:	f04f 0300 	mov.w	r3, #0
    ba6c:	eba9 0a04 	sub.w	sl, r9, r4
    ba70:	4445      	add	r5, r8
    ba72:	eba8 0404 	sub.w	r4, r8, r4
    ba76:	b22d      	sxth	r5, r5
    ba78:	fa0f fa8a 	sxth.w	sl, sl
    ba7c:	b224      	sxth	r4, r4
            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
    ba7e:	9301      	str	r3, [sp, #4]
        if(xdiff > 0) {
    ba80:	f340 80cd 	ble.w	bc1e <lv_draw_line+0x726>
            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
    ba84:	4633      	mov	r3, r6
    ba86:	4652      	mov	r2, sl
    ba88:	4639      	mov	r1, r7
    ba8a:	9400      	str	r4, [sp, #0]
    ba8c:	a813      	add	r0, sp, #76	; 0x4c
    ba8e:	f000 f997 	bl	bdc0 <lv_draw_mask_line_points_init>
                                          LV_DRAW_MASK_LINE_SIDE_LEFT);
            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
    ba92:	2301      	movs	r3, #1
    ba94:	e9cd 5300 	strd	r5, r3, [sp]
    ba98:	4633      	mov	r3, r6
    ba9a:	9a07      	ldr	r2, [sp, #28]
                                          LV_DRAW_MASK_LINE_SIDE_RIGHT);
        }
        else {
            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
                                          LV_DRAW_MASK_LINE_SIDE_LEFT);
            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
    ba9c:	4639      	mov	r1, r7
        }
    }
    else {
        lv_draw_mask_line_points_init(&mask_left_param, p1.x + w_half1, p1.y, p2.x + w_half1, p2.y,
                                      LV_DRAW_MASK_LINE_SIDE_LEFT);
        lv_draw_mask_line_points_init(&mask_right_param, p1.x - w_half0, p1.y, p2.x - w_half0, p2.y,
    ba9e:	a81e      	add	r0, sp, #120	; 0x78
    baa0:	f000 f98e 	bl	bdc0 <lv_draw_mask_line_points_init>
                                      LV_DRAW_MASK_LINE_SIDE_RIGHT);
    }

    /*Use the normal vector for the endings*/

    int16_t mask_left_id = lv_draw_mask_add(&mask_left_param, NULL);
    baa4:	2100      	movs	r1, #0
    baa6:	a813      	add	r0, sp, #76	; 0x4c
    baa8:	f000 f91e 	bl	bce8 <lv_draw_mask_add>
    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);
    baac:	2100      	movs	r1, #0
    int16_t mask_left_id = lv_draw_mask_add(&mask_left_param, NULL);
    baae:	9009      	str	r0, [sp, #36]	; 0x24
    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);
    bab0:	a81e      	add	r0, sp, #120	; 0x78
    bab2:	f000 f919 	bl	bce8 <lv_draw_mask_add>
    int16_t mask_top_id = LV_MASK_ID_INV;
    int16_t mask_bottom_id = LV_MASK_ID_INV;

    if(!dsc->raw_end) {
    bab6:	f89b 400b 	ldrb.w	r4, [fp, #11]
    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);
    baba:	900a      	str	r0, [sp, #40]	; 0x28
    if(!dsc->raw_end) {
    babc:	f014 0410 	ands.w	r4, r4, #16
    bac0:	f040 80ce 	bne.w	bc60 <lv_draw_line+0x768>
        lv_draw_mask_line_points_init(&mask_top_param, p1.x, p1.y, p1.x - ydiff, p1.y + xdiff, LV_DRAW_MASK_LINE_SIDE_BOTTOM);
    bac4:	2103      	movs	r1, #3
    bac6:	1bf2      	subs	r2, r6, r7
    bac8:	eba9 0308 	sub.w	r3, r9, r8
    bacc:	b215      	sxth	r5, r2
    bace:	fa09 f282 	sxtah	r2, r9, r2
    bad2:	fa0f fa83 	sxth.w	sl, r3
    bad6:	b212      	sxth	r2, r2
    bad8:	fa07 f383 	sxtah	r3, r7, r3
    badc:	9101      	str	r1, [sp, #4]
    bade:	9200      	str	r2, [sp, #0]
    bae0:	4639      	mov	r1, r7
    bae2:	464a      	mov	r2, r9
    bae4:	b21b      	sxth	r3, r3
    bae6:	a829      	add	r0, sp, #164	; 0xa4
    bae8:	f000 f96a 	bl	bdc0 <lv_draw_mask_line_points_init>
        lv_draw_mask_line_points_init(&mask_bottom_param, p2.x, p2.y, p2.x - ydiff, p2.y + xdiff,  LV_DRAW_MASK_LINE_SIDE_TOP);
    baec:	2202      	movs	r2, #2
    baee:	4445      	add	r5, r8
    baf0:	eb06 030a 	add.w	r3, r6, sl
    baf4:	b22d      	sxth	r5, r5
    baf6:	b21b      	sxth	r3, r3
    baf8:	4631      	mov	r1, r6
    bafa:	9201      	str	r2, [sp, #4]
    bafc:	a834      	add	r0, sp, #208	; 0xd0
    bafe:	4642      	mov	r2, r8
    bb00:	9500      	str	r5, [sp, #0]
    bb02:	f000 f95d 	bl	bdc0 <lv_draw_mask_line_points_init>
        mask_top_id = lv_draw_mask_add(&mask_top_param, NULL);
    bb06:	4621      	mov	r1, r4
    bb08:	a829      	add	r0, sp, #164	; 0xa4
    bb0a:	f000 f8ed 	bl	bce8 <lv_draw_mask_add>
        mask_bottom_id = lv_draw_mask_add(&mask_bottom_param, NULL);
    bb0e:	4621      	mov	r1, r4
        mask_top_id = lv_draw_mask_add(&mask_top_param, NULL);
    bb10:	9008      	str	r0, [sp, #32]
        mask_bottom_id = lv_draw_mask_add(&mask_bottom_param, NULL);
    bb12:	a834      	add	r0, sp, #208	; 0xd0
    bb14:	f000 f8e8 	bl	bce8 <lv_draw_mask_add>
    bb18:	4680      	mov	r8, r0
    }

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
    bb1a:	f7fe fd81 	bl	a620 <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    bb1e:	f00e ffd1 	bl	1aac4 <lv_disp_get_buf>

    const lv_area_t * disp_area = &vdb->area;

    /*Store the coordinates of the `draw_a` relative to the VDB */
    draw_area.x1 -= disp_area->x1;
    bb22:	f9bd 103c 	ldrsh.w	r1, [sp, #60]	; 0x3c
    bb26:	f9b0 2010 	ldrsh.w	r2, [r0, #16]
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
    bb2a:	4604      	mov	r4, r0
    draw_area.x1 -= disp_area->x1;
    bb2c:	1a8b      	subs	r3, r1, r2
    draw_area.y1 -= disp_area->y1;
    bb2e:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
    draw_area.x1 -= disp_area->x1;
    bb32:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
    draw_area.y1 -= disp_area->y1;
    bb36:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
    bb3a:	1a1b      	subs	r3, r3, r0
    bb3c:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
    draw_area.x2 -= disp_area->x1;
    bb40:	f9bd 3040 	ldrsh.w	r3, [sp, #64]	; 0x40
    bb44:	1a9a      	subs	r2, r3, r2
    bb46:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
    draw_area.y2 -= disp_area->y1;
    bb4a:	f8bd 2042 	ldrh.w	r2, [sp, #66]	; 0x42
    bb4e:	f103 0901 	add.w	r9, r3, #1
    bb52:	1a12      	subs	r2, r2, r0
     * So deal with it only with steep lines. */
    int32_t draw_area_w = lv_area_get_width(&draw_area);

    /*Draw the background line by line*/
    int32_t h;
    size_t mask_buf_size = LV_MATH_MIN(lv_area_get_size(&draw_area), LV_HOR_RES_MAX);
    bb54:	a80f      	add	r0, sp, #60	; 0x3c
    bb56:	eba9 0901 	sub.w	r9, r9, r1
    draw_area.y2 -= disp_area->y1;
    bb5a:	f8ad 2042 	strh.w	r2, [sp, #66]	; 0x42
    size_t mask_buf_size = LV_MATH_MIN(lv_area_get_size(&draw_area), LV_HOR_RES_MAX);
    bb5e:	f00f f88f 	bl	1ac80 <lv_area_get_size>
    bb62:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    bb66:	fa0f f989 	sxth.w	r9, r9
    bb6a:	d27e      	bcs.n	bc6a <lv_draw_line+0x772>
    bb6c:	a80f      	add	r0, sp, #60	; 0x3c
    bb6e:	f00f f887 	bl	1ac80 <lv_area_get_size>
    bb72:	4606      	mov	r6, r0
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
    bb74:	4630      	mov	r0, r6
    bb76:	f000 ffc1 	bl	cafc <_lv_mem_buf_get>
    fill_area.y1 = draw_area.y1 + disp_area->y1;
    fill_area.y2 = fill_area.y1;

    int32_t x = vdb->area.x1 + draw_area.x1;

    uint32_t mask_p = 0;
    bb7a:	2700      	movs	r7, #0
    fill_area.x1 = draw_area.x1 + disp_area->x1;
    bb7c:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
    bb80:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c

    _lv_memset_ff(mask_buf, mask_buf_size);
    bb84:	4631      	mov	r1, r6
    fill_area.x1 = draw_area.x1 + disp_area->x1;
    bb86:	441a      	add	r2, r3
    bb88:	b212      	sxth	r2, r2
    bb8a:	9207      	str	r2, [sp, #28]
    bb8c:	f8ad 2044 	strh.w	r2, [sp, #68]	; 0x44
    fill_area.x2 = draw_area.x2 + disp_area->x1;
    bb90:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
    bb94:	4605      	mov	r5, r0
    fill_area.x2 = draw_area.x2 + disp_area->x1;
    bb96:	4413      	add	r3, r2
    bb98:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
    fill_area.y1 = draw_area.y1 + disp_area->y1;
    bb9c:	8a62      	ldrh	r2, [r4, #18]
    bb9e:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
    bba2:	4413      	add	r3, r2
    bba4:	b21b      	sxth	r3, r3
    bba6:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    fill_area.y2 = fill_area.y1;
    bbaa:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
    _lv_memset_ff(mask_buf, mask_buf_size);
    bbae:	f00c fcf2 	bl	18596 <_lv_memset_ff>
    /*Fill the first row with 'color'*/
    for(h = draw_area.y1 + disp_area->y1; h <= draw_area.y2 + disp_area->y1; h++) {
    bbb2:	f9bd 303e 	ldrsh.w	r3, [sp, #62]	; 0x3e
    bbb6:	f9b4 a012 	ldrsh.w	sl, [r4, #18]
    bbba:	449a      	add	sl, r3
    bbbc:	f9bd 3042 	ldrsh.w	r3, [sp, #66]	; 0x42
    bbc0:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
    bbc4:	4413      	add	r3, r2
    bbc6:	459a      	cmp	sl, r3
    bbc8:	dd52      	ble.n	bc70 <lv_draw_line+0x778>
            _lv_memset_ff(mask_buf, mask_buf_size);
        }
    }

    /*Flush the last part*/
    if(fill_area.y1 != fill_area.y2) {
    bbca:	f9bd 304a 	ldrsh.w	r3, [sp, #74]	; 0x4a
    bbce:	f9bd 2046 	ldrsh.w	r2, [sp, #70]	; 0x46
    bbd2:	429a      	cmp	r2, r3
    bbd4:	d013      	beq.n	bbfe <lv_draw_line+0x706>
        fill_area.y2--;
    bbd6:	3b01      	subs	r3, #1
    bbd8:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
        _lv_blend_fill(&fill_area, clip,
                       dsc->color, mask_buf, LV_DRAW_MASK_RES_CHANGED, dsc->opa,
                       dsc->blend_mode);
    bbdc:	f89b 300b 	ldrb.w	r3, [fp, #11]
        _lv_blend_fill(&fill_area, clip,
    bbe0:	f8db 2000 	ldr.w	r2, [fp]
    bbe4:	f003 0303 	and.w	r3, r3, #3
    bbe8:	9302      	str	r3, [sp, #8]
    bbea:	f89b 300a 	ldrb.w	r3, [fp, #10]
    bbee:	a90d      	add	r1, sp, #52	; 0x34
    bbf0:	9301      	str	r3, [sp, #4]
    bbf2:	2302      	movs	r3, #2
    bbf4:	a811      	add	r0, sp, #68	; 0x44
    bbf6:	9300      	str	r3, [sp, #0]
    bbf8:	462b      	mov	r3, r5
    bbfa:	f00b fcef 	bl	175dc <_lv_blend_fill>

    }

    _lv_mem_buf_release(mask_buf);
    bbfe:	4628      	mov	r0, r5
    bc00:	f000 ffde 	bl	cbc0 <_lv_mem_buf_release>

    lv_draw_mask_remove_id(mask_left_id);
    bc04:	9809      	ldr	r0, [sp, #36]	; 0x24
    bc06:	f000 f8a7 	bl	bd58 <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_right_id);
    bc0a:	980a      	ldr	r0, [sp, #40]	; 0x28
    bc0c:	f000 f8a4 	bl	bd58 <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_top_id);
    bc10:	9808      	ldr	r0, [sp, #32]
    bc12:	f000 f8a1 	bl	bd58 <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_bottom_id);
    bc16:	4640      	mov	r0, r8
    bc18:	f000 f89e 	bl	bd58 <lv_draw_mask_remove_id>
    bc1c:	e509      	b.n	b632 <lv_draw_line+0x13a>
            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
    bc1e:	4633      	mov	r3, r6
    bc20:	9a07      	ldr	r2, [sp, #28]
    bc22:	4639      	mov	r1, r7
    bc24:	9500      	str	r5, [sp, #0]
    bc26:	a813      	add	r0, sp, #76	; 0x4c
    bc28:	f000 f8ca 	bl	bdc0 <lv_draw_mask_line_points_init>
            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
    bc2c:	2301      	movs	r3, #1
    bc2e:	4652      	mov	r2, sl
    bc30:	e9cd 4300 	strd	r4, r3, [sp]
    bc34:	4633      	mov	r3, r6
    bc36:	e731      	b.n	ba9c <lv_draw_line+0x5a4>
        lv_draw_mask_line_points_init(&mask_left_param, p1.x + w_half1, p1.y, p2.x + w_half1, p2.y,
    bc38:	2200      	movs	r2, #0
    bc3a:	1973      	adds	r3, r6, r5
    bc3c:	443d      	add	r5, r7
    bc3e:	e9cd 8200 	strd	r8, r2, [sp]
    bc42:	b21b      	sxth	r3, r3
    bc44:	464a      	mov	r2, r9
    bc46:	b229      	sxth	r1, r5
    bc48:	a813      	add	r0, sp, #76	; 0x4c
    bc4a:	f000 f8b9 	bl	bdc0 <lv_draw_mask_line_points_init>
        lv_draw_mask_line_points_init(&mask_right_param, p1.x - w_half0, p1.y, p2.x - w_half0, p2.y,
    bc4e:	2201      	movs	r2, #1
    bc50:	1b33      	subs	r3, r6, r4
    bc52:	1b39      	subs	r1, r7, r4
    bc54:	e9cd 8200 	strd	r8, r2, [sp]
    bc58:	b21b      	sxth	r3, r3
    bc5a:	464a      	mov	r2, r9
    bc5c:	b209      	sxth	r1, r1
    bc5e:	e71e      	b.n	ba9e <lv_draw_line+0x5a6>
    int16_t mask_bottom_id = LV_MASK_ID_INV;
    bc60:	f04f 38ff 	mov.w	r8, #4294967295
    int16_t mask_top_id = LV_MASK_ID_INV;
    bc64:	f8cd 8020 	str.w	r8, [sp, #32]
    bc68:	e757      	b.n	bb1a <lv_draw_line+0x622>
    size_t mask_buf_size = LV_MATH_MIN(lv_area_get_size(&draw_area), LV_HOR_RES_MAX);
    bc6a:	f44f 76a0 	mov.w	r6, #320	; 0x140
    bc6e:	e781      	b.n	bb74 <lv_draw_line+0x67c>
        lv_draw_mask_res_t mask_res = lv_draw_mask_apply(&mask_buf[mask_p], x, h, draw_area_w);
    bc70:	19eb      	adds	r3, r5, r7
    bc72:	930b      	str	r3, [sp, #44]	; 0x2c
    bc74:	9907      	ldr	r1, [sp, #28]
    bc76:	464b      	mov	r3, r9
    bc78:	fa0f f28a 	sxth.w	r2, sl
    bc7c:	19e8      	adds	r0, r5, r7
    bc7e:	f000 f849 	bl	bd14 <lv_draw_mask_apply>
        if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
    bc82:	b918      	cbnz	r0, bc8c <lv_draw_line+0x794>
            _lv_memset_00(&mask_buf[mask_p], draw_area_w);
    bc84:	4649      	mov	r1, r9
    bc86:	19e8      	adds	r0, r5, r7
    bc88:	f00c fc81 	bl	1858e <_lv_memset_00>
        mask_p += draw_area_w;
    bc8c:	444f      	add	r7, r9
        if((uint32_t) mask_p + draw_area_w < mask_buf_size) {
    bc8e:	eb07 0309 	add.w	r3, r7, r9
    bc92:	429e      	cmp	r6, r3
    bc94:	d907      	bls.n	bca6 <lv_draw_line+0x7ae>
            fill_area.y2 ++;
    bc96:	f8bd 304a 	ldrh.w	r3, [sp, #74]	; 0x4a
    bc9a:	3301      	adds	r3, #1
    bc9c:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
    for(h = draw_area.y1 + disp_area->y1; h <= draw_area.y2 + disp_area->y1; h++) {
    bca0:	f10a 0a01 	add.w	sl, sl, #1
    bca4:	e78a      	b.n	bbbc <lv_draw_line+0x6c4>
                           dsc->blend_mode);
    bca6:	f89b 300b 	ldrb.w	r3, [fp, #11]
            _lv_blend_fill(&fill_area, clip,
    bcaa:	f8db 2000 	ldr.w	r2, [fp]
    bcae:	f003 0303 	and.w	r3, r3, #3
    bcb2:	9302      	str	r3, [sp, #8]
    bcb4:	f89b 300a 	ldrb.w	r3, [fp, #10]
    bcb8:	a90d      	add	r1, sp, #52	; 0x34
    bcba:	9301      	str	r3, [sp, #4]
    bcbc:	2302      	movs	r3, #2
    bcbe:	a811      	add	r0, sp, #68	; 0x44
    bcc0:	9300      	str	r3, [sp, #0]
    bcc2:	462b      	mov	r3, r5
    bcc4:	f00b fc8a 	bl	175dc <_lv_blend_fill>
            fill_area.y1 = fill_area.y2 + 1;
    bcc8:	f8bd 304a 	ldrh.w	r3, [sp, #74]	; 0x4a
            _lv_memset_ff(mask_buf, mask_buf_size);
    bccc:	4631      	mov	r1, r6
            fill_area.y1 = fill_area.y2 + 1;
    bcce:	3301      	adds	r3, #1
    bcd0:	b21b      	sxth	r3, r3
            _lv_memset_ff(mask_buf, mask_buf_size);
    bcd2:	4628      	mov	r0, r5
            fill_area.y1 = fill_area.y2 + 1;
    bcd4:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
            fill_area.y2 = fill_area.y1;
    bcd8:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
            mask_p = 0;
    bcdc:	2700      	movs	r7, #0
            _lv_memset_ff(mask_buf, mask_buf_size);
    bcde:	f00c fc5a 	bl	18596 <_lv_memset_ff>
    bce2:	e7dd      	b.n	bca0 <lv_draw_line+0x7a8>
    bce4:	000440e8 	.word	0x000440e8

0000bce8 <lv_draw_mask_add>:
 * @param param an initialized mask parameter. Only the pointer is saved.
 * @param custom_id a custom pointer to identify the mask. Used in `lv_draw_mask_remove_custom`.
 * @return the an integer, the ID of the mask. Can be used in `lv_draw_mask_remove_id`.
 */
int16_t lv_draw_mask_add(void * param, void * custom_id)
{
    bce8:	2300      	movs	r3, #0
    bcea:	b570      	push	{r4, r5, r6, lr}
    /*Look for a free entry*/
    uint8_t i;
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param == NULL) break;
    bcec:	4c08      	ldr	r4, [pc, #32]	; (bd10 <lv_draw_mask_add+0x28>)
    bcee:	f854 6033 	ldr.w	r6, [r4, r3, lsl #3]
    bcf2:	b2da      	uxtb	r2, r3
    bcf4:	eb04 05c3 	add.w	r5, r4, r3, lsl #3
    bcf8:	b12e      	cbz	r6, bd06 <lv_draw_mask_add+0x1e>
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
    bcfa:	3301      	adds	r3, #1
    bcfc:	2b10      	cmp	r3, #16
    bcfe:	d1f6      	bne.n	bcee <lv_draw_mask_add+0x6>
    }

    if(i >= _LV_MASK_MAX_NUM) {
        LV_LOG_WARN("lv_mask_add: no place to add the mask");
        return LV_MASK_ID_INV;
    bd00:	f04f 30ff 	mov.w	r0, #4294967295

    LV_GC_ROOT(_lv_draw_mask_list[i]).param = param;
    LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id = custom_id;

    return i;
}
    bd04:	bd70      	pop	{r4, r5, r6, pc}
    LV_GC_ROOT(_lv_draw_mask_list[i]).param = param;
    bd06:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
    LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id = custom_id;
    bd0a:	6069      	str	r1, [r5, #4]
    return i;
    bd0c:	b210      	sxth	r0, r2
    bd0e:	e7f9      	b.n	bd04 <lv_draw_mask_add+0x1c>
    bd10:	20025d28 	.word	0x20025d28

0000bd14 <lv_draw_mask_apply>:
 * - `LV_DRAW_MASK_RES_FULL_COVER`: the whole line is fully visible. `mask_buf` is unchanged
 * - `LV_DRAW_MASK_RES_CHANGED`: `mask_buf` has changed, it shows the desired opacity of each pixel in the given line
 */
LV_ATTRIBUTE_FAST_MEM lv_draw_mask_res_t lv_draw_mask_apply(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,
                                                            lv_coord_t len)
{
    bd14:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    bd18:	4607      	mov	r7, r0
    bd1a:	4688      	mov	r8, r1
    bd1c:	4691      	mov	r9, r2
    bd1e:	469a      	mov	sl, r3
    bool changed = false;
    bd20:	2500      	movs	r5, #0
    lv_draw_mask_common_dsc_t * dsc;

    _lv_draw_mask_saved_t * m = LV_GC_ROOT(_lv_draw_mask_list);
    bd22:	4e0c      	ldr	r6, [pc, #48]	; (bd54 <lv_draw_mask_apply+0x40>)

    while(m->param) {
    bd24:	6834      	ldr	r4, [r6, #0]
    bd26:	b934      	cbnz	r4, bd36 <lv_draw_mask_apply+0x22>
        else if(res == LV_DRAW_MASK_RES_CHANGED) changed = true;

        m++;
    }

    return changed ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;
    bd28:	2d00      	cmp	r5, #0
    bd2a:	bf14      	ite	ne
    bd2c:	2002      	movne	r0, #2
    bd2e:	2001      	moveq	r0, #1
}
    bd30:	b002      	add	sp, #8
    bd32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        res = dsc->cb(mask_buf, abs_x, abs_y, len, (void *)m->param);
    bd36:	9400      	str	r4, [sp, #0]
    bd38:	4653      	mov	r3, sl
    bd3a:	464a      	mov	r2, r9
    bd3c:	4641      	mov	r1, r8
    bd3e:	4638      	mov	r0, r7
    bd40:	6824      	ldr	r4, [r4, #0]
    bd42:	47a0      	blx	r4
        if(res == LV_DRAW_MASK_RES_TRANSP) return LV_DRAW_MASK_RES_TRANSP;
    bd44:	2800      	cmp	r0, #0
    bd46:	d0f3      	beq.n	bd30 <lv_draw_mask_apply+0x1c>
        else if(res == LV_DRAW_MASK_RES_CHANGED) changed = true;
    bd48:	2802      	cmp	r0, #2
    bd4a:	bf08      	it	eq
    bd4c:	2501      	moveq	r5, #1
        m++;
    bd4e:	3608      	adds	r6, #8
    bd50:	e7e8      	b.n	bd24 <lv_draw_mask_apply+0x10>
    bd52:	bf00      	nop
    bd54:	20025d28 	.word	0x20025d28

0000bd58 <lv_draw_mask_remove_id>:
 * @param id the ID of the mask.  Returned by `lv_draw_mask_add`
 * @return the parameter of the removed mask.
 * If more masks have `custom_id` ID then the last mask's parameter will be returned
 */
void * lv_draw_mask_remove_id(int16_t id)
{
    bd58:	4603      	mov	r3, r0
    bd5a:	2100      	movs	r1, #0
    void * p = NULL;

    if(id != LV_MASK_ID_INV) {
    bd5c:	1c42      	adds	r2, r0, #1
        p = LV_GC_ROOT(_lv_draw_mask_list[id]).param;
    bd5e:	bf1f      	itttt	ne
    bd60:	4a05      	ldrne	r2, [pc, #20]	; (bd78 <lv_draw_mask_remove_id+0x20>)
    bd62:	f852 0030 	ldrne.w	r0, [r2, r0, lsl #3]
        LV_GC_ROOT(_lv_draw_mask_list[id]).param = NULL;
    bd66:	f842 1033 	strne.w	r1, [r2, r3, lsl #3]
        LV_GC_ROOT(_lv_draw_mask_list[id]).custom_id = NULL;
    bd6a:	eb02 03c3 	addne.w	r3, r2, r3, lsl #3
    bd6e:	bf14      	ite	ne
    bd70:	6059      	strne	r1, [r3, #4]
    void * p = NULL;
    bd72:	4608      	moveq	r0, r1
    }

    return p;
}
    bd74:	4770      	bx	lr
    bd76:	bf00      	nop
    bd78:	20025d28 	.word	0x20025d28

0000bd7c <lv_draw_mask_remove_custom>:
 * @param custom_id a pointer used in `lv_draw_mask_add`
 * @return return the parameter of the removed mask.
 * If more masks have `custom_id` ID then the last mask's parameter will be returned
 */
void * lv_draw_mask_remove_custom(void * custom_id)
{
    bd7c:	2200      	movs	r2, #0
    bd7e:	4601      	mov	r1, r0
    bd80:	b530      	push	{r4, r5, lr}
    void * p = NULL;
    bd82:	4610      	mov	r0, r2
    uint8_t i;
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id == custom_id) {
            p = LV_GC_ROOT(_lv_draw_mask_list[i]).param;
            LV_GC_ROOT(_lv_draw_mask_list[i]).param = NULL;
    bd84:	4614      	mov	r4, r2
    bd86:	4b06      	ldr	r3, [pc, #24]	; (bda0 <lv_draw_mask_remove_custom+0x24>)
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id == custom_id) {
    bd88:	685d      	ldr	r5, [r3, #4]
    bd8a:	3201      	adds	r2, #1
    bd8c:	428d      	cmp	r5, r1
            p = LV_GC_ROOT(_lv_draw_mask_list[i]).param;
    bd8e:	bf04      	itt	eq
    bd90:	6818      	ldreq	r0, [r3, #0]
            LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id = NULL;
    bd92:	e9c3 4400 	strdeq	r4, r4, [r3]
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
    bd96:	2a10      	cmp	r2, #16
    bd98:	f103 0308 	add.w	r3, r3, #8
    bd9c:	d1f4      	bne.n	bd88 <lv_draw_mask_remove_custom+0xc>
        }
    }
    return p;
}
    bd9e:	bd30      	pop	{r4, r5, pc}
    bda0:	20025d28 	.word	0x20025d28

0000bda4 <lv_draw_mask_get_cnt>:
/**
 * Count the currently added masks
 * @return number of active masks
 */
LV_ATTRIBUTE_FAST_MEM uint8_t lv_draw_mask_get_cnt(void)
{
    bda4:	2300      	movs	r3, #0
    uint8_t cnt = 0;
    bda6:	4618      	mov	r0, r3
    uint8_t i;
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param) cnt++;
    bda8:	4a04      	ldr	r2, [pc, #16]	; (bdbc <lv_draw_mask_get_cnt+0x18>)
    bdaa:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    bdae:	b109      	cbz	r1, bdb4 <lv_draw_mask_get_cnt+0x10>
    bdb0:	3001      	adds	r0, #1
    bdb2:	b2c0      	uxtb	r0, r0
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
    bdb4:	3301      	adds	r3, #1
    bdb6:	2b10      	cmp	r3, #16
    bdb8:	d1f7      	bne.n	bdaa <lv_draw_mask_get_cnt+0x6>
    }
    return cnt;
}
    bdba:	4770      	bx	lr
    bdbc:	20025d28 	.word	0x20025d28

0000bdc0 <lv_draw_mask_line_points_init>:
 * With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept
 * With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept
 */
void lv_draw_mask_line_points_init(lv_draw_mask_line_param_t * param, lv_coord_t p1x, lv_coord_t p1y, lv_coord_t p2x,
                                   lv_coord_t p2y, lv_draw_mask_line_side_t side)
{
    bdc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bdc4:	4615      	mov	r5, r2
    bdc6:	f9bd 8018 	ldrsh.w	r8, [sp, #24]
    bdca:	460e      	mov	r6, r1
    _lv_memset_00(param, sizeof(lv_draw_mask_line_param_t));
    bdcc:	212c      	movs	r1, #44	; 0x2c
{
    bdce:	4604      	mov	r4, r0
    bdd0:	461f      	mov	r7, r3
    _lv_memset_00(param, sizeof(lv_draw_mask_line_param_t));
    bdd2:	f00c fbff 	bl	185d4 <_lv_memset_00>

    if(p1y > p2y) {
    bdd6:	4545      	cmp	r5, r8
    bdd8:	dd05      	ble.n	bde6 <lv_draw_mask_line_points_init+0x26>
    bdda:	462b      	mov	r3, r5
    bddc:	4645      	mov	r5, r8
    bdde:	4698      	mov	r8, r3
    bde0:	4633      	mov	r3, r6
        lv_coord_t t;
        t = p2x;
        p2x = p1x;
        p1x = t;
    bde2:	463e      	mov	r6, r7
        p2x = p1x;
    bde4:	461f      	mov	r7, r3

    param->cfg.p1.x = p1x;
    param->cfg.p1.y = p1y;
    param->cfg.p2.x = p2x;
    param->cfg.p2.y = p2y;
    param->cfg.side = side;
    bde6:	7c23      	ldrb	r3, [r4, #16]
    bde8:	f89d 201c 	ldrb.w	r2, [sp, #28]
    param->cfg.p1.y = p1y;
    bdec:	8165      	strh	r5, [r4, #10]
    param->cfg.side = side;
    bdee:	f362 0301 	bfi	r3, r2, #0, #2
    bdf2:	7423      	strb	r3, [r4, #16]

    param->origo.x = p1x;
    param->origo.y = p1y;
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
    bdf4:	eba8 0205 	sub.w	r2, r8, r5
    bdf8:	1bbb      	subs	r3, r7, r6
    bdfa:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
    bdfe:	ea82 71e2 	eor.w	r1, r2, r2, asr #31
    be02:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
    be06:	eba1 71e2 	sub.w	r1, r1, r2, asr #31
    be0a:	4288      	cmp	r0, r1
    be0c:	bfd4      	ite	le
    be0e:	2000      	movle	r0, #0
    be10:	2001      	movgt	r0, #1
    be12:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
    param->origo.y = p1y;
    be16:	82a5      	strh	r5, [r4, #20]
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
    be18:	f360 0100 	bfi	r1, r0, #0, #1
    param->yx_steep = 0;
    be1c:	2000      	movs	r0, #0
    param->xy_steep = 0;
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_line;
    be1e:	4d29      	ldr	r5, [pc, #164]	; (bec4 <lv_draw_mask_line_points_init+0x104>)
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
    be20:	f884 1028 	strb.w	r1, [r4, #40]	; 0x28
    param->dsc.type = LV_DRAW_MASK_TYPE_LINE;

    int32_t dx = p2x - p1x;
    int32_t dy = p2y - p1y;

    if(param->flat) {
    be24:	07c9      	lsls	r1, r1, #31
    param->xy_steep = 0;
    be26:	e9c4 0006 	strd	r0, r0, [r4, #24]
    param->cfg.p1.x = p1x;
    be2a:	8126      	strh	r6, [r4, #8]
    param->cfg.p2.x = p2x;
    be2c:	81a7      	strh	r7, [r4, #12]
    param->cfg.p2.y = p2y;
    be2e:	f8a4 800e 	strh.w	r8, [r4, #14]
    param->origo.x = p1x;
    be32:	8266      	strh	r6, [r4, #18]
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_line;
    be34:	6025      	str	r5, [r4, #0]
    param->dsc.type = LV_DRAW_MASK_TYPE_LINE;
    be36:	7120      	strb	r0, [r4, #4]
    if(param->flat) {
    be38:	d524      	bpl.n	be84 <lv_draw_mask_line_points_init+0xc4>
        /*Normalize the steep. Delta x should be relative to delta x = 1024*/
        int32_t m;

        if(dx) {
    be3a:	b133      	cbz	r3, be4a <lv_draw_mask_line_points_init+0x8a>
            m = (1 << 20) / dx;  /*m is multiplier to normalize y (upscaled by 1024)*/
    be3c:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    be40:	fb91 f1f3 	sdiv	r1, r1, r3
            param->yx_steep = (m * dy) >> 10;
    be44:	4351      	muls	r1, r2
    be46:	1289      	asrs	r1, r1, #10
    be48:	61e1      	str	r1, [r4, #28]
        }

        if(dy) {
    be4a:	b132      	cbz	r2, be5a <lv_draw_mask_line_points_init+0x9a>
            m = (1 << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/
    be4c:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    be50:	fb91 f2f2 	sdiv	r2, r1, r2
            param->xy_steep = (m * dx) >> 10;
    be54:	4353      	muls	r3, r2
    be56:	129b      	asrs	r3, r3, #10
    be58:	61a3      	str	r3, [r4, #24]
        }
        param->steep = param->yx_steep;
    be5a:	69e3      	ldr	r3, [r4, #28]
            param->yx_steep = (m * dy) >> 10;
        }
        param->steep = param->xy_steep;
    }

    if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) param->inv = 0;
    be5c:	7c22      	ldrb	r2, [r4, #16]
        param->steep = param->xy_steep;
    be5e:	6223      	str	r3, [r4, #32]
    if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) param->inv = 0;
    be60:	f012 0203 	ands.w	r2, r2, #3
    be64:	6a21      	ldr	r1, [r4, #32]
    be66:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    be6a:	d11d      	bne.n	bea8 <lv_draw_mask_line_points_init+0xe8>
    be6c:	f36f 0341 	bfc	r3, #1, #1
    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) param->inv = 1;
    be70:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        if(param->steep > 0) param->inv = 0;
        else param->inv = 1;
    }

    param->spx = param->steep >> 2;
    if(param->steep < 0) param->spx = -param->spx;
    be74:	2900      	cmp	r1, #0
    param->spx = param->steep >> 2;
    be76:	ea4f 03a1 	mov.w	r3, r1, asr #2
    if(param->steep < 0) param->spx = -param->spx;
    be7a:	bfb8      	it	lt
    be7c:	425b      	neglt	r3, r3
    be7e:	6263      	str	r3, [r4, #36]	; 0x24
}
    be80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(dy) {
    be84:	b132      	cbz	r2, be94 <lv_draw_mask_line_points_init+0xd4>
            m = (1 << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/
    be86:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    be8a:	fb91 f1f2 	sdiv	r1, r1, r2
            param->xy_steep = (m * dx) >> 10;
    be8e:	4359      	muls	r1, r3
    be90:	1289      	asrs	r1, r1, #10
    be92:	61a1      	str	r1, [r4, #24]
        if(dx) {
    be94:	b133      	cbz	r3, bea4 <lv_draw_mask_line_points_init+0xe4>
            m = (1 << 20) / dx;  /*m is multiplier to normalize x (upscaled by 1024)*/
    be96:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    be9a:	fb91 f3f3 	sdiv	r3, r1, r3
            param->yx_steep = (m * dy) >> 10;
    be9e:	435a      	muls	r2, r3
    bea0:	1292      	asrs	r2, r2, #10
    bea2:	61e2      	str	r2, [r4, #28]
        param->steep = param->xy_steep;
    bea4:	69a3      	ldr	r3, [r4, #24]
    bea6:	e7d9      	b.n	be5c <lv_draw_mask_line_points_init+0x9c>
    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) param->inv = 1;
    bea8:	2a01      	cmp	r2, #1
    beaa:	d102      	bne.n	beb2 <lv_draw_mask_line_points_init+0xf2>
    beac:	f043 0302 	orr.w	r3, r3, #2
    beb0:	e7de      	b.n	be70 <lv_draw_mask_line_points_init+0xb0>
    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP) {
    beb2:	2a02      	cmp	r2, #2
    beb4:	d102      	bne.n	bebc <lv_draw_mask_line_points_init+0xfc>
        if(param->steep > 0) param->inv = 1;
    beb6:	2900      	cmp	r1, #0
    beb8:	dcf8      	bgt.n	beac <lv_draw_mask_line_points_init+0xec>
    beba:	e7d7      	b.n	be6c <lv_draw_mask_line_points_init+0xac>
        if(param->steep > 0) param->inv = 0;
    bebc:	2900      	cmp	r1, #0
    bebe:	dcd5      	bgt.n	be6c <lv_draw_mask_line_points_init+0xac>
    bec0:	e7f4      	b.n	beac <lv_draw_mask_line_points_init+0xec>
    bec2:	bf00      	nop
    bec4:	000185dd 	.word	0x000185dd

0000bec8 <lv_draw_mask_radius_init>:
 * @param rect coordinates of the rectangle to affect (absolute coordinates)
 * @param radius radius of the rectangle
 * @param inv: true: keep the pixels inside the rectangle; keep the pixels outside of the rectangle
 */
void lv_draw_mask_radius_init(lv_draw_mask_radius_param_t * param, const lv_area_t * rect, lv_coord_t radius, bool inv)
{
    bec8:	b570      	push	{r4, r5, r6, lr}
    beca:	4604      	mov	r4, r0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    becc:	88c8      	ldrh	r0, [r1, #6]
    bece:	4616      	mov	r6, r2
    bed0:	884a      	ldrh	r2, [r1, #2]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    bed2:	888d      	ldrh	r5, [r1, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    bed4:	3001      	adds	r0, #1
    bed6:	1a80      	subs	r0, r0, r2
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    bed8:	880a      	ldrh	r2, [r1, #0]
    beda:	3501      	adds	r5, #1
    bedc:	1aad      	subs	r5, r5, r2
    lv_coord_t w = lv_area_get_width(rect);
    lv_coord_t h = lv_area_get_height(rect);
    int32_t short_side = LV_MATH_MIN(w, h);
    bede:	b200      	sxth	r0, r0
    bee0:	b22d      	sxth	r5, r5
    bee2:	42a8      	cmp	r0, r5
    bee4:	bfa8      	it	ge
    bee6:	4628      	movge	r0, r5
    if(radius > short_side >> 1) radius = short_side >> 1;
    bee8:	1042      	asrs	r2, r0, #1
    beea:	ebb6 0f60 	cmp.w	r6, r0, asr #1
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
    beee:	f104 0008 	add.w	r0, r4, #8
    bef2:	bfc8      	it	gt
    bef4:	b216      	sxthgt	r6, r2
    bef6:	f00c fd24 	bl	18942 <_lv_memcpy_small.constprop.0>

    lv_area_copy(&param->cfg.rect, rect);
    param->cfg.radius = radius;
    param->cfg.outer = inv ? 1 : 0;
    befa:	7ca2      	ldrb	r2, [r4, #18]
    param->cfg.radius = radius;
    befc:	8226      	strh	r6, [r4, #16]
    param->cfg.outer = inv ? 1 : 0;
    befe:	f363 0200 	bfi	r2, r3, #0, #1
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_radius;
    bf02:	4b05      	ldr	r3, [pc, #20]	; (bf18 <lv_draw_mask_radius_init+0x50>)
    param->cfg.outer = inv ? 1 : 0;
    bf04:	74a2      	strb	r2, [r4, #18]
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_radius;
    bf06:	6023      	str	r3, [r4, #0]
    param->dsc.type = LV_DRAW_MASK_TYPE_RADIUS;
    bf08:	2302      	movs	r3, #2
    param->y_prev = INT32_MIN;
    param->y_prev_x.f = 0;
    param->y_prev_x.i = 0;
    bf0a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    param->dsc.type = LV_DRAW_MASK_TYPE_RADIUS;
    bf0e:	7123      	strb	r3, [r4, #4]
    param->y_prev_x.i = 0;
    bf10:	2300      	movs	r3, #0
    bf12:	e9c4 2305 	strd	r2, r3, [r4, #20]
}
    bf16:	bd70      	pop	{r4, r5, r6, pc}
    bf18:	0001894d 	.word	0x0001894d

0000bf1c <lv_draw_rect_dsc_init>:
 *   GLOBAL FUNCTIONS
 **********************/

LV_ATTRIBUTE_FAST_MEM void lv_draw_rect_dsc_init(lv_draw_rect_dsc_t * dsc)
{
    _lv_memset_00(dsc, sizeof(lv_draw_rect_dsc_t));
    bf1c:	2168      	movs	r1, #104	; 0x68
{
    bf1e:	b510      	push	{r4, lr}
    bf20:	4604      	mov	r4, r0
    _lv_memset_00(dsc, sizeof(lv_draw_rect_dsc_t));
    bf22:	f00c ff86 	bl	18e32 <_lv_memset_00>
    dsc->bg_color = LV_COLOR_WHITE;
    dsc->bg_grad_color = LV_COLOR_BLACK;
    bf26:	f04f 33ff 	mov.w	r3, #4294967295
    bf2a:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
    dsc->border_color = LV_COLOR_BLACK;
    dsc->pattern_recolor = LV_COLOR_BLACK;
    dsc->value_color = LV_COLOR_BLACK;
    dsc->shadow_color = LV_COLOR_BLACK;
    dsc->bg_grad_color_stop = 0xFF;
    bf2e:	21ff      	movs	r1, #255	; 0xff
    dsc->bg_grad_color = LV_COLOR_BLACK;
    bf30:	e9c4 3201 	strd	r3, r2, [r4, #4]
    dsc->bg_opa = LV_OPA_COVER;
    bf34:	74a3      	strb	r3, [r4, #18]
    dsc->outline_opa = LV_OPA_COVER;
    dsc->border_opa = LV_OPA_COVER;
    bf36:	7723      	strb	r3, [r4, #28]
    dsc->pattern_opa = LV_OPA_COVER;
    bf38:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    dsc->pattern_font = LV_THEME_DEFAULT_FONT_NORMAL;
    dsc->value_opa = LV_OPA_COVER;
    bf3c:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
    dsc->value_font = LV_THEME_DEFAULT_FONT_NORMAL;
    dsc->shadow_opa = LV_OPA_COVER;
    bf40:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
    dsc->border_side = LV_BORDER_SIDE_FULL;
    bf44:	230f      	movs	r3, #15
    dsc->border_color = LV_COLOR_BLACK;
    bf46:	6162      	str	r2, [r4, #20]
    dsc->value_color = LV_COLOR_BLACK;
    bf48:	65a2      	str	r2, [r4, #88]	; 0x58
    dsc->shadow_color = LV_COLOR_BLACK;
    bf4a:	62e2      	str	r2, [r4, #44]	; 0x2c
    dsc->pattern_recolor = LV_COLOR_BLACK;
    bf4c:	6462      	str	r2, [r4, #68]	; 0x44
    dsc->pattern_font = LV_THEME_DEFAULT_FONT_NORMAL;
    bf4e:	4a04      	ldr	r2, [pc, #16]	; (bf60 <lv_draw_rect_dsc_init+0x44>)
    dsc->bg_grad_color_stop = 0xFF;
    bf50:	8221      	strh	r1, [r4, #16]
    dsc->outline_opa = LV_OPA_COVER;
    bf52:	f884 1028 	strb.w	r1, [r4, #40]	; 0x28
    dsc->pattern_font = LV_THEME_DEFAULT_FONT_NORMAL;
    bf56:	6422      	str	r2, [r4, #64]	; 0x40
    dsc->value_font = LV_THEME_DEFAULT_FONT_NORMAL;
    bf58:	6522      	str	r2, [r4, #80]	; 0x50
    dsc->border_side = LV_BORDER_SIDE_FULL;
    bf5a:	8363      	strh	r3, [r4, #26]

}
    bf5c:	bd10      	pop	{r4, pc}
    bf5e:	bf00      	nop
    bf60:	200004f4 	.word	0x200004f4

0000bf64 <_lv_img_cache_open>:
 * @param color color The color of the image with `LV_IMG_CF_ALPHA_...`
 * @return pointer to the cache entry or NULL if can open the image
 */
lv_img_cache_entry_t * _lv_img_cache_open(const void * src, lv_color_t color)
{
    if(entry_cnt == 0) {
    bf64:	4b45      	ldr	r3, [pc, #276]	; (c07c <_lv_img_cache_open+0x118>)
{
    bf66:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if(entry_cnt == 0) {
    bf6a:	881c      	ldrh	r4, [r3, #0]
{
    bf6c:	4605      	mov	r5, r0
    bf6e:	460e      	mov	r6, r1
    bf70:	4699      	mov	r9, r3
    if(entry_cnt == 0) {
    bf72:	2c00      	cmp	r4, #0
    bf74:	d059      	beq.n	c02a <_lv_img_cache_open+0xc6>
        LV_LOG_WARN("lv_img_cache_open: the cache size is 0");
        return NULL;
    }

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    bf76:	4b42      	ldr	r3, [pc, #264]	; (c080 <_lv_img_cache_open+0x11c>)

    /*Decrement all lifes. Make the entries older*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
    bf78:	2100      	movs	r1, #0
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    bf7a:	681f      	ldr	r7, [r3, #0]
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
    bf7c:	4841      	ldr	r0, [pc, #260]	; (c084 <_lv_img_cache_open+0x120>)
    bf7e:	463b      	mov	r3, r7
    for(i = 0; i < entry_cnt; i++) {
    bf80:	b28a      	uxth	r2, r1
    bf82:	4294      	cmp	r4, r2
    bf84:	d833      	bhi.n	bfee <_lv_img_cache_open+0x8a>
    bf86:	f04f 0800 	mov.w	r8, #0

    /*Is the image cached?*/
    lv_img_cache_entry_t * cached_src = NULL;
    for(i = 0; i < entry_cnt; i++) {
        bool match = false;
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
    bf8a:	f04f 0a28 	mov.w	sl, #40	; 0x28
    for(i = 0; i < entry_cnt; i++) {
    bf8e:	f8b9 1000 	ldrh.w	r1, [r9]
    bf92:	fa1f f388 	uxth.w	r3, r8
    bf96:	4299      	cmp	r1, r3
    bf98:	d832      	bhi.n	c000 <_lv_img_cache_open+0x9c>
    }

    /*The image is not cached then cache it now*/
    if(cached_src == NULL) {
        /*Find an entry to reuse. Select the entry with the least life*/
        cached_src = &cache[0];
    bf9a:	463c      	mov	r4, r7
        for(i = 1; i < entry_cnt; i++) {
    bf9c:	2301      	movs	r3, #1
    bf9e:	f107 0228 	add.w	r2, r7, #40	; 0x28
    bfa2:	4299      	cmp	r1, r3
    bfa4:	d852      	bhi.n	c04c <_lv_img_cache_open+0xe8>
                cached_src = &cache[i];
            }
        }

        /*Close the decoder to reuse if it was opened (has a valid source)*/
        if(cached_src->dec_dsc.src) {
    bfa6:	6863      	ldr	r3, [r4, #4]
    bfa8:	b113      	cbz	r3, bfb0 <_lv_img_cache_open+0x4c>
            lv_img_decoder_close(&cached_src->dec_dsc);
    bfaa:	4620      	mov	r0, r4
    bfac:	f00e fd63 	bl	1aa76 <lv_img_decoder_close>
            LV_LOG_INFO("image draw: cache miss, cached to an empty entry");
        }

        /*Open the image and measure the time to open*/
        uint32_t t_start;
        t_start                          = lv_tick_get();
    bfb0:	f00e fddf 	bl	1ab72 <lv_tick_get>
        cached_src->dec_dsc.time_to_open = 0;
    bfb4:	f04f 0800 	mov.w	r8, #0
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, color);
    bfb8:	4629      	mov	r1, r5
        t_start                          = lv_tick_get();
    bfba:	4607      	mov	r7, r0
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, color);
    bfbc:	4632      	mov	r2, r6
    bfbe:	4620      	mov	r0, r4
        cached_src->dec_dsc.time_to_open = 0;
    bfc0:	f8c4 8018 	str.w	r8, [r4, #24]
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, color);
    bfc4:	f000 fa44 	bl	c450 <lv_img_decoder_open>
        if(open_res == LV_RES_INV) {
    bfc8:	4605      	mov	r5, r0
    bfca:	2800      	cmp	r0, #0
    bfcc:	d147      	bne.n	c05e <_lv_img_cache_open+0xfa>
            LV_LOG_WARN("Image draw cannot open the image resource");
            lv_img_decoder_close(&cached_src->dec_dsc);
    bfce:	4620      	mov	r0, r4
    bfd0:	f00e fd51 	bl	1aa76 <lv_img_decoder_close>
            _lv_memset_00(&cached_src->dec_dsc, sizeof(lv_img_decoder_dsc_t));
    bfd4:	4620      	mov	r0, r4
    bfd6:	2124      	movs	r1, #36	; 0x24
    bfd8:	f00e fcb8 	bl	1a94c <_lv_memset_00>
            _lv_memset_00(cached_src, sizeof(lv_img_cache_entry_t));
    bfdc:	4620      	mov	r0, r4
    bfde:	2128      	movs	r1, #40	; 0x28
    bfe0:	f00e fcb4 	bl	1a94c <_lv_memset_00>
            cached_src->life = INT32_MIN; /*Make the empty entry very "weak" to force its use  */
    bfe4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    bfe8:	6263      	str	r3, [r4, #36]	; 0x24
            return NULL;
    bfea:	462c      	mov	r4, r5
    bfec:	e01d      	b.n	c02a <_lv_img_cache_open+0xc6>
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
    bfee:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    bff0:	3101      	adds	r1, #1
    bff2:	4282      	cmp	r2, r0
            cache[i].life -= LV_IMG_CACHE_AGING;
    bff4:	bfa4      	itt	ge
    bff6:	f102 32ff 	addge.w	r2, r2, #4294967295
    bffa:	625a      	strge	r2, [r3, #36]	; 0x24
    for(i = 0; i < entry_cnt; i++) {
    bffc:	3328      	adds	r3, #40	; 0x28
    bffe:	e7bf      	b.n	bf80 <_lv_img_cache_open+0x1c>
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
    c000:	fa1f f488 	uxth.w	r4, r8
    c004:	fb0a 7404 	mla	r4, sl, r4, r7
    c008:	6860      	ldr	r0, [r4, #4]
    c00a:	f00c fa9a 	bl	18542 <lv_img_src_get_type>
        if(src_type == LV_IMG_SRC_VARIABLE) {
    c00e:	b978      	cbnz	r0, c030 <_lv_img_cache_open+0xcc>
            if(cache[i].dec_dsc.src == src && cache[i].dec_dsc.color.full == color.full) match = true;
    c010:	6863      	ldr	r3, [r4, #4]
    c012:	42ab      	cmp	r3, r5
    c014:	d114      	bne.n	c040 <_lv_img_cache_open+0xdc>
    c016:	68a3      	ldr	r3, [r4, #8]
    c018:	42b3      	cmp	r3, r6
    c01a:	d111      	bne.n	c040 <_lv_img_cache_open+0xdc>
            cached_src->life += cached_src->dec_dsc.time_to_open * LV_IMG_CACHE_LIFE_GAIN;
    c01c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c01e:	69a2      	ldr	r2, [r4, #24]
    c020:	4413      	add	r3, r2
            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;
    c022:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    c026:	dc0e      	bgt.n	c046 <_lv_img_cache_open+0xe2>
    c028:	6263      	str	r3, [r4, #36]	; 0x24

        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
    }

    return cached_src;
}
    c02a:	4620      	mov	r0, r4
    c02c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        else if(src_type == LV_IMG_SRC_FILE) {
    c030:	2801      	cmp	r0, #1
    c032:	d105      	bne.n	c040 <_lv_img_cache_open+0xdc>
            if(strcmp(cache[i].dec_dsc.src, src) == 0) match = true;
    c034:	4629      	mov	r1, r5
    c036:	6860      	ldr	r0, [r4, #4]
    c038:	f7f4 fa0a 	bl	450 <strcmp>
    c03c:	2800      	cmp	r0, #0
    c03e:	d0ed      	beq.n	c01c <_lv_img_cache_open+0xb8>
    for(i = 0; i < entry_cnt; i++) {
    c040:	f108 0801 	add.w	r8, r8, #1
    c044:	e7a3      	b.n	bf8e <_lv_img_cache_open+0x2a>
            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;
    c046:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    c04a:	e7ed      	b.n	c028 <_lv_img_cache_open+0xc4>
            if(cache[i].life < cached_src->life) {
    c04c:	6a57      	ldr	r7, [r2, #36]	; 0x24
    c04e:	6a60      	ldr	r0, [r4, #36]	; 0x24
        for(i = 1; i < entry_cnt; i++) {
    c050:	3301      	adds	r3, #1
            if(cache[i].life < cached_src->life) {
    c052:	4287      	cmp	r7, r0
    c054:	bfb8      	it	lt
    c056:	4614      	movlt	r4, r2
        for(i = 1; i < entry_cnt; i++) {
    c058:	b29b      	uxth	r3, r3
    c05a:	3228      	adds	r2, #40	; 0x28
    c05c:	e7a1      	b.n	bfa2 <_lv_img_cache_open+0x3e>
        if(cached_src->dec_dsc.time_to_open == 0) {
    c05e:	69a3      	ldr	r3, [r4, #24]
        cached_src->life = 0;
    c060:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
        if(cached_src->dec_dsc.time_to_open == 0) {
    c064:	2b00      	cmp	r3, #0
    c066:	d1e0      	bne.n	c02a <_lv_img_cache_open+0xc6>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
    c068:	4638      	mov	r0, r7
    c06a:	f00e fd8f 	bl	1ab8c <lv_tick_elaps>
        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
    c06e:	b108      	cbz	r0, c074 <_lv_img_cache_open+0x110>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
    c070:	61a0      	str	r0, [r4, #24]
    c072:	e7da      	b.n	c02a <_lv_img_cache_open+0xc6>
        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
    c074:	2301      	movs	r3, #1
    c076:	61a3      	str	r3, [r4, #24]
    c078:	e7d7      	b.n	c02a <_lv_img_cache_open+0xc6>
    c07a:	bf00      	nop
    c07c:	20029f32 	.word	0x20029f32
    c080:	20025dac 	.word	0x20025dac
    c084:	80000002 	.word	0x80000002

0000c088 <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
    c088:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c08c:	4606      	mov	r6, r0

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
    c08e:	2500      	movs	r5, #0
        if(cache[i].dec_dsc.src == src || src == NULL) {
    c090:	f04f 0928 	mov.w	r9, #40	; 0x28
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    c094:	4b0f      	ldr	r3, [pc, #60]	; (c0d4 <lv_img_cache_invalidate_src+0x4c>)
    for(i = 0; i < entry_cnt; i++) {
    c096:	4f10      	ldr	r7, [pc, #64]	; (c0d8 <lv_img_cache_invalidate_src+0x50>)
    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
    c098:	f8d3 8000 	ldr.w	r8, [r3]
    for(i = 0; i < entry_cnt; i++) {
    c09c:	883a      	ldrh	r2, [r7, #0]
    c09e:	b2ab      	uxth	r3, r5
    c0a0:	429a      	cmp	r2, r3
    c0a2:	d801      	bhi.n	c0a8 <lv_img_cache_invalidate_src+0x20>

            _lv_memset_00(&cache[i].dec_dsc, sizeof(lv_img_decoder_dsc_t));
            _lv_memset_00(&cache[i], sizeof(lv_img_cache_entry_t));
        }
    }
}
    c0a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(cache[i].dec_dsc.src == src || src == NULL) {
    c0a8:	b2ac      	uxth	r4, r5
    c0aa:	fb09 8404 	mla	r4, r9, r4, r8
    c0ae:	6863      	ldr	r3, [r4, #4]
    c0b0:	42b3      	cmp	r3, r6
    c0b2:	d000      	beq.n	c0b6 <lv_img_cache_invalidate_src+0x2e>
    c0b4:	b95e      	cbnz	r6, c0ce <lv_img_cache_invalidate_src+0x46>
            if(cache[i].dec_dsc.src != NULL) {
    c0b6:	b113      	cbz	r3, c0be <lv_img_cache_invalidate_src+0x36>
                lv_img_decoder_close(&cache[i].dec_dsc);
    c0b8:	4620      	mov	r0, r4
    c0ba:	f00e fcdc 	bl	1aa76 <lv_img_decoder_close>
            _lv_memset_00(&cache[i].dec_dsc, sizeof(lv_img_decoder_dsc_t));
    c0be:	2124      	movs	r1, #36	; 0x24
    c0c0:	4620      	mov	r0, r4
    c0c2:	f00e fc43 	bl	1a94c <_lv_memset_00>
            _lv_memset_00(&cache[i], sizeof(lv_img_cache_entry_t));
    c0c6:	2128      	movs	r1, #40	; 0x28
    c0c8:	4620      	mov	r0, r4
    c0ca:	f00e fc3f 	bl	1a94c <_lv_memset_00>
    for(i = 0; i < entry_cnt; i++) {
    c0ce:	3501      	adds	r5, #1
    c0d0:	e7e4      	b.n	c09c <lv_img_cache_invalidate_src+0x14>
    c0d2:	bf00      	nop
    c0d4:	20025dac 	.word	0x20025dac
    c0d8:	20029f32 	.word	0x20029f32

0000c0dc <lv_img_cache_set_size>:
{
    c0dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
    c0e0:	4c13      	ldr	r4, [pc, #76]	; (c130 <lv_img_cache_set_size+0x54>)
{
    c0e2:	4605      	mov	r5, r0
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
    c0e4:	6823      	ldr	r3, [r4, #0]
    c0e6:	b12b      	cbz	r3, c0f4 <lv_img_cache_set_size+0x18>
        lv_img_cache_invalidate_src(NULL);
    c0e8:	2000      	movs	r0, #0
    c0ea:	f7ff ffcd 	bl	c088 <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
    c0ee:	6820      	ldr	r0, [r4, #0]
    c0f0:	f000 fce6 	bl	cac0 <lv_mem_free>
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
    c0f4:	2728      	movs	r7, #40	; 0x28
    c0f6:	fb07 f005 	mul.w	r0, r7, r5
    c0fa:	f000 fccd 	bl	ca98 <lv_mem_alloc>
    c0fe:	4b0d      	ldr	r3, [pc, #52]	; (c134 <lv_img_cache_set_size+0x58>)
    c100:	6020      	str	r0, [r4, #0]
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
    c102:	b910      	cbnz	r0, c10a <lv_img_cache_set_size+0x2e>
        entry_cnt = 0;
    c104:	8018      	strh	r0, [r3, #0]
}
    c106:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    for(i = 0; i < entry_cnt; i++) {
    c10a:	2600      	movs	r6, #0
    entry_cnt = new_entry_cnt;
    c10c:	801d      	strh	r5, [r3, #0]
    for(i = 0; i < entry_cnt; i++) {
    c10e:	42b5      	cmp	r5, r6
    c110:	d0f9      	beq.n	c106 <lv_img_cache_set_size+0x2a>
        _lv_memset_00(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, sizeof(lv_img_decoder_dsc_t));
    c112:	fb07 f806 	mul.w	r8, r7, r6
    c116:	6820      	ldr	r0, [r4, #0]
    c118:	2124      	movs	r1, #36	; 0x24
    c11a:	4440      	add	r0, r8
    c11c:	f00e fc16 	bl	1a94c <_lv_memset_00>
        _lv_memset_00(&LV_GC_ROOT(_lv_img_cache_array)[i], sizeof(lv_img_cache_entry_t));
    c120:	6820      	ldr	r0, [r4, #0]
    c122:	2128      	movs	r1, #40	; 0x28
    c124:	4440      	add	r0, r8
    c126:	f00e fc11 	bl	1a94c <_lv_memset_00>
    for(i = 0; i < entry_cnt; i++) {
    c12a:	3601      	adds	r6, #1
    c12c:	e7ef      	b.n	c10e <lv_img_cache_set_size+0x32>
    c12e:	bf00      	nop
    c130:	20025dac 	.word	0x20025dac
    c134:	20029f32 	.word	0x20029f32

0000c138 <lv_img_decoder_built_in_read_line>:
 * @param buf a buffer to store the decoded pixels
 * @return LV_RES_OK: ok; LV_RES_INV: failed
 */
lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                           lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
    c138:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    c13c:	7c08      	ldrb	r0, [r1, #16]
{
    c13e:	461e      	mov	r6, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    c140:	f000 031e 	and.w	r3, r0, #30
{
    c144:	b087      	sub	sp, #28
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    c146:	2b04      	cmp	r3, #4
{
    c148:	460d      	mov	r5, r1
    c14a:	4614      	mov	r4, r2
    c14c:	f9bd 8038 	ldrsh.w	r8, [sp, #56]	; 0x38
    c150:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    c152:	d103      	bne.n	c15c <lv_img_decoder_built_in_read_line+0x24>
        lv_fs_read(user_data->f, fs_buf, w, NULL);
        data_tmp = fs_buf;
#else
        LV_LOG_WARN("Image built-in alpha line reader can't read file because LV_USE_FILESYSTEM = 0");
        data_tmp = NULL; /*To avoid warnings*/
        return LV_RES_INV;
    c154:	2000      	movs	r0, #0
}
    c156:	b007      	add	sp, #28
    c158:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
    c15c:	f000 031f 	and.w	r3, r0, #31
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
    c160:	2b06      	cmp	r3, #6
    c162:	d0f7      	beq.n	c154 <lv_img_decoder_built_in_read_line+0x1c>
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
    c164:	f1a3 020b 	sub.w	r2, r3, #11
    c168:	2a03      	cmp	r2, #3
    c16a:	f200 809d 	bhi.w	c2a8 <lv_img_decoder_built_in_read_line+0x170>
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
    c16e:	f44f 437f 	mov.w	r3, #65280	; 0xff00
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
    c172:	aa02      	add	r2, sp, #8
    c174:	4691      	mov	r9, r2
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
    c176:	f8ad 3000 	strh.w	r3, [sp]
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
    c17a:	f5a3 03ad 	sub.w	r3, r3, #5668864	; 0x568000
    c17e:	f5a3 5328 	sub.w	r3, r3, #10752	; 0x2a00
    c182:	9301      	str	r3, [sp, #4]
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
    c184:	4b88      	ldr	r3, [pc, #544]	; (c3a8 <lv_img_decoder_built_in_read_line+0x270>)
    c186:	f103 0e10 	add.w	lr, r3, #16
    c18a:	4694      	mov	ip, r2
    c18c:	6818      	ldr	r0, [r3, #0]
    c18e:	6859      	ldr	r1, [r3, #4]
    c190:	3308      	adds	r3, #8
    c192:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    c196:	4573      	cmp	r3, lr
    c198:	4662      	mov	r2, ip
    c19a:	d1f6      	bne.n	c18a <lv_img_decoder_built_in_read_line+0x52>
    for(i = 0; i < len; i++) {
    c19c:	2300      	movs	r3, #0
    lv_color_t bg_color = dsc->color;
    c19e:	68a9      	ldr	r1, [r5, #8]
    for(i = 0; i < len; i++) {
    c1a0:	b21a      	sxth	r2, r3
    c1a2:	4590      	cmp	r8, r2
    c1a4:	dc0e      	bgt.n	c1c4 <lv_img_decoder_built_in_read_line+0x8c>
    uint8_t px_size            = lv_img_cf_get_px_size(dsc->header.cf);
    c1a6:	7c28      	ldrb	r0, [r5, #16]
    c1a8:	f000 001f 	and.w	r0, r0, #31
    c1ac:	f7fe fc58 	bl	aa60 <lv_img_cf_get_px_size>
    switch(dsc->header.cf) {
    c1b0:	7c2b      	ldrb	r3, [r5, #16]
    c1b2:	f003 031f 	and.w	r3, r3, #31
    c1b6:	3b0b      	subs	r3, #11
    c1b8:	2b03      	cmp	r3, #3
    c1ba:	d857      	bhi.n	c26c <lv_img_decoder_built_in_read_line+0x134>
    c1bc:	e8df f003 	tbb	[pc, r3]
    c1c0:	4e3e2b06 	.word	0x4e3e2b06
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = bg_color.full;
    c1c4:	f847 1023 	str.w	r1, [r7, r3, lsl #2]
    for(i = 0; i < len; i++) {
    c1c8:	3301      	adds	r3, #1
    c1ca:	e7e9      	b.n	c1a0 <lv_img_decoder_built_in_read_line+0x68>
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
    c1cc:	692a      	ldr	r2, [r5, #16]
            opa_table = alpha1_opa_table;
    c1ce:	46ec      	mov	ip, sp
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
    c1d0:	f3c2 3347 	ubfx	r3, r2, #13, #8
            if(dsc->header.w & 0x7) w++;
    c1d4:	f412 5fe0 	tst.w	r2, #7168	; 0x1c00
            ofs += w * y + (x >> 3); /*First pixel*/
    c1d8:	ea4f 02e4 	mov.w	r2, r4, asr #3
            pos       = 7 - (x & 0x7);
    c1dc:	ea6f 0404 	mvn.w	r4, r4
            if(dsc->header.w & 0x7) w++;
    c1e0:	bf18      	it	ne
    c1e2:	3301      	addne	r3, #1
            ofs += w * y + (x >> 3); /*First pixel*/
    c1e4:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 7 - (x & 0x7);
    c1e8:	f004 0407 	and.w	r4, r4, #7
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
    c1ec:	7b29      	ldrb	r1, [r5, #12]
    c1ee:	2900      	cmp	r1, #0
    c1f0:	d1b0      	bne.n	c154 <lv_img_decoder_built_in_read_line+0x1c>
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    c1f2:	2601      	movs	r6, #1
        data_tmp = img_dsc->data + ofs;
    c1f4:	686a      	ldr	r2, [r5, #4]
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    c1f6:	4086      	lsls	r6, r0
        data_tmp = img_dsc->data + ofs;
    c1f8:	6892      	ldr	r2, [r2, #8]
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];

        pos -= px_size;
    c1fa:	b240      	sxtb	r0, r0
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    c1fc:	3e01      	subs	r6, #1
        if(pos < 0) {
            pos = 8 - px_size;
    c1fe:	f1c0 0e08 	rsb	lr, r0, #8
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    c202:	b2b6      	uxth	r6, r6
        data_tmp = img_dsc->data + ofs;
    c204:	4413      	add	r3, r2
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    c206:	3703      	adds	r7, #3
            pos = 8 - px_size;
    c208:	fa4f fe8e 	sxtb.w	lr, lr
    for(i = 0; i < len; i++) {
    c20c:	b20a      	sxth	r2, r1
    c20e:	4590      	cmp	r8, r2
    c210:	dc2f      	bgt.n	c272 <lv_img_decoder_built_in_read_line+0x13a>
        }
    }
#if LV_USE_FILESYSTEM
    _lv_mem_buf_release(fs_buf);
#endif
    return LV_RES_OK;
    c212:	2001      	movs	r0, #1
    c214:	e79f      	b.n	c156 <lv_img_decoder_built_in_read_line+0x1e>
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
    c216:	692a      	ldr	r2, [r5, #16]
            opa_table = alpha2_opa_table;
    c218:	f10d 0c04 	add.w	ip, sp, #4
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
    c21c:	f3c2 3308 	ubfx	r3, r2, #12, #9
            if(dsc->header.w & 0x3) w++;
    c220:	f412 6f40 	tst.w	r2, #3072	; 0xc00
            ofs += w * y + (x >> 2); /*First pixel*/
    c224:	ea4f 02a4 	mov.w	r2, r4, asr #2
            pos       = 6 - ((x & 0x3) * 2);
    c228:	ea6f 0404 	mvn.w	r4, r4
            if(dsc->header.w & 0x3) w++;
    c22c:	bf18      	it	ne
    c22e:	3301      	addne	r3, #1
            pos       = 6 - ((x & 0x3) * 2);
    c230:	f004 0403 	and.w	r4, r4, #3
            ofs += w * y + (x >> 2); /*First pixel*/
    c234:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 6 - ((x & 0x3) * 2);
    c238:	0064      	lsls	r4, r4, #1
            break;
    c23a:	e7d7      	b.n	c1ec <lv_img_decoder_built_in_read_line+0xb4>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
    c23c:	692a      	ldr	r2, [r5, #16]
            pos       = 4 - ((x & 0x1) * 4);
    c23e:	46cc      	mov	ip, r9
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
    c240:	f3c2 23c9 	ubfx	r3, r2, #11, #10
            if(dsc->header.w & 0x1) w++;
    c244:	0551      	lsls	r1, r2, #21
    c246:	bf48      	it	mi
    c248:	3301      	addmi	r3, #1
            ofs += w * y + (x >> 1); /*First pixel*/
    c24a:	1062      	asrs	r2, r4, #1
            pos       = 4 - ((x & 0x1) * 4);
    c24c:	f014 0f01 	tst.w	r4, #1
    c250:	bf0c      	ite	eq
    c252:	2404      	moveq	r4, #4
    c254:	2400      	movne	r4, #0
            ofs += w * y + (x >> 1); /*First pixel*/
    c256:	fb03 2306 	mla	r3, r3, r6, r2
            pos       = 4 - ((x & 0x1) * 4);
    c25a:	e7c7      	b.n	c1ec <lv_img_decoder_built_in_read_line+0xb4>
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
    c25c:	692b      	ldr	r3, [r5, #16]
    c25e:	f3c3 238a 	ubfx	r3, r3, #10, #11
            ofs += w * y + x;  /*First pixel*/
    c262:	fb16 4303 	smlabb	r3, r6, r3, r4
            pos = 0;
    c266:	2400      	movs	r4, #0
    switch(dsc->header.cf) {
    c268:	46a4      	mov	ip, r4
    c26a:	e7bf      	b.n	c1ec <lv_img_decoder_built_in_read_line+0xb4>
    c26c:	2400      	movs	r4, #0
    c26e:	4623      	mov	r3, r4
    c270:	e7fa      	b.n	c268 <lv_img_decoder_built_in_read_line+0x130>
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
    c272:	781a      	ldrb	r2, [r3, #0]
    c274:	fa06 f904 	lsl.w	r9, r6, r4
    c278:	ea02 0209 	and.w	r2, r2, r9
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
    c27c:	f895 9010 	ldrb.w	r9, [r5, #16]
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
    c280:	4122      	asrs	r2, r4
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    c282:	f009 091f 	and.w	r9, r9, #31
    c286:	f1b9 0f0e 	cmp.w	r9, #14
    c28a:	b2d2      	uxtb	r2, r2
        pos -= px_size;
    c28c:	eba4 0400 	sub.w	r4, r4, r0
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    c290:	bf18      	it	ne
    c292:	f81c 2002 	ldrbne.w	r2, [ip, r2]
        pos -= px_size;
    c296:	b264      	sxtb	r4, r4
        if(pos < 0) {
    c298:	2c00      	cmp	r4, #0
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
    c29a:	f807 2021 	strb.w	r2, [r7, r1, lsl #2]
            pos = 8 - px_size;
    c29e:	bfbc      	itt	lt
    c2a0:	4674      	movlt	r4, lr
            data_tmp++;
    c2a2:	3301      	addlt	r3, #1
    for(i = 0; i < len; i++) {
    c2a4:	3101      	adds	r1, #1
    c2a6:	e7b1      	b.n	c20c <lv_img_decoder_built_in_read_line+0xd4>
    else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
    c2a8:	3b07      	subs	r3, #7
    c2aa:	2b03      	cmp	r3, #3
    c2ac:	f63f af52 	bhi.w	c154 <lv_img_decoder_built_in_read_line+0x1c>
    uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf);
    c2b0:	f000 001f 	and.w	r0, r0, #31
    c2b4:	f7fe fbd4 	bl	aa60 <lv_img_cf_get_px_size>
    switch(dsc->header.cf) {
    c2b8:	7c2b      	ldrb	r3, [r5, #16]
    c2ba:	f003 031f 	and.w	r3, r3, #31
    c2be:	3b07      	subs	r3, #7
    c2c0:	2b03      	cmp	r3, #3
    c2c2:	d86e      	bhi.n	c3a2 <lv_img_decoder_built_in_read_line+0x26a>
    c2c4:	e8df f003 	tbb	[pc, r3]
    c2c8:	64544202 	.word	0x64544202
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
    c2cc:	692a      	ldr	r2, [r5, #16]
    c2ce:	f3c2 3347 	ubfx	r3, r2, #13, #8
            if(dsc->header.w & 0x7) w++;
    c2d2:	f412 5fe0 	tst.w	r2, #7168	; 0x1c00
            ofs += w * y + (x >> 3); /*First pixel*/
    c2d6:	ea4f 02e4 	mov.w	r2, r4, asr #3
            pos = 7 - (x & 0x7);
    c2da:	ea6f 0404 	mvn.w	r4, r4
            if(dsc->header.w & 0x7) w++;
    c2de:	bf18      	it	ne
    c2e0:	3301      	addne	r3, #1
            ofs += w * y + (x >> 3); /*First pixel*/
    c2e2:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 7 - (x & 0x7);
    c2e6:	f004 0407 	and.w	r4, r4, #7
            ofs += 8;                /*Skip the palette*/
    c2ea:	3308      	adds	r3, #8
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
    c2ec:	7b2a      	ldrb	r2, [r5, #12]
    c2ee:	2a00      	cmp	r2, #0
    c2f0:	f47f af30 	bne.w	c154 <lv_img_decoder_built_in_read_line+0x1c>
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    c2f4:	6a2e      	ldr	r6, [r5, #32]
        data_tmp                     = img_dsc->data + ofs;
    c2f6:	686d      	ldr	r5, [r5, #4]
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    c2f8:	2101      	movs	r1, #1
        data_tmp                     = img_dsc->data + ofs;
    c2fa:	68ad      	ldr	r5, [r5, #8]
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    c2fc:	4081      	lsls	r1, r0
        data_tmp                     = img_dsc->data + ofs;
    c2fe:	442b      	add	r3, r5
    for(i = 0; i < len; i++) {
    c300:	4615      	mov	r5, r2
        pos -= px_size;
    c302:	b240      	sxtb	r0, r0
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    c304:	3901      	subs	r1, #1
            pos = 8 - px_size;
    c306:	f1c0 0c08 	rsb	ip, r0, #8
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
    c30a:	fa1f f981 	uxth.w	r9, r1
    c30e:	3f04      	subs	r7, #4
            pos = 8 - px_size;
    c310:	fa4f fc8c 	sxtb.w	ip, ip
    for(i = 0; i < len; i++) {
    c314:	b22a      	sxth	r2, r5
    c316:	4590      	cmp	r8, r2
    c318:	f77f af7b 	ble.w	c212 <lv_img_decoder_built_in_read_line+0xda>
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
    c31c:	781a      	ldrb	r2, [r3, #0]
    c31e:	fa09 fe04 	lsl.w	lr, r9, r4
    c322:	ea02 020e 	and.w	r2, r2, lr
        lv_color_t color = user_data->palette[val_act];
    c326:	6831      	ldr	r1, [r6, #0]
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
    c328:	4122      	asrs	r2, r4
        lv_color_t color = user_data->palette[val_act];
    c32a:	b2d2      	uxtb	r2, r2
    c32c:	f851 e022 	ldr.w	lr, [r1, r2, lsl #2]
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
    c330:	6871      	ldr	r1, [r6, #4]
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = color.full;
    c332:	f847 ef04 	str.w	lr, [r7, #4]!
        pos -= px_size;
    c336:	1a24      	subs	r4, r4, r0
    c338:	b264      	sxtb	r4, r4
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
    c33a:	5c8a      	ldrb	r2, [r1, r2]
        if(pos < 0) {
    c33c:	2c00      	cmp	r4, #0
            pos = 8 - px_size;
    c33e:	bfb8      	it	lt
    c340:	4664      	movlt	r4, ip
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
    c342:	70fa      	strb	r2, [r7, #3]
            data_tmp++;
    c344:	bfb8      	it	lt
    c346:	3301      	addlt	r3, #1
    for(i = 0; i < len; i++) {
    c348:	3501      	adds	r5, #1
    c34a:	e7e3      	b.n	c314 <lv_img_decoder_built_in_read_line+0x1dc>
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
    c34c:	692a      	ldr	r2, [r5, #16]
    c34e:	f3c2 3308 	ubfx	r3, r2, #12, #9
            if(dsc->header.w & 0x3) w++;
    c352:	f412 6f40 	tst.w	r2, #3072	; 0xc00
            ofs += w * y + (x >> 2); /*First pixel*/
    c356:	ea4f 02a4 	mov.w	r2, r4, asr #2
            pos = 6 - ((x & 0x3) * 2);
    c35a:	ea6f 0404 	mvn.w	r4, r4
            if(dsc->header.w & 0x3) w++;
    c35e:	bf18      	it	ne
    c360:	3301      	addne	r3, #1
            ofs += w * y + (x >> 2); /*First pixel*/
    c362:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 6 - ((x & 0x3) * 2);
    c366:	f004 0403 	and.w	r4, r4, #3
            ofs += 16;               /*Skip the palette*/
    c36a:	3310      	adds	r3, #16
            pos = 6 - ((x & 0x3) * 2);
    c36c:	0064      	lsls	r4, r4, #1
            break;
    c36e:	e7bd      	b.n	c2ec <lv_img_decoder_built_in_read_line+0x1b4>
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
    c370:	692a      	ldr	r2, [r5, #16]
    c372:	f3c2 23c9 	ubfx	r3, r2, #11, #10
            if(dsc->header.w & 0x1) w++;
    c376:	0552      	lsls	r2, r2, #21
    c378:	bf48      	it	mi
    c37a:	3301      	addmi	r3, #1
            ofs += w * y + (x >> 1); /*First pixel*/
    c37c:	1062      	asrs	r2, r4, #1
    c37e:	fb03 2306 	mla	r3, r3, r6, r2
            pos = 4 - ((x & 0x1) * 4);
    c382:	f014 0f01 	tst.w	r4, #1
    c386:	bf0c      	ite	eq
    c388:	2404      	moveq	r4, #4
    c38a:	2400      	movne	r4, #0
            ofs += 64;               /*Skip the palette*/
    c38c:	3340      	adds	r3, #64	; 0x40
            pos = 4 - ((x & 0x1) * 4);
    c38e:	e7ad      	b.n	c2ec <lv_img_decoder_built_in_read_line+0x1b4>
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
    c390:	692b      	ldr	r3, [r5, #16]
    c392:	f3c3 238a 	ubfx	r3, r3, #10, #11
            ofs += w * y + x;  /*First pixel*/
    c396:	fb16 4303 	smlabb	r3, r6, r3, r4
            pos = 0;
    c39a:	2400      	movs	r4, #0
            ofs += 1024;       /*Skip the palette*/
    c39c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
            break;
    c3a0:	e7a4      	b.n	c2ec <lv_img_decoder_built_in_read_line+0x1b4>
    switch(dsc->header.cf) {
    c3a2:	2300      	movs	r3, #0
    c3a4:	461c      	mov	r4, r3
    c3a6:	e7a1      	b.n	c2ec <lv_img_decoder_built_in_read_line+0x1b4>
    c3a8:	0001dd8d 	.word	0x0001dd8d

0000c3ac <lv_img_decoder_built_in_info>:
{
    c3ac:	b538      	push	{r3, r4, r5, lr}
    lv_img_src_t src_type = lv_img_src_get_type(src);
    c3ae:	4608      	mov	r0, r1
{
    c3b0:	460d      	mov	r5, r1
    c3b2:	4614      	mov	r4, r2
    lv_img_src_t src_type = lv_img_src_get_type(src);
    c3b4:	f00c f8c5 	bl	18542 <lv_img_src_get_type>
    if(src_type == LV_IMG_SRC_VARIABLE) {
    c3b8:	b9c8      	cbnz	r0, c3ee <lv_img_decoder_built_in_info+0x42>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
    c3ba:	782b      	ldrb	r3, [r5, #0]
    c3bc:	f3c3 0304 	ubfx	r3, r3, #0, #5
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
    c3c0:	3b04      	subs	r3, #4
    c3c2:	b2db      	uxtb	r3, r3
    c3c4:	2b0a      	cmp	r3, #10
    c3c6:	d811      	bhi.n	c3ec <lv_img_decoder_built_in_info+0x40>
        header->h  = ((lv_img_dsc_t *)src)->header.h;
    c3c8:	886b      	ldrh	r3, [r5, #2]
    c3ca:	8862      	ldrh	r2, [r4, #2]
    c3cc:	f3c3 134a 	ubfx	r3, r3, #5, #11
    c3d0:	f363 124f 	bfi	r2, r3, #5, #11
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
    c3d4:	6829      	ldr	r1, [r5, #0]
        header->h  = ((lv_img_dsc_t *)src)->header.h;
    c3d6:	8062      	strh	r2, [r4, #2]
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
    c3d8:	6823      	ldr	r3, [r4, #0]
    c3da:	4a09      	ldr	r2, [pc, #36]	; (c400 <lv_img_decoder_built_in_info+0x54>)
    c3dc:	f023 131f 	bic.w	r3, r3, #2031647	; 0x1f001f
    c3e0:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
    c3e4:	400a      	ands	r2, r1
    return LV_RES_OK;
    c3e6:	2001      	movs	r0, #1
        header->cf = LV_IMG_CF_ALPHA_1BIT;
    c3e8:	4313      	orrs	r3, r2
    c3ea:	6023      	str	r3, [r4, #0]
}
    c3ec:	bd38      	pop	{r3, r4, r5, pc}
    else if(src_type == LV_IMG_SRC_SYMBOL) {
    c3ee:	2802      	cmp	r0, #2
    c3f0:	d104      	bne.n	c3fc <lv_img_decoder_built_in_info+0x50>
        header->cf = LV_IMG_CF_ALPHA_1BIT;
    c3f2:	6823      	ldr	r3, [r4, #0]
    c3f4:	f403 7278 	and.w	r2, r3, #992	; 0x3e0
    c3f8:	4b02      	ldr	r3, [pc, #8]	; (c404 <lv_img_decoder_built_in_info+0x58>)
    c3fa:	e7f4      	b.n	c3e6 <lv_img_decoder_built_in_info+0x3a>
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
    c3fc:	2000      	movs	r0, #0
    c3fe:	e7f5      	b.n	c3ec <lv_img_decoder_built_in_info+0x40>
    c400:	001ffc1f 	.word	0x001ffc1f
    c404:	0020040b 	.word	0x0020040b

0000c408 <lv_img_decoder_get_info>:
    header->cf = LV_IMG_CF_UNKNOWN;
    c408:	680b      	ldr	r3, [r1, #0]
{
    c40a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    header->cf = LV_IMG_CF_UNKNOWN;
    c40e:	f403 7340 	and.w	r3, r3, #768	; 0x300
{
    c412:	4607      	mov	r7, r0
    header->cf = LV_IMG_CF_UNKNOWN;
    c414:	600b      	str	r3, [r1, #0]
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c416:	480d      	ldr	r0, [pc, #52]	; (c44c <lv_img_decoder_get_info+0x44>)
{
    c418:	460e      	mov	r6, r1
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c41a:	f00e fef6 	bl	1b20a <_lv_ll_get_head>
    lv_res_t res = LV_RES_INV;
    c41e:	2400      	movs	r4, #0
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c420:	4605      	mov	r5, r0
    c422:	f8df 8028 	ldr.w	r8, [pc, #40]	; c44c <lv_img_decoder_get_info+0x44>
    c426:	b915      	cbnz	r5, c42e <lv_img_decoder_get_info+0x26>
}
    c428:	4620      	mov	r0, r4
    c42a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(d->info_cb) {
    c42e:	682c      	ldr	r4, [r5, #0]
    c430:	b134      	cbz	r4, c440 <lv_img_decoder_get_info+0x38>
            res = d->info_cb(d, src, header);
    c432:	4632      	mov	r2, r6
    c434:	4639      	mov	r1, r7
    c436:	4628      	mov	r0, r5
    c438:	47a0      	blx	r4
            if(res == LV_RES_OK) break;
    c43a:	2801      	cmp	r0, #1
            res = d->info_cb(d, src, header);
    c43c:	4604      	mov	r4, r0
            if(res == LV_RES_OK) break;
    c43e:	d0f3      	beq.n	c428 <lv_img_decoder_get_info+0x20>
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c440:	4629      	mov	r1, r5
    c442:	4640      	mov	r0, r8
    c444:	f00e fee7 	bl	1b216 <_lv_ll_get_next>
    c448:	4605      	mov	r5, r0
    c44a:	e7ec      	b.n	c426 <lv_img_decoder_get_info+0x1e>
    c44c:	20025db0 	.word	0x20025db0

0000c450 <lv_img_decoder_open>:
{
    c450:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c454:	4605      	mov	r5, r0
    dsc->color     = color;
    c456:	6082      	str	r2, [r0, #8]
    dsc->src_type  = lv_img_src_get_type(src);
    c458:	4608      	mov	r0, r1
{
    c45a:	460f      	mov	r7, r1
    dsc->src_type  = lv_img_src_get_type(src);
    c45c:	f00c f871 	bl	18542 <lv_img_src_get_type>
    dsc->user_data = NULL;
    c460:	2300      	movs	r3, #0
    if(dsc->src_type == LV_IMG_SRC_FILE) {
    c462:	2801      	cmp	r0, #1
    dsc->src_type  = lv_img_src_get_type(src);
    c464:	7328      	strb	r0, [r5, #12]
    dsc->user_data = NULL;
    c466:	622b      	str	r3, [r5, #32]
    if(dsc->src_type == LV_IMG_SRC_FILE) {
    c468:	d117      	bne.n	c49a <lv_img_decoder_open+0x4a>
        size_t fnlen = strlen(src);
    c46a:	4638      	mov	r0, r7
    c46c:	f7f3 fffa 	bl	464 <strlen>
        dsc->src = lv_mem_alloc(fnlen + 1);
    c470:	3001      	adds	r0, #1
    c472:	f000 fb11 	bl	ca98 <lv_mem_alloc>
__ssp_bos_icheck2_restrict(stpcpy, char *, const char *)
#if __GNUC_PREREQ__(4,8) || defined(__clang__)
__ssp_bos_icheck3_restrict(stpncpy, char *, const char *)
#endif
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
    c476:	4639      	mov	r1, r7
    c478:	6068      	str	r0, [r5, #4]
    c47a:	f011 fa87 	bl	1d98c <strcpy>
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c47e:	4816      	ldr	r0, [pc, #88]	; (c4d8 <lv_img_decoder_open+0x88>)
    c480:	f00e fec3 	bl	1b20a <_lv_ll_get_head>
    lv_res_t res = LV_RES_INV;
    c484:	2600      	movs	r6, #0
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c486:	4604      	mov	r4, r0
        dsc->error_msg = NULL;
    c488:	46b0      	mov	r8, r6
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c48a:	f8df a04c 	ldr.w	sl, [pc, #76]	; c4d8 <lv_img_decoder_open+0x88>
        res = d->info_cb(d, src, &dsc->header);
    c48e:	f105 0910 	add.w	r9, r5, #16
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c492:	b924      	cbnz	r4, c49e <lv_img_decoder_open+0x4e>
}
    c494:	4630      	mov	r0, r6
    c496:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        dsc->src       = src;
    c49a:	606f      	str	r7, [r5, #4]
    c49c:	e7ef      	b.n	c47e <lv_img_decoder_open+0x2e>
        if(d->info_cb == NULL || d->open_cb == NULL) continue;
    c49e:	6823      	ldr	r3, [r4, #0]
    c4a0:	b1a3      	cbz	r3, c4cc <lv_img_decoder_open+0x7c>
    c4a2:	6862      	ldr	r2, [r4, #4]
    c4a4:	b192      	cbz	r2, c4cc <lv_img_decoder_open+0x7c>
        res = d->info_cb(d, src, &dsc->header);
    c4a6:	464a      	mov	r2, r9
    c4a8:	4639      	mov	r1, r7
    c4aa:	4620      	mov	r0, r4
    c4ac:	4798      	blx	r3
        if(res != LV_RES_OK) continue;
    c4ae:	2801      	cmp	r0, #1
        res = d->info_cb(d, src, &dsc->header);
    c4b0:	4606      	mov	r6, r0
        if(res != LV_RES_OK) continue;
    c4b2:	d10b      	bne.n	c4cc <lv_img_decoder_open+0x7c>
        res = d->open_cb(d, dsc);
    c4b4:	4629      	mov	r1, r5
    c4b6:	4620      	mov	r0, r4
    c4b8:	6863      	ldr	r3, [r4, #4]
        dsc->error_msg = NULL;
    c4ba:	f8c5 801c 	str.w	r8, [r5, #28]
        dsc->img_data  = NULL;
    c4be:	f8c5 8014 	str.w	r8, [r5, #20]
        dsc->decoder   = d;
    c4c2:	602c      	str	r4, [r5, #0]
        res = d->open_cb(d, dsc);
    c4c4:	4798      	blx	r3
        if(res == LV_RES_OK) break;
    c4c6:	2801      	cmp	r0, #1
        res = d->open_cb(d, dsc);
    c4c8:	4606      	mov	r6, r0
        if(res == LV_RES_OK) break;
    c4ca:	d0e3      	beq.n	c494 <lv_img_decoder_open+0x44>
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
    c4cc:	4621      	mov	r1, r4
    c4ce:	4650      	mov	r0, sl
    c4d0:	f00e fea1 	bl	1b216 <_lv_ll_get_next>
    c4d4:	4604      	mov	r4, r0
    c4d6:	e7dc      	b.n	c492 <lv_img_decoder_open+0x42>
    c4d8:	20025db0 	.word	0x20025db0

0000c4dc <lv_img_decoder_create>:
{
    c4dc:	b510      	push	{r4, lr}
    decoder = _lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
    c4de:	4805      	ldr	r0, [pc, #20]	; (c4f4 <lv_img_decoder_create+0x18>)
    c4e0:	f00e fe5c 	bl	1b19c <_lv_ll_ins_head>
    if(decoder == NULL) return NULL;
    c4e4:	4604      	mov	r4, r0
    c4e6:	b110      	cbz	r0, c4ee <lv_img_decoder_create+0x12>
    _lv_memset_00(decoder, sizeof(lv_img_decoder_t));
    c4e8:	2114      	movs	r1, #20
    c4ea:	f00e fa45 	bl	1a978 <_lv_memset_00>
}
    c4ee:	4620      	mov	r0, r4
    c4f0:	bd10      	pop	{r4, pc}
    c4f2:	bf00      	nop
    c4f4:	20025db0 	.word	0x20025db0

0000c4f8 <_lv_img_decoder_init>:
{
    c4f8:	b508      	push	{r3, lr}
    _lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
    c4fa:	2114      	movs	r1, #20
    c4fc:	4807      	ldr	r0, [pc, #28]	; (c51c <_lv_img_decoder_init+0x24>)
    c4fe:	f00e fe45 	bl	1b18c <_lv_ll_init>
    decoder = lv_img_decoder_create();
    c502:	f7ff ffeb 	bl	c4dc <lv_img_decoder_create>
    if(decoder == NULL) {
    c506:	b138      	cbz	r0, c518 <_lv_img_decoder_init+0x20>
    decoder->info_cb = info_cb;
    c508:	4b05      	ldr	r3, [pc, #20]	; (c520 <_lv_img_decoder_init+0x28>)
    c50a:	6003      	str	r3, [r0, #0]
    decoder->open_cb = open_cb;
    c50c:	4b05      	ldr	r3, [pc, #20]	; (c524 <_lv_img_decoder_init+0x2c>)
    c50e:	6043      	str	r3, [r0, #4]
    decoder->read_line_cb = read_line_cb;
    c510:	4b05      	ldr	r3, [pc, #20]	; (c528 <_lv_img_decoder_init+0x30>)
    c512:	6083      	str	r3, [r0, #8]
    decoder->close_cb = close_cb;
    c514:	4b05      	ldr	r3, [pc, #20]	; (c52c <_lv_img_decoder_init+0x34>)
    c516:	60c3      	str	r3, [r0, #12]
}
    c518:	bd08      	pop	{r3, pc}
    c51a:	bf00      	nop
    c51c:	20025db0 	.word	0x20025db0
    c520:	0000c3ad 	.word	0x0000c3ad
    c524:	0001a981 	.word	0x0001a981
    c528:	0000c139 	.word	0x0000c139
    c52c:	0001a955 	.word	0x0001a955

0000c530 <lv_disp_drv_init>:
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_disp_drv_init(lv_disp_drv_t * driver)
{
    c530:	b510      	push	{r4, lr}
    _lv_memset_00(driver, sizeof(lv_disp_drv_t));
    c532:	2130      	movs	r1, #48	; 0x30
{
    c534:	4604      	mov	r4, r0
    _lv_memset_00(driver, sizeof(lv_disp_drv_t));
    c536:	f00e faaf 	bl	1aa98 <_lv_memset_00>

    driver->flush_cb         = NULL;
    c53a:	2200      	movs	r2, #0
    driver->hor_res          = LV_HOR_RES_MAX;
    c53c:	4b09      	ldr	r3, [pc, #36]	; (c564 <lv_disp_drv_init+0x34>)
    driver->flush_cb         = NULL;
    c53e:	60e2      	str	r2, [r4, #12]
    driver->ver_res          = LV_VER_RES_MAX;
    driver->buffer           = NULL;
    c540:	e9c4 3200 	strd	r3, r2, [r4]
    driver->rotated          = 0;
    driver->color_chroma_key = LV_COLOR_TRANSP;
    driver->dpi = LV_DPI;

#if LV_ANTIALIAS
    driver->antialiasing = true;
    c544:	8923      	ldrh	r3, [r4, #8]

#if LV_USE_USER_DATA
    driver->user_data = NULL;
#endif

    driver->set_px_cb = NULL;
    c546:	6162      	str	r2, [r4, #20]
    driver->antialiasing = true;
    c548:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
    c54c:	f023 030f 	bic.w	r3, r3, #15
    c550:	f443 7302 	orr.w	r3, r3, #520	; 0x208
    c554:	f043 0301 	orr.w	r3, r3, #1
    c558:	8123      	strh	r3, [r4, #8]
    driver->color_chroma_key = LV_COLOR_TRANSP;
    c55a:	f04f 23ff 	mov.w	r3, #4278255360	; 0xff00ff00
    driver->user_data = NULL;
    c55e:	e9c4 320a 	strd	r3, r2, [r4, #40]	; 0x28
}
    c562:	bd10      	pop	{r4, pc}
    c564:	00f00140 	.word	0x00f00140

0000c568 <lv_disp_get_default>:
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
    return disp_def;
}
    c568:	4b01      	ldr	r3, [pc, #4]	; (c570 <lv_disp_get_default+0x8>)
    c56a:	6818      	ldr	r0, [r3, #0]
    c56c:	4770      	bx	lr
    c56e:	bf00      	nop
    c570:	20025d04 	.word	0x20025d04

0000c574 <lv_disp_get_hor_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
    c574:	b910      	cbnz	r0, c57c <lv_disp_get_hor_res+0x8>
    return disp_def;
    c576:	4b07      	ldr	r3, [pc, #28]	; (c594 <lv_disp_get_hor_res+0x20>)
    c578:	6818      	ldr	r0, [r3, #0]

    if(disp == NULL)
    c57a:	b138      	cbz	r0, c58c <lv_disp_get_hor_res+0x18>
        return LV_HOR_RES_MAX;
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
    c57c:	7a03      	ldrb	r3, [r0, #8]
    c57e:	079b      	lsls	r3, r3, #30
    c580:	bf54      	ite	pl
    c582:	f9b0 0000 	ldrshpl.w	r0, [r0]
    c586:	f9b0 0002 	ldrshmi.w	r0, [r0, #2]
    c58a:	4770      	bx	lr
        return LV_HOR_RES_MAX;
    c58c:	f44f 70a0 	mov.w	r0, #320	; 0x140
}
    c590:	4770      	bx	lr
    c592:	bf00      	nop
    c594:	20025d04 	.word	0x20025d04

0000c598 <lv_disp_get_ver_res>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
    c598:	b910      	cbnz	r0, c5a0 <lv_disp_get_ver_res+0x8>
    return disp_def;
    c59a:	4b06      	ldr	r3, [pc, #24]	; (c5b4 <lv_disp_get_ver_res+0x1c>)
    c59c:	6818      	ldr	r0, [r3, #0]

    if(disp == NULL)
    c59e:	b138      	cbz	r0, c5b0 <lv_disp_get_ver_res+0x18>
        return LV_VER_RES_MAX;
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
    c5a0:	7a03      	ldrb	r3, [r0, #8]
    c5a2:	079b      	lsls	r3, r3, #30
    c5a4:	bf54      	ite	pl
    c5a6:	f9b0 0002 	ldrshpl.w	r0, [r0, #2]
    c5aa:	f9b0 0000 	ldrshmi.w	r0, [r0]
    c5ae:	4770      	bx	lr
        return LV_VER_RES_MAX;
    c5b0:	20f0      	movs	r0, #240	; 0xf0
}
    c5b2:	4770      	bx	lr
    c5b4:	20025d04 	.word	0x20025d04

0000c5b8 <lv_disp_get_dpi>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return dpi of the display
 */
lv_coord_t lv_disp_get_dpi(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
    c5b8:	b910      	cbnz	r0, c5c0 <lv_disp_get_dpi+0x8>
    return disp_def;
    c5ba:	4b04      	ldr	r3, [pc, #16]	; (c5cc <lv_disp_get_dpi+0x14>)
    c5bc:	6818      	ldr	r0, [r3, #0]
    if(disp == NULL) return LV_DPI;  /*Do not return 0 because it might be a divider*/
    c5be:	b118      	cbz	r0, c5c8 <lv_disp_get_dpi+0x10>
    return disp->driver.dpi;
    c5c0:	8900      	ldrh	r0, [r0, #8]
    c5c2:	f3c0 0089 	ubfx	r0, r0, #2, #10
    c5c6:	4770      	bx	lr
    if(disp == NULL) return LV_DPI;  /*Do not return 0 because it might be a divider*/
    c5c8:	2082      	movs	r0, #130	; 0x82
}
    c5ca:	4770      	bx	lr
    c5cc:	20025d04 	.word	0x20025d04

0000c5d0 <lv_disp_get_size_category>:
 * @param disp pointer to a display (NULL to use the default display)
 * @return LV_DISP_SIZE_SMALL/MEDIUM/LARGE/EXTRA_LARGE
 */
lv_disp_size_t lv_disp_get_size_category(lv_disp_t * disp)
{
    if(disp == NULL) disp = lv_disp_get_default();
    c5d0:	4602      	mov	r2, r0
{
    c5d2:	b508      	push	{r3, lr}
    if(disp == NULL) disp = lv_disp_get_default();
    c5d4:	b910      	cbnz	r0, c5dc <lv_disp_get_size_category+0xc>
    return disp_def;
    c5d6:	4b0f      	ldr	r3, [pc, #60]	; (c614 <lv_disp_get_size_category+0x44>)
    c5d8:	681a      	ldr	r2, [r3, #0]

    uint32_t w;
    if(disp == NULL) w = LV_HOR_RES_MAX;
    c5da:	b19a      	cbz	r2, c604 <lv_disp_get_size_category+0x34>
    else w = lv_disp_get_hor_res(disp);
    c5dc:	4610      	mov	r0, r2
    c5de:	f7ff ffc9 	bl	c574 <lv_disp_get_hor_res>
    c5e2:	4601      	mov	r1, r0

    uint32_t dpi = lv_disp_get_dpi(disp);
    c5e4:	4610      	mov	r0, r2
    c5e6:	f7ff ffe7 	bl	c5b8 <lv_disp_get_dpi>

    w = w * 10 / dpi;
    c5ea:	230a      	movs	r3, #10
    c5ec:	434b      	muls	r3, r1
    c5ee:	fbb3 f0f0 	udiv	r0, r3, r0

    if(w < LV_DISP_SMALL_LIMIT) return LV_DISP_SIZE_SMALL;
    c5f2:	281d      	cmp	r0, #29
    c5f4:	d909      	bls.n	c60a <lv_disp_get_size_category+0x3a>
    if(w < LV_DISP_MEDIUM_LIMIT) return LV_DISP_SIZE_MEDIUM;
    c5f6:	2831      	cmp	r0, #49	; 0x31
    c5f8:	d909      	bls.n	c60e <lv_disp_get_size_category+0x3e>
    if(w < LV_DISP_LARGE_LIMIT) return LV_DISP_SIZE_LARGE;
    else return LV_DISP_SIZE_EXTRA_LARGE;
    c5fa:	2846      	cmp	r0, #70	; 0x46
    c5fc:	bf34      	ite	cc
    c5fe:	2002      	movcc	r0, #2
    c600:	2003      	movcs	r0, #3
}
    c602:	bd08      	pop	{r3, pc}
    if(disp == NULL) w = LV_HOR_RES_MAX;
    c604:	f44f 71a0 	mov.w	r1, #320	; 0x140
    c608:	e7ec      	b.n	c5e4 <lv_disp_get_size_category+0x14>
    if(w < LV_DISP_SMALL_LIMIT) return LV_DISP_SIZE_SMALL;
    c60a:	2000      	movs	r0, #0
    c60c:	e7f9      	b.n	c602 <lv_disp_get_size_category+0x32>
    if(w < LV_DISP_MEDIUM_LIMIT) return LV_DISP_SIZE_MEDIUM;
    c60e:	2001      	movs	r0, #1
    c610:	e7f7      	b.n	c602 <lv_disp_get_size_category+0x32>
    c612:	bf00      	nop
    c614:	20025d04 	.word	0x20025d04

0000c618 <lv_disp_get_next>:
 * @param disp pointer to the current display. NULL to initialize.
 * @return the next display or NULL if no more. Give the first display when the parameter is NULL
 */
lv_disp_t * lv_disp_get_next(lv_disp_t * disp)
{
    if(disp == NULL)
    c618:	4601      	mov	r1, r0
        return _lv_ll_get_head(&LV_GC_ROOT(_lv_disp_ll));
    c61a:	4803      	ldr	r0, [pc, #12]	; (c628 <lv_disp_get_next+0x10>)
    if(disp == NULL)
    c61c:	b909      	cbnz	r1, c622 <lv_disp_get_next+0xa>
        return _lv_ll_get_head(&LV_GC_ROOT(_lv_disp_ll));
    c61e:	f00e bdf4 	b.w	1b20a <_lv_ll_get_head>
    else
        return _lv_ll_get_next(&LV_GC_ROOT(_lv_disp_ll), disp);
    c622:	f00e bdf8 	b.w	1b216 <_lv_ll_get_next>
    c626:	bf00      	nop
    c628:	20025d1c 	.word	0x20025d1c

0000c62c <lv_disp_drv_register>:
{
    c62c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c62e:	4605      	mov	r5, r0
    lv_disp_t * disp = _lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
    c630:	4831      	ldr	r0, [pc, #196]	; (c6f8 <lv_disp_drv_register+0xcc>)
    c632:	f00e fdb3 	bl	1b19c <_lv_ll_ins_head>
    if(!disp) {
    c636:	4604      	mov	r4, r0
    c638:	b910      	cbnz	r0, c640 <lv_disp_drv_register+0x14>
        return NULL;
    c63a:	2400      	movs	r4, #0
}
    c63c:	4620      	mov	r0, r4
    c63e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    _lv_memset_00(disp, sizeof(lv_disp_t));
    c640:	f44f 71c2 	mov.w	r1, #388	; 0x184
    c644:	f00e fa28 	bl	1aa98 <_lv_memset_00>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    c648:	4628      	mov	r0, r5
    c64a:	4623      	mov	r3, r4
    c64c:	f105 0230 	add.w	r2, r5, #48	; 0x30
    c650:	f850 1b04 	ldr.w	r1, [r0], #4
    c654:	4290      	cmp	r0, r2
    c656:	f843 1b04 	str.w	r1, [r3], #4
    c65a:	d1f9      	bne.n	c650 <lv_disp_drv_register+0x24>
    _lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
    c65c:	213c      	movs	r1, #60	; 0x3c
    c65e:	f104 0034 	add.w	r0, r4, #52	; 0x34
    c662:	f00e fd93 	bl	1b18c <_lv_ll_init>
    disp->last_activity_time = 0;
    c666:	2300      	movs	r3, #0
    if(disp_def == NULL) disp_def = disp;
    c668:	4e24      	ldr	r6, [pc, #144]	; (c6fc <lv_disp_drv_register+0xd0>)
    disp->last_activity_time = 0;
    c66a:	f8c4 3180 	str.w	r3, [r4, #384]	; 0x180
    if(disp_def == NULL) disp_def = disp;
    c66e:	6833      	ldr	r3, [r6, #0]
    c670:	b903      	cbnz	r3, c674 <lv_disp_drv_register+0x48>
    c672:	6034      	str	r4, [r6, #0]
    disp->refr_task = lv_task_create(_lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_REFR_TASK_PRIO, disp);
    c674:	4623      	mov	r3, r4
    c676:	2203      	movs	r2, #3
    c678:	211e      	movs	r1, #30
    c67a:	4821      	ldr	r0, [pc, #132]	; (c700 <lv_disp_drv_register+0xd4>)
    lv_disp_t * disp_def_tmp = disp_def;
    c67c:	6837      	ldr	r7, [r6, #0]
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
    c67e:	6034      	str	r4, [r6, #0]
    disp->refr_task = lv_task_create(_lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_REFR_TASK_PRIO, disp);
    c680:	f00e fefc 	bl	1b47c <lv_task_create>
    c684:	6320      	str	r0, [r4, #48]	; 0x30
    if(disp->refr_task == NULL) return NULL;
    c686:	2800      	cmp	r0, #0
    c688:	d0d7      	beq.n	c63a <lv_disp_drv_register+0xe>
    disp->inv_p = 0;
    c68a:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
    disp->last_activity_time = 0;
    c68e:	2500      	movs	r5, #0
    disp->inv_p = 0;
    c690:	f36f 0309 	bfc	r3, #0, #10
    c694:	f8a4 317e 	strh.w	r3, [r4, #382]	; 0x17e
    disp->bg_color = LV_COLOR_WHITE;
    c698:	f04f 33ff 	mov.w	r3, #4294967295
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    c69c:	4629      	mov	r1, r5
    disp->bg_img = NULL;
    c69e:	e9c4 3515 	strd	r3, r5, [r4, #84]	; 0x54
    disp->bg_opa = LV_OPA_COVER;
    c6a2:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    c6a6:	4628      	mov	r0, r5
    disp->last_activity_time = 0;
    c6a8:	f8c4 5180 	str.w	r5, [r4, #384]	; 0x180
    disp->prev_scr  = NULL;
    c6ac:	6465      	str	r5, [r4, #68]	; 0x44
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    c6ae:	f7fc fe8d 	bl	93cc <lv_obj_create>
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    c6b2:	4629      	mov	r1, r5
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
    c6b4:	6420      	str	r0, [r4, #64]	; 0x40
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    c6b6:	4628      	mov	r0, r5
    c6b8:	f7fc fe88 	bl	93cc <lv_obj_create>
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    c6bc:	4629      	mov	r1, r5
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
    c6be:	64a0      	str	r0, [r4, #72]	; 0x48
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    c6c0:	4628      	mov	r0, r5
    c6c2:	f7fc fe83 	bl	93cc <lv_obj_create>
    lv_obj_reset_style_list(disp->top_layer, LV_OBJ_PART_MAIN);
    c6c6:	4629      	mov	r1, r5
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
    c6c8:	64e0      	str	r0, [r4, #76]	; 0x4c
    lv_obj_reset_style_list(disp->top_layer, LV_OBJ_PART_MAIN);
    c6ca:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    c6cc:	f009 fc56 	bl	15f7c <lv_obj_reset_style_list>
    lv_obj_reset_style_list(disp->sys_layer, LV_OBJ_PART_MAIN);
    c6d0:	4629      	mov	r1, r5
    c6d2:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    c6d4:	f009 fc52 	bl	15f7c <lv_obj_reset_style_list>
    lv_obj_set_click(disp->top_layer, false);
    c6d8:	4629      	mov	r1, r5
    c6da:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    c6dc:	f008 fff9 	bl	156d2 <lv_obj_set_click>
    lv_obj_set_click(disp->sys_layer, false);
    c6e0:	4629      	mov	r1, r5
    c6e2:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    c6e4:	f008 fff5 	bl	156d2 <lv_obj_set_click>
    lv_obj_invalidate(disp->act_scr);
    c6e8:	6c20      	ldr	r0, [r4, #64]	; 0x40
    c6ea:	f009 f899 	bl	15820 <lv_obj_invalidate>
    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
    c6ee:	6b20      	ldr	r0, [r4, #48]	; 0x30
    disp_def = disp_def_tmp; /*Revert the default display*/
    c6f0:	6037      	str	r7, [r6, #0]
    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
    c6f2:	f00e fed7 	bl	1b4a4 <lv_task_ready>
    if(lv_disp_is_true_double_buf(disp) && disp->driver.set_px_cb) {
    c6f6:	e7a1      	b.n	c63c <lv_disp_drv_register+0x10>
    c6f8:	20025d1c 	.word	0x20025d1c
    c6fc:	20025d04 	.word	0x20025d04
    c700:	0000a62d 	.word	0x0000a62d

0000c704 <lv_indev_drv_init>:
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_indev_drv_init(lv_indev_drv_t * driver)
{
    c704:	b510      	push	{r4, lr}
    _lv_memset_00(driver, sizeof(lv_indev_drv_t));
    c706:	2120      	movs	r1, #32
{
    c708:	4604      	mov	r4, r0
    _lv_memset_00(driver, sizeof(lv_indev_drv_t));
    c70a:	f00e fa0b 	bl	1ab24 <_lv_memset_00>

    driver->type                 = LV_INDEV_TYPE_NONE;
    c70e:	2300      	movs	r3, #0
    driver->drag_limit           = LV_INDEV_DEF_DRAG_LIMIT;
    driver->drag_throw           = LV_INDEV_DEF_DRAG_THROW;
    driver->long_press_time      = LV_INDEV_DEF_LONG_PRESS_TIME;
    c710:	4a02      	ldr	r2, [pc, #8]	; (c71c <lv_indev_drv_init+0x18>)
    driver->type                 = LV_INDEV_TYPE_NONE;
    c712:	7023      	strb	r3, [r4, #0]
    driver->long_press_time      = LV_INDEV_DEF_LONG_PRESS_TIME;
    c714:	4b02      	ldr	r3, [pc, #8]	; (c720 <lv_indev_drv_init+0x1c>)
    c716:	e9c4 2306 	strd	r2, r3, [r4, #24]
    driver->long_press_rep_time  = LV_INDEV_DEF_LONG_PRESS_REP_TIME;
    driver->gesture_limit        = LV_INDEV_DEF_GESTURE_LIMIT;
    driver->gesture_min_velocity = LV_INDEV_DEF_GESTURE_MIN_VELOCITY;
}
    c71a:	bd10      	pop	{r4, pc}
    c71c:	32030a0a 	.word	0x32030a0a
    c720:	00640190 	.word	0x00640190

0000c724 <lv_indev_drv_register>:
 * Register an initialized input device driver.
 * @param driver pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)
 * @return pointer to the new input device or NULL on error
 */
lv_indev_t * lv_indev_drv_register(lv_indev_drv_t * driver)
{
    c724:	b538      	push	{r3, r4, r5, lr}

    if(driver->disp == NULL) driver->disp = lv_disp_get_default();
    c726:	6903      	ldr	r3, [r0, #16]
{
    c728:	4605      	mov	r5, r0
    if(driver->disp == NULL) driver->disp = lv_disp_get_default();
    c72a:	b133      	cbz	r3, c73a <lv_indev_drv_register+0x16>
        LV_LOG_WARN("lv_indev_drv_register: no display registered hence can't attach the indev to "
                    "a display");
        return NULL;
    }

    lv_indev_t * indev = _lv_ll_ins_head(&LV_GC_ROOT(_lv_indev_ll));
    c72c:	4816      	ldr	r0, [pc, #88]	; (c788 <lv_indev_drv_register+0x64>)
    c72e:	f00e fd35 	bl	1b19c <_lv_ll_ins_head>
    if(!indev) {
    c732:	4604      	mov	r4, r0
    c734:	b940      	cbnz	r0, c748 <lv_indev_drv_register+0x24>
    indev->btn_points       = NULL;

    indev->driver.read_task = lv_task_create(_lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_HIGH, indev);

    return indev;
}
    c736:	4620      	mov	r0, r4
    c738:	bd38      	pop	{r3, r4, r5, pc}
    if(driver->disp == NULL) driver->disp = lv_disp_get_default();
    c73a:	f7ff ff15 	bl	c568 <lv_disp_get_default>
    c73e:	4604      	mov	r4, r0
    c740:	6128      	str	r0, [r5, #16]
    if(driver->disp == NULL) {
    c742:	2800      	cmp	r0, #0
    c744:	d0f7      	beq.n	c736 <lv_indev_drv_register+0x12>
    c746:	e7f1      	b.n	c72c <lv_indev_drv_register+0x8>
    _lv_memset_00(indev, sizeof(lv_indev_t));
    c748:	2164      	movs	r1, #100	; 0x64
    c74a:	f00e f9eb 	bl	1ab24 <_lv_memset_00>
    c74e:	4628      	mov	r0, r5
    c750:	4623      	mov	r3, r4
    c752:	f105 0220 	add.w	r2, r5, #32
    c756:	f850 1b04 	ldr.w	r1, [r0], #4
    c75a:	4290      	cmp	r0, r2
    c75c:	f843 1b04 	str.w	r1, [r3], #4
    c760:	d1f9      	bne.n	c756 <lv_indev_drv_register+0x32>
    indev->proc.reset_query = 1;
    c762:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
    indev->driver.read_task = lv_task_create(_lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_HIGH, indev);
    c766:	2204      	movs	r2, #4
    indev->proc.reset_query = 1;
    c768:	f043 0302 	orr.w	r3, r3, #2
    c76c:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
    indev->cursor           = NULL;
    c770:	2300      	movs	r3, #0
    indev->driver.read_task = lv_task_create(_lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_HIGH, indev);
    c772:	211e      	movs	r1, #30
    indev->group            = NULL;
    c774:	e9c4 3316 	strd	r3, r3, [r4, #88]	; 0x58
    indev->btn_points       = NULL;
    c778:	6623      	str	r3, [r4, #96]	; 0x60
    indev->driver.read_task = lv_task_create(_lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_HIGH, indev);
    c77a:	4804      	ldr	r0, [pc, #16]	; (c78c <lv_indev_drv_register+0x68>)
    c77c:	4623      	mov	r3, r4
    c77e:	f00e fe7d 	bl	1b47c <lv_task_create>
    c782:	6160      	str	r0, [r4, #20]
    return indev;
    c784:	e7d7      	b.n	c736 <lv_indev_drv_register+0x12>
    c786:	bf00      	nop
    c788:	20025dbc 	.word	0x20025dbc
    c78c:	00009081 	.word	0x00009081

0000c790 <lv_indev_get_next>:
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
    if(indev == NULL)
    c790:	4601      	mov	r1, r0
        return _lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
    c792:	4803      	ldr	r0, [pc, #12]	; (c7a0 <lv_indev_get_next+0x10>)
    if(indev == NULL)
    c794:	b909      	cbnz	r1, c79a <lv_indev_get_next+0xa>
        return _lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
    c796:	f00e bd38 	b.w	1b20a <_lv_ll_get_head>
    else
        return _lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
    c79a:	f00e bd3c 	b.w	1b216 <_lv_ll_get_next>
    c79e:	bf00      	nop
    c7a0:	20025dbc 	.word	0x20025dbc

0000c7a4 <anim_mark_list_change>:

    return anim_list_changed;
}
static void anim_mark_list_change(void)
{
    anim_list_changed = true;
    c7a4:	2201      	movs	r2, #1
{
    c7a6:	b508      	push	{r3, lr}
    anim_list_changed = true;
    c7a8:	4b07      	ldr	r3, [pc, #28]	; (c7c8 <anim_mark_list_change+0x24>)
    if(_lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll)) == NULL)
    c7aa:	4808      	ldr	r0, [pc, #32]	; (c7cc <anim_mark_list_change+0x28>)
    anim_list_changed = true;
    c7ac:	701a      	strb	r2, [r3, #0]
    if(_lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll)) == NULL)
    c7ae:	f00e fd2c 	bl	1b20a <_lv_ll_get_head>
    c7b2:	4b07      	ldr	r3, [pc, #28]	; (c7d0 <anim_mark_list_change+0x2c>)
    c7b4:	4601      	mov	r1, r0
    c7b6:	b920      	cbnz	r0, c7c2 <anim_mark_list_change+0x1e>
        lv_task_set_prio(_lv_anim_task, LV_TASK_PRIO_OFF);
    else
        lv_task_set_prio(_lv_anim_task, LV_ANIM_TASK_PRIO);
    c7b8:	6818      	ldr	r0, [r3, #0]
}
    c7ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        lv_task_set_prio(_lv_anim_task, LV_ANIM_TASK_PRIO);
    c7be:	f000 bba7 	b.w	cf10 <lv_task_set_prio>
    c7c2:	2104      	movs	r1, #4
    c7c4:	e7f8      	b.n	c7b8 <anim_mark_list_change+0x14>
    c7c6:	bf00      	nop
    c7c8:	2002a051 	.word	0x2002a051
    c7cc:	20025d10 	.word	0x20025d10
    c7d0:	20025d08 	.word	0x20025d08

0000c7d4 <anim_task>:
{
    c7d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
    c7d8:	4854      	ldr	r0, [pc, #336]	; (c92c <anim_task+0x158>)
{
    c7da:	b092      	sub	sp, #72	; 0x48
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
    c7dc:	f00e fd15 	bl	1b20a <_lv_ll_get_head>
    c7e0:	4601      	mov	r1, r0
    c7e2:	4c52      	ldr	r4, [pc, #328]	; (c92c <anim_task+0x158>)
    c7e4:	b991      	cbnz	r1, c80c <anim_task+0x38>
    uint32_t elaps = lv_tick_elaps(last_task_run);
    c7e6:	4d52      	ldr	r5, [pc, #328]	; (c930 <anim_task+0x15c>)
        anim_list_changed = false;
    c7e8:	f8df 8148 	ldr.w	r8, [pc, #328]	; c934 <anim_task+0x160>
    uint32_t elaps = lv_tick_elaps(last_task_run);
    c7ec:	6828      	ldr	r0, [r5, #0]
    c7ee:	f00e f9cd 	bl	1ab8c <lv_tick_elaps>
    c7f2:	4606      	mov	r6, r0
    a = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
    c7f4:	484d      	ldr	r0, [pc, #308]	; (c92c <anim_task+0x158>)
    c7f6:	f00e fd08 	bl	1b20a <_lv_ll_get_head>
    c7fa:	4604      	mov	r4, r0
            a = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
    c7fc:	4f4b      	ldr	r7, [pc, #300]	; (c92c <anim_task+0x158>)
    while(a != NULL) {
    c7fe:	b984      	cbnz	r4, c822 <anim_task+0x4e>
    last_task_run = lv_tick_get();
    c800:	f00e f9b7 	bl	1ab72 <lv_tick_get>
    c804:	6028      	str	r0, [r5, #0]
}
    c806:	b012      	add	sp, #72	; 0x48
    c808:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        a->has_run = 0;
    c80c:	f891 3044 	ldrb.w	r3, [r1, #68]	; 0x44
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
    c810:	4620      	mov	r0, r4
        a->has_run = 0;
    c812:	f36f 0341 	bfc	r3, #1, #1
    c816:	f881 3044 	strb.w	r3, [r1, #68]	; 0x44
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
    c81a:	f00e fcfc 	bl	1b216 <_lv_ll_get_next>
    c81e:	4601      	mov	r1, r0
    c820:	e7e0      	b.n	c7e4 <anim_task+0x10>
        anim_list_changed = false;
    c822:	2300      	movs	r3, #0
    c824:	f888 3000 	strb.w	r3, [r8]
        if(!a->has_run) {
    c828:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c82c:	079a      	lsls	r2, r3, #30
    c82e:	d477      	bmi.n	c920 <anim_task+0x14c>
            a->has_run = 1; /*The list readying might be reseted so need to know which anim has run already*/
    c830:	f043 0302 	orr.w	r3, r3, #2
    c834:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
            int32_t new_act_time = a->act_time + elaps;
    c838:	6aa3      	ldr	r3, [r4, #40]	; 0x28
            if(a->act_time <= 0 && new_act_time >= 0) {
    c83a:	2b00      	cmp	r3, #0
    c83c:	dc05      	bgt.n	c84a <anim_task+0x76>
    c83e:	42f3      	cmn	r3, r6
    c840:	d403      	bmi.n	c84a <anim_task+0x76>
                if(a->start_cb) a->start_cb(a);
    c842:	68a3      	ldr	r3, [r4, #8]
    c844:	b10b      	cbz	r3, c84a <anim_task+0x76>
    c846:	4620      	mov	r0, r4
    c848:	4798      	blx	r3
            a->act_time += elaps;
    c84a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    c84c:	4433      	add	r3, r6
            if(a->act_time >= 0) {
    c84e:	2b00      	cmp	r3, #0
            a->act_time += elaps;
    c850:	62a3      	str	r3, [r4, #40]	; 0x28
            if(a->act_time >= 0) {
    c852:	db33      	blt.n	c8bc <anim_task+0xe8>
                if(a->path.cb) new_value = a->path.cb(&a->path, a);
    c854:	4620      	mov	r0, r4
                if(a->act_time > a->time) a->act_time = a->time;
    c856:	6a62      	ldr	r2, [r4, #36]	; 0x24
                if(a->path.cb) new_value = a->path.cb(&a->path, a);
    c858:	4621      	mov	r1, r4
                if(a->act_time > a->time) a->act_time = a->time;
    c85a:	4293      	cmp	r3, r2
                if(a->path.cb) new_value = a->path.cb(&a->path, a);
    c85c:	f850 3f10 	ldr.w	r3, [r0, #16]!
                if(a->act_time > a->time) a->act_time = a->time;
    c860:	bfc8      	it	gt
    c862:	62a2      	strgt	r2, [r4, #40]	; 0x28
                if(a->path.cb) new_value = a->path.cb(&a->path, a);
    c864:	2b00      	cmp	r3, #0
    c866:	d032      	beq.n	c8ce <anim_task+0xfa>
    c868:	4798      	blx	r3
                if(new_value != a->current) {
    c86a:	69e3      	ldr	r3, [r4, #28]
    c86c:	4283      	cmp	r3, r0
    c86e:	d005      	beq.n	c87c <anim_task+0xa8>
                    if(a->exec_cb) a->exec_cb(a->var, new_value);
    c870:	6863      	ldr	r3, [r4, #4]
                    a->current = new_value;
    c872:	61e0      	str	r0, [r4, #28]
                    if(a->exec_cb) a->exec_cb(a->var, new_value);
    c874:	b113      	cbz	r3, c87c <anim_task+0xa8>
    c876:	b201      	sxth	r1, r0
    c878:	6820      	ldr	r0, [r4, #0]
    c87a:	4798      	blx	r3
                if(a->act_time >= a->time) {
    c87c:	e9d4 3209 	ldrd	r3, r2, [r4, #36]	; 0x24
    c880:	429a      	cmp	r2, r3
    c882:	db1b      	blt.n	c8bc <anim_task+0xe8>
    if(a->playback_now == 0 && a->repeat_cnt > 0 && a->repeat_cnt != LV_ANIM_REPEAT_INFINITE) {
    c884:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c888:	6b21      	ldr	r1, [r4, #48]	; 0x30
    c88a:	f013 0301 	ands.w	r3, r3, #1
    c88e:	d127      	bne.n	c8e0 <anim_task+0x10c>
    c890:	8f22      	ldrh	r2, [r4, #56]	; 0x38
    c892:	b9fa      	cbnz	r2, c8d4 <anim_task+0x100>
    if(a->repeat_cnt == 0 && ((a->playback_time == 0) || (a->playback_time && a->playback_now == 1))) {
    c894:	2900      	cmp	r1, #0
    c896:	d140      	bne.n	c91a <anim_task+0x146>
        _lv_memcpy(&a_tmp, a, sizeof(lv_anim_t));
    c898:	2248      	movs	r2, #72	; 0x48
    c89a:	4621      	mov	r1, r4
    c89c:	4668      	mov	r0, sp
    c89e:	f00e f995 	bl	1abcc <_lv_memcpy>
        _lv_ll_remove(&LV_GC_ROOT(_lv_anim_ll), a);
    c8a2:	4621      	mov	r1, r4
    c8a4:	4638      	mov	r0, r7
    c8a6:	f00e fcf1 	bl	1b28c <_lv_ll_remove>
        lv_mem_free(a);
    c8aa:	4620      	mov	r0, r4
    c8ac:	f000 f908 	bl	cac0 <lv_mem_free>
        anim_mark_list_change();
    c8b0:	f7ff ff78 	bl	c7a4 <anim_mark_list_change>
        if(a_tmp.ready_cb != NULL) a_tmp.ready_cb(&a_tmp);
    c8b4:	9b03      	ldr	r3, [sp, #12]
    c8b6:	b10b      	cbz	r3, c8bc <anim_task+0xe8>
    c8b8:	4668      	mov	r0, sp
    c8ba:	4798      	blx	r3
        if(anim_list_changed)
    c8bc:	f898 3000 	ldrb.w	r3, [r8]
    c8c0:	2b00      	cmp	r3, #0
    c8c2:	d02d      	beq.n	c920 <anim_task+0x14c>
            a = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
    c8c4:	4638      	mov	r0, r7
    c8c6:	f00e fca0 	bl	1b20a <_lv_ll_get_head>
            a = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
    c8ca:	4604      	mov	r4, r0
    c8cc:	e797      	b.n	c7fe <anim_task+0x2a>
                else new_value = lv_anim_path_linear(&a->path, a);
    c8ce:	f00e f96c 	bl	1abaa <lv_anim_path_linear>
    c8d2:	e7ca      	b.n	c86a <anim_task+0x96>
    if(a->playback_now == 0 && a->repeat_cnt > 0 && a->repeat_cnt != LV_ANIM_REPEAT_INFINITE) {
    c8d4:	f64f 70ff 	movw	r0, #65535	; 0xffff
    c8d8:	4282      	cmp	r2, r0
    c8da:	d004      	beq.n	c8e6 <anim_task+0x112>
        a->repeat_cnt--;
    c8dc:	3a01      	subs	r2, #1
    c8de:	8722      	strh	r2, [r4, #56]	; 0x38
    if(a->repeat_cnt == 0 && ((a->playback_time == 0) || (a->playback_time && a->playback_now == 1))) {
    c8e0:	8f22      	ldrh	r2, [r4, #56]	; 0x38
    c8e2:	2a00      	cmp	r2, #0
    c8e4:	d0d6      	beq.n	c894 <anim_task+0xc0>
        a->act_time = -(int32_t)(a->repeat_delay); /*Restart the animation*/
    c8e6:	6b62      	ldr	r2, [r4, #52]	; 0x34
    c8e8:	4252      	negs	r2, r2
    c8ea:	62a2      	str	r2, [r4, #40]	; 0x28
        if(a->playback_time != 0) {
    c8ec:	2900      	cmp	r1, #0
    c8ee:	d0e5      	beq.n	c8bc <anim_task+0xe8>
            if(a->playback_now == 0) a->act_time = -(int32_t)(a->playback_delay);
    c8f0:	b913      	cbnz	r3, c8f8 <anim_task+0x124>
    c8f2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    c8f4:	4252      	negs	r2, r2
    c8f6:	62a2      	str	r2, [r4, #40]	; 0x28
            a->playback_now = a->playback_now == 0 ? 1 : 0;
    c8f8:	f083 0201 	eor.w	r2, r3, #1
    c8fc:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
            tmp      = a->start;
    c900:	69a0      	ldr	r0, [r4, #24]
            a->playback_now = a->playback_now == 0 ? 1 : 0;
    c902:	f362 0300 	bfi	r3, r2, #0, #1
    c906:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
            a->time = a->playback_now == 0 ? a->time_orig : a->playback_time;
    c90a:	07db      	lsls	r3, r3, #31
            a->start = a->end;
    c90c:	6a22      	ldr	r2, [r4, #32]
            a->time = a->playback_now == 0 ? a->time_orig : a->playback_time;
    c90e:	bf58      	it	pl
    c910:	6c21      	ldrpl	r1, [r4, #64]	; 0x40
            a->start = a->end;
    c912:	61a2      	str	r2, [r4, #24]
            a->end   = tmp;
    c914:	6220      	str	r0, [r4, #32]
            a->time = a->playback_now == 0 ? a->time_orig : a->playback_time;
    c916:	6261      	str	r1, [r4, #36]	; 0x24
    c918:	e7d0      	b.n	c8bc <anim_task+0xe8>
    if(a->repeat_cnt == 0 && ((a->playback_time == 0) || (a->playback_time && a->playback_now == 1))) {
    c91a:	2b00      	cmp	r3, #0
    c91c:	d0e3      	beq.n	c8e6 <anim_task+0x112>
    c91e:	e7bb      	b.n	c898 <anim_task+0xc4>
            a = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
    c920:	4621      	mov	r1, r4
    c922:	4638      	mov	r0, r7
    c924:	f00e fc77 	bl	1b216 <_lv_ll_get_next>
    c928:	e7cf      	b.n	c8ca <anim_task+0xf6>
    c92a:	bf00      	nop
    c92c:	20025d10 	.word	0x20025d10
    c930:	20025d0c 	.word	0x20025d0c
    c934:	2002a051 	.word	0x2002a051

0000c938 <_lv_anim_core_init>:
{
    c938:	b508      	push	{r3, lr}
    _lv_ll_init(&LV_GC_ROOT(_lv_anim_ll), sizeof(lv_anim_t));
    c93a:	2148      	movs	r1, #72	; 0x48
    c93c:	480a      	ldr	r0, [pc, #40]	; (c968 <_lv_anim_core_init+0x30>)
    c93e:	f00e fc25 	bl	1b18c <_lv_ll_init>
    last_task_run = lv_tick_get();
    c942:	f00e f916 	bl	1ab72 <lv_tick_get>
    c946:	4b09      	ldr	r3, [pc, #36]	; (c96c <_lv_anim_core_init+0x34>)
    _lv_anim_task = lv_task_create(anim_task, LV_DISP_DEF_REFR_PERIOD, LV_ANIM_TASK_PRIO, NULL);
    c948:	2204      	movs	r2, #4
    last_task_run = lv_tick_get();
    c94a:	6018      	str	r0, [r3, #0]
    _lv_anim_task = lv_task_create(anim_task, LV_DISP_DEF_REFR_PERIOD, LV_ANIM_TASK_PRIO, NULL);
    c94c:	211e      	movs	r1, #30
    c94e:	2300      	movs	r3, #0
    c950:	4807      	ldr	r0, [pc, #28]	; (c970 <_lv_anim_core_init+0x38>)
    c952:	f00e fd93 	bl	1b47c <lv_task_create>
    c956:	4b07      	ldr	r3, [pc, #28]	; (c974 <_lv_anim_core_init+0x3c>)
    c958:	6018      	str	r0, [r3, #0]
    anim_mark_list_change(); /*Turn off the animation task*/
    c95a:	f7ff ff23 	bl	c7a4 <anim_mark_list_change>
    anim_list_changed = false; /*The list has not actually changed*/
    c95e:	2200      	movs	r2, #0
    c960:	4b05      	ldr	r3, [pc, #20]	; (c978 <_lv_anim_core_init+0x40>)
    c962:	701a      	strb	r2, [r3, #0]
}
    c964:	bd08      	pop	{r3, pc}
    c966:	bf00      	nop
    c968:	20025d10 	.word	0x20025d10
    c96c:	20025d0c 	.word	0x20025d0c
    c970:	0000c7d5 	.word	0x0000c7d5
    c974:	20025d08 	.word	0x20025d08
    c978:	2002a051 	.word	0x2002a051

0000c97c <lv_anim_init>:
{
    c97c:	b510      	push	{r4, lr}
__ssp_bos_icheck3(memset, void *, int)
    c97e:	2248      	movs	r2, #72	; 0x48
    c980:	2100      	movs	r1, #0
    c982:	4604      	mov	r4, r0
    c984:	f010 fffa 	bl	1d97c <memset>
    a->end     = 100;
    c988:	2364      	movs	r3, #100	; 0x64
    c98a:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    _lv_memcpy_small(&a->path, &lv_anim_path_def, sizeof(lv_anim_path_cb_t));
    c98e:	4908      	ldr	r1, [pc, #32]	; (c9b0 <lv_anim_init+0x34>)
    a->end     = 100;
    c990:	e9c4 3208 	strd	r3, r2, [r4, #32]
    _lv_memcpy_small(&a->path, &lv_anim_path_def, sizeof(lv_anim_path_cb_t));
    c994:	f104 0010 	add.w	r0, r4, #16
    c998:	2204      	movs	r2, #4
    c99a:	f00e f917 	bl	1abcc <_lv_memcpy>
    a->repeat_cnt = 1;
    c99e:	2301      	movs	r3, #1
    c9a0:	8723      	strh	r3, [r4, #56]	; 0x38
    a->early_apply = 1;
    c9a2:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
    c9a6:	f043 0301 	orr.w	r3, r3, #1
    c9aa:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
}
    c9ae:	bd10      	pop	{r4, pc}
    c9b0:	0001f15c 	.word	0x0001f15c

0000c9b4 <lv_anim_del>:
{
    c9b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c9b8:	4606      	mov	r6, r0
    a        = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
    c9ba:	4813      	ldr	r0, [pc, #76]	; (ca08 <lv_anim_del+0x54>)
{
    c9bc:	460d      	mov	r5, r1
    a        = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
    c9be:	f00e fc24 	bl	1b20a <_lv_ll_get_head>
    bool del = false;
    c9c2:	f04f 0800 	mov.w	r8, #0
    a        = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
    c9c6:	4604      	mov	r4, r0
        a_next = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
    c9c8:	f8df 903c 	ldr.w	r9, [pc, #60]	; ca08 <lv_anim_del+0x54>
    while(a != NULL) {
    c9cc:	b914      	cbnz	r4, c9d4 <lv_anim_del+0x20>
}
    c9ce:	4640      	mov	r0, r8
    c9d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        a_next = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
    c9d4:	4621      	mov	r1, r4
    c9d6:	4648      	mov	r0, r9
    c9d8:	f00e fc1d 	bl	1b216 <_lv_ll_get_next>
        if(a->var == var && (a->exec_cb == exec_cb || exec_cb == NULL)) {
    c9dc:	6823      	ldr	r3, [r4, #0]
        a_next = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
    c9de:	4607      	mov	r7, r0
        if(a->var == var && (a->exec_cb == exec_cb || exec_cb == NULL)) {
    c9e0:	42b3      	cmp	r3, r6
    c9e2:	d10e      	bne.n	ca02 <lv_anim_del+0x4e>
    c9e4:	6863      	ldr	r3, [r4, #4]
    c9e6:	42ab      	cmp	r3, r5
    c9e8:	d000      	beq.n	c9ec <lv_anim_del+0x38>
    c9ea:	b955      	cbnz	r5, ca02 <lv_anim_del+0x4e>
            _lv_ll_remove(&LV_GC_ROOT(_lv_anim_ll), a);
    c9ec:	4621      	mov	r1, r4
    c9ee:	4648      	mov	r0, r9
    c9f0:	f00e fc4c 	bl	1b28c <_lv_ll_remove>
            lv_mem_free(a);
    c9f4:	4620      	mov	r0, r4
    c9f6:	f000 f863 	bl	cac0 <lv_mem_free>
            del = true;
    c9fa:	f04f 0801 	mov.w	r8, #1
            anim_mark_list_change(); /*Read by `anim_task`. It need to know if a delete occurred in
    c9fe:	f7ff fed1 	bl	c7a4 <anim_mark_list_change>
            del = true;
    ca02:	463c      	mov	r4, r7
    ca04:	e7e2      	b.n	c9cc <lv_anim_del+0x18>
    ca06:	bf00      	nop
    ca08:	20025d10 	.word	0x20025d10

0000ca0c <lv_anim_start>:
    if(a->exec_cb != NULL) lv_anim_del(a->var, a->exec_cb); /*fp == NULL would delete all animations of var*/
    ca0c:	6841      	ldr	r1, [r0, #4]
{
    ca0e:	b538      	push	{r3, r4, r5, lr}
    ca10:	4605      	mov	r5, r0
    if(a->exec_cb != NULL) lv_anim_del(a->var, a->exec_cb); /*fp == NULL would delete all animations of var*/
    ca12:	b111      	cbz	r1, ca1a <lv_anim_start+0xe>
    ca14:	6800      	ldr	r0, [r0, #0]
    ca16:	f7ff ffcd 	bl	c9b4 <lv_anim_del>
    if(_lv_ll_is_empty(&LV_GC_ROOT(_lv_anim_ll))) {
    ca1a:	4812      	ldr	r0, [pc, #72]	; (ca64 <lv_anim_start+0x58>)
    ca1c:	f00e fcc8 	bl	1b3b0 <_lv_ll_is_empty>
    ca20:	b120      	cbz	r0, ca2c <lv_anim_start+0x20>
        last_task_run = lv_tick_get() - 1;
    ca22:	f00e f8a6 	bl	1ab72 <lv_tick_get>
    ca26:	4b10      	ldr	r3, [pc, #64]	; (ca68 <lv_anim_start+0x5c>)
    ca28:	3801      	subs	r0, #1
    ca2a:	6018      	str	r0, [r3, #0]
    lv_anim_t * new_anim = _lv_ll_ins_head(&LV_GC_ROOT(_lv_anim_ll));
    ca2c:	480d      	ldr	r0, [pc, #52]	; (ca64 <lv_anim_start+0x58>)
    ca2e:	f00e fbb5 	bl	1b19c <_lv_ll_ins_head>
    if(new_anim == NULL) return;
    ca32:	4604      	mov	r4, r0
    ca34:	b1a0      	cbz	r0, ca60 <lv_anim_start+0x54>
    a->time_orig = a->time;
    ca36:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    _lv_memcpy(new_anim, a, sizeof(lv_anim_t));
    ca38:	2248      	movs	r2, #72	; 0x48
    a->time_orig = a->time;
    ca3a:	642b      	str	r3, [r5, #64]	; 0x40
    _lv_memcpy(new_anim, a, sizeof(lv_anim_t));
    ca3c:	4629      	mov	r1, r5
    ca3e:	f00e f8c5 	bl	1abcc <_lv_memcpy>
    if(new_anim->early_apply) {
    ca42:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
    ca46:	07db      	lsls	r3, r3, #31
    ca48:	d506      	bpl.n	ca58 <lv_anim_start+0x4c>
        if(new_anim->exec_cb && new_anim->var) new_anim->exec_cb(new_anim->var, new_anim->start);
    ca4a:	6863      	ldr	r3, [r4, #4]
    ca4c:	b123      	cbz	r3, ca58 <lv_anim_start+0x4c>
    ca4e:	6820      	ldr	r0, [r4, #0]
    ca50:	b110      	cbz	r0, ca58 <lv_anim_start+0x4c>
    ca52:	f9b4 1018 	ldrsh.w	r1, [r4, #24]
    ca56:	4798      	blx	r3
}
    ca58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    anim_mark_list_change();
    ca5c:	f7ff bea2 	b.w	c7a4 <anim_mark_list_change>
}
    ca60:	bd38      	pop	{r3, r4, r5, pc}
    ca62:	bf00      	nop
    ca64:	20025d10 	.word	0x20025d10
    ca68:	20025d0c 	.word	0x20025d0c

0000ca6c <lv_anim_get>:
{
    ca6c:	b570      	push	{r4, r5, r6, lr}
    ca6e:	4604      	mov	r4, r0
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
    ca70:	4808      	ldr	r0, [pc, #32]	; (ca94 <lv_anim_get+0x28>)
{
    ca72:	460d      	mov	r5, r1
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
    ca74:	f00e fbc9 	bl	1b20a <_lv_ll_get_head>
    ca78:	4e06      	ldr	r6, [pc, #24]	; (ca94 <lv_anim_get+0x28>)
    ca7a:	b900      	cbnz	r0, ca7e <lv_anim_get+0x12>
}
    ca7c:	bd70      	pop	{r4, r5, r6, pc}
        if(a->var == var && a->exec_cb == exec_cb) {
    ca7e:	6803      	ldr	r3, [r0, #0]
    ca80:	42a3      	cmp	r3, r4
    ca82:	d102      	bne.n	ca8a <lv_anim_get+0x1e>
    ca84:	6843      	ldr	r3, [r0, #4]
    ca86:	42ab      	cmp	r3, r5
    ca88:	d0f8      	beq.n	ca7c <lv_anim_get+0x10>
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
    ca8a:	4601      	mov	r1, r0
    ca8c:	4630      	mov	r0, r6
    ca8e:	f00e fbc2 	bl	1b216 <_lv_ll_get_next>
    ca92:	e7f2      	b.n	ca7a <lv_anim_get+0xe>
    ca94:	20025d10 	.word	0x20025d10

0000ca98 <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(size_t size)
{
    ca98:	b510      	push	{r4, lr}
    if(size == 0) {
    ca9a:	b168      	cbz	r0, cab8 <lv_mem_alloc+0x20>
#ifdef LV_ARCH_64
    /*Round the size up to 8*/
    size = (size + 7) & (~0x7);
#else
    /*Round the size up to 4*/
    size = (size + 3) & (~0x3);
    ca9c:	3003      	adds	r0, #3
    ca9e:	f020 0403 	bic.w	r4, r0, #3
	return k_aligned_alloc(sizeof(void *), size);
    caa2:	1d21      	adds	r1, r4, #4
    caa4:	2004      	movs	r0, #4
    caa6:	f004 fd9f 	bl	115e8 <k_aligned_alloc>
#if LV_ENABLE_GC == 1 /*gc must not include header*/
    alloc = LV_MEM_CUSTOM_ALLOC(size);
#else                 /* LV_ENABLE_GC */
    /*Allocate a header too to store the size*/
    alloc = LV_MEM_CUSTOM_ALLOC(size + sizeof(lv_mem_header_t));
    if(alloc != NULL) {
    caaa:	b120      	cbz	r0, cab6 <lv_mem_alloc+0x1e>
        ((lv_mem_ent_t *)alloc)->header.s.d_size = size;
        ((lv_mem_ent_t *)alloc)->header.s.used   = 1;
    caac:	0064      	lsls	r4, r4, #1
    caae:	f044 0401 	orr.w	r4, r4, #1
    cab2:	f840 4b04 	str.w	r4, [r0], #4
        }
#endif
    }

    return alloc;
}
    cab6:	bd10      	pop	{r4, pc}
        return &zero_mem;
    cab8:	4800      	ldr	r0, [pc, #0]	; (cabc <lv_mem_alloc+0x24>)
    caba:	e7fc      	b.n	cab6 <lv_mem_alloc+0x1e>
    cabc:	20025e68 	.word	0x20025e68

0000cac0 <lv_mem_free>:
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
    if(data == &zero_mem) return;
    cac0:	4b06      	ldr	r3, [pc, #24]	; (cadc <lv_mem_free+0x1c>)
    cac2:	4298      	cmp	r0, r3
    cac4:	d008      	beq.n	cad8 <lv_mem_free+0x18>
    if(data == NULL) return;
    cac6:	b138      	cbz	r0, cad8 <lv_mem_free+0x18>
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
    e->header.s.used = 0;
    cac8:	f810 3c04 	ldrb.w	r3, [r0, #-4]
    cacc:	f36f 0300 	bfc	r3, #0, #1
    cad0:	f800 3d04 	strb.w	r3, [r0, #-4]!


#endif /*LV_MEM_AUTO_DEFRAG*/
#else /*Use custom, user defined free function*/
#if LV_ENABLE_GC == 0
    LV_MEM_CUSTOM_FREE(e);
    cad4:	f010 bf2c 	b.w	1d930 <k_free>
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
    cad8:	4770      	bx	lr
    cada:	bf00      	nop
    cadc:	20025e68 	.word	0x20025e68

0000cae0 <_lv_mem_get_size>:

#if LV_ENABLE_GC == 0

uint32_t _lv_mem_get_size(const void * data)
{
    if(data == NULL) return 0;
    cae0:	b140      	cbz	r0, caf4 <_lv_mem_get_size+0x14>
    if(data == &zero_mem) return 0;
    cae2:	4b05      	ldr	r3, [pc, #20]	; (caf8 <_lv_mem_get_size+0x18>)
    cae4:	4298      	cmp	r0, r3
    cae6:	d004      	beq.n	caf2 <_lv_mem_get_size+0x12>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));

    return e->header.s.d_size;
    cae8:	f850 0c04 	ldr.w	r0, [r0, #-4]
    caec:	f3c0 005e 	ubfx	r0, r0, #1, #31
    caf0:	4770      	bx	lr
    if(data == NULL) return 0;
    caf2:	2000      	movs	r0, #0
}
    caf4:	4770      	bx	lr
    caf6:	bf00      	nop
    caf8:	20025e68 	.word	0x20025e68

0000cafc <_lv_mem_buf_get>:
 * Get a temporal buffer with the given size.
 * @param size the required size
 */
void * _lv_mem_buf_get(uint32_t size)
{
    if(size == 0) return NULL;
    cafc:	4601      	mov	r1, r0
{
    cafe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(size == 0) return NULL;
    cb00:	b190      	cbz	r0, cb28 <_lv_mem_buf_get+0x2c>

    /*Try small static buffers first*/
    uint8_t i;
    if(size <= MEM_BUF_SMALL_SIZE) {
    cb02:	2810      	cmp	r0, #16
    cb04:	d811      	bhi.n	cb2a <_lv_mem_buf_get+0x2e>
        for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
            if(mem_buf_small[i].used == 0) {
    cb06:	4a2c      	ldr	r2, [pc, #176]	; (cbb8 <_lv_mem_buf_get+0xbc>)
    cb08:	7993      	ldrb	r3, [r2, #6]
    cb0a:	f013 0301 	ands.w	r3, r3, #1
    cb0e:	d003      	beq.n	cb18 <_lv_mem_buf_get+0x1c>
    cb10:	7b93      	ldrb	r3, [r2, #14]
    cb12:	07df      	lsls	r7, r3, #31
    cb14:	d409      	bmi.n	cb2a <_lv_mem_buf_get+0x2e>
    cb16:	2301      	movs	r3, #1
                mem_buf_small[i].used = 1;
    cb18:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
    cb1c:	7981      	ldrb	r1, [r0, #6]
    cb1e:	f041 0101 	orr.w	r1, r1, #1
    cb22:	7181      	strb	r1, [r0, #6]
                return mem_buf_small[i].p;
    cb24:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
        }
    }

    LV_DEBUG_ASSERT(false, "No free buffer. Increase LV_DRAW_BUF_MAX_NUM.", 0x00);
    return NULL;
}
    cb28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if(LV_GC_ROOT(_lv_mem_buf[i]).used == 0 && LV_GC_ROOT(_lv_mem_buf[i]).size >= size) {
    cb2a:	4824      	ldr	r0, [pc, #144]	; (cbbc <_lv_mem_buf_get+0xc0>)
            if(mem_buf_small[i].used == 0) {
    cb2c:	2300      	movs	r3, #0
    cb2e:	f04f 32ff 	mov.w	r2, #4294967295
    cb32:	4605      	mov	r5, r0
        if(LV_GC_ROOT(_lv_mem_buf[i]).used == 0 && LV_GC_ROOT(_lv_mem_buf[i]).size >= size) {
    cb34:	f100 0c04 	add.w	ip, r0, #4
    cb38:	eb00 07c3 	add.w	r7, r0, r3, lsl #3
    cb3c:	79be      	ldrb	r6, [r7, #6]
    cb3e:	4634      	mov	r4, r6
    cb40:	07f6      	lsls	r6, r6, #31
    cb42:	d413      	bmi.n	cb6c <_lv_mem_buf_get+0x70>
    cb44:	f83c 6033 	ldrh.w	r6, [ip, r3, lsl #3]
    cb48:	428e      	cmp	r6, r1
    cb4a:	d30f      	bcc.n	cb6c <_lv_mem_buf_get+0x70>
            if(LV_GC_ROOT(_lv_mem_buf[i]).size == size) {
    cb4c:	d105      	bne.n	cb5a <_lv_mem_buf_get+0x5e>
                LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
    cb4e:	f044 0401 	orr.w	r4, r4, #1
                return LV_GC_ROOT(_lv_mem_buf[i]).p;
    cb52:	f850 0033 	ldr.w	r0, [r0, r3, lsl #3]
                LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
    cb56:	71bc      	strb	r4, [r7, #6]
                return LV_GC_ROOT(_lv_mem_buf[i]).p;
    cb58:	e7e6      	b.n	cb28 <_lv_mem_buf_get+0x2c>
            else if(i_guess < 0) {
    cb5a:	1c57      	adds	r7, r2, #1
    cb5c:	d101      	bne.n	cb62 <_lv_mem_buf_get+0x66>
                i_guess = i;
    cb5e:	b25a      	sxtb	r2, r3
    cb60:	e004      	b.n	cb6c <_lv_mem_buf_get+0x70>
            else if(LV_GC_ROOT(_lv_mem_buf[i]).size < LV_GC_ROOT(_lv_mem_buf[i_guess]).size) {
    cb62:	eb00 04c2 	add.w	r4, r0, r2, lsl #3
    cb66:	88a4      	ldrh	r4, [r4, #4]
    cb68:	42b4      	cmp	r4, r6
    cb6a:	d8f8      	bhi.n	cb5e <_lv_mem_buf_get+0x62>
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
    cb6c:	3301      	adds	r3, #1
    cb6e:	2b10      	cmp	r3, #16
    cb70:	d1e2      	bne.n	cb38 <_lv_mem_buf_get+0x3c>
    if(i_guess >= 0) {
    cb72:	1c54      	adds	r4, r2, #1
    cb74:	d008      	beq.n	cb88 <_lv_mem_buf_get+0x8c>
        LV_GC_ROOT(_lv_mem_buf[i_guess]).used = 1;
    cb76:	eb05 01c2 	add.w	r1, r5, r2, lsl #3
    cb7a:	798b      	ldrb	r3, [r1, #6]
        return LV_GC_ROOT(_lv_mem_buf[i_guess]).p;
    cb7c:	f855 0032 	ldr.w	r0, [r5, r2, lsl #3]
        LV_GC_ROOT(_lv_mem_buf[i_guess]).used = 1;
    cb80:	f043 0301 	orr.w	r3, r3, #1
    cb84:	718b      	strb	r3, [r1, #6]
        return LV_GC_ROOT(_lv_mem_buf[i_guess]).p;
    cb86:	e7cf      	b.n	cb28 <_lv_mem_buf_get+0x2c>
    cb88:	2400      	movs	r4, #0
        if(LV_GC_ROOT(_lv_mem_buf[i]).used == 0) {
    cb8a:	eb05 03c4 	add.w	r3, r5, r4, lsl #3
    cb8e:	7998      	ldrb	r0, [r3, #6]
    cb90:	4602      	mov	r2, r0
    cb92:	07c0      	lsls	r0, r0, #31
    cb94:	d40a      	bmi.n	cbac <_lv_mem_buf_get+0xb0>
            LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
    cb96:	f042 0201 	orr.w	r2, r2, #1
            LV_GC_ROOT(_lv_mem_buf[i]).p = lv_mem_realloc(LV_GC_ROOT(_lv_mem_buf[i]).p, size);
    cb9a:	f855 0034 	ldr.w	r0, [r5, r4, lsl #3]
            LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
    cb9e:	719a      	strb	r2, [r3, #6]
            LV_GC_ROOT(_lv_mem_buf[i]).size = size;
    cba0:	8099      	strh	r1, [r3, #4]
            LV_GC_ROOT(_lv_mem_buf[i]).p = lv_mem_realloc(LV_GC_ROOT(_lv_mem_buf[i]).p, size);
    cba2:	f00e fc43 	bl	1b42c <lv_mem_realloc>
    cba6:	f845 0034 	str.w	r0, [r5, r4, lsl #3]
            return  LV_GC_ROOT(_lv_mem_buf[i]).p;
    cbaa:	e7bd      	b.n	cb28 <_lv_mem_buf_get+0x2c>
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
    cbac:	3401      	adds	r4, #1
    cbae:	2c10      	cmp	r4, #16
    cbb0:	d1eb      	bne.n	cb8a <_lv_mem_buf_get+0x8e>
    if(size == 0) return NULL;
    cbb2:	2000      	movs	r0, #0
    cbb4:	e7b8      	b.n	cb28 <_lv_mem_buf_get+0x2c>
    cbb6:	bf00      	nop
    cbb8:	200004ac 	.word	0x200004ac
    cbbc:	20025dc8 	.word	0x20025dc8

0000cbc0 <_lv_mem_buf_release>:
{
    uint8_t i;

    /*Try small static buffers first*/
    for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
        if(mem_buf_small[i].p == p) {
    cbc0:	4b11      	ldr	r3, [pc, #68]	; (cc08 <_lv_mem_buf_release+0x48>)
{
    cbc2:	b510      	push	{r4, lr}
        if(mem_buf_small[i].p == p) {
    cbc4:	681a      	ldr	r2, [r3, #0]
    cbc6:	4290      	cmp	r0, r2
    cbc8:	d00a      	beq.n	cbe0 <_lv_mem_buf_release+0x20>
    cbca:	689a      	ldr	r2, [r3, #8]
    cbcc:	4290      	cmp	r0, r2
    cbce:	d109      	bne.n	cbe4 <_lv_mem_buf_release+0x24>
    cbd0:	2201      	movs	r2, #1
            mem_buf_small[i].used = 0;
    cbd2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    cbd6:	799a      	ldrb	r2, [r3, #6]
    cbd8:	f36f 0200 	bfc	r2, #0, #1
    cbdc:	719a      	strb	r2, [r3, #6]
            return;
        }
    }

    LV_LOG_ERROR("lv_mem_buf_release: p is not a known buffer")
}
    cbde:	bd10      	pop	{r4, pc}
        if(mem_buf_small[i].p == p) {
    cbe0:	2200      	movs	r2, #0
    cbe2:	e7f6      	b.n	cbd2 <_lv_mem_buf_release+0x12>
    cbe4:	2300      	movs	r3, #0
        if(LV_GC_ROOT(_lv_mem_buf[i]).p == p) {
    cbe6:	4a09      	ldr	r2, [pc, #36]	; (cc0c <_lv_mem_buf_release+0x4c>)
    cbe8:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
    cbec:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    cbf0:	4284      	cmp	r4, r0
    cbf2:	d104      	bne.n	cbfe <_lv_mem_buf_release+0x3e>
            LV_GC_ROOT(_lv_mem_buf[i]).used = 0;
    cbf4:	798b      	ldrb	r3, [r1, #6]
    cbf6:	f36f 0300 	bfc	r3, #0, #1
    cbfa:	718b      	strb	r3, [r1, #6]
            return;
    cbfc:	e7ef      	b.n	cbde <_lv_mem_buf_release+0x1e>
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
    cbfe:	3301      	adds	r3, #1
    cc00:	2b10      	cmp	r3, #16
    cc02:	d1f1      	bne.n	cbe8 <_lv_mem_buf_release+0x28>
    cc04:	e7eb      	b.n	cbde <_lv_mem_buf_release+0x1e>
    cc06:	bf00      	nop
    cc08:	200004ac 	.word	0x200004ac
    cc0c:	20025dc8 	.word	0x20025dc8

0000cc10 <_lv_mem_buf_free_all>:

/**
 * Free all memory buffers
 */
void _lv_mem_buf_free_all(void)
{
    cc10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint8_t i;
    for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
        mem_buf_small[i].used = 0;
    cc12:	2500      	movs	r5, #0
    cc14:	4c0e      	ldr	r4, [pc, #56]	; (cc50 <_lv_mem_buf_free_all+0x40>)
    }

    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
        if(LV_GC_ROOT(_lv_mem_buf[i]).p) {
            lv_mem_free(LV_GC_ROOT(_lv_mem_buf[i]).p);
            LV_GC_ROOT(_lv_mem_buf[i]).p = NULL;
    cc16:	462e      	mov	r6, r5
    cc18:	4627      	mov	r7, r4
        mem_buf_small[i].used = 0;
    cc1a:	4b0e      	ldr	r3, [pc, #56]	; (cc54 <_lv_mem_buf_free_all+0x44>)
    cc1c:	799a      	ldrb	r2, [r3, #6]
    cc1e:	f36f 0200 	bfc	r2, #0, #1
    cc22:	719a      	strb	r2, [r3, #6]
    cc24:	7b9a      	ldrb	r2, [r3, #14]
    cc26:	f36f 0200 	bfc	r2, #0, #1
    cc2a:	739a      	strb	r2, [r3, #14]
        if(LV_GC_ROOT(_lv_mem_buf[i]).p) {
    cc2c:	6820      	ldr	r0, [r4, #0]
    cc2e:	b148      	cbz	r0, cc44 <_lv_mem_buf_free_all+0x34>
            lv_mem_free(LV_GC_ROOT(_lv_mem_buf[i]).p);
    cc30:	f7ff ff46 	bl	cac0 <lv_mem_free>
            LV_GC_ROOT(_lv_mem_buf[i]).p = NULL;
    cc34:	6026      	str	r6, [r4, #0]
            LV_GC_ROOT(_lv_mem_buf[i]).used = 0;
    cc36:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
    cc3a:	799a      	ldrb	r2, [r3, #6]
    cc3c:	f366 0200 	bfi	r2, r6, #0, #1
    cc40:	719a      	strb	r2, [r3, #6]
            LV_GC_ROOT(_lv_mem_buf[i]).size = 0;
    cc42:	80a6      	strh	r6, [r4, #4]
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
    cc44:	3501      	adds	r5, #1
    cc46:	2d10      	cmp	r5, #16
    cc48:	f104 0408 	add.w	r4, r4, #8
    cc4c:	d1ee      	bne.n	cc2c <_lv_mem_buf_free_all+0x1c>
        }
    }
}
    cc4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    cc50:	20025dc8 	.word	0x20025dc8
    cc54:	200004ac 	.word	0x200004ac

0000cc58 <_lv_task_core_init>:

/**
 * Init the lv_task module
 */
void _lv_task_core_init(void)
{
    cc58:	b508      	push	{r3, lr}
    _lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
    cc5a:	2118      	movs	r1, #24
    cc5c:	4804      	ldr	r0, [pc, #16]	; (cc70 <_lv_task_core_init+0x18>)
    cc5e:	f00e fa95 	bl	1b18c <_lv_ll_init>

    task_list_changed = false;
    cc62:	2200      	movs	r2, #0
    cc64:	4b03      	ldr	r3, [pc, #12]	; (cc74 <_lv_task_core_init+0x1c>)
    cc66:	701a      	strb	r2, [r3, #0]
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
    lv_task_run = en;
    cc68:	2201      	movs	r2, #1
    cc6a:	4b03      	ldr	r3, [pc, #12]	; (cc78 <_lv_task_core_init+0x20>)
    cc6c:	701a      	strb	r2, [r3, #0]
}
    cc6e:	bd08      	pop	{r3, pc}
    cc70:	20025e58 	.word	0x20025e58
    cc74:	2002a077 	.word	0x2002a077
    cc78:	2002a074 	.word	0x2002a074

0000cc7c <lv_task_create_basic>:
{
    cc7c:	b570      	push	{r4, r5, r6, lr}
    tmp = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    cc7e:	481c      	ldr	r0, [pc, #112]	; (ccf0 <lv_task_create_basic+0x74>)
    cc80:	f00e fac3 	bl	1b20a <_lv_ll_get_head>
    if(NULL == tmp) {
    cc84:	4601      	mov	r1, r0
    cc86:	b148      	cbz	r0, cc9c <lv_task_create_basic+0x20>
            tmp = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
    cc88:	4c19      	ldr	r4, [pc, #100]	; (ccf0 <lv_task_create_basic+0x74>)
            if(tmp->prio <= DEF_PRIO) {
    cc8a:	7d0b      	ldrb	r3, [r1, #20]
    cc8c:	f003 0307 	and.w	r3, r3, #7
    cc90:	2b03      	cmp	r3, #3
    cc92:	d80b      	bhi.n	ccac <lv_task_create_basic+0x30>
                new_task = _lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
    cc94:	4816      	ldr	r0, [pc, #88]	; (ccf0 <lv_task_create_basic+0x74>)
    cc96:	f00e fac7 	bl	1b228 <_lv_ll_ins_prev>
    cc9a:	e002      	b.n	cca2 <lv_task_create_basic+0x26>
        new_task = _lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
    cc9c:	4814      	ldr	r0, [pc, #80]	; (ccf0 <lv_task_create_basic+0x74>)
    cc9e:	f00e fa7d 	bl	1b19c <_lv_ll_ins_head>
        if(new_task == NULL) return NULL;
    cca2:	4604      	mov	r4, r0
    cca4:	b960      	cbnz	r0, ccc0 <lv_task_create_basic+0x44>
    cca6:	2400      	movs	r4, #0
}
    cca8:	4620      	mov	r0, r4
    ccaa:	bd70      	pop	{r4, r5, r6, pc}
            tmp = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
    ccac:	4620      	mov	r0, r4
    ccae:	f00e fab2 	bl	1b216 <_lv_ll_get_next>
        } while(tmp != NULL);
    ccb2:	4601      	mov	r1, r0
    ccb4:	2800      	cmp	r0, #0
    ccb6:	d1e8      	bne.n	cc8a <lv_task_create_basic+0xe>
            new_task = _lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
    ccb8:	480d      	ldr	r0, [pc, #52]	; (ccf0 <lv_task_create_basic+0x74>)
    ccba:	f00e fa8a 	bl	1b1d2 <_lv_ll_ins_tail>
    ccbe:	e7f0      	b.n	cca2 <lv_task_create_basic+0x26>
    task_list_changed = true;
    ccc0:	2501      	movs	r5, #1
    ccc2:	4b0c      	ldr	r3, [pc, #48]	; (ccf4 <lv_task_create_basic+0x78>)
    new_task->prio    = DEF_PRIO;
    ccc4:	2203      	movs	r2, #3
    task_list_changed = true;
    ccc6:	701d      	strb	r5, [r3, #0]
    new_task->period  = DEF_PERIOD;
    ccc8:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    cccc:	6003      	str	r3, [r0, #0]
    new_task->prio    = DEF_PRIO;
    ccce:	7d03      	ldrb	r3, [r0, #20]
    new_task->task_cb = NULL;
    ccd0:	2600      	movs	r6, #0
    new_task->prio    = DEF_PRIO;
    ccd2:	f362 0302 	bfi	r3, r2, #0, #3
    ccd6:	7503      	strb	r3, [r0, #20]
    new_task->repeat_count = -1;
    ccd8:	f04f 33ff 	mov.w	r3, #4294967295
    new_task->task_cb = NULL;
    ccdc:	6086      	str	r6, [r0, #8]
    new_task->repeat_count = -1;
    ccde:	6103      	str	r3, [r0, #16]
    new_task->last_run = lv_tick_get();
    cce0:	f00d ff47 	bl	1ab72 <lv_tick_get>
    task_created = true;
    cce4:	4b04      	ldr	r3, [pc, #16]	; (ccf8 <lv_task_create_basic+0x7c>)
    new_task->last_run = lv_tick_get();
    cce6:	6060      	str	r0, [r4, #4]
    new_task->user_data = NULL;
    cce8:	60e6      	str	r6, [r4, #12]
    task_created = true;
    ccea:	701d      	strb	r5, [r3, #0]
    return new_task;
    ccec:	e7dc      	b.n	cca8 <lv_task_create_basic+0x2c>
    ccee:	bf00      	nop
    ccf0:	20025e58 	.word	0x20025e58
    ccf4:	2002a077 	.word	0x2002a077
    ccf8:	2002a075 	.word	0x2002a075

0000ccfc <lv_task_del>:
{
    ccfc:	b538      	push	{r3, r4, r5, lr}
    ccfe:	4604      	mov	r4, r0
    task_list_changed = true;
    cd00:	2501      	movs	r5, #1
    _lv_ll_remove(&LV_GC_ROOT(_lv_task_ll), task);
    cd02:	4601      	mov	r1, r0
    cd04:	4807      	ldr	r0, [pc, #28]	; (cd24 <lv_task_del+0x28>)
    cd06:	f00e fac1 	bl	1b28c <_lv_ll_remove>
    task_list_changed = true;
    cd0a:	4b07      	ldr	r3, [pc, #28]	; (cd28 <lv_task_del+0x2c>)
    lv_mem_free(task);
    cd0c:	4620      	mov	r0, r4
    task_list_changed = true;
    cd0e:	701d      	strb	r5, [r3, #0]
    lv_mem_free(task);
    cd10:	f7ff fed6 	bl	cac0 <lv_mem_free>
    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
    cd14:	4b05      	ldr	r3, [pc, #20]	; (cd2c <lv_task_del+0x30>)
    cd16:	681b      	ldr	r3, [r3, #0]
    cd18:	42a3      	cmp	r3, r4
    cd1a:	bf04      	itt	eq
    cd1c:	4b04      	ldreq	r3, [pc, #16]	; (cd30 <lv_task_del+0x34>)
    cd1e:	701d      	strbeq	r5, [r3, #0]
}
    cd20:	bd38      	pop	{r3, r4, r5, pc}
    cd22:	bf00      	nop
    cd24:	20025e58 	.word	0x20025e58
    cd28:	2002a077 	.word	0x2002a077
    cd2c:	20025e54 	.word	0x20025e54
    cd30:	2002a076 	.word	0x2002a076

0000cd34 <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
    cd34:	b538      	push	{r3, r4, r5, lr}
    cd36:	4604      	mov	r4, r0
 * @return the time remaining, or 0 if it needs to be run again
 */
static uint32_t lv_task_time_remaining(lv_task_t * task)
{
    /*Check if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
    cd38:	6840      	ldr	r0, [r0, #4]
    cd3a:	f00d ff27 	bl	1ab8c <lv_tick_elaps>
    if(elp >= task->period)
    cd3e:	6823      	ldr	r3, [r4, #0]
    cd40:	4298      	cmp	r0, r3
    cd42:	d31c      	bcc.n	cd7e <lv_task_exec+0x4a>
        task->last_run = lv_tick_get();
    cd44:	f00d ff15 	bl	1ab72 <lv_tick_get>
        task_deleted   = false;
    cd48:	2300      	movs	r3, #0
    cd4a:	4d0e      	ldr	r5, [pc, #56]	; (cd84 <lv_task_exec+0x50>)
        task_created   = false;
    cd4c:	4a0e      	ldr	r2, [pc, #56]	; (cd88 <lv_task_exec+0x54>)
        task_deleted   = false;
    cd4e:	702b      	strb	r3, [r5, #0]
        task_created   = false;
    cd50:	7013      	strb	r3, [r2, #0]
        if(task->task_cb) task->task_cb(task);
    cd52:	68a3      	ldr	r3, [r4, #8]
        task->last_run = lv_tick_get();
    cd54:	6060      	str	r0, [r4, #4]
        if(task->task_cb) task->task_cb(task);
    cd56:	b943      	cbnz	r3, cd6a <lv_task_exec+0x36>
            if(task->repeat_count > 0) {
    cd58:	6923      	ldr	r3, [r4, #16]
    cd5a:	2b00      	cmp	r3, #0
    cd5c:	dc0c      	bgt.n	cd78 <lv_task_exec+0x44>
            if(task->repeat_count == 0) {
    cd5e:	6923      	ldr	r3, [r4, #16]
    cd60:	b943      	cbnz	r3, cd74 <lv_task_exec+0x40>
                lv_task_del(task);
    cd62:	4620      	mov	r0, r4
    cd64:	f7ff ffca 	bl	ccfc <lv_task_del>
    cd68:	e004      	b.n	cd74 <lv_task_exec+0x40>
        if(task->task_cb) task->task_cb(task);
    cd6a:	4620      	mov	r0, r4
    cd6c:	4798      	blx	r3
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
    cd6e:	782b      	ldrb	r3, [r5, #0]
    cd70:	2b00      	cmp	r3, #0
    cd72:	d0f1      	beq.n	cd58 <lv_task_exec+0x24>
                lv_task_del(task);
    cd74:	2001      	movs	r0, #1
}
    cd76:	bd38      	pop	{r3, r4, r5, pc}
                task->repeat_count--;
    cd78:	3b01      	subs	r3, #1
    cd7a:	6123      	str	r3, [r4, #16]
    cd7c:	e7ef      	b.n	cd5e <lv_task_exec+0x2a>
    bool exec = false;
    cd7e:	2000      	movs	r0, #0
    cd80:	e7f9      	b.n	cd76 <lv_task_exec+0x42>
    cd82:	bf00      	nop
    cd84:	2002a076 	.word	0x2002a076
    cd88:	2002a075 	.word	0x2002a075

0000cd8c <lv_task_handler>:
    if(already_running) return 1;
    cd8c:	4b54      	ldr	r3, [pc, #336]	; (cee0 <lv_task_handler+0x154>)
{
    cd8e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(already_running) return 1;
    cd92:	781c      	ldrb	r4, [r3, #0]
    cd94:	2001      	movs	r0, #1
    cd96:	b924      	cbnz	r4, cda2 <lv_task_handler+0x16>
    if(lv_task_run == false) {
    cd98:	4a52      	ldr	r2, [pc, #328]	; (cee4 <lv_task_handler+0x158>)
    already_running = true;
    cd9a:	7018      	strb	r0, [r3, #0]
    if(lv_task_run == false) {
    cd9c:	7812      	ldrb	r2, [r2, #0]
    cd9e:	b91a      	cbnz	r2, cda8 <lv_task_handler+0x1c>
        already_running = false; /*Release mutex*/
    cda0:	701a      	strb	r2, [r3, #0]
}
    cda2:	b003      	add	sp, #12
    cda4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    handler_start = lv_tick_get();
    cda8:	f00d fee3 	bl	1ab72 <lv_tick_get>
        task_deleted             = false;
    cdac:	46a3      	mov	fp, r4
    handler_start = lv_tick_get();
    cdae:	4b4e      	ldr	r3, [pc, #312]	; (cee8 <lv_task_handler+0x15c>)
        task_deleted             = false;
    cdb0:	4d4e      	ldr	r5, [pc, #312]	; (ceec <lv_task_handler+0x160>)
    handler_start = lv_tick_get();
    cdb2:	6018      	str	r0, [r3, #0]
    lv_task_t * task_interrupter = NULL;
    cdb4:	9301      	str	r3, [sp, #4]
        task_created             = false;
    cdb6:	4f4e      	ldr	r7, [pc, #312]	; (cef0 <lv_task_handler+0x164>)
        LV_GC_ROOT(_lv_task_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    cdb8:	f8df 814c 	ldr.w	r8, [pc, #332]	; cf08 <lv_task_handler+0x17c>
    cdbc:	484d      	ldr	r0, [pc, #308]	; (cef4 <lv_task_handler+0x168>)
        task_deleted             = false;
    cdbe:	f885 b000 	strb.w	fp, [r5]
        task_created             = false;
    cdc2:	f887 b000 	strb.w	fp, [r7]
        LV_GC_ROOT(_lv_task_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    cdc6:	f00e fa20 	bl	1b20a <_lv_ll_get_head>
    cdca:	46c1      	mov	r9, r8
            if(task_list_changed) {
    cdcc:	f8df a13c 	ldr.w	sl, [pc, #316]	; cf0c <lv_task_handler+0x180>
        LV_GC_ROOT(_lv_task_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    cdd0:	f8c8 0000 	str.w	r0, [r8]
        while(LV_GC_ROOT(_lv_task_act)) {
    cdd4:	f8d9 1000 	ldr.w	r1, [r9]
    cdd8:	b1b9      	cbz	r1, ce0a <lv_task_handler+0x7e>
            next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
    cdda:	4846      	ldr	r0, [pc, #280]	; (cef4 <lv_task_handler+0x168>)
    cddc:	f00e fa1b 	bl	1b216 <_lv_ll_get_next>
    cde0:	4606      	mov	r6, r0
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
    cde2:	f8d9 0000 	ldr.w	r0, [r9]
    cde6:	7d03      	ldrb	r3, [r0, #20]
    cde8:	f013 0207 	ands.w	r2, r3, #7
    cdec:	d00d      	beq.n	ce0a <lv_task_handler+0x7e>
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
    cdee:	42a0      	cmp	r0, r4
    cdf0:	d103      	bne.n	cdfa <lv_task_handler+0x6e>
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
    cdf2:	2400      	movs	r4, #0
                LV_GC_ROOT(_lv_task_act) = next;
    cdf4:	f8c9 6000 	str.w	r6, [r9]
                continue; /*Load the next task*/
    cdf8:	e7ec      	b.n	cdd4 <lv_task_handler+0x48>
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
    cdfa:	2a05      	cmp	r2, #5
    cdfc:	d138      	bne.n	ce70 <lv_task_handler+0xe4>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
    cdfe:	f7ff ff99 	bl	cd34 <lv_task_exec>
            if(task_created || task_deleted) {
    ce02:	4b3b      	ldr	r3, [pc, #236]	; (cef0 <lv_task_handler+0x164>)
    ce04:	781b      	ldrb	r3, [r3, #0]
    ce06:	2b00      	cmp	r3, #0
    ce08:	d05f      	beq.n	ceca <lv_task_handler+0x13e>
    busy_time += lv_tick_elaps(handler_start);
    ce0a:	9b01      	ldr	r3, [sp, #4]
    ce0c:	4c3a      	ldr	r4, [pc, #232]	; (cef8 <lv_task_handler+0x16c>)
    ce0e:	6818      	ldr	r0, [r3, #0]
    ce10:	f00d febc 	bl	1ab8c <lv_tick_elaps>
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
    ce14:	4d39      	ldr	r5, [pc, #228]	; (cefc <lv_task_handler+0x170>)
    busy_time += lv_tick_elaps(handler_start);
    ce16:	6823      	ldr	r3, [r4, #0]
    ce18:	4403      	add	r3, r0
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
    ce1a:	6828      	ldr	r0, [r5, #0]
    busy_time += lv_tick_elaps(handler_start);
    ce1c:	6023      	str	r3, [r4, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
    ce1e:	f00d feb5 	bl	1ab8c <lv_tick_elaps>
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
    ce22:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
    ce26:	d315      	bcc.n	ce54 <lv_task_handler+0xc8>
        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
    ce28:	2364      	movs	r3, #100	; 0x64
    ce2a:	6822      	ldr	r2, [r4, #0]
    ce2c:	4353      	muls	r3, r2
    ce2e:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    ce32:	fbb3 f3f2 	udiv	r3, r3, r2
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
    ce36:	b2da      	uxtb	r2, r3
    ce38:	2a64      	cmp	r2, #100	; 0x64
    ce3a:	bf8c      	ite	hi
    ce3c:	2300      	movhi	r3, #0
    ce3e:	f1c3 0364 	rsbls	r3, r3, #100	; 0x64
    ce42:	4a2f      	ldr	r2, [pc, #188]	; (cf00 <lv_task_handler+0x174>)
    ce44:	bf98      	it	ls
    ce46:	b2db      	uxtbls	r3, r3
    ce48:	7013      	strb	r3, [r2, #0]
        busy_time         = 0;
    ce4a:	2300      	movs	r3, #0
    ce4c:	6023      	str	r3, [r4, #0]
        idle_period_start = lv_tick_get();
    ce4e:	f00d fe90 	bl	1ab72 <lv_tick_get>
    ce52:	6028      	str	r0, [r5, #0]
    time_till_next = LV_NO_TASK_READY;
    ce54:	f04f 33ff 	mov.w	r3, #4294967295
    ce58:	4d2a      	ldr	r5, [pc, #168]	; (cf04 <lv_task_handler+0x178>)
    next = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    ce5a:	4826      	ldr	r0, [pc, #152]	; (cef4 <lv_task_handler+0x168>)
    time_till_next = LV_NO_TASK_READY;
    ce5c:	602b      	str	r3, [r5, #0]
    next = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
    ce5e:	f00e f9d4 	bl	1b20a <_lv_ll_get_head>
    ce62:	4604      	mov	r4, r0
        next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), next); /*Find the next task*/
    ce64:	4e23      	ldr	r6, [pc, #140]	; (cef4 <lv_task_handler+0x168>)
    while(next) {
    ce66:	b9dc      	cbnz	r4, cea0 <lv_task_handler+0x114>
    already_running = false; /*Release the mutex*/
    ce68:	4b1d      	ldr	r3, [pc, #116]	; (cee0 <lv_task_handler+0x154>)
    return time_till_next;
    ce6a:	6828      	ldr	r0, [r5, #0]
    already_running = false; /*Release the mutex*/
    ce6c:	701c      	strb	r4, [r3, #0]
    return time_till_next;
    ce6e:	e798      	b.n	cda2 <lv_task_handler+0x16>
            else if(task_interrupter) {
    ce70:	b134      	cbz	r4, ce80 <lv_task_handler+0xf4>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
    ce72:	7d22      	ldrb	r2, [r4, #20]
    ce74:	f003 0307 	and.w	r3, r3, #7
    ce78:	f002 0207 	and.w	r2, r2, #7
    ce7c:	4293      	cmp	r3, r2
    ce7e:	d9c0      	bls.n	ce02 <lv_task_handler+0x76>
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
    ce80:	f7ff ff58 	bl	cd34 <lv_task_exec>
    ce84:	2800      	cmp	r0, #0
    ce86:	d0bc      	beq.n	ce02 <lv_task_handler+0x76>
                    if(!task_created && !task_deleted) {
    ce88:	783b      	ldrb	r3, [r7, #0]
    ce8a:	2b00      	cmp	r3, #0
    ce8c:	d1bd      	bne.n	ce0a <lv_task_handler+0x7e>
    ce8e:	782b      	ldrb	r3, [r5, #0]
    ce90:	2b00      	cmp	r3, #0
    ce92:	d1ba      	bne.n	ce0a <lv_task_handler+0x7e>
                        task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
    ce94:	f8d8 4000 	ldr.w	r4, [r8]
    } while(!end_flag);
    ce98:	e78d      	b.n	cdb6 <lv_task_handler+0x2a>
            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
    ce9a:	f8c9 6000 	str.w	r6, [r9]
    ce9e:	e799      	b.n	cdd4 <lv_task_handler+0x48>
        if(next->prio != LV_TASK_PRIO_OFF) {
    cea0:	7d23      	ldrb	r3, [r4, #20]
    cea2:	075b      	lsls	r3, r3, #29
    cea4:	d00b      	beq.n	cebe <lv_task_handler+0x132>
    uint32_t elp = lv_tick_elaps(task->last_run);
    cea6:	6860      	ldr	r0, [r4, #4]
    cea8:	f00d fe70 	bl	1ab8c <lv_tick_elaps>
    if(elp >= task->period)
    ceac:	6823      	ldr	r3, [r4, #0]
    ceae:	4298      	cmp	r0, r3
        return 0;
    ceb0:	bf2c      	ite	cs
    ceb2:	2000      	movcs	r0, #0
    return task->period - elp;
    ceb4:	1a18      	subcc	r0, r3, r0
            if(delay < time_till_next)
    ceb6:	682b      	ldr	r3, [r5, #0]
    ceb8:	4283      	cmp	r3, r0
                time_till_next = delay;
    ceba:	bf88      	it	hi
    cebc:	6028      	strhi	r0, [r5, #0]
        next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), next); /*Find the next task*/
    cebe:	4621      	mov	r1, r4
    cec0:	4630      	mov	r0, r6
    cec2:	f00e f9a8 	bl	1b216 <_lv_ll_get_next>
    cec6:	4604      	mov	r4, r0
    cec8:	e7cd      	b.n	ce66 <lv_task_handler+0xda>
            if(task_created || task_deleted) {
    ceca:	782b      	ldrb	r3, [r5, #0]
    cecc:	2b00      	cmp	r3, #0
    cece:	d19c      	bne.n	ce0a <lv_task_handler+0x7e>
            if(task_list_changed) {
    ced0:	f89a 2000 	ldrb.w	r2, [sl]
    ced4:	2a00      	cmp	r2, #0
    ced6:	d0e0      	beq.n	ce9a <lv_task_handler+0x10e>
                task_interrupter = NULL;
    ced8:	461c      	mov	r4, r3
                task_list_changed = false;
    ceda:	f88a 3000 	strb.w	r3, [sl]
    } while(!end_flag);
    cede:	e76a      	b.n	cdb6 <lv_task_handler+0x2a>
    cee0:	2002a072 	.word	0x2002a072
    cee4:	2002a074 	.word	0x2002a074
    cee8:	20025e70 	.word	0x20025e70
    ceec:	2002a076 	.word	0x2002a076
    cef0:	2002a075 	.word	0x2002a075
    cef4:	20025e58 	.word	0x20025e58
    cef8:	20025e6c 	.word	0x20025e6c
    cefc:	20025e74 	.word	0x20025e74
    cf00:	2002a073 	.word	0x2002a073
    cf04:	20025e78 	.word	0x20025e78
    cf08:	20025e54 	.word	0x20025e54
    cf0c:	2002a077 	.word	0x2002a077

0000cf10 <lv_task_set_prio>:
    if(task->prio == prio) return;
    cf10:	7d03      	ldrb	r3, [r0, #20]
{
    cf12:	b570      	push	{r4, r5, r6, lr}
    if(task->prio == prio) return;
    cf14:	f003 0307 	and.w	r3, r3, #7
    cf18:	428b      	cmp	r3, r1
{
    cf1a:	4604      	mov	r4, r0
    cf1c:	460d      	mov	r5, r1
    if(task->prio == prio) return;
    cf1e:	d017      	beq.n	cf50 <lv_task_set_prio+0x40>
    _LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i) {
    cf20:	480f      	ldr	r0, [pc, #60]	; (cf60 <lv_task_set_prio+0x50>)
    cf22:	f00e f972 	bl	1b20a <_lv_ll_get_head>
    cf26:	4602      	mov	r2, r0
    cf28:	4e0d      	ldr	r6, [pc, #52]	; (cf60 <lv_task_set_prio+0x50>)
    cf2a:	b132      	cbz	r2, cf3a <lv_task_set_prio+0x2a>
        if(i->prio <= prio) {
    cf2c:	7d13      	ldrb	r3, [r2, #20]
    cf2e:	f003 0307 	and.w	r3, r3, #7
    cf32:	429d      	cmp	r5, r3
    cf34:	db0d      	blt.n	cf52 <lv_task_set_prio+0x42>
            if(i != task) _lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
    cf36:	42a2      	cmp	r2, r4
    cf38:	d003      	beq.n	cf42 <lv_task_set_prio+0x32>
        _lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
    cf3a:	4621      	mov	r1, r4
    cf3c:	4808      	ldr	r0, [pc, #32]	; (cf60 <lv_task_set_prio+0x50>)
    cf3e:	f00e fa0b 	bl	1b358 <_lv_ll_move_before>
    task_list_changed = true;
    cf42:	2201      	movs	r2, #1
    cf44:	4b07      	ldr	r3, [pc, #28]	; (cf64 <lv_task_set_prio+0x54>)
    cf46:	701a      	strb	r2, [r3, #0]
    task->prio = prio;
    cf48:	7d23      	ldrb	r3, [r4, #20]
    cf4a:	f365 0302 	bfi	r3, r5, #0, #3
    cf4e:	7523      	strb	r3, [r4, #20]
}
    cf50:	bd70      	pop	{r4, r5, r6, pc}
    _LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i) {
    cf52:	4611      	mov	r1, r2
    cf54:	4630      	mov	r0, r6
    cf56:	f00e f95e 	bl	1b216 <_lv_ll_get_next>
    cf5a:	4602      	mov	r2, r0
    cf5c:	e7e5      	b.n	cf2a <lv_task_set_prio+0x1a>
    cf5e:	bf00      	nop
    cf60:	20025e58 	.word	0x20025e58
    cf64:	2002a077 	.word	0x2002a077

0000cf68 <_lv_txt_get_width>:
 * @param flags settings for the text from 'txt_flag_t' enum
 * @return length of a char_num long text
 */
lv_coord_t _lv_txt_get_width(const char * txt, uint32_t length, const lv_font_t * font, lv_coord_t letter_space,
                             lv_txt_flag_t flag)
{
    cf68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cf6c:	4688      	mov	r8, r1
    cf6e:	4617      	mov	r7, r2
    cf70:	461e      	mov	r6, r3
    if(txt == NULL) return 0;
    cf72:	4605      	mov	r5, r0
    cf74:	2400      	movs	r4, #0
{
    cf76:	b085      	sub	sp, #20
    if(txt == NULL) return 0;
    cf78:	2800      	cmp	r0, #0
    cf7a:	d040      	beq.n	cffe <_lv_txt_get_width+0x96>
    if(font == NULL) return 0;
    cf7c:	2a00      	cmp	r2, #0
    cf7e:	d040      	beq.n	d002 <_lv_txt_get_width+0x9a>

    uint32_t i                   = 0;
    cf80:	9403      	str	r4, [sp, #12]
    lv_coord_t width             = 0;
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    cf82:	f88d 400b 	strb.w	r4, [sp, #11]

    if(length != 0) {
    cf86:	2900      	cmp	r1, #0
    cf88:	d132      	bne.n	cff0 <_lv_txt_get_width+0x88>
    lv_coord_t width             = 0;
    cf8a:	460c      	mov	r4, r1
                                      aligned */
        }
    }

    return width;
}
    cf8c:	4620      	mov	r0, r4
    cf8e:	b005      	add	sp, #20
    cf90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            uint32_t letter      = _lv_txt_encoded_next(txt, &i);
    cf94:	f8da 3000 	ldr.w	r3, [sl]
    cf98:	a903      	add	r1, sp, #12
    cf9a:	4628      	mov	r0, r5
    cf9c:	4798      	blx	r3
    cf9e:	4683      	mov	fp, r0
            uint32_t letter_next = _lv_txt_encoded_next(&txt[i], NULL);
    cfa0:	9803      	ldr	r0, [sp, #12]
    cfa2:	2100      	movs	r1, #0
    cfa4:	f8da 3000 	ldr.w	r3, [sl]
    cfa8:	4428      	add	r0, r5
    cfaa:	4798      	blx	r3
    cfac:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    cfae:	f1b9 0f00 	cmp.w	r9, #0
    cfb2:	d10e      	bne.n	cfd2 <_lv_txt_get_width+0x6a>
            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
    cfb4:	4659      	mov	r1, fp
    cfb6:	4638      	mov	r0, r7
    cfb8:	f00e fb39 	bl	1b62e <lv_font_get_glyph_width>
    cfbc:	b200      	sxth	r0, r0
            if(char_width > 0) {
    cfbe:	2800      	cmp	r0, #0
    cfc0:	dc11      	bgt.n	cfe6 <_lv_txt_get_width+0x7e>
        while(i < length) {
    cfc2:	9b03      	ldr	r3, [sp, #12]
    cfc4:	4598      	cmp	r8, r3
    cfc6:	d8e5      	bhi.n	cf94 <_lv_txt_get_width+0x2c>
        if(width > 0) {
    cfc8:	2c00      	cmp	r4, #0
    cfca:	dddf      	ble.n	cf8c <_lv_txt_get_width+0x24>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
    cfcc:	1ba4      	subs	r4, r4, r6
    cfce:	b224      	sxth	r4, r4
    cfd0:	e7dc      	b.n	cf8c <_lv_txt_get_width+0x24>
    cfd2:	9001      	str	r0, [sp, #4]
                if(_lv_txt_is_cmd(&cmd_state, letter) != false) {
    cfd4:	4659      	mov	r1, fp
    cfd6:	f10d 000b 	add.w	r0, sp, #11
    cfda:	f00e fa85 	bl	1b4e8 <_lv_txt_is_cmd>
    cfde:	9a01      	ldr	r2, [sp, #4]
    cfe0:	2800      	cmp	r0, #0
    cfe2:	d0e7      	beq.n	cfb4 <_lv_txt_get_width+0x4c>
    cfe4:	e7ed      	b.n	cfc2 <_lv_txt_get_width+0x5a>
                width += letter_space;
    cfe6:	4434      	add	r4, r6
    cfe8:	fa00 f484 	sxtah	r4, r0, r4
    cfec:	b224      	sxth	r4, r4
    cfee:	e7e8      	b.n	cfc2 <_lv_txt_get_width+0x5a>
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    cff0:	f89d 9038 	ldrb.w	r9, [sp, #56]	; 0x38
            uint32_t letter      = _lv_txt_encoded_next(txt, &i);
    cff4:	f8df a010 	ldr.w	sl, [pc, #16]	; d008 <_lv_txt_get_width+0xa0>
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    cff8:	f009 0901 	and.w	r9, r9, #1
    cffc:	e7e1      	b.n	cfc2 <_lv_txt_get_width+0x5a>
    if(txt == NULL) return 0;
    cffe:	4604      	mov	r4, r0
    d000:	e7c4      	b.n	cf8c <_lv_txt_get_width+0x24>
    d002:	4614      	mov	r4, r2
    d004:	e7c2      	b.n	cf8c <_lv_txt_get_width+0x24>
    d006:	bf00      	nop
    d008:	200004c4 	.word	0x200004c4

0000d00c <_lv_txt_get_next_line>:
{
    d00c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d010:	b08f      	sub	sp, #60	; 0x3c
    d012:	4699      	mov	r9, r3
    d014:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
    if(txt == NULL) return 0;
    d018:	4606      	mov	r6, r0
{
    d01a:	9102      	str	r1, [sp, #8]
    d01c:	9204      	str	r2, [sp, #16]
    d01e:	9303      	str	r3, [sp, #12]
    if(txt == NULL) return 0;
    d020:	b190      	cbz	r0, d048 <_lv_txt_get_next_line+0x3c>
    if(font == NULL) return 0;
    d022:	2900      	cmp	r1, #0
    d024:	f000 80cd 	beq.w	d1c2 <_lv_txt_get_next_line+0x1b6>
    if((flag & LV_TXT_FLAG_EXPAND) || (flag & LV_TXT_FLAG_FIT)) {
    d028:	9b03      	ldr	r3, [sp, #12]
    d02a:	f013 0312 	ands.w	r3, r3, #18
    d02e:	d00e      	beq.n	d04e <_lv_txt_get_next_line+0x42>
        for(i = 0; txt[i] != '\n' && txt[i] != '\r' && txt[i] != '\0'; i++) {
    d030:	2000      	movs	r0, #0
    d032:	e000      	b.n	d036 <_lv_txt_get_next_line+0x2a>
    d034:	3001      	adds	r0, #1
    d036:	5c33      	ldrb	r3, [r6, r0]
    d038:	2b0a      	cmp	r3, #10
    d03a:	f000 80c4 	beq.w	d1c6 <_lv_txt_get_next_line+0x1ba>
    d03e:	2b0d      	cmp	r3, #13
    d040:	f000 80c1 	beq.w	d1c6 <_lv_txt_get_next_line+0x1ba>
    d044:	2b00      	cmp	r3, #0
    d046:	d1f5      	bne.n	d034 <_lv_txt_get_next_line+0x28>
}
    d048:	b00f      	add	sp, #60	; 0x3c
    d04a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    d04e:	9a03      	ldr	r2, [sp, #12]
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    d050:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    d054:	f012 0202 	ands.w	r2, r2, #2
    d058:	9205      	str	r2, [sp, #20]
    d05a:	f647 4218 	movw	r2, #31768	; 0x7c18
    d05e:	bf18      	it	ne
    d060:	4691      	movne	r9, r2
    uint32_t i = 0;                                        /* Iterating index into txt */
    d062:	930b      	str	r3, [sp, #44]	; 0x2c
    while(txt[i] != '\0' && max_width > 0) {
    d064:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d066:	9300      	str	r3, [sp, #0]
    d068:	eb06 0a03 	add.w	sl, r6, r3
    d06c:	5cf3      	ldrb	r3, [r6, r3]
    d06e:	2b00      	cmp	r3, #0
    d070:	f000 808e 	beq.w	d190 <_lv_txt_get_next_line+0x184>
    d074:	f1b9 0f00 	cmp.w	r9, #0
    d078:	f340 808a 	ble.w	d190 <_lv_txt_get_next_line+0x184>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    d07c:	f647 4318 	movw	r3, #31768	; 0x7c18
    d080:	9a05      	ldr	r2, [sp, #20]
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
    d082:	2400      	movs	r4, #0
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
    d084:	2a00      	cmp	r2, #0
    d086:	bf08      	it	eq
    d088:	464b      	moveq	r3, r9
    d08a:	9307      	str	r3, [sp, #28]
    letter = _lv_txt_encoded_next(txt, &i_next);
    d08c:	4b4f      	ldr	r3, [pc, #316]	; (d1cc <_lv_txt_get_next_line+0x1c0>)
    d08e:	4650      	mov	r0, sl
    d090:	681a      	ldr	r2, [r3, #0]
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
    d092:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
    letter = _lv_txt_encoded_next(txt, &i_next);
    d096:	a90c      	add	r1, sp, #48	; 0x30
    d098:	4790      	blx	r2
    uint32_t break_index = NO_BREAK_FOUND; /* only used for "long" words */
    d09a:	f04f 3bff 	mov.w	fp, #4294967295
    letter = _lv_txt_encoded_next(txt, &i_next);
    d09e:	4680      	mov	r8, r0
    lv_coord_t cur_w = 0;  /* Pixel Width of transversed string */
    d0a0:	4627      	mov	r7, r4
    uint32_t letter_next = 0; /* Letter at i_next */
    d0a2:	4622      	mov	r2, r4
    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
    d0a4:	4625      	mov	r5, r4
    i_next_next = i_next;
    d0a6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    uint32_t word_len = 0;   /* Number of characters in the transversed word */
    d0a8:	9401      	str	r4, [sp, #4]
    i_next_next = i_next;
    d0aa:	930d      	str	r3, [sp, #52]	; 0x34
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    d0ac:	9b03      	ldr	r3, [sp, #12]
    d0ae:	f003 0301 	and.w	r3, r3, #1
    d0b2:	9308      	str	r3, [sp, #32]
    while(txt[i] != '\0') {
    d0b4:	f81a 1005 	ldrb.w	r1, [sl, r5]
    d0b8:	b949      	cbnz	r1, d0ce <_lv_txt_get_next_line+0xc2>
    if(break_index == NO_BREAK_FOUND) {
    d0ba:	f1bb 3fff 	cmp.w	fp, #4294967295
    d0be:	d053      	beq.n	d168 <_lv_txt_get_next_line+0x15c>
    if(force) return break_index;
    d0c0:	9b00      	ldr	r3, [sp, #0]
    d0c2:	465d      	mov	r5, fp
    d0c4:	2b00      	cmp	r3, #0
    d0c6:	d057      	beq.n	d178 <_lv_txt_get_next_line+0x16c>
    if(word_w_ptr != NULL) *word_w_ptr = 0; /* Return no word */
    d0c8:	2400      	movs	r4, #0
    return 0;
    d0ca:	4625      	mov	r5, r4
    d0cc:	e054      	b.n	d178 <_lv_txt_get_next_line+0x16c>
        letter_next = _lv_txt_encoded_next(txt, &i_next_next);
    d0ce:	4b3f      	ldr	r3, [pc, #252]	; (d1cc <_lv_txt_get_next_line+0x1c0>)
    d0d0:	4650      	mov	r0, sl
    d0d2:	681a      	ldr	r2, [r3, #0]
    d0d4:	a90d      	add	r1, sp, #52	; 0x34
    d0d6:	4790      	blx	r2
        word_len++;
    d0d8:	9b01      	ldr	r3, [sp, #4]
        letter_next = _lv_txt_encoded_next(txt, &i_next_next);
    d0da:	4602      	mov	r2, r0
        word_len++;
    d0dc:	3301      	adds	r3, #1
    d0de:	9306      	str	r3, [sp, #24]
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    d0e0:	9b08      	ldr	r3, [sp, #32]
    d0e2:	b173      	cbz	r3, d102 <_lv_txt_get_next_line+0xf6>
    d0e4:	9009      	str	r0, [sp, #36]	; 0x24
            if(_lv_txt_is_cmd(cmd_state, letter) != false) {
    d0e6:	4641      	mov	r1, r8
    d0e8:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
    d0ec:	f00e f9fc 	bl	1b4e8 <_lv_txt_is_cmd>
    d0f0:	9a09      	ldr	r2, [sp, #36]	; 0x24
    d0f2:	b130      	cbz	r0, d102 <_lv_txt_get_next_line+0xf6>
        i_next = i_next_next;
    d0f4:	e9dd 510c 	ldrd	r5, r1, [sp, #48]	; 0x30
    uint8_t i;
    bool ret = false;

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
    d0f8:	9b06      	ldr	r3, [sp, #24]
        letter_next = _lv_txt_encoded_next(txt, &i_next_next);
    d0fa:	4690      	mov	r8, r2
        i_next = i_next_next;
    d0fc:	910c      	str	r1, [sp, #48]	; 0x30
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
    d0fe:	9301      	str	r3, [sp, #4]
    d100:	e7d8      	b.n	d0b4 <_lv_txt_get_next_line+0xa8>
        letter_w = lv_font_get_glyph_width(font, letter, letter_next);
    d102:	4641      	mov	r1, r8
    d104:	9802      	ldr	r0, [sp, #8]
    d106:	9209      	str	r2, [sp, #36]	; 0x24
    d108:	f00e fa91 	bl	1b62e <lv_font_get_glyph_width>
    d10c:	b201      	sxth	r1, r0
        if(letter_w > 0) {
    d10e:	2900      	cmp	r1, #0
            cur_w += letter_space;
    d110:	bfc8      	it	gt
    d112:	9b04      	ldrgt	r3, [sp, #16]
        cur_w += letter_w;
    d114:	fa07 f780 	sxtah	r7, r7, r0
    d118:	b23f      	sxth	r7, r7
            cur_w += letter_space;
    d11a:	bfc4      	itt	gt
    d11c:	18ff      	addgt	r7, r7, r3
    d11e:	b23f      	sxthgt	r7, r7
        if(break_index == NO_BREAK_FOUND && (cur_w - letter_space) > max_width) {
    d120:	f1bb 3fff 	cmp.w	fp, #4294967295
        if(letter_w > 0) {
    d124:	9a09      	ldr	r2, [sp, #36]	; 0x24
        if(break_index == NO_BREAK_FOUND && (cur_w - letter_space) > max_width) {
    d126:	d105      	bne.n	d134 <_lv_txt_get_next_line+0x128>
    d128:	9b04      	ldr	r3, [sp, #16]
    d12a:	1af9      	subs	r1, r7, r3
    d12c:	9b07      	ldr	r3, [sp, #28]
    d12e:	4299      	cmp	r1, r3
    d130:	bfc8      	it	gt
    d132:	46ab      	movgt	fp, r5
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
    d134:	f1b8 0f0a 	cmp.w	r8, #10
    d138:	d010      	beq.n	d15c <_lv_txt_get_next_line+0x150>
    d13a:	f1b8 0f0d 	cmp.w	r8, #13
    d13e:	d00d      	beq.n	d15c <_lv_txt_get_next_line+0x150>
    d140:	2100      	movs	r1, #0
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
    d142:	4b23      	ldr	r3, [pc, #140]	; (d1d0 <_lv_txt_get_next_line+0x1c4>)
    d144:	b2c8      	uxtb	r0, r1
    d146:	5c18      	ldrb	r0, [r3, r0]
    d148:	b920      	cbnz	r0, d154 <_lv_txt_get_next_line+0x148>
        if(word_w_ptr != NULL && break_index == NO_BREAK_FOUND) *word_w_ptr = cur_w;
    d14a:	f1bb 3fff 	cmp.w	fp, #4294967295
    d14e:	bf08      	it	eq
    d150:	463c      	moveq	r4, r7
    d152:	e7cf      	b.n	d0f4 <_lv_txt_get_next_line+0xe8>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
    d154:	4580      	cmp	r8, r0
    d156:	f101 0101 	add.w	r1, r1, #1
    d15a:	d1f2      	bne.n	d142 <_lv_txt_get_next_line+0x136>
            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;
    d15c:	2d00      	cmp	r5, #0
    d15e:	d1ac      	bne.n	d0ba <_lv_txt_get_next_line+0xae>
    d160:	f1bb 3fff 	cmp.w	fp, #4294967295
    d164:	d1ac      	bne.n	d0c0 <_lv_txt_get_next_line+0xb4>
    d166:	463c      	mov	r4, r7
        if(word_len == 0 || (letter == '\r' && letter_next == '\n')) i = i_next;
    d168:	9b01      	ldr	r3, [sp, #4]
    d16a:	b123      	cbz	r3, d176 <_lv_txt_get_next_line+0x16a>
    d16c:	f1b8 0f0d 	cmp.w	r8, #13
    d170:	d102      	bne.n	d178 <_lv_txt_get_next_line+0x16c>
    d172:	2a0a      	cmp	r2, #10
    d174:	d100      	bne.n	d178 <_lv_txt_get_next_line+0x16c>
    d176:	9d0c      	ldr	r5, [sp, #48]	; 0x30
        max_width -= word_w;
    d178:	eba9 0904 	sub.w	r9, r9, r4
    d17c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d17e:	fa0f f989 	sxth.w	r9, r9
        if(advance == 0) {
    d182:	b975      	cbnz	r5, d1a2 <_lv_txt_get_next_line+0x196>
            if(i == 0) _lv_txt_encoded_next(txt, &i); // prevent inf loops
    d184:	b95b      	cbnz	r3, d19e <_lv_txt_get_next_line+0x192>
    d186:	4b11      	ldr	r3, [pc, #68]	; (d1cc <_lv_txt_get_next_line+0x1c0>)
    d188:	4630      	mov	r0, r6
    d18a:	681b      	ldr	r3, [r3, #0]
    d18c:	a90b      	add	r1, sp, #44	; 0x2c
    d18e:	4798      	blx	r3
    if(i == 0) {
    d190:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d192:	b923      	cbnz	r3, d19e <_lv_txt_get_next_line+0x192>
        _lv_txt_encoded_next(txt, &i);
    d194:	4b0d      	ldr	r3, [pc, #52]	; (d1cc <_lv_txt_get_next_line+0x1c0>)
    d196:	4630      	mov	r0, r6
    d198:	681b      	ldr	r3, [r3, #0]
    d19a:	a90b      	add	r1, sp, #44	; 0x2c
    d19c:	4798      	blx	r3
    return i;
    d19e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    d1a0:	e752      	b.n	d048 <_lv_txt_get_next_line+0x3c>
        i += advance;
    d1a2:	441d      	add	r5, r3
        if(txt[0] == '\n' || txt[0] == '\r') break;
    d1a4:	7833      	ldrb	r3, [r6, #0]
        i += advance;
    d1a6:	950b      	str	r5, [sp, #44]	; 0x2c
        if(txt[0] == '\n' || txt[0] == '\r') break;
    d1a8:	2b0a      	cmp	r3, #10
    d1aa:	d0f1      	beq.n	d190 <_lv_txt_get_next_line+0x184>
    d1ac:	2b0d      	cmp	r3, #13
    d1ae:	d0ef      	beq.n	d190 <_lv_txt_get_next_line+0x184>
        if(txt[i] == '\n' || txt[i] == '\r') {
    d1b0:	5d73      	ldrb	r3, [r6, r5]
    d1b2:	2b0a      	cmp	r3, #10
    d1b4:	d002      	beq.n	d1bc <_lv_txt_get_next_line+0x1b0>
    d1b6:	2b0d      	cmp	r3, #13
    d1b8:	f47f af54 	bne.w	d064 <_lv_txt_get_next_line+0x58>
            i++;  /* Include the following newline in the current line */
    d1bc:	3501      	adds	r5, #1
    d1be:	950b      	str	r5, [sp, #44]	; 0x2c
            break;
    d1c0:	e7e6      	b.n	d190 <_lv_txt_get_next_line+0x184>
    if(txt == NULL) return 0;
    d1c2:	9802      	ldr	r0, [sp, #8]
    d1c4:	e740      	b.n	d048 <_lv_txt_get_next_line+0x3c>
        if(txt[i] != '\0') i++;    /*To go beyond `\n`*/
    d1c6:	3001      	adds	r0, #1
    d1c8:	e73e      	b.n	d048 <_lv_txt_get_next_line+0x3c>
    d1ca:	bf00      	nop
    d1cc:	200004c4 	.word	0x200004c4
    d1d0:	00044109 	.word	0x00044109

0000d1d4 <get_glyph_dsc_id.isra.0.part.0>:

/**********************
 *   STATIC FUNCTIONS
 **********************/

static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
    d1d4:	b5f0      	push	{r4, r5, r6, r7, lr}
{
    if(letter == '\0') return 0;

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
    d1d6:	6804      	ldr	r4, [r0, #0]
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
    d1d8:	460d      	mov	r5, r1

    /*Check the cache first*/
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    d1da:	69a3      	ldr	r3, [r4, #24]
static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
    d1dc:	b085      	sub	sp, #20
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    d1de:	428b      	cmp	r3, r1
    d1e0:	d00b      	beq.n	d1fa <get_glyph_dsc_id.isra.0.part.0+0x26>

    uint16_t i;
    for(i = 0; i < fdsc->cmap_num; i++) {
    d1e2:	2300      	movs	r3, #0
    d1e4:	f04f 0c14 	mov.w	ip, #20
    d1e8:	8a67      	ldrh	r7, [r4, #18]
    d1ea:	f3c7 0709 	ubfx	r7, r7, #0, #10
    d1ee:	b29a      	uxth	r2, r3
    d1f0:	4297      	cmp	r7, r2
    d1f2:	d805      	bhi.n	d200 <get_glyph_dsc_id.isra.0.part.0+0x2c>
        fdsc->last_glyph_id = glyph_id;
        return glyph_id;
    }

    fdsc->last_letter = letter;
    fdsc->last_glyph_id = 0;
    d1f4:	2000      	movs	r0, #0
    fdsc->last_letter = letter;
    d1f6:	61a5      	str	r5, [r4, #24]
    fdsc->last_glyph_id = 0;
    d1f8:	e011      	b.n	d21e <get_glyph_dsc_id.isra.0.part.0+0x4a>
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
    d1fa:	69e0      	ldr	r0, [r4, #28]
    return 0;

}
    d1fc:	b005      	add	sp, #20
    d1fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
    d200:	fb0c f603 	mul.w	r6, ip, r3
    d204:	68a2      	ldr	r2, [r4, #8]
    d206:	3301      	adds	r3, #1
    d208:	1991      	adds	r1, r2, r6
    d20a:	5992      	ldr	r2, [r2, r6]
        if(rcp > fdsc->cmaps[i].range_length) continue;
    d20c:	8888      	ldrh	r0, [r1, #4]
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
    d20e:	1aaa      	subs	r2, r5, r2
        if(rcp > fdsc->cmaps[i].range_length) continue;
    d210:	4282      	cmp	r2, r0
    d212:	d8ec      	bhi.n	d1ee <get_glyph_dsc_id.isra.0.part.0+0x1a>
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
    d214:	7c8b      	ldrb	r3, [r1, #18]
    d216:	b923      	cbnz	r3, d222 <get_glyph_dsc_id.isra.0.part.0+0x4e>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
    d218:	88c8      	ldrh	r0, [r1, #6]
    d21a:	4410      	add	r0, r2
        fdsc->last_letter = letter;
    d21c:	61a5      	str	r5, [r4, #24]
    fdsc->last_glyph_id = 0;
    d21e:	61e0      	str	r0, [r4, #28]
    return 0;
    d220:	e7ec      	b.n	d1fc <get_glyph_dsc_id.isra.0.part.0+0x28>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
    d222:	2b01      	cmp	r3, #1
    d224:	d104      	bne.n	d230 <get_glyph_dsc_id.isra.0.part.0+0x5c>
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
    d226:	68cb      	ldr	r3, [r1, #12]
    d228:	5c98      	ldrb	r0, [r3, r2]
    d22a:	88cb      	ldrh	r3, [r1, #6]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
    d22c:	4418      	add	r0, r3
    d22e:	e7f5      	b.n	d21c <get_glyph_dsc_id.isra.0.part.0+0x48>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
    d230:	2b02      	cmp	r3, #2
    d232:	d113      	bne.n	d25c <get_glyph_dsc_id.isra.0.part.0+0x88>
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
    d234:	4816      	ldr	r0, [pc, #88]	; (d290 <get_glyph_dsc_id.isra.0.part.0+0xbc>)
            uint16_t key = rcp;
    d236:	f8ad 200e 	strh.w	r2, [sp, #14]
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
    d23a:	8a0a      	ldrh	r2, [r1, #16]
    d23c:	9000      	str	r0, [sp, #0]
    d23e:	6889      	ldr	r1, [r1, #8]
    d240:	f10d 000e 	add.w	r0, sp, #14
    d244:	f00e f9cc 	bl	1b5e0 <_lv_utils_bsearch>
            if(p) {
    d248:	2800      	cmp	r0, #0
    d24a:	d0e7      	beq.n	d21c <get_glyph_dsc_id.isra.0.part.0+0x48>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
    d24c:	68a3      	ldr	r3, [r4, #8]
    d24e:	441e      	add	r6, r3
    d250:	68b3      	ldr	r3, [r6, #8]
    d252:	1ac0      	subs	r0, r0, r3
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
    d254:	88f3      	ldrh	r3, [r6, #6]
    d256:	eb03 0050 	add.w	r0, r3, r0, lsr #1
    d25a:	e7df      	b.n	d21c <get_glyph_dsc_id.isra.0.part.0+0x48>
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
    d25c:	2b03      	cmp	r3, #3
    d25e:	d115      	bne.n	d28c <get_glyph_dsc_id.isra.0.part.0+0xb8>
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
    d260:	4b0b      	ldr	r3, [pc, #44]	; (d290 <get_glyph_dsc_id.isra.0.part.0+0xbc>)
            uint16_t key = rcp;
    d262:	f8ad 200e 	strh.w	r2, [sp, #14]
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
    d266:	8a0a      	ldrh	r2, [r1, #16]
    d268:	9300      	str	r3, [sp, #0]
    d26a:	6889      	ldr	r1, [r1, #8]
    d26c:	2302      	movs	r3, #2
    d26e:	f10d 000e 	add.w	r0, sp, #14
    d272:	f00e f9b5 	bl	1b5e0 <_lv_utils_bsearch>
            if(p) {
    d276:	2800      	cmp	r0, #0
    d278:	d0d0      	beq.n	d21c <get_glyph_dsc_id.isra.0.part.0+0x48>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
    d27a:	68a3      	ldr	r3, [r4, #8]
    d27c:	441e      	add	r6, r3
    d27e:	68b3      	ldr	r3, [r6, #8]
    d280:	1ac0      	subs	r0, r0, r3
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
    d282:	68f3      	ldr	r3, [r6, #12]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
    d284:	0840      	lsrs	r0, r0, #1
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
    d286:	5c18      	ldrb	r0, [r3, r0]
    d288:	88f3      	ldrh	r3, [r6, #6]
    d28a:	e7cf      	b.n	d22c <get_glyph_dsc_id.isra.0.part.0+0x58>
        uint32_t glyph_id = 0;
    d28c:	2000      	movs	r0, #0
    d28e:	e7c5      	b.n	d21c <get_glyph_dsc_id.isra.0.part.0+0x48>
    d290:	0001b66b 	.word	0x0001b66b

0000d294 <lv_font_get_glyph_dsc_fmt_txt>:
    if(unicode_letter == '\t') {
    d294:	2a09      	cmp	r2, #9
{
    d296:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    d29a:	460c      	mov	r4, r1
    d29c:	4680      	mov	r8, r0
    d29e:	4611      	mov	r1, r2
    d2a0:	469a      	mov	sl, r3
    if(unicode_letter == '\t') {
    d2a2:	d006      	beq.n	d2b2 <lv_font_get_glyph_dsc_fmt_txt+0x1e>
    if(letter == '\0') return 0;
    d2a4:	2a00      	cmp	r2, #0
    d2a6:	d136      	bne.n	d316 <lv_font_get_glyph_dsc_fmt_txt+0x82>
    if(!gid) return false;
    d2a8:	2600      	movs	r6, #0
}
    d2aa:	4630      	mov	r0, r6
    d2ac:	b004      	add	sp, #16
    d2ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        is_tab = true;
    d2b2:	2601      	movs	r6, #1
        unicode_letter = ' ';
    d2b4:	2120      	movs	r1, #32
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
    d2b6:	46c1      	mov	r9, r8
    d2b8:	f859 7f10 	ldr.w	r7, [r9, #16]!
    d2bc:	4648      	mov	r0, r9
    d2be:	f7ff ff89 	bl	d1d4 <get_glyph_dsc_id.isra.0.part.0>
    if(!gid) return false;
    d2c2:	4605      	mov	r5, r0
    d2c4:	2800      	cmp	r0, #0
    d2c6:	d0ef      	beq.n	d2a8 <lv_font_get_glyph_dsc_fmt_txt+0x14>
    if(fdsc->kern_dsc) {
    d2c8:	68fb      	ldr	r3, [r7, #12]
    d2ca:	bb33      	cbnz	r3, d31a <lv_font_get_glyph_dsc_fmt_txt+0x86>
    int8_t kvalue = 0;
    d2cc:	2000      	movs	r0, #0
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
    d2ce:	687b      	ldr	r3, [r7, #4]
    d2d0:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
    d2d4:	8a3b      	ldrh	r3, [r7, #16]
    d2d6:	4343      	muls	r3, r0
    uint32_t adv_w = gdsc->adv_w;
    d2d8:	8868      	ldrh	r0, [r5, #2]
    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
    d2da:	111b      	asrs	r3, r3, #4
    uint32_t adv_w = gdsc->adv_w;
    d2dc:	f3c0 120b 	ubfx	r2, r0, #4, #12
    d2e0:	4610      	mov	r0, r2
    if(is_tab) adv_w *= 2;
    d2e2:	b10e      	cbz	r6, d2e8 <lv_font_get_glyph_dsc_fmt_txt+0x54>
    d2e4:	b210      	sxth	r0, r2
    d2e6:	0040      	lsls	r0, r0, #1
    adv_w  = (adv_w + (1 << 3)) >> 4;
    d2e8:	3308      	adds	r3, #8
    d2ea:	4403      	add	r3, r0
    d2ec:	091b      	lsrs	r3, r3, #4
    dsc_out->adv_w = adv_w;
    d2ee:	8023      	strh	r3, [r4, #0]
    dsc_out->box_h = gdsc->box_h;
    d2f0:	796b      	ldrb	r3, [r5, #5]
    d2f2:	80a3      	strh	r3, [r4, #4]
    dsc_out->box_w = gdsc->box_w;
    d2f4:	792b      	ldrb	r3, [r5, #4]
    d2f6:	8063      	strh	r3, [r4, #2]
    dsc_out->ofs_x = gdsc->ofs_x;
    d2f8:	f995 2006 	ldrsb.w	r2, [r5, #6]
    d2fc:	80e2      	strh	r2, [r4, #6]
    dsc_out->ofs_y = gdsc->ofs_y;
    d2fe:	f995 2007 	ldrsb.w	r2, [r5, #7]
    d302:	8122      	strh	r2, [r4, #8]
    dsc_out->bpp   = (uint8_t)fdsc->bpp;
    d304:	7cfa      	ldrb	r2, [r7, #19]
    d306:	f3c2 0283 	ubfx	r2, r2, #2, #4
    d30a:	72a2      	strb	r2, [r4, #10]
    if(is_tab) dsc_out->box_w = dsc_out->box_w * 2;
    d30c:	2e00      	cmp	r6, #0
    d30e:	d060      	beq.n	d3d2 <lv_font_get_glyph_dsc_fmt_txt+0x13e>
    d310:	005b      	lsls	r3, r3, #1
    d312:	8063      	strh	r3, [r4, #2]
    d314:	e7c9      	b.n	d2aa <lv_font_get_glyph_dsc_fmt_txt+0x16>
    bool is_tab = false;
    d316:	2600      	movs	r6, #0
    d318:	e7cd      	b.n	d2b6 <lv_font_get_glyph_dsc_fmt_txt+0x22>
    if(letter == '\0') return 0;
    d31a:	f1ba 0f00 	cmp.w	sl, #0
    d31e:	d0d5      	beq.n	d2cc <lv_font_get_glyph_dsc_fmt_txt+0x38>
    d320:	4651      	mov	r1, sl
    d322:	4648      	mov	r0, r9
    d324:	f7ff ff56 	bl	d1d4 <get_glyph_dsc_id.isra.0.part.0>
        if(gid_next) {
    d328:	2800      	cmp	r0, #0
    d32a:	d0cf      	beq.n	d2cc <lv_font_get_glyph_dsc_fmt_txt+0x38>
            kvalue = get_kern_value(font, gid, gid_next);
    d32c:	f8d8 3010 	ldr.w	r3, [r8, #16]
{
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;

    int8_t value = 0;

    if(fdsc->kern_classes == 0) {
    d330:	f8d3 800c 	ldr.w	r8, [r3, #12]
    d334:	7cdb      	ldrb	r3, [r3, #19]
    d336:	065b      	lsls	r3, r3, #25
    d338:	d436      	bmi.n	d3a8 <lv_font_get_glyph_dsc_fmt_txt+0x114>
        /*Kern pairs*/
        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;
        if(kdsc->glyph_ids_size == 0) {
    d33a:	f898 300b 	ldrb.w	r3, [r8, #11]
    d33e:	f013 0303 	ands.w	r3, r3, #3
    d342:	d119      	bne.n	d378 <lv_font_get_glyph_dsc_fmt_txt+0xe4>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint8_t * g_ids = kdsc->glyph_ids;
    d344:	f8d8 9000 	ldr.w	r9, [r8]
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
    d348:	f8d8 2008 	ldr.w	r2, [r8, #8]
    d34c:	4b22      	ldr	r3, [pc, #136]	; (d3d8 <lv_font_get_glyph_dsc_fmt_txt+0x144>)
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
    d34e:	eb05 2000 	add.w	r0, r5, r0, lsl #8
    d352:	f8ad 000c 	strh.w	r0, [sp, #12]
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
    d356:	9300      	str	r3, [sp, #0]
    d358:	4649      	mov	r1, r9
    d35a:	2302      	movs	r3, #2
    d35c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    d360:	a803      	add	r0, sp, #12
    d362:	f00e f93d 	bl	1b5e0 <_lv_utils_bsearch>

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
    d366:	2800      	cmp	r0, #0
    d368:	d0b1      	beq.n	d2ce <lv_font_get_glyph_dsc_fmt_txt+0x3a>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - g_ids);
    d36a:	eba0 0009 	sub.w	r0, r0, r9
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
    d36e:	0840      	lsrs	r0, r0, #1

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - (const uint8_t *)g_ids);
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
                value = kdsc->values[ofs];
    d370:	f8d8 3004 	ldr.w	r3, [r8, #4]
    d374:	5618      	ldrsb	r0, [r3, r0]
    d376:	e7aa      	b.n	d2ce <lv_font_get_glyph_dsc_fmt_txt+0x3a>
        else if(kdsc->glyph_ids_size == 1) {
    d378:	2b01      	cmp	r3, #1
    d37a:	d1a7      	bne.n	d2cc <lv_font_get_glyph_dsc_fmt_txt+0x38>
            const uint16_t * g_ids = kdsc->glyph_ids;
    d37c:	f8d8 9000 	ldr.w	r9, [r8]
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
    d380:	f8d8 2008 	ldr.w	r2, [r8, #8]
    d384:	4b15      	ldr	r3, [pc, #84]	; (d3dc <lv_font_get_glyph_dsc_fmt_txt+0x148>)
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
    d386:	eb05 2000 	add.w	r0, r5, r0, lsl #8
    d38a:	9003      	str	r0, [sp, #12]
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
    d38c:	9300      	str	r3, [sp, #0]
    d38e:	4649      	mov	r1, r9
    d390:	2304      	movs	r3, #4
    d392:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    d396:	a803      	add	r0, sp, #12
    d398:	f00e f922 	bl	1b5e0 <_lv_utils_bsearch>
            if(kid_p) {
    d39c:	2800      	cmp	r0, #0
    d39e:	d096      	beq.n	d2ce <lv_font_get_glyph_dsc_fmt_txt+0x3a>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - (const uint8_t *)g_ids);
    d3a0:	eba0 0009 	sub.w	r0, r0, r9
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
    d3a4:	0900      	lsrs	r0, r0, #4
    d3a6:	e7e3      	b.n	d370 <lv_font_get_glyph_dsc_fmt_txt+0xdc>
        }
    }
    else {
        /*Kern classes*/
        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
    d3a8:	f8d8 3004 	ldr.w	r3, [r8, #4]
    d3ac:	5d5b      	ldrb	r3, [r3, r5]
        uint8_t right_class = kdsc->right_class_mapping[gid_right];

        /* If class = 0, kerning not exist for that glyph
         * else got the value form `class_pair_values` 2D array*/
        if(left_class > 0 && right_class > 0) {
    d3ae:	2b00      	cmp	r3, #0
    d3b0:	d08c      	beq.n	d2cc <lv_font_get_glyph_dsc_fmt_txt+0x38>
        uint8_t right_class = kdsc->right_class_mapping[gid_right];
    d3b2:	f8d8 2008 	ldr.w	r2, [r8, #8]
    d3b6:	5c11      	ldrb	r1, [r2, r0]
        if(left_class > 0 && right_class > 0) {
    d3b8:	2900      	cmp	r1, #0
    d3ba:	d087      	beq.n	d2cc <lv_font_get_glyph_dsc_fmt_txt+0x38>
            value = kdsc->class_pair_values[(left_class - 1) * kdsc->right_class_cnt + (right_class - 1)];
    d3bc:	f8d8 2000 	ldr.w	r2, [r8]
    d3c0:	f898 000d 	ldrb.w	r0, [r8, #13]
    d3c4:	3b01      	subs	r3, #1
    d3c6:	440a      	add	r2, r1
    d3c8:	fb00 2303 	mla	r3, r0, r3, r2
    d3cc:	f913 0c01 	ldrsb.w	r0, [r3, #-1]
    d3d0:	e77d      	b.n	d2ce <lv_font_get_glyph_dsc_fmt_txt+0x3a>
    return true;
    d3d2:	2601      	movs	r6, #1
    d3d4:	e769      	b.n	d2aa <lv_font_get_glyph_dsc_fmt_txt+0x16>
    d3d6:	bf00      	nop
    d3d8:	0001b647 	.word	0x0001b647
    d3dc:	0001b659 	.word	0x0001b659

0000d3e0 <_lv_font_clean_up_fmt_txt>:
{
    d3e0:	b510      	push	{r4, lr}
    if(LV_GC_ROOT(_lv_font_decompr_buf)) {
    d3e2:	4c04      	ldr	r4, [pc, #16]	; (d3f4 <_lv_font_clean_up_fmt_txt+0x14>)
    d3e4:	6820      	ldr	r0, [r4, #0]
    d3e6:	b118      	cbz	r0, d3f0 <_lv_font_clean_up_fmt_txt+0x10>
        lv_mem_free(LV_GC_ROOT(_lv_font_decompr_buf));
    d3e8:	f7ff fb6a 	bl	cac0 <lv_mem_free>
        LV_GC_ROOT(_lv_font_decompr_buf) = NULL;
    d3ec:	2300      	movs	r3, #0
    d3ee:	6023      	str	r3, [r4, #0]
}
    d3f0:	bd10      	pop	{r4, pc}
    d3f2:	bf00      	nop
    d3f4:	20025da8 	.word	0x20025da8

0000d3f8 <apply_theme>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void apply_theme(lv_theme_t * th, lv_obj_t * obj, lv_theme_style_t name)
{
    d3f8:	b570      	push	{r4, r5, r6, lr}
    d3fa:	4604      	mov	r4, r0
    if(th->base) {
    d3fc:	6880      	ldr	r0, [r0, #8]
{
    d3fe:	460d      	mov	r5, r1
    d400:	4616      	mov	r6, r2
    if(th->base) {
    d402:	b108      	cbz	r0, d408 <apply_theme+0x10>
        apply_theme(th->base, obj, name);
    d404:	f7ff fff8 	bl	d3f8 <apply_theme>
    }

    /*apply_xcb is deprecated, use apply_cb instead*/
    if(th->apply_xcb) {
    d408:	6863      	ldr	r3, [r4, #4]
    d40a:	b123      	cbz	r3, d416 <apply_theme+0x1e>
        th->apply_xcb(obj, name);
    d40c:	4631      	mov	r1, r6
    d40e:	4628      	mov	r0, r5
    }
    else if(th->apply_cb) {
        th->apply_cb(act_theme, obj, name);
    }
}
    d410:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        th->apply_xcb(obj, name);
    d414:	4718      	bx	r3
    else if(th->apply_cb) {
    d416:	6823      	ldr	r3, [r4, #0]
    d418:	b133      	cbz	r3, d428 <apply_theme+0x30>
        th->apply_cb(act_theme, obj, name);
    d41a:	4804      	ldr	r0, [pc, #16]	; (d42c <apply_theme+0x34>)
    d41c:	4632      	mov	r2, r6
    d41e:	4629      	mov	r1, r5
}
    d420:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        th->apply_cb(act_theme, obj, name);
    d424:	6800      	ldr	r0, [r0, #0]
    d426:	4718      	bx	r3
}
    d428:	bd70      	pop	{r4, r5, r6, pc}
    d42a:	bf00      	nop
    d42c:	20025e7c 	.word	0x20025e7c

0000d430 <lv_theme_set_act>:
    act_theme = th;
    d430:	4b01      	ldr	r3, [pc, #4]	; (d438 <lv_theme_set_act+0x8>)
    d432:	6018      	str	r0, [r3, #0]
}
    d434:	4770      	bx	lr
    d436:	bf00      	nop
    d438:	20025e7c 	.word	0x20025e7c

0000d43c <lv_theme_apply>:

static void clear_styles(lv_obj_t * obj, lv_theme_style_t name)
{
    switch(name) {
    d43c:	2904      	cmp	r1, #4
{
    d43e:	b538      	push	{r3, r4, r5, lr}
    d440:	4605      	mov	r5, r0
    d442:	460c      	mov	r4, r1
    switch(name) {
    d444:	d011      	beq.n	d46a <lv_theme_apply+0x2e>
    d446:	bf94      	ite	ls
    d448:	f101 33ff 	addls.w	r3, r1, #4294967295
    d44c:	1f4b      	subhi	r3, r1, #5
    d44e:	2b02      	cmp	r3, #2
    d450:	d803      	bhi.n	d45a <lv_theme_apply+0x1e>
        case LV_THEME_NONE:
            break;

        case LV_THEME_SCR:
            lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);
    d452:	2100      	movs	r1, #0
#endif

#if LV_USE_CHECKBOX
        case LV_THEME_CHECKBOX:
            lv_obj_clean_style_list(obj, LV_CHECKBOX_PART_BG);
            lv_obj_clean_style_list(obj, LV_CHECKBOX_PART_BULLET);
    d454:	4628      	mov	r0, r5
    d456:	f008 fb7b 	bl	15b50 <lv_obj_clean_style_list>
    apply_theme(act_theme, obj, name);
    d45a:	4b06      	ldr	r3, [pc, #24]	; (d474 <lv_theme_apply+0x38>)
    d45c:	4622      	mov	r2, r4
    d45e:	4629      	mov	r1, r5
    d460:	6818      	ldr	r0, [r3, #0]
}
    d462:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    apply_theme(act_theme, obj, name);
    d466:	f7ff bfc7 	b.w	d3f8 <apply_theme>
            lv_obj_clean_style_list(obj, LV_CHECKBOX_PART_BG);
    d46a:	2100      	movs	r1, #0
    d46c:	f008 fb70 	bl	15b50 <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_CHECKBOX_PART_BULLET);
    d470:	2140      	movs	r1, #64	; 0x40
    d472:	e7ef      	b.n	d454 <lv_theme_apply+0x18>
    d474:	20025e7c 	.word	0x20025e7c

0000d478 <lv_theme_get_font_normal>:
    return act_theme->font_normal;
    d478:	4b01      	ldr	r3, [pc, #4]	; (d480 <lv_theme_get_font_normal+0x8>)
    d47a:	681b      	ldr	r3, [r3, #0]
}
    d47c:	6998      	ldr	r0, [r3, #24]
    d47e:	4770      	bx	lr
    d480:	20025e7c 	.word	0x20025e7c

0000d484 <theme_apply>:
{
    LV_UNUSED(th);

    lv_style_list_t * list;

    switch(name) {
    d484:	3a01      	subs	r2, #1
{
    d486:	b570      	push	{r4, r5, r6, lr}
    d488:	460c      	mov	r4, r1
    d48a:	2a04      	cmp	r2, #4
    d48c:	d80c      	bhi.n	d4a8 <theme_apply+0x24>
    d48e:	e8df f002 	tbb	[pc, r2]
    d492:	1203      	.short	0x1203
    d494:	221a      	.short	0x221a
    d496:	12          	.byte	0x12
    d497:	00          	.byte	0x00
        case LV_THEME_NONE:
            break;

        case LV_THEME_SCR:
            list = lv_obj_get_style_list(obj, LV_OBJ_PART_MAIN);
    d498:	2100      	movs	r1, #0
    d49a:	4620      	mov	r0, r4
    d49c:	f008 fb26 	bl	15aec <lv_obj_get_style_list>
            _lv_style_list_add_style(list, &styles->scr);
    d4a0:	4b18      	ldr	r3, [pc, #96]	; (d504 <theme_apply+0x80>)
    d4a2:	6819      	ldr	r1, [r3, #0]
            list = lv_obj_get_style_list(obj, LV_CHECKBOX_PART_BG);
            _lv_style_list_add_style(list, &styles->cb_bg);

            list = lv_obj_get_style_list(obj, LV_CHECKBOX_PART_BULLET);
            _lv_style_list_add_style(list, &styles->btn);
            _lv_style_list_add_style(list, &styles->cb_bullet);
    d4a4:	f009 fc93 	bl	16dce <_lv_style_list_add_style>
#endif
        default:
            break;
    }

    lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    d4a8:	22ff      	movs	r2, #255	; 0xff
    d4aa:	4620      	mov	r0, r4
}
    d4ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    d4b0:	4611      	mov	r1, r2
    d4b2:	f7fc bc61 	b.w	9d78 <lv_obj_refresh_style>
            list = lv_obj_get_style_list(obj, LV_OBJ_PART_MAIN);
    d4b6:	2100      	movs	r1, #0
    d4b8:	4620      	mov	r0, r4
    d4ba:	f008 fb17 	bl	15aec <lv_obj_get_style_list>
            _lv_style_list_add_style(list, &styles->bg);
    d4be:	4b11      	ldr	r3, [pc, #68]	; (d504 <theme_apply+0x80>)
    d4c0:	6819      	ldr	r1, [r3, #0]
    d4c2:	3104      	adds	r1, #4
    d4c4:	e7ee      	b.n	d4a4 <theme_apply+0x20>
            list = lv_obj_get_style_list(obj, LV_BTN_PART_MAIN);
    d4c6:	2100      	movs	r1, #0
    d4c8:	4620      	mov	r0, r4
    d4ca:	f008 fb0f 	bl	15aec <lv_obj_get_style_list>
            _lv_style_list_add_style(list, &styles->btn);
    d4ce:	4b0d      	ldr	r3, [pc, #52]	; (d504 <theme_apply+0x80>)
    d4d0:	6819      	ldr	r1, [r3, #0]
    d4d2:	3110      	adds	r1, #16
    d4d4:	e7e6      	b.n	d4a4 <theme_apply+0x20>
            _lv_style_list_add_style(list, &styles->cb_bg);
    d4d6:	4e0b      	ldr	r6, [pc, #44]	; (d504 <theme_apply+0x80>)
            list = lv_obj_get_style_list(obj, LV_CHECKBOX_PART_BG);
    d4d8:	2100      	movs	r1, #0
    d4da:	4620      	mov	r0, r4
    d4dc:	f008 fb06 	bl	15aec <lv_obj_get_style_list>
            _lv_style_list_add_style(list, &styles->cb_bg);
    d4e0:	6831      	ldr	r1, [r6, #0]
    d4e2:	311c      	adds	r1, #28
    d4e4:	f009 fc73 	bl	16dce <_lv_style_list_add_style>
            list = lv_obj_get_style_list(obj, LV_CHECKBOX_PART_BULLET);
    d4e8:	2140      	movs	r1, #64	; 0x40
    d4ea:	4620      	mov	r0, r4
    d4ec:	f008 fafe 	bl	15aec <lv_obj_get_style_list>
    d4f0:	4605      	mov	r5, r0
            _lv_style_list_add_style(list, &styles->btn);
    d4f2:	6831      	ldr	r1, [r6, #0]
    d4f4:	3110      	adds	r1, #16
    d4f6:	f009 fc6a 	bl	16dce <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->cb_bullet);
    d4fa:	6831      	ldr	r1, [r6, #0]
    d4fc:	4628      	mov	r0, r5
    d4fe:	3120      	adds	r1, #32
    d500:	e7d0      	b.n	d4a4 <theme_apply+0x20>
    d502:	bf00      	nop
    d504:	20025e80 	.word	0x20025e80

0000d508 <style_init_reset>:
 *   STATIC FUNCTIONS
 **********************/

static void style_init_reset(lv_style_t * style)
{
    if(inited) lv_style_reset(style);
    d508:	4b03      	ldr	r3, [pc, #12]	; (d518 <style_init_reset+0x10>)
    d50a:	781b      	ldrb	r3, [r3, #0]
    d50c:	b10b      	cbz	r3, d512 <style_init_reset+0xa>
    d50e:	f009 bcab 	b.w	16e68 <lv_style_reset>
    else lv_style_init(style);
    d512:	f009 bc14 	b.w	16d3e <lv_style_init>
    d516:	bf00      	nop
    d518:	2002a078 	.word	0x2002a078

0000d51c <lv_theme_material_init>:
{
    d51c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d520:	461f      	mov	r7, r3
    if(!inited) {
    d522:	4bca      	ldr	r3, [pc, #808]	; (d84c <lv_theme_material_init+0x330>)
{
    d524:	4680      	mov	r8, r0
    if(!inited) {
    d526:	781b      	ldrb	r3, [r3, #0]
{
    d528:	4689      	mov	r9, r1
    d52a:	4616      	mov	r6, r2
    d52c:	4cc8      	ldr	r4, [pc, #800]	; (d850 <lv_theme_material_init+0x334>)
    if(!inited) {
    d52e:	b92b      	cbnz	r3, d53c <lv_theme_material_init+0x20>
        LV_GC_ROOT(_lv_theme_material_styles) = lv_mem_alloc(sizeof(theme_styles_t));
    d530:	2024      	movs	r0, #36	; 0x24
    d532:	f7ff fab1 	bl	ca98 <lv_mem_alloc>
    d536:	4bc7      	ldr	r3, [pc, #796]	; (d854 <lv_theme_material_init+0x338>)
        styles = (theme_styles_t *)LV_GC_ROOT(_lv_theme_material_styles);
    d538:	6020      	str	r0, [r4, #0]
        LV_GC_ROOT(_lv_theme_material_styles) = lv_mem_alloc(sizeof(theme_styles_t));
    d53a:	6018      	str	r0, [r3, #0]
    theme.color_primary = color_primary;
    d53c:	4dc6      	ldr	r5, [pc, #792]	; (d858 <lv_theme_material_init+0x33c>)
    theme.font_normal = font_normal;
    d53e:	9b08      	ldr	r3, [sp, #32]
    style_init_reset(&styles->scr);
    d540:	6820      	ldr	r0, [r4, #0]
    theme.font_normal = font_normal;
    d542:	61ab      	str	r3, [r5, #24]
    theme.font_subtitle = font_subtitle;
    d544:	9b09      	ldr	r3, [sp, #36]	; 0x24
    theme.font_small = font_small;
    d546:	616f      	str	r7, [r5, #20]
    theme.font_subtitle = font_subtitle;
    d548:	61eb      	str	r3, [r5, #28]
    theme.font_title = font_title;
    d54a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    theme.color_secondary = color_secondary;
    d54c:	e9c5 8903 	strd	r8, r9, [r5, #12]
    theme.flags = flags;
    d550:	e9c5 3608 	strd	r3, r6, [r5, #32]
    style_init_reset(&styles->scr);
    d554:	f7ff ffd8 	bl	d508 <style_init_reset>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
    d558:	22ff      	movs	r2, #255	; 0xff
    d55a:	6820      	ldr	r0, [r4, #0]
    d55c:	212c      	movs	r1, #44	; 0x2c
    d55e:	f009 fd61 	bl	17024 <_lv_style_set_opa>
    lv_style_set_bg_color(&styles->scr, LV_STATE_DEFAULT, COLOR_SCR);
    d562:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d564:	6826      	ldr	r6, [r4, #0]
    d566:	079a      	lsls	r2, r3, #30
    d568:	bf4c      	ite	mi
    d56a:	48bc      	ldrmi	r0, [pc, #752]	; (d85c <lv_theme_material_init+0x340>)
    d56c:	48bc      	ldrpl	r0, [pc, #752]	; (d860 <lv_theme_material_init+0x344>)
    d56e:	f00e f89c 	bl	1b6aa <lv_color_hex>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
    d572:	2129      	movs	r1, #41	; 0x29
    d574:	4602      	mov	r2, r0
    d576:	4630      	mov	r0, r6
    d578:	f009 fd10 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->scr, LV_STATE_DEFAULT, COLOR_SCR_TEXT);
    d57c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d57e:	6826      	ldr	r6, [r4, #0]
    d580:	079b      	lsls	r3, r3, #30
    d582:	bf4c      	ite	mi
    d584:	48b7      	ldrmi	r0, [pc, #732]	; (d864 <lv_theme_material_init+0x348>)
    d586:	48b8      	ldrpl	r0, [pc, #736]	; (d868 <lv_theme_material_init+0x34c>)
    d588:	f00e f88f 	bl	1b6aa <lv_color_hex>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
    d58c:	f248 0189 	movw	r1, #32905	; 0x8089
    d590:	4602      	mov	r2, r0
    d592:	4630      	mov	r0, r6
    d594:	f009 fd02 	bl	16f9c <_lv_style_set_color>
    lv_style_set_value_color(&styles->scr, LV_STATE_DEFAULT, COLOR_SCR_TEXT);
    d598:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d59a:	6826      	ldr	r6, [r4, #0]
    d59c:	079f      	lsls	r7, r3, #30
    d59e:	bf4c      	ite	mi
    d5a0:	48b0      	ldrmi	r0, [pc, #704]	; (d864 <lv_theme_material_init+0x348>)
    d5a2:	48b1      	ldrpl	r0, [pc, #708]	; (d868 <lv_theme_material_init+0x34c>)
    d5a4:	f00e f881 	bl	1b6aa <lv_color_hex>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
    d5a8:	2179      	movs	r1, #121	; 0x79
    d5aa:	4602      	mov	r2, r0
    d5ac:	4630      	mov	r0, r6
    d5ae:	f009 fcf5 	bl	16f9c <_lv_style_set_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
    d5b2:	217e      	movs	r1, #126	; 0x7e
    d5b4:	69aa      	ldr	r2, [r5, #24]
    d5b6:	6820      	ldr	r0, [r4, #0]
    d5b8:	f009 fd7a 	bl	170b0 <_lv_style_set_ptr>
    style_init_reset(&styles->bg);
    d5bc:	6820      	ldr	r0, [r4, #0]
    d5be:	3004      	adds	r0, #4
    d5c0:	f7ff ffa2 	bl	d508 <style_init_reset>
    lv_style_set_radius(&styles->bg, LV_STATE_DEFAULT, LV_DPX(8));
    d5c4:	2000      	movs	r0, #0
    d5c6:	6826      	ldr	r6, [r4, #0]
    d5c8:	f7fe fff6 	bl	c5b8 <lv_disp_get_dpi>
    d5cc:	300a      	adds	r0, #10
    d5ce:	00c0      	lsls	r0, r0, #3
    d5d0:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d5d4:	f106 0604 	add.w	r6, r6, #4
    d5d8:	f2c0 879c 	blt.w	e514 <lv_theme_material_init+0xff8>
    d5dc:	2000      	movs	r0, #0
    d5de:	f7fe ffeb 	bl	c5b8 <lv_disp_get_dpi>
    d5e2:	f100 020a 	add.w	r2, r0, #10
    d5e6:	20a0      	movs	r0, #160	; 0xa0
    d5e8:	00d2      	lsls	r2, r2, #3
    d5ea:	fb92 f2f0 	sdiv	r2, r2, r0
    d5ee:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
    d5f0:	4630      	mov	r0, r6
    d5f2:	2101      	movs	r1, #1
    d5f4:	f009 fc8e 	bl	16f14 <_lv_style_set_int>
    lv_style_set_bg_opa(&styles->bg, LV_STATE_DEFAULT, LV_OPA_COVER);
    d5f8:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
    d5fa:	22ff      	movs	r2, #255	; 0xff
    d5fc:	3004      	adds	r0, #4
    d5fe:	212c      	movs	r1, #44	; 0x2c
    d600:	f009 fd10 	bl	17024 <_lv_style_set_opa>
    lv_style_set_bg_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG);
    d604:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d606:	6826      	ldr	r6, [r4, #0]
    d608:	0798      	lsls	r0, r3, #30
    d60a:	bf4c      	ite	mi
    d60c:	f06f 407f 	mvnmi.w	r0, #4278190080	; 0xff000000
    d610:	4896      	ldrpl	r0, [pc, #600]	; (d86c <lv_theme_material_init+0x350>)
    d612:	f00e f84a 	bl	1b6aa <lv_color_hex>
    d616:	3604      	adds	r6, #4
    d618:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
    d61a:	2129      	movs	r1, #41	; 0x29
    d61c:	4630      	mov	r0, r6
    d61e:	f009 fcbd 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_BORDER);
    d622:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d624:	6826      	ldr	r6, [r4, #0]
    d626:	0799      	lsls	r1, r3, #30
    d628:	bf4c      	ite	mi
    d62a:	4891      	ldrmi	r0, [pc, #580]	; (d870 <lv_theme_material_init+0x354>)
    d62c:	4891      	ldrpl	r0, [pc, #580]	; (d874 <lv_theme_material_init+0x358>)
    d62e:	f00e f83c 	bl	1b6aa <lv_color_hex>
    d632:	3604      	adds	r6, #4
    d634:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
    d636:	2139      	movs	r1, #57	; 0x39
    d638:	4630      	mov	r0, r6
    d63a:	f009 fcaf 	bl	16f9c <_lv_style_set_color>
    if((theme.flags & LV_THEME_MATERIAL_FLAG_NO_FOCUS) == 0)lv_style_set_border_color(&styles->bg, LV_STATE_FOCUSED,
    d63e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d640:	069a      	lsls	r2, r3, #26
    d642:	d406      	bmi.n	d652 <lv_theme_material_init+0x136>
    d644:	6820      	ldr	r0, [r4, #0]
    d646:	f240 2139 	movw	r1, #569	; 0x239
    d64a:	68ea      	ldr	r2, [r5, #12]
    d64c:	3004      	adds	r0, #4
    d64e:	f009 fca5 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->bg, LV_STATE_EDITED, theme.color_secondary);
    d652:	6820      	ldr	r0, [r4, #0]
    d654:	f240 4139 	movw	r1, #1081	; 0x439
    d658:	692a      	ldr	r2, [r5, #16]
    d65a:	3004      	adds	r0, #4
    d65c:	f009 fc9e 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_width(&styles->bg, LV_STATE_DEFAULT, BORDER_WIDTH);
    d660:	2000      	movs	r0, #0
    d662:	6826      	ldr	r6, [r4, #0]
    d664:	f7fe ffa8 	bl	c5b8 <lv_disp_get_dpi>
    d668:	3028      	adds	r0, #40	; 0x28
    d66a:	0040      	lsls	r0, r0, #1
    d66c:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d670:	f106 0604 	add.w	r6, r6, #4
    d674:	f2c0 8751 	blt.w	e51a <lv_theme_material_init+0xffe>
    d678:	2000      	movs	r0, #0
    d67a:	f7fe ff9d 	bl	c5b8 <lv_disp_get_dpi>
    d67e:	f100 0228 	add.w	r2, r0, #40	; 0x28
    d682:	20a0      	movs	r0, #160	; 0xa0
    d684:	0052      	lsls	r2, r2, #1
    d686:	fb92 f2f0 	sdiv	r2, r2, r0
    d68a:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
    d68c:	4630      	mov	r0, r6
    d68e:	2130      	movs	r1, #48	; 0x30
    d690:	f009 fc40 	bl	16f14 <_lv_style_set_int>
    lv_style_set_border_post(&styles->bg, LV_STATE_DEFAULT, true);
    d694:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
    d696:	2201      	movs	r2, #1
    d698:	3004      	adds	r0, #4
    d69a:	2133      	movs	r1, #51	; 0x33
    d69c:	f009 fc3a 	bl	16f14 <_lv_style_set_int>
    lv_style_set_text_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_TEXT);
    d6a0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d6a2:	6826      	ldr	r6, [r4, #0]
    d6a4:	079b      	lsls	r3, r3, #30
    d6a6:	bf54      	ite	pl
    d6a8:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    d6ac:	486d      	ldrmi	r0, [pc, #436]	; (d864 <lv_theme_material_init+0x348>)
    d6ae:	f00d fffc 	bl	1b6aa <lv_color_hex>
    d6b2:	3604      	adds	r6, #4
    d6b4:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
    d6b6:	f248 0189 	movw	r1, #32905	; 0x8089
    d6ba:	4630      	mov	r0, r6
    d6bc:	f009 fc6e 	bl	16f9c <_lv_style_set_color>
    lv_style_set_value_font(&styles->bg, LV_STATE_DEFAULT, theme.font_normal);
    d6c0:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
    d6c2:	217e      	movs	r1, #126	; 0x7e
    d6c4:	3004      	adds	r0, #4
    d6c6:	69aa      	ldr	r2, [r5, #24]
    d6c8:	f009 fcf2 	bl	170b0 <_lv_style_set_ptr>
    lv_style_set_value_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_TEXT);
    d6cc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d6ce:	6826      	ldr	r6, [r4, #0]
    d6d0:	079f      	lsls	r7, r3, #30
    d6d2:	bf54      	ite	pl
    d6d4:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    d6d8:	4862      	ldrmi	r0, [pc, #392]	; (d864 <lv_theme_material_init+0x348>)
    d6da:	f00d ffe6 	bl	1b6aa <lv_color_hex>
    d6de:	3604      	adds	r6, #4
    d6e0:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
    d6e2:	2179      	movs	r1, #121	; 0x79
    d6e4:	4630      	mov	r0, r6
    d6e6:	f009 fc59 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_TEXT);
    d6ea:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d6ec:	6826      	ldr	r6, [r4, #0]
    d6ee:	0798      	lsls	r0, r3, #30
    d6f0:	bf54      	ite	pl
    d6f2:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    d6f6:	485b      	ldrmi	r0, [pc, #364]	; (d864 <lv_theme_material_init+0x348>)
    d6f8:	f00d ffd7 	bl	1b6aa <lv_color_hex>
    d6fc:	3604      	adds	r6, #4
    d6fe:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
    d700:	f248 01a9 	movw	r1, #32937	; 0x80a9
    d704:	4630      	mov	r0, r6
    d706:	f009 fc49 	bl	16f9c <_lv_style_set_color>
    lv_style_set_line_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_TEXT);
    d70a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d70c:	6826      	ldr	r6, [r4, #0]
    d70e:	0799      	lsls	r1, r3, #30
    d710:	bf54      	ite	pl
    d712:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    d716:	4853      	ldrmi	r0, [pc, #332]	; (d864 <lv_theme_material_init+0x348>)
    d718:	f00d ffc7 	bl	1b6aa <lv_color_hex>
    d71c:	3604      	adds	r6, #4
    d71e:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
    d720:	2199      	movs	r1, #153	; 0x99
    d722:	4630      	mov	r0, r6
    d724:	f009 fc3a 	bl	16f9c <_lv_style_set_color>
    lv_style_set_line_width(&styles->bg, LV_STATE_DEFAULT, 1);
    d728:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_WIDTH, line_width, lv_style_int_t, _int, scalar)
    d72a:	2201      	movs	r2, #1
    d72c:	2190      	movs	r1, #144	; 0x90
    d72e:	3004      	adds	r0, #4
    d730:	f009 fbf0 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_left(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
    d734:	2000      	movs	r0, #0
    d736:	6827      	ldr	r7, [r4, #0]
    d738:	f7fe ff4a 	bl	c5d0 <lv_disp_get_size_category>
    d73c:	2801      	cmp	r0, #1
    d73e:	f107 0704 	add.w	r7, r7, #4
    d742:	f04f 0000 	mov.w	r0, #0
    d746:	f200 86eb 	bhi.w	e520 <lv_theme_material_init+0x1004>
    d74a:	f7fe ff35 	bl	c5b8 <lv_disp_get_dpi>
    d74e:	260f      	movs	r6, #15
    d750:	f04f 0850 	mov.w	r8, #80	; 0x50
    d754:	fb00 8006 	mla	r0, r0, r6, r8
    d758:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d75c:	f280 86e5 	bge.w	e52a <lv_theme_material_init+0x100e>
    d760:	2601      	movs	r6, #1
    d762:	2000      	movs	r0, #0
    d764:	f7fe ff28 	bl	c5b8 <lv_disp_get_dpi>
    d768:	3028      	adds	r0, #40	; 0x28
    d76a:	0040      	lsls	r0, r0, #1
    d76c:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d770:	f2c0 86e6 	blt.w	e540 <lv_theme_material_init+0x1024>
    d774:	2000      	movs	r0, #0
    d776:	f7fe ff1f 	bl	c5b8 <lv_disp_get_dpi>
    d77a:	f100 0228 	add.w	r2, r0, #40	; 0x28
    d77e:	20a0      	movs	r0, #160	; 0xa0
    d780:	0052      	lsls	r2, r2, #1
    d782:	fb92 f2f0 	sdiv	r2, r2, r0
    d786:	b212      	sxth	r2, r2
    d788:	4432      	add	r2, r6
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    d78a:	4638      	mov	r0, r7
    d78c:	2112      	movs	r1, #18
    d78e:	b212      	sxth	r2, r2
    d790:	f009 fbc0 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_right(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
    d794:	2000      	movs	r0, #0
    d796:	6827      	ldr	r7, [r4, #0]
    d798:	f7fe ff1a 	bl	c5d0 <lv_disp_get_size_category>
    d79c:	2801      	cmp	r0, #1
    d79e:	f107 0704 	add.w	r7, r7, #4
    d7a2:	f04f 0000 	mov.w	r0, #0
    d7a6:	f200 86ce 	bhi.w	e546 <lv_theme_material_init+0x102a>
    d7aa:	f7fe ff05 	bl	c5b8 <lv_disp_get_dpi>
    d7ae:	260f      	movs	r6, #15
    d7b0:	f04f 0850 	mov.w	r8, #80	; 0x50
    d7b4:	fb00 8006 	mla	r0, r0, r6, r8
    d7b8:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d7bc:	f280 86c8 	bge.w	e550 <lv_theme_material_init+0x1034>
    d7c0:	2601      	movs	r6, #1
    d7c2:	2000      	movs	r0, #0
    d7c4:	f7fe fef8 	bl	c5b8 <lv_disp_get_dpi>
    d7c8:	3028      	adds	r0, #40	; 0x28
    d7ca:	0040      	lsls	r0, r0, #1
    d7cc:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d7d0:	f2c0 86c9 	blt.w	e566 <lv_theme_material_init+0x104a>
    d7d4:	2000      	movs	r0, #0
    d7d6:	f7fe feef 	bl	c5b8 <lv_disp_get_dpi>
    d7da:	f100 0228 	add.w	r2, r0, #40	; 0x28
    d7de:	20a0      	movs	r0, #160	; 0xa0
    d7e0:	0052      	lsls	r2, r2, #1
    d7e2:	fb92 f2f0 	sdiv	r2, r2, r0
    d7e6:	b212      	sxth	r2, r2
    d7e8:	4432      	add	r2, r6
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    d7ea:	4638      	mov	r0, r7
    d7ec:	2113      	movs	r1, #19
    d7ee:	b212      	sxth	r2, r2
    d7f0:	f009 fb90 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_top(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
    d7f4:	2000      	movs	r0, #0
    d7f6:	6827      	ldr	r7, [r4, #0]
    d7f8:	f7fe feea 	bl	c5d0 <lv_disp_get_size_category>
    d7fc:	2801      	cmp	r0, #1
    d7fe:	f107 0704 	add.w	r7, r7, #4
    d802:	f04f 0000 	mov.w	r0, #0
    d806:	f200 86b1 	bhi.w	e56c <lv_theme_material_init+0x1050>
    d80a:	f7fe fed5 	bl	c5b8 <lv_disp_get_dpi>
    d80e:	260f      	movs	r6, #15
    d810:	f04f 0850 	mov.w	r8, #80	; 0x50
    d814:	fb00 8006 	mla	r0, r0, r6, r8
    d818:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d81c:	f280 86ab 	bge.w	e576 <lv_theme_material_init+0x105a>
    d820:	2601      	movs	r6, #1
    d822:	2000      	movs	r0, #0
    d824:	f7fe fec8 	bl	c5b8 <lv_disp_get_dpi>
    d828:	3028      	adds	r0, #40	; 0x28
    d82a:	0040      	lsls	r0, r0, #1
    d82c:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d830:	f2c0 86ac 	blt.w	e58c <lv_theme_material_init+0x1070>
    d834:	2000      	movs	r0, #0
    d836:	f7fe febf 	bl	c5b8 <lv_disp_get_dpi>
    d83a:	f100 0228 	add.w	r2, r0, #40	; 0x28
    d83e:	20a0      	movs	r0, #160	; 0xa0
    d840:	0052      	lsls	r2, r2, #1
    d842:	fb92 f2f0 	sdiv	r2, r2, r0
    d846:	b212      	sxth	r2, r2
    d848:	e016      	b.n	d878 <lv_theme_material_init+0x35c>
    d84a:	bf00      	nop
    d84c:	2002a078 	.word	0x2002a078
    d850:	20025e80 	.word	0x20025e80
    d854:	20025e64 	.word	0x20025e64
    d858:	20025e84 	.word	0x20025e84
    d85c:	00eaeff3 	.word	0x00eaeff3
    d860:	00444b5a 	.word	0x00444b5a
    d864:	003b3e42 	.word	0x003b3e42
    d868:	00e7e9ec 	.word	0x00e7e9ec
    d86c:	00586273 	.word	0x00586273
    d870:	00d6dde3 	.word	0x00d6dde3
    d874:	00808a97 	.word	0x00808a97
    d878:	4432      	add	r2, r6
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    d87a:	4638      	mov	r0, r7
    d87c:	2110      	movs	r1, #16
    d87e:	b212      	sxth	r2, r2
    d880:	f009 fb48 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_bottom(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
    d884:	2000      	movs	r0, #0
    d886:	6827      	ldr	r7, [r4, #0]
    d888:	f7fe fea2 	bl	c5d0 <lv_disp_get_size_category>
    d88c:	2801      	cmp	r0, #1
    d88e:	f107 0704 	add.w	r7, r7, #4
    d892:	f04f 0000 	mov.w	r0, #0
    d896:	f200 867c 	bhi.w	e592 <lv_theme_material_init+0x1076>
    d89a:	f7fe fe8d 	bl	c5b8 <lv_disp_get_dpi>
    d89e:	260f      	movs	r6, #15
    d8a0:	f04f 0850 	mov.w	r8, #80	; 0x50
    d8a4:	fb00 8006 	mla	r0, r0, r6, r8
    d8a8:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d8ac:	f280 8676 	bge.w	e59c <lv_theme_material_init+0x1080>
    d8b0:	2601      	movs	r6, #1
    d8b2:	2000      	movs	r0, #0
    d8b4:	f7fe fe80 	bl	c5b8 <lv_disp_get_dpi>
    d8b8:	3028      	adds	r0, #40	; 0x28
    d8ba:	0040      	lsls	r0, r0, #1
    d8bc:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d8c0:	f2c0 8677 	blt.w	e5b2 <lv_theme_material_init+0x1096>
    d8c4:	2000      	movs	r0, #0
    d8c6:	f7fe fe77 	bl	c5b8 <lv_disp_get_dpi>
    d8ca:	f100 0228 	add.w	r2, r0, #40	; 0x28
    d8ce:	20a0      	movs	r0, #160	; 0xa0
    d8d0:	0052      	lsls	r2, r2, #1
    d8d2:	fb92 f2f0 	sdiv	r2, r2, r0
    d8d6:	b212      	sxth	r2, r2
    d8d8:	4432      	add	r2, r6
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    d8da:	4638      	mov	r0, r7
    d8dc:	2111      	movs	r1, #17
    d8de:	b212      	sxth	r2, r2
    d8e0:	f009 fb18 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_inner(&styles->bg, LV_STATE_DEFAULT, PAD_DEF);
    d8e4:	2000      	movs	r0, #0
    d8e6:	6827      	ldr	r7, [r4, #0]
    d8e8:	f7fe fe72 	bl	c5d0 <lv_disp_get_size_category>
    d8ec:	2801      	cmp	r0, #1
    d8ee:	f107 0704 	add.w	r7, r7, #4
    d8f2:	f04f 0000 	mov.w	r0, #0
    d8f6:	f200 865f 	bhi.w	e5b8 <lv_theme_material_init+0x109c>
    d8fa:	f7fe fe5d 	bl	c5b8 <lv_disp_get_dpi>
    d8fe:	260f      	movs	r6, #15
    d900:	f04f 0850 	mov.w	r8, #80	; 0x50
    d904:	fb00 8006 	mla	r0, r0, r6, r8
    d908:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    d90c:	f280 8659 	bge.w	e5c2 <lv_theme_material_init+0x10a6>
    d910:	2201      	movs	r2, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
    d912:	4638      	mov	r0, r7
    d914:	2114      	movs	r1, #20
    d916:	f009 fafd 	bl	16f14 <_lv_style_set_int>
    lv_style_set_transition_time(&styles->bg, LV_STATE_DEFAULT, TRANSITION_TIME);
    d91a:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
    d91c:	2200      	movs	r2, #0
    d91e:	21b0      	movs	r1, #176	; 0xb0
    d920:	3004      	adds	r0, #4
    d922:	f009 faf7 	bl	16f14 <_lv_style_set_int>
    lv_style_set_transition_prop_6(&styles->bg, LV_STATE_DEFAULT, LV_STYLE_BORDER_COLOR);
    d926:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_6, transition_prop_6, lv_style_int_t, _int, scalar)
    d928:	2239      	movs	r2, #57	; 0x39
    d92a:	21b7      	movs	r1, #183	; 0xb7
    d92c:	3004      	adds	r0, #4
    d92e:	f009 faf1 	bl	16f14 <_lv_style_set_int>
    style_init_reset(&styles->bg_sec);
    d932:	6820      	ldr	r0, [r4, #0]
    d934:	300c      	adds	r0, #12
    d936:	f7ff fde7 	bl	d508 <style_init_reset>
    lv_style_copy(&styles->bg_sec, &styles->bg);
    d93a:	6820      	ldr	r0, [r4, #0]
    d93c:	1d01      	adds	r1, r0, #4
    d93e:	300c      	adds	r0, #12
    d940:	f009 faac 	bl	16e9c <lv_style_copy>
    lv_style_set_bg_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC);
    d944:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d946:	6826      	ldr	r6, [r4, #0]
    d948:	079a      	lsls	r2, r3, #30
    d94a:	bf4c      	ite	mi
    d94c:	48c6      	ldrmi	r0, [pc, #792]	; (dc68 <lv_theme_material_init+0x74c>)
    d94e:	48c7      	ldrpl	r0, [pc, #796]	; (dc6c <lv_theme_material_init+0x750>)
    d950:	f00d feab 	bl	1b6aa <lv_color_hex>
    d954:	360c      	adds	r6, #12
    d956:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
    d958:	2129      	movs	r1, #41	; 0x29
    d95a:	4630      	mov	r0, r6
    d95c:	f009 fb1e 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_BORDER);
    d960:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d962:	6826      	ldr	r6, [r4, #0]
    d964:	079b      	lsls	r3, r3, #30
    d966:	bf4c      	ite	mi
    d968:	48c1      	ldrmi	r0, [pc, #772]	; (dc70 <lv_theme_material_init+0x754>)
    d96a:	48c2      	ldrpl	r0, [pc, #776]	; (dc74 <lv_theme_material_init+0x758>)
    d96c:	f00d fe9d 	bl	1b6aa <lv_color_hex>
    d970:	360c      	adds	r6, #12
    d972:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
    d974:	2139      	movs	r1, #57	; 0x39
    d976:	4630      	mov	r0, r6
    d978:	f009 fb10 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
    d97c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d97e:	6826      	ldr	r6, [r4, #0]
    d980:	079f      	lsls	r7, r3, #30
    d982:	bf4c      	ite	mi
    d984:	48bc      	ldrmi	r0, [pc, #752]	; (dc78 <lv_theme_material_init+0x75c>)
    d986:	48bd      	ldrpl	r0, [pc, #756]	; (dc7c <lv_theme_material_init+0x760>)
    d988:	f00d fe8f 	bl	1b6aa <lv_color_hex>
    d98c:	360c      	adds	r6, #12
    d98e:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
    d990:	f248 0189 	movw	r1, #32905	; 0x8089
    d994:	4630      	mov	r0, r6
    d996:	f009 fb01 	bl	16f9c <_lv_style_set_color>
    lv_style_set_value_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
    d99a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d99c:	6826      	ldr	r6, [r4, #0]
    d99e:	0798      	lsls	r0, r3, #30
    d9a0:	bf4c      	ite	mi
    d9a2:	48b5      	ldrmi	r0, [pc, #724]	; (dc78 <lv_theme_material_init+0x75c>)
    d9a4:	48b5      	ldrpl	r0, [pc, #724]	; (dc7c <lv_theme_material_init+0x760>)
    d9a6:	f00d fe80 	bl	1b6aa <lv_color_hex>
    d9aa:	360c      	adds	r6, #12
    d9ac:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
    d9ae:	2179      	movs	r1, #121	; 0x79
    d9b0:	4630      	mov	r0, r6
    d9b2:	f009 faf3 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
    d9b6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d9b8:	6826      	ldr	r6, [r4, #0]
    d9ba:	0799      	lsls	r1, r3, #30
    d9bc:	bf4c      	ite	mi
    d9be:	48ae      	ldrmi	r0, [pc, #696]	; (dc78 <lv_theme_material_init+0x75c>)
    d9c0:	48ae      	ldrpl	r0, [pc, #696]	; (dc7c <lv_theme_material_init+0x760>)
    d9c2:	f00d fe72 	bl	1b6aa <lv_color_hex>
    d9c6:	360c      	adds	r6, #12
    d9c8:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
    d9ca:	f248 01a9 	movw	r1, #32937	; 0x80a9
    d9ce:	4630      	mov	r0, r6
    d9d0:	f009 fae4 	bl	16f9c <_lv_style_set_color>
    lv_style_set_line_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
    d9d4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d9d6:	6826      	ldr	r6, [r4, #0]
    d9d8:	079a      	lsls	r2, r3, #30
    d9da:	bf4c      	ite	mi
    d9dc:	48a6      	ldrmi	r0, [pc, #664]	; (dc78 <lv_theme_material_init+0x75c>)
    d9de:	48a7      	ldrpl	r0, [pc, #668]	; (dc7c <lv_theme_material_init+0x760>)
    d9e0:	f00d fe63 	bl	1b6aa <lv_color_hex>
    d9e4:	360c      	adds	r6, #12
    d9e6:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
    d9e8:	2199      	movs	r1, #153	; 0x99
    d9ea:	4630      	mov	r0, r6
    d9ec:	f009 fad6 	bl	16f9c <_lv_style_set_color>
    style_init_reset(&styles->bg_click);
    d9f0:	6820      	ldr	r0, [r4, #0]
    d9f2:	3008      	adds	r0, #8
    d9f4:	f7ff fd88 	bl	d508 <style_init_reset>
    lv_style_set_bg_color(&styles->bg_click, LV_STATE_PRESSED, COLOR_BG_PR);
    d9f8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    d9fa:	6826      	ldr	r6, [r4, #0]
    d9fc:	079b      	lsls	r3, r3, #30
    d9fe:	bf4c      	ite	mi
    da00:	489f      	ldrmi	r0, [pc, #636]	; (dc80 <lv_theme_material_init+0x764>)
    da02:	48a0      	ldrpl	r0, [pc, #640]	; (dc84 <lv_theme_material_init+0x768>)
    da04:	f00d fe51 	bl	1b6aa <lv_color_hex>
    da08:	3608      	adds	r6, #8
    da0a:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
    da0c:	f241 0129 	movw	r1, #4137	; 0x1029
    da10:	4630      	mov	r0, r6
    da12:	f009 fac3 	bl	16f9c <_lv_style_set_color>
    lv_style_set_bg_color(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_CHK);
    da16:	6820      	ldr	r0, [r4, #0]
    da18:	68ea      	ldr	r2, [r5, #12]
    da1a:	f240 1129 	movw	r1, #297	; 0x129
    da1e:	3008      	adds	r0, #8
    da20:	f009 fabc 	bl	16f9c <_lv_style_set_color>
    lv_style_set_bg_color(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_PR_CHK);
    da24:	6820      	ldr	r0, [r4, #0]
    da26:	2133      	movs	r1, #51	; 0x33
    da28:	f100 0608 	add.w	r6, r0, #8
    da2c:	68e8      	ldr	r0, [r5, #12]
    da2e:	f00d fb85 	bl	1b13c <lv_color_darken>
    da32:	f241 1129 	movw	r1, #4393	; 0x1129
    da36:	4602      	mov	r2, r0
    da38:	4630      	mov	r0, r6
    da3a:	f009 faaf 	bl	16f9c <_lv_style_set_color>
    lv_style_set_bg_color(&styles->bg_click, LV_STATE_DISABLED, COLOR_BG_DIS);
    da3e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    da40:	6826      	ldr	r6, [r4, #0]
    da42:	079f      	lsls	r7, r3, #30
    da44:	bf4c      	ite	mi
    da46:	f06f 407f 	mvnmi.w	r0, #4278190080	; 0xff000000
    da4a:	488f      	ldrpl	r0, [pc, #572]	; (dc88 <lv_theme_material_init+0x76c>)
    da4c:	f00d fe2d 	bl	1b6aa <lv_color_hex>
    da50:	3608      	adds	r6, #8
    da52:	4602      	mov	r2, r0
    da54:	f242 0129 	movw	r1, #8233	; 0x2029
    da58:	4630      	mov	r0, r6
    da5a:	f009 fa9f 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_width(&styles->bg_click, LV_STATE_CHECKED, 0);
    da5e:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
    da60:	2200      	movs	r2, #0
    da62:	f44f 7198 	mov.w	r1, #304	; 0x130
    da66:	3008      	adds	r0, #8
    da68:	f009 fa54 	bl	16f14 <_lv_style_set_int>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_FOCUSED | LV_STATE_PRESSED, lv_color_darken(theme.color_primary,
    da6c:	6820      	ldr	r0, [r4, #0]
    da6e:	2133      	movs	r1, #51	; 0x33
    da70:	f100 0608 	add.w	r6, r0, #8
    da74:	68e8      	ldr	r0, [r5, #12]
    da76:	f00d fb61 	bl	1b13c <lv_color_darken>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
    da7a:	f241 2139 	movw	r1, #4665	; 0x1239
    da7e:	4602      	mov	r2, r0
    da80:	4630      	mov	r0, r6
    da82:	f009 fa8b 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_PRESSED, COLOR_BG_BORDER_PR);
    da86:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    da88:	6824      	ldr	r4, [r4, #0]
    da8a:	079e      	lsls	r6, r3, #30
    da8c:	f104 0408 	add.w	r4, r4, #8
    da90:	f100 85a2 	bmi.w	e5d8 <lv_theme_material_init+0x10bc>
    da94:	487d      	ldr	r0, [pc, #500]	; (dc8c <lv_theme_material_init+0x770>)
    da96:	f00d fe08 	bl	1b6aa <lv_color_hex>
    da9a:	b2c6      	uxtb	r6, r0
    da9c:	f3c0 2107 	ubfx	r1, r0, #8, #8
    daa0:	f3c0 4307 	ubfx	r3, r0, #16, #8
    daa4:	0e00      	lsrs	r0, r0, #24
    daa6:	2200      	movs	r2, #0
    daa8:	f366 0207 	bfi	r2, r6, #0, #8
    daac:	f361 220f 	bfi	r2, r1, #8, #8
    dab0:	f363 4217 	bfi	r2, r3, #16, #8
    dab4:	f360 621f 	bfi	r2, r0, #24, #8
    dab8:	f241 0139 	movw	r1, #4153	; 0x1039
    dabc:	4620      	mov	r0, r4
    dabe:	f009 fa6d 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_BORDER_CHK);
    dac2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dac4:	4c72      	ldr	r4, [pc, #456]	; (dc90 <lv_theme_material_init+0x774>)
    dac6:	079d      	lsls	r5, r3, #30
    dac8:	bf4c      	ite	mi
    daca:	4872      	ldrmi	r0, [pc, #456]	; (dc94 <lv_theme_material_init+0x778>)
    dacc:	486f      	ldrpl	r0, [pc, #444]	; (dc8c <lv_theme_material_init+0x770>)
    dace:	6826      	ldr	r6, [r4, #0]
    dad0:	f00d fdeb 	bl	1b6aa <lv_color_hex>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_BORDER_CHK_PR);
    dad4:	4d70      	ldr	r5, [pc, #448]	; (dc98 <lv_theme_material_init+0x77c>)
    lv_style_set_border_color(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_BORDER_CHK);
    dad6:	3608      	adds	r6, #8
    dad8:	4602      	mov	r2, r0
    dada:	f240 1139 	movw	r1, #313	; 0x139
    dade:	4630      	mov	r0, r6
    dae0:	f009 fa5c 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_BORDER_CHK_PR);
    dae4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dae6:	6826      	ldr	r6, [r4, #0]
    dae8:	0798      	lsls	r0, r3, #30
    daea:	bf4c      	ite	mi
    daec:	4869      	ldrmi	r0, [pc, #420]	; (dc94 <lv_theme_material_init+0x778>)
    daee:	4867      	ldrpl	r0, [pc, #412]	; (dc8c <lv_theme_material_init+0x770>)
    daf0:	f00d fddb 	bl	1b6aa <lv_color_hex>
    daf4:	3608      	adds	r6, #8
    daf6:	4602      	mov	r2, r0
    daf8:	f241 1139 	movw	r1, #4409	; 0x1139
    dafc:	4630      	mov	r0, r6
    dafe:	f009 fa4d 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_DISABLED, COLOR_BG_BORDER_DIS);
    db02:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    db04:	6826      	ldr	r6, [r4, #0]
    db06:	0799      	lsls	r1, r3, #30
    db08:	bf4c      	ite	mi
    db0a:	4864      	ldrmi	r0, [pc, #400]	; (dc9c <lv_theme_material_init+0x780>)
    db0c:	485f      	ldrpl	r0, [pc, #380]	; (dc8c <lv_theme_material_init+0x770>)
    db0e:	f00d fdcc 	bl	1b6aa <lv_color_hex>
    db12:	3608      	adds	r6, #8
    db14:	4602      	mov	r2, r0
    db16:	f242 0139 	movw	r1, #8249	; 0x2039
    db1a:	4630      	mov	r0, r6
    db1c:	f009 fa3e 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->bg_click, LV_STATE_PRESSED, COLOR_BG_TEXT_PR);
    db20:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    db22:	6826      	ldr	r6, [r4, #0]
    db24:	079a      	lsls	r2, r3, #30
    db26:	bf54      	ite	pl
    db28:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    db2c:	4859      	ldrmi	r0, [pc, #356]	; (dc94 <lv_theme_material_init+0x778>)
    db2e:	f00d fdbc 	bl	1b6aa <lv_color_hex>
    db32:	3608      	adds	r6, #8
    db34:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
    db36:	f249 0189 	movw	r1, #37001	; 0x9089
    db3a:	4630      	mov	r0, r6
    db3c:	f009 fa2e 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_TEXT_CHK);
    db40:	6820      	ldr	r0, [r4, #0]
    db42:	f100 0608 	add.w	r6, r0, #8
    db46:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    db4a:	f00d fdae 	bl	1b6aa <lv_color_hex>
    db4e:	f248 1189 	movw	r1, #33161	; 0x8189
    db52:	4602      	mov	r2, r0
    db54:	4630      	mov	r0, r6
    db56:	f009 fa21 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_TEXT_CHK_PR);
    db5a:	6820      	ldr	r0, [r4, #0]
    db5c:	f100 0608 	add.w	r6, r0, #8
    db60:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    db64:	f00d fda1 	bl	1b6aa <lv_color_hex>
    db68:	f249 1189 	movw	r1, #37257	; 0x9189
    db6c:	4602      	mov	r2, r0
    db6e:	4630      	mov	r0, r6
    db70:	f009 fa14 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->bg_click, LV_STATE_DISABLED, COLOR_BG_TEXT_DIS);
    db74:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    db76:	2200      	movs	r2, #0
    db78:	f013 0f02 	tst.w	r3, #2
    db7c:	bf14      	ite	ne
    db7e:	23aa      	movne	r3, #170	; 0xaa
    db80:	2399      	moveq	r3, #153	; 0x99
    db82:	f363 0207 	bfi	r2, r3, #0, #8
    db86:	f363 220f 	bfi	r2, r3, #8, #8
    db8a:	6820      	ldr	r0, [r4, #0]
    db8c:	f363 4217 	bfi	r2, r3, #16, #8
    db90:	3008      	adds	r0, #8
    db92:	f24a 0189 	movw	r1, #41097	; 0xa089
    db96:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
    db9a:	f009 f9ff 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->bg_click, LV_STATE_PRESSED, COLOR_BG_TEXT_PR);
    db9e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dba0:	6826      	ldr	r6, [r4, #0]
    dba2:	079b      	lsls	r3, r3, #30
    dba4:	bf54      	ite	pl
    dba6:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    dbaa:	483a      	ldrmi	r0, [pc, #232]	; (dc94 <lv_theme_material_init+0x778>)
    dbac:	f00d fd7d 	bl	1b6aa <lv_color_hex>
    dbb0:	3608      	adds	r6, #8
    dbb2:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
    dbb4:	f249 01a9 	movw	r1, #37033	; 0x90a9
    dbb8:	4630      	mov	r0, r6
    dbba:	f009 f9ef 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_TEXT_CHK);
    dbbe:	6820      	ldr	r0, [r4, #0]
    dbc0:	f100 0608 	add.w	r6, r0, #8
    dbc4:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    dbc8:	f00d fd6f 	bl	1b6aa <lv_color_hex>
    dbcc:	f248 11a9 	movw	r1, #33193	; 0x81a9
    dbd0:	4602      	mov	r2, r0
    dbd2:	4630      	mov	r0, r6
    dbd4:	f009 f9e2 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_TEXT_CHK_PR);
    dbd8:	6820      	ldr	r0, [r4, #0]
    dbda:	f100 0608 	add.w	r6, r0, #8
    dbde:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    dbe2:	f00d fd62 	bl	1b6aa <lv_color_hex>
    dbe6:	f249 11a9 	movw	r1, #37289	; 0x91a9
    dbea:	4602      	mov	r2, r0
    dbec:	4630      	mov	r0, r6
    dbee:	f009 f9d5 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->bg_click, LV_STATE_DISABLED, COLOR_BG_TEXT_DIS);
    dbf2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dbf4:	2200      	movs	r2, #0
    dbf6:	f013 0f02 	tst.w	r3, #2
    dbfa:	bf14      	ite	ne
    dbfc:	23aa      	movne	r3, #170	; 0xaa
    dbfe:	2399      	moveq	r3, #153	; 0x99
    dc00:	f363 0207 	bfi	r2, r3, #0, #8
    dc04:	f363 220f 	bfi	r2, r3, #8, #8
    dc08:	6820      	ldr	r0, [r4, #0]
    dc0a:	f363 4217 	bfi	r2, r3, #16, #8
    dc0e:	f24a 01a9 	movw	r1, #41129	; 0xa0a9
    dc12:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
    dc16:	3008      	adds	r0, #8
    dc18:	f009 f9c0 	bl	16f9c <_lv_style_set_color>
    lv_style_set_transition_prop_5(&styles->bg_click, LV_STATE_DEFAULT, LV_STYLE_BG_COLOR);
    dc1c:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_5, transition_prop_5, lv_style_int_t, _int, scalar)
    dc1e:	2229      	movs	r2, #41	; 0x29
    dc20:	21b6      	movs	r1, #182	; 0xb6
    dc22:	3008      	adds	r0, #8
    dc24:	f009 f976 	bl	16f14 <_lv_style_set_int>
    style_init_reset(&styles->btn);
    dc28:	6820      	ldr	r0, [r4, #0]
    dc2a:	3010      	adds	r0, #16
    dc2c:	f7ff fc6c 	bl	d508 <style_init_reset>
    lv_style_set_radius(&styles->btn, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
    dc30:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
    dc32:	f647 72ff 	movw	r2, #32767	; 0x7fff
    dc36:	2101      	movs	r1, #1
    dc38:	3010      	adds	r0, #16
    dc3a:	f009 f96b 	bl	16f14 <_lv_style_set_int>
    lv_style_set_bg_opa(&styles->btn, LV_STATE_DEFAULT, LV_OPA_COVER);
    dc3e:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
    dc40:	22ff      	movs	r2, #255	; 0xff
    dc42:	3010      	adds	r0, #16
    dc44:	212c      	movs	r1, #44	; 0x2c
    dc46:	f009 f9ed 	bl	17024 <_lv_style_set_opa>
    lv_style_set_bg_color(&styles->btn, LV_STATE_DEFAULT, COLOR_BTN);
    dc4a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dc4c:	6826      	ldr	r6, [r4, #0]
    dc4e:	079f      	lsls	r7, r3, #30
    dc50:	bf4c      	ite	mi
    dc52:	f06f 407f 	mvnmi.w	r0, #4278190080	; 0xff000000
    dc56:	480c      	ldrpl	r0, [pc, #48]	; (dc88 <lv_theme_material_init+0x76c>)
    dc58:	f00d fd27 	bl	1b6aa <lv_color_hex>
    dc5c:	3610      	adds	r6, #16
    dc5e:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
    dc60:	2129      	movs	r1, #41	; 0x29
    dc62:	4630      	mov	r0, r6
    dc64:	e01c      	b.n	dca0 <lv_theme_material_init+0x784>
    dc66:	bf00      	nop
    dc68:	00d4d7d9 	.word	0x00d4d7d9
    dc6c:	0045494d 	.word	0x0045494d
    dc70:	00dfe7ed 	.word	0x00dfe7ed
    dc74:	00404040 	.word	0x00404040
    dc78:	0031404f 	.word	0x0031404f
    dc7c:	00a5a8ad 	.word	0x00a5a8ad
    dc80:	00eeeeee 	.word	0x00eeeeee
    dc84:	00494f57 	.word	0x00494f57
    dc88:	00586273 	.word	0x00586273
    dc8c:	005f656e 	.word	0x005f656e
    dc90:	20025e80 	.word	0x20025e80
    dc94:	003b3e42 	.word	0x003b3e42
    dc98:	20025e84 	.word	0x20025e84
    dc9c:	00d6dde3 	.word	0x00d6dde3
    dca0:	f009 f97c 	bl	16f9c <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_PRESSED, COLOR_BTN_PR);
    dca4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dca6:	6826      	ldr	r6, [r4, #0]
    dca8:	0798      	lsls	r0, r3, #30
    dcaa:	f106 0610 	add.w	r6, r6, #16
    dcae:	f140 8499 	bpl.w	e5e4 <lv_theme_material_init+0x10c8>
    dcb2:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    dcb6:	f00d fcf8 	bl	1b6aa <lv_color_hex>
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    dcba:	f04f 0ce6 	mov.w	ip, #230	; 0xe6
    dcbe:	2219      	movs	r2, #25
    dcc0:	f3c0 4307 	ubfx	r3, r0, #16, #8
    dcc4:	fb13 f30c 	smulbb	r3, r3, ip
    dcc8:	7ba9      	ldrb	r1, [r5, #14]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    dcca:	f3c0 2e07 	ubfx	lr, r0, #8, #8
    dcce:	fb1e fe0c 	smulbb	lr, lr, ip
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    dcd2:	fb12 3101 	smlabb	r1, r2, r1, r3
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
    dcd6:	b2c0      	uxtb	r0, r0
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    dcd8:	f248 0381 	movw	r3, #32897	; 0x8081
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
    dcdc:	fb10 f00c 	smulbb	r0, r0, ip
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    dce0:	7b6f      	ldrb	r7, [r5, #13]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    dce2:	4359      	muls	r1, r3
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    dce4:	fb12 e707 	smlabb	r7, r2, r7, lr
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
    dce8:	f895 e00c 	ldrb.w	lr, [r5, #12]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    dcec:	435f      	muls	r7, r3
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
    dcee:	fb12 000e 	smlabb	r0, r2, lr, r0
    dcf2:	2200      	movs	r2, #0
    dcf4:	4343      	muls	r3, r0
    dcf6:	f3c3 53c7 	ubfx	r3, r3, #23, #8
    dcfa:	f363 0207 	bfi	r2, r3, #0, #8
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
    dcfe:	f3c7 57c7 	ubfx	r7, r7, #23, #8
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
    dd02:	f3c1 51c7 	ubfx	r1, r1, #23, #8
    dd06:	f367 220f 	bfi	r2, r7, #8, #8
    dd0a:	f361 4217 	bfi	r2, r1, #16, #8
    dd0e:	4630      	mov	r0, r6
    dd10:	f241 0129 	movw	r1, #4137	; 0x1029
    dd14:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
    dd18:	f009 f940 	bl	16f9c <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_CHECKED, COLOR_BTN_CHK);
    dd1c:	6820      	ldr	r0, [r4, #0]
    dd1e:	68ea      	ldr	r2, [r5, #12]
    dd20:	f240 1129 	movw	r1, #297	; 0x129
    dd24:	3010      	adds	r0, #16
    dd26:	f009 f939 	bl	16f9c <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, COLOR_BTN_CHK_PR);
    dd2a:	6820      	ldr	r0, [r4, #0]
    dd2c:	214c      	movs	r1, #76	; 0x4c
    dd2e:	f100 0610 	add.w	r6, r0, #16
    dd32:	68e8      	ldr	r0, [r5, #12]
    dd34:	f00d fa02 	bl	1b13c <lv_color_darken>
    dd38:	f241 1129 	movw	r1, #4393	; 0x1129
    dd3c:	4602      	mov	r2, r0
    dd3e:	4630      	mov	r0, r6
    dd40:	f009 f92c 	bl	16f9c <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_DISABLED, COLOR_BTN);
    dd44:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dd46:	6826      	ldr	r6, [r4, #0]
    dd48:	0799      	lsls	r1, r3, #30
    dd4a:	bf4c      	ite	mi
    dd4c:	f06f 407f 	mvnmi.w	r0, #4278190080	; 0xff000000
    dd50:	48d4      	ldrpl	r0, [pc, #848]	; (e0a4 <lv_theme_material_init+0xb88>)
    dd52:	f00d fcaa 	bl	1b6aa <lv_color_hex>
    dd56:	3610      	adds	r6, #16
    dd58:	4602      	mov	r2, r0
    dd5a:	f242 0129 	movw	r1, #8233	; 0x2029
    dd5e:	4630      	mov	r0, r6
    dd60:	f009 f91c 	bl	16f9c <_lv_style_set_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_DISABLED | LV_STATE_CHECKED, COLOR_BTN_DIS);
    dd64:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dd66:	2200      	movs	r2, #0
    dd68:	f013 0f02 	tst.w	r3, #2
    dd6c:	bf14      	ite	ne
    dd6e:	23cc      	movne	r3, #204	; 0xcc
    dd70:	2388      	moveq	r3, #136	; 0x88
    dd72:	f363 0207 	bfi	r2, r3, #0, #8
    dd76:	f363 220f 	bfi	r2, r3, #8, #8
    dd7a:	6820      	ldr	r0, [r4, #0]
    dd7c:	f363 4217 	bfi	r2, r3, #16, #8
    dd80:	f242 1129 	movw	r1, #8489	; 0x2129
    dd84:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
    dd88:	3010      	adds	r0, #16
    dd8a:	f009 f907 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->btn, LV_STATE_DEFAULT, COLOR_BTN_BORDER);
    dd8e:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
    dd90:	2139      	movs	r1, #57	; 0x39
    dd92:	68ea      	ldr	r2, [r5, #12]
    dd94:	3010      	adds	r0, #16
    dd96:	f009 f901 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->btn, LV_STATE_PRESSED, COLOR_BTN_BORDER_PR);
    dd9a:	6820      	ldr	r0, [r4, #0]
    dd9c:	68ea      	ldr	r2, [r5, #12]
    dd9e:	f241 0139 	movw	r1, #4153	; 0x1039
    dda2:	3010      	adds	r0, #16
    dda4:	f009 f8fa 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_color(&styles->btn, LV_STATE_DISABLED, COLOR_BTN_BORDER_INA);
    dda8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    ddaa:	6826      	ldr	r6, [r4, #0]
    ddac:	079a      	lsls	r2, r3, #30
    ddae:	f106 0610 	add.w	r6, r6, #16
    ddb2:	f100 8424 	bmi.w	e5fe <lv_theme_material_init+0x10e2>
    ddb6:	48bc      	ldr	r0, [pc, #752]	; (e0a8 <lv_theme_material_init+0xb8c>)
    ddb8:	f00d fc77 	bl	1b6aa <lv_color_hex>
    ddbc:	b2c7      	uxtb	r7, r0
    ddbe:	f3c0 2107 	ubfx	r1, r0, #8, #8
    ddc2:	f3c0 4307 	ubfx	r3, r0, #16, #8
    ddc6:	0e00      	lsrs	r0, r0, #24
    ddc8:	2200      	movs	r2, #0
    ddca:	f367 0207 	bfi	r2, r7, #0, #8
    ddce:	f361 220f 	bfi	r2, r1, #8, #8
    ddd2:	f363 4217 	bfi	r2, r3, #16, #8
    ddd6:	f360 621f 	bfi	r2, r0, #24, #8
    ddda:	f242 0139 	movw	r1, #8249	; 0x2039
    ddde:	4630      	mov	r0, r6
    dde0:	f009 f8dc 	bl	16f9c <_lv_style_set_color>
    lv_style_set_border_width(&styles->btn, LV_STATE_DEFAULT, BORDER_WIDTH);
    dde4:	2000      	movs	r0, #0
    dde6:	6826      	ldr	r6, [r4, #0]
    dde8:	f7fe fbe6 	bl	c5b8 <lv_disp_get_dpi>
    ddec:	3028      	adds	r0, #40	; 0x28
    ddee:	0040      	lsls	r0, r0, #1
    ddf0:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    ddf4:	f106 0610 	add.w	r6, r6, #16
    ddf8:	f2c0 8407 	blt.w	e60a <lv_theme_material_init+0x10ee>
    ddfc:	2000      	movs	r0, #0
    ddfe:	f7fe fbdb 	bl	c5b8 <lv_disp_get_dpi>
    de02:	f100 0228 	add.w	r2, r0, #40	; 0x28
    de06:	20a0      	movs	r0, #160	; 0xa0
    de08:	0052      	lsls	r2, r2, #1
    de0a:	fb92 f2f0 	sdiv	r2, r2, r0
    de0e:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
    de10:	4630      	mov	r0, r6
    de12:	2130      	movs	r1, #48	; 0x30
    de14:	f009 f87e 	bl	16f14 <_lv_style_set_int>
    lv_style_set_border_opa(&styles->btn, LV_STATE_CHECKED, LV_OPA_TRANSP);
    de18:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_OPA, border_opa, lv_opa_t, _opa, scalar)
    de1a:	2200      	movs	r2, #0
    de1c:	3010      	adds	r0, #16
    de1e:	f44f 719e 	mov.w	r1, #316	; 0x13c
    de22:	f009 f8ff 	bl	17024 <_lv_style_set_opa>
    lv_style_set_text_color(&styles->btn, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
    de26:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    de28:	6826      	ldr	r6, [r4, #0]
    de2a:	079b      	lsls	r3, r3, #30
    de2c:	bf54      	ite	pl
    de2e:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    de32:	489e      	ldrmi	r0, [pc, #632]	; (e0ac <lv_theme_material_init+0xb90>)
    de34:	f00d fc39 	bl	1b6aa <lv_color_hex>
    de38:	3610      	adds	r6, #16
    de3a:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
    de3c:	f248 0189 	movw	r1, #32905	; 0x8089
    de40:	4630      	mov	r0, r6
    de42:	f009 f8ab 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_PRESSED, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
    de46:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    de48:	6826      	ldr	r6, [r4, #0]
    de4a:	079f      	lsls	r7, r3, #30
    de4c:	bf54      	ite	pl
    de4e:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    de52:	4896      	ldrmi	r0, [pc, #600]	; (e0ac <lv_theme_material_init+0xb90>)
    de54:	f00d fc29 	bl	1b6aa <lv_color_hex>
    de58:	3610      	adds	r6, #16
    de5a:	4602      	mov	r2, r0
    de5c:	f249 0189 	movw	r1, #37001	; 0x9089
    de60:	4630      	mov	r0, r6
    de62:	f009 f89b 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_CHECKED,  lv_color_hex(0xffffff));
    de66:	6820      	ldr	r0, [r4, #0]
    lv_style_set_pad_left(&styles->btn, LV_STATE_DEFAULT, LV_DPX(40));
    de68:	f04f 0850 	mov.w	r8, #80	; 0x50
    lv_style_set_text_color(&styles->btn, LV_STATE_CHECKED,  lv_color_hex(0xffffff));
    de6c:	f100 0610 	add.w	r6, r0, #16
    de70:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    de74:	f00d fc19 	bl	1b6aa <lv_color_hex>
    de78:	f248 1189 	movw	r1, #33161	; 0x8189
    de7c:	4602      	mov	r2, r0
    de7e:	4630      	mov	r0, r6
    de80:	f009 f88c 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, lv_color_hex(0xffffff));
    de84:	6820      	ldr	r0, [r4, #0]
    de86:	f100 0610 	add.w	r6, r0, #16
    de8a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    de8e:	f00d fc0c 	bl	1b6aa <lv_color_hex>
    de92:	f249 1189 	movw	r1, #37257	; 0x9189
    de96:	4602      	mov	r2, r0
    de98:	4630      	mov	r0, r6
    de9a:	f009 f87f 	bl	16f9c <_lv_style_set_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_DISABLED, IS_LIGHT ? lv_color_hex(0x888888) : lv_color_hex(0x888888));
    de9e:	6820      	ldr	r0, [r4, #0]
    dea0:	f100 0610 	add.w	r6, r0, #16
    dea4:	4882      	ldr	r0, [pc, #520]	; (e0b0 <lv_theme_material_init+0xb94>)
    dea6:	f00d fc00 	bl	1b6aa <lv_color_hex>
    deaa:	f24a 0189 	movw	r1, #41097	; 0xa089
    deae:	4602      	mov	r2, r0
    deb0:	4630      	mov	r0, r6
    deb2:	f009 f873 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
    deb6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    deb8:	6826      	ldr	r6, [r4, #0]
    deba:	0798      	lsls	r0, r3, #30
    debc:	bf54      	ite	pl
    debe:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    dec2:	487a      	ldrmi	r0, [pc, #488]	; (e0ac <lv_theme_material_init+0xb90>)
    dec4:	f00d fbf1 	bl	1b6aa <lv_color_hex>
    dec8:	3610      	adds	r6, #16
    deca:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
    decc:	f248 01a9 	movw	r1, #32937	; 0x80a9
    ded0:	4630      	mov	r0, r6
    ded2:	f009 f863 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_PRESSED, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
    ded6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    ded8:	6826      	ldr	r6, [r4, #0]
    deda:	0799      	lsls	r1, r3, #30
    dedc:	bf54      	ite	pl
    dede:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    dee2:	4872      	ldrmi	r0, [pc, #456]	; (e0ac <lv_theme_material_init+0xb90>)
    dee4:	f00d fbe1 	bl	1b6aa <lv_color_hex>
    dee8:	3610      	adds	r6, #16
    deea:	4602      	mov	r2, r0
    deec:	f249 01a9 	movw	r1, #37033	; 0x90a9
    def0:	4630      	mov	r0, r6
    def2:	f009 f853 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_PRESSED, lv_color_hex(0xffffff));
    def6:	6820      	ldr	r0, [r4, #0]
    def8:	f100 0610 	add.w	r6, r0, #16
    defc:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    df00:	f00d fbd3 	bl	1b6aa <lv_color_hex>
    df04:	f249 01a9 	movw	r1, #37033	; 0x90a9
    df08:	4602      	mov	r2, r0
    df0a:	4630      	mov	r0, r6
    df0c:	f009 f846 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, lv_color_hex(0xffffff));
    df10:	6820      	ldr	r0, [r4, #0]
    df12:	f100 0610 	add.w	r6, r0, #16
    df16:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    df1a:	f00d fbc6 	bl	1b6aa <lv_color_hex>
    df1e:	f249 11a9 	movw	r1, #37289	; 0x91a9
    df22:	4602      	mov	r2, r0
    df24:	4630      	mov	r0, r6
    df26:	f009 f839 	bl	16f9c <_lv_style_set_color>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_DISABLED, IS_LIGHT ? lv_color_hex(0x888888) : lv_color_hex(0x888888));
    df2a:	6820      	ldr	r0, [r4, #0]
    df2c:	f100 0610 	add.w	r6, r0, #16
    df30:	485f      	ldr	r0, [pc, #380]	; (e0b0 <lv_theme_material_init+0xb94>)
    df32:	f00d fbba 	bl	1b6aa <lv_color_hex>
    df36:	f24a 01a9 	movw	r1, #41129	; 0xa0a9
    df3a:	4602      	mov	r2, r0
    df3c:	4630      	mov	r0, r6
    df3e:	f009 f82d 	bl	16f9c <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
    df42:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    df44:	6826      	ldr	r6, [r4, #0]
    df46:	079a      	lsls	r2, r3, #30
    df48:	bf54      	ite	pl
    df4a:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    df4e:	4857      	ldrmi	r0, [pc, #348]	; (e0ac <lv_theme_material_init+0xb90>)
    df50:	f00d fbab 	bl	1b6aa <lv_color_hex>
    df54:	3610      	adds	r6, #16
    df56:	4602      	mov	r2, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
    df58:	2179      	movs	r1, #121	; 0x79
    df5a:	4630      	mov	r0, r6
    df5c:	f009 f81e 	bl	16f9c <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_PRESSED, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
    df60:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    df62:	6826      	ldr	r6, [r4, #0]
    df64:	079b      	lsls	r3, r3, #30
    df66:	bf54      	ite	pl
    df68:	f06f 407f 	mvnpl.w	r0, #4278190080	; 0xff000000
    df6c:	484f      	ldrmi	r0, [pc, #316]	; (e0ac <lv_theme_material_init+0xb90>)
    df6e:	f00d fb9c 	bl	1b6aa <lv_color_hex>
    df72:	3610      	adds	r6, #16
    df74:	4602      	mov	r2, r0
    df76:	f241 0179 	movw	r1, #4217	; 0x1079
    df7a:	4630      	mov	r0, r6
    df7c:	f009 f80e 	bl	16f9c <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_CHECKED,  lv_color_hex(0xffffff));
    df80:	6820      	ldr	r0, [r4, #0]
    df82:	f100 0610 	add.w	r6, r0, #16
    df86:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    df8a:	f00d fb8e 	bl	1b6aa <lv_color_hex>
    df8e:	f240 1179 	movw	r1, #377	; 0x179
    df92:	4602      	mov	r2, r0
    df94:	4630      	mov	r0, r6
    df96:	f009 f801 	bl	16f9c <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, lv_color_hex(0xffffff));
    df9a:	6820      	ldr	r0, [r4, #0]
    df9c:	f100 0610 	add.w	r6, r0, #16
    dfa0:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    dfa4:	f00d fb81 	bl	1b6aa <lv_color_hex>
    dfa8:	f241 1179 	movw	r1, #4473	; 0x1179
    dfac:	4602      	mov	r2, r0
    dfae:	4630      	mov	r0, r6
    dfb0:	f008 fff4 	bl	16f9c <_lv_style_set_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_DISABLED, IS_LIGHT ? lv_color_hex(0x888888) : lv_color_hex(0x888888));
    dfb4:	6820      	ldr	r0, [r4, #0]
    dfb6:	f100 0610 	add.w	r6, r0, #16
    dfba:	483d      	ldr	r0, [pc, #244]	; (e0b0 <lv_theme_material_init+0xb94>)
    dfbc:	f00d fb75 	bl	1b6aa <lv_color_hex>
    dfc0:	f242 0179 	movw	r1, #8313	; 0x2079
    dfc4:	4602      	mov	r2, r0
    dfc6:	4630      	mov	r0, r6
    dfc8:	f008 ffe8 	bl	16f9c <_lv_style_set_color>
    lv_style_set_pad_left(&styles->btn, LV_STATE_DEFAULT, LV_DPX(40));
    dfcc:	2000      	movs	r0, #0
    dfce:	6827      	ldr	r7, [r4, #0]
    dfd0:	2628      	movs	r6, #40	; 0x28
    dfd2:	f7fe faf1 	bl	c5b8 <lv_disp_get_dpi>
    dfd6:	fb00 8006 	mla	r0, r0, r6, r8
    dfda:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    dfde:	f107 0710 	add.w	r7, r7, #16
    dfe2:	f2c0 8314 	blt.w	e60e <lv_theme_material_init+0x10f2>
    dfe6:	2000      	movs	r0, #0
    dfe8:	f7fe fae6 	bl	c5b8 <lv_disp_get_dpi>
    dfec:	fb00 8206 	mla	r2, r0, r6, r8
    dff0:	26a0      	movs	r6, #160	; 0xa0
    dff2:	fb92 f2f6 	sdiv	r2, r2, r6
    dff6:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    dff8:	4638      	mov	r0, r7
    dffa:	2112      	movs	r1, #18
    dffc:	f008 ff8a 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_right(&styles->btn, LV_STATE_DEFAULT, LV_DPX(40));
    e000:	2000      	movs	r0, #0
    e002:	6827      	ldr	r7, [r4, #0]
    e004:	2628      	movs	r6, #40	; 0x28
    e006:	f7fe fad7 	bl	c5b8 <lv_disp_get_dpi>
    e00a:	f04f 0850 	mov.w	r8, #80	; 0x50
    e00e:	fb00 8006 	mla	r0, r0, r6, r8
    e012:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e016:	f107 0710 	add.w	r7, r7, #16
    e01a:	f2c0 82fa 	blt.w	e612 <lv_theme_material_init+0x10f6>
    e01e:	2000      	movs	r0, #0
    e020:	f7fe faca 	bl	c5b8 <lv_disp_get_dpi>
    e024:	fb00 8206 	mla	r2, r0, r6, r8
    e028:	26a0      	movs	r6, #160	; 0xa0
    e02a:	fb92 f2f6 	sdiv	r2, r2, r6
    e02e:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    e030:	4638      	mov	r0, r7
    e032:	2113      	movs	r1, #19
    e034:	f008 ff6e 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_top(&styles->btn, LV_STATE_DEFAULT, LV_DPX(15));
    e038:	2000      	movs	r0, #0
    e03a:	6827      	ldr	r7, [r4, #0]
    e03c:	260f      	movs	r6, #15
    e03e:	f7fe fabb 	bl	c5b8 <lv_disp_get_dpi>
    e042:	f04f 0850 	mov.w	r8, #80	; 0x50
    e046:	fb00 8006 	mla	r0, r0, r6, r8
    e04a:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e04e:	f107 0710 	add.w	r7, r7, #16
    e052:	f2c0 82e0 	blt.w	e616 <lv_theme_material_init+0x10fa>
    e056:	2000      	movs	r0, #0
    e058:	f7fe faae 	bl	c5b8 <lv_disp_get_dpi>
    e05c:	fb00 8206 	mla	r2, r0, r6, r8
    e060:	26a0      	movs	r6, #160	; 0xa0
    e062:	fb92 f2f6 	sdiv	r2, r2, r6
    e066:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    e068:	4638      	mov	r0, r7
    e06a:	2110      	movs	r1, #16
    e06c:	f008 ff52 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_bottom(&styles->btn, LV_STATE_DEFAULT, LV_DPX(15));
    e070:	2000      	movs	r0, #0
    e072:	6827      	ldr	r7, [r4, #0]
    e074:	260f      	movs	r6, #15
    e076:	f7fe fa9f 	bl	c5b8 <lv_disp_get_dpi>
    e07a:	f04f 0850 	mov.w	r8, #80	; 0x50
    e07e:	fb00 8006 	mla	r0, r0, r6, r8
    e082:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e086:	f107 0710 	add.w	r7, r7, #16
    e08a:	f2c0 82c6 	blt.w	e61a <lv_theme_material_init+0x10fe>
    e08e:	2000      	movs	r0, #0
    e090:	f7fe fa92 	bl	c5b8 <lv_disp_get_dpi>
    e094:	fb00 8206 	mla	r2, r0, r6, r8
    e098:	26a0      	movs	r6, #160	; 0xa0
    e09a:	fb92 f2f6 	sdiv	r2, r2, r6
    e09e:	b212      	sxth	r2, r2
    e0a0:	e008      	b.n	e0b4 <lv_theme_material_init+0xb98>
    e0a2:	bf00      	nop
    e0a4:	00586273 	.word	0x00586273
    e0a8:	00404040 	.word	0x00404040
    e0ac:	0031404f 	.word	0x0031404f
    e0b0:	00888888 	.word	0x00888888
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    e0b4:	4638      	mov	r0, r7
    e0b6:	2111      	movs	r1, #17
    e0b8:	f008 ff2c 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_inner(&styles->btn, LV_STATE_DEFAULT, LV_DPX(20));
    e0bc:	2000      	movs	r0, #0
    e0be:	6827      	ldr	r7, [r4, #0]
    e0c0:	2614      	movs	r6, #20
    e0c2:	f7fe fa79 	bl	c5b8 <lv_disp_get_dpi>
    e0c6:	f04f 0850 	mov.w	r8, #80	; 0x50
    e0ca:	fb00 8006 	mla	r0, r0, r6, r8
    e0ce:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e0d2:	f107 0710 	add.w	r7, r7, #16
    e0d6:	f2c0 82a2 	blt.w	e61e <lv_theme_material_init+0x1102>
    e0da:	2000      	movs	r0, #0
    e0dc:	f7fe fa6c 	bl	c5b8 <lv_disp_get_dpi>
    e0e0:	fb00 8206 	mla	r2, r0, r6, r8
    e0e4:	26a0      	movs	r6, #160	; 0xa0
    e0e6:	fb92 f2f6 	sdiv	r2, r2, r6
    e0ea:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
    e0ec:	4638      	mov	r0, r7
    e0ee:	2114      	movs	r1, #20
    e0f0:	f008 ff10 	bl	16f14 <_lv_style_set_int>
    lv_style_set_outline_width(&styles->btn, LV_STATE_DEFAULT, OUTLINE_WIDTH);
    e0f4:	6a68      	ldr	r0, [r5, #36]	; 0x24
    e0f6:	6826      	ldr	r6, [r4, #0]
    e0f8:	f010 0720 	ands.w	r7, r0, #32
    e0fc:	f106 0610 	add.w	r6, r6, #16
    e100:	f040 828f 	bne.w	e622 <lv_theme_material_init+0x1106>
    e104:	4638      	mov	r0, r7
    e106:	f7fe fa57 	bl	c5b8 <lv_disp_get_dpi>
    e10a:	3028      	adds	r0, #40	; 0x28
    e10c:	0040      	lsls	r0, r0, #1
    e10e:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e112:	f2c0 8288 	blt.w	e626 <lv_theme_material_init+0x110a>
    e116:	4638      	mov	r0, r7
    e118:	f7fe fa4e 	bl	c5b8 <lv_disp_get_dpi>
    e11c:	f100 0228 	add.w	r2, r0, #40	; 0x28
    e120:	20a0      	movs	r0, #160	; 0xa0
    e122:	0052      	lsls	r2, r2, #1
    e124:	fb92 f2f0 	sdiv	r2, r2, r0
    e128:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_WIDTH, outline_width, lv_style_int_t, _int, scalar)
    e12a:	2140      	movs	r1, #64	; 0x40
    e12c:	4630      	mov	r0, r6
    e12e:	f008 fef1 	bl	16f14 <_lv_style_set_int>
    lv_style_set_outline_opa(&styles->btn, LV_STATE_DEFAULT, LV_OPA_0);
    e132:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_OPA, outline_opa, lv_opa_t, _opa, scalar)
    e134:	2200      	movs	r2, #0
    e136:	214c      	movs	r1, #76	; 0x4c
    e138:	3010      	adds	r0, #16
    e13a:	f008 ff73 	bl	17024 <_lv_style_set_opa>
    lv_style_set_outline_opa(&styles->btn, LV_STATE_FOCUSED, LV_OPA_50);
    e13e:	6820      	ldr	r0, [r4, #0]
    e140:	227f      	movs	r2, #127	; 0x7f
    e142:	f44f 7113 	mov.w	r1, #588	; 0x24c
    e146:	3010      	adds	r0, #16
    e148:	f008 ff6c 	bl	17024 <_lv_style_set_opa>
    lv_style_set_outline_color(&styles->btn, LV_STATE_DEFAULT, theme.color_primary);
    e14c:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_COLOR, outline_color, lv_color_t, _color, nonscalar)
    e14e:	2149      	movs	r1, #73	; 0x49
    e150:	68ea      	ldr	r2, [r5, #12]
    e152:	3010      	adds	r0, #16
    e154:	f008 ff22 	bl	16f9c <_lv_style_set_color>
    lv_style_set_outline_color(&styles->btn, LV_STATE_EDITED, theme.color_secondary);
    e158:	6820      	ldr	r0, [r4, #0]
    e15a:	f240 4149 	movw	r1, #1097	; 0x449
    e15e:	692a      	ldr	r2, [r5, #16]
    e160:	3010      	adds	r0, #16
    e162:	f008 ff1b 	bl	16f9c <_lv_style_set_color>
    lv_style_set_transition_time(&styles->btn, LV_STATE_DEFAULT, TRANSITION_TIME);
    e166:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
    e168:	2200      	movs	r2, #0
    e16a:	21b0      	movs	r1, #176	; 0xb0
    e16c:	3010      	adds	r0, #16
    e16e:	f008 fed1 	bl	16f14 <_lv_style_set_int>
    lv_style_set_transition_prop_4(&styles->btn, LV_STATE_DEFAULT, LV_STYLE_BORDER_OPA);
    e172:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_4, transition_prop_4, lv_style_int_t, _int, scalar)
    e174:	223c      	movs	r2, #60	; 0x3c
    e176:	21b5      	movs	r1, #181	; 0xb5
    e178:	3010      	adds	r0, #16
    e17a:	f008 fecb 	bl	16f14 <_lv_style_set_int>
    lv_style_set_transition_prop_5(&styles->btn, LV_STATE_DEFAULT, LV_STYLE_BG_COLOR);
    e17e:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_5, transition_prop_5, lv_style_int_t, _int, scalar)
    e180:	2229      	movs	r2, #41	; 0x29
    e182:	21b6      	movs	r1, #182	; 0xb6
    e184:	3010      	adds	r0, #16
    e186:	f008 fec5 	bl	16f14 <_lv_style_set_int>
    lv_style_set_transition_prop_6(&styles->btn, LV_STATE_DEFAULT, LV_STYLE_OUTLINE_OPA);
    e18a:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_6, transition_prop_6, lv_style_int_t, _int, scalar)
    e18c:	224c      	movs	r2, #76	; 0x4c
    e18e:	21b7      	movs	r1, #183	; 0xb7
    e190:	3010      	adds	r0, #16
    e192:	f008 febf 	bl	16f14 <_lv_style_set_int>
    lv_style_set_transition_delay(&styles->btn, LV_STATE_DEFAULT, TRANSITION_TIME);
    e196:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_DELAY, transition_delay, lv_style_int_t, _int, scalar)
    e198:	2200      	movs	r2, #0
    e19a:	21b1      	movs	r1, #177	; 0xb1
    e19c:	3010      	adds	r0, #16
    e19e:	f008 feb9 	bl	16f14 <_lv_style_set_int>
    lv_style_set_transition_delay(&styles->btn, LV_STATE_PRESSED, 0);
    e1a2:	6820      	ldr	r0, [r4, #0]
    e1a4:	2200      	movs	r2, #0
    e1a6:	f241 01b1 	movw	r1, #4273	; 0x10b1
    e1aa:	3010      	adds	r0, #16
    e1ac:	f008 feb2 	bl	16f14 <_lv_style_set_int>
    style_init_reset(&styles->pad_inner);
    e1b0:	6820      	ldr	r0, [r4, #0]
    e1b2:	3014      	adds	r0, #20
    e1b4:	f7ff f9a8 	bl	d508 <style_init_reset>
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
    e1b8:	2000      	movs	r0, #0
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
    e1ba:	6827      	ldr	r7, [r4, #0]
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
    e1bc:	f7fe fa08 	bl	c5d0 <lv_disp_get_size_category>
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
    e1c0:	2832      	cmp	r0, #50	; 0x32
    e1c2:	f107 0714 	add.w	r7, r7, #20
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
    e1c6:	f04f 0000 	mov.w	r0, #0
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
    e1ca:	f200 822e 	bhi.w	e62a <lv_theme_material_init+0x110e>
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
    e1ce:	f7fe f9f3 	bl	c5b8 <lv_disp_get_dpi>
    e1d2:	2614      	movs	r6, #20
    e1d4:	f04f 0850 	mov.w	r8, #80	; 0x50
    e1d8:	fb00 8006 	mla	r0, r0, r6, r8
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
    e1dc:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e1e0:	f280 8227 	bge.w	e632 <lv_theme_material_init+0x1116>
    e1e4:	2201      	movs	r2, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
    e1e6:	2114      	movs	r1, #20
    e1e8:	4638      	mov	r0, r7
    e1ea:	f008 fe93 	bl	16f14 <_lv_style_set_int>
    style_init_reset(&styles->pad_small);
    e1ee:	6820      	ldr	r0, [r4, #0]
    e1f0:	3018      	adds	r0, #24
    e1f2:	f7ff f989 	bl	d508 <style_init_reset>
    lv_style_int_t pad_small_value = lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(10) : LV_DPX(20);
    e1f6:	2000      	movs	r0, #0
    e1f8:	f7fe f9ea 	bl	c5d0 <lv_disp_get_size_category>
    e1fc:	2832      	cmp	r0, #50	; 0x32
    e1fe:	f04f 0000 	mov.w	r0, #0
    e202:	f200 8220 	bhi.w	e646 <lv_theme_material_init+0x112a>
    e206:	f7fe f9d7 	bl	c5b8 <lv_disp_get_dpi>
    e20a:	260a      	movs	r6, #10
    e20c:	2750      	movs	r7, #80	; 0x50
    e20e:	fb00 7006 	mla	r0, r0, r6, r7
    e212:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e216:	f280 821a 	bge.w	e64e <lv_theme_material_init+0x1132>
    e21a:	2601      	movs	r6, #1
    lv_style_set_pad_left(&styles->pad_small, LV_STATE_DEFAULT,  pad_small_value);
    e21c:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    e21e:	4632      	mov	r2, r6
    e220:	2112      	movs	r1, #18
    e222:	3018      	adds	r0, #24
    e224:	f008 fe76 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_right(&styles->pad_small, LV_STATE_DEFAULT, pad_small_value);
    e228:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    e22a:	4632      	mov	r2, r6
    e22c:	2113      	movs	r1, #19
    e22e:	3018      	adds	r0, #24
    e230:	f008 fe70 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_top(&styles->pad_small, LV_STATE_DEFAULT,  pad_small_value);
    e234:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    e236:	4632      	mov	r2, r6
    e238:	2110      	movs	r1, #16
    e23a:	3018      	adds	r0, #24
    e23c:	f008 fe6a 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_bottom(&styles->pad_small, LV_STATE_DEFAULT, pad_small_value);
    e240:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    e242:	4632      	mov	r2, r6
    e244:	2111      	movs	r1, #17
    e246:	3018      	adds	r0, #24
    e248:	f008 fe64 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_inner(&styles->pad_small, LV_STATE_DEFAULT, pad_small_value);
    e24c:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
    e24e:	4632      	mov	r2, r6
    e250:	2114      	movs	r1, #20
    e252:	3018      	adds	r0, #24
    e254:	f008 fe5e 	bl	16f14 <_lv_style_set_int>
    style_init_reset(&styles->cb_bg);
    e258:	6820      	ldr	r0, [r4, #0]
    e25a:	301c      	adds	r0, #28
    e25c:	f7ff f954 	bl	d508 <style_init_reset>
    lv_style_set_radius(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(4));
    e260:	2000      	movs	r0, #0
    e262:	6826      	ldr	r6, [r4, #0]
    e264:	f7fe f9a8 	bl	c5b8 <lv_disp_get_dpi>
    e268:	3014      	adds	r0, #20
    e26a:	0080      	lsls	r0, r0, #2
    e26c:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e270:	f106 061c 	add.w	r6, r6, #28
    e274:	f2c0 81f5 	blt.w	e662 <lv_theme_material_init+0x1146>
    e278:	2000      	movs	r0, #0
    e27a:	f7fe f99d 	bl	c5b8 <lv_disp_get_dpi>
    e27e:	f100 0214 	add.w	r2, r0, #20
    e282:	20a0      	movs	r0, #160	; 0xa0
    e284:	0092      	lsls	r2, r2, #2
    e286:	fb92 f2f0 	sdiv	r2, r2, r0
    e28a:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
    e28c:	4630      	mov	r0, r6
    e28e:	2101      	movs	r1, #1
    e290:	f008 fe40 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_inner(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(10));
    e294:	2000      	movs	r0, #0
    e296:	6827      	ldr	r7, [r4, #0]
    e298:	260a      	movs	r6, #10
    e29a:	f7fe f98d 	bl	c5b8 <lv_disp_get_dpi>
    e29e:	f04f 0850 	mov.w	r8, #80	; 0x50
    e2a2:	fb00 8006 	mla	r0, r0, r6, r8
    e2a6:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e2aa:	f107 071c 	add.w	r7, r7, #28
    e2ae:	f2c0 81da 	blt.w	e666 <lv_theme_material_init+0x114a>
    e2b2:	2000      	movs	r0, #0
    e2b4:	f7fe f980 	bl	c5b8 <lv_disp_get_dpi>
    e2b8:	fb00 8206 	mla	r2, r0, r6, r8
    e2bc:	26a0      	movs	r6, #160	; 0xa0
    e2be:	fb92 f2f6 	sdiv	r2, r2, r6
    e2c2:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
    e2c4:	2114      	movs	r1, #20
    e2c6:	4638      	mov	r0, r7
    e2c8:	f008 fe24 	bl	16f14 <_lv_style_set_int>
    lv_style_set_outline_color(&styles->cb_bg, LV_STATE_DEFAULT, theme.color_primary);
    e2cc:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_COLOR, outline_color, lv_color_t, _color, nonscalar)
    e2ce:	68ea      	ldr	r2, [r5, #12]
    e2d0:	2149      	movs	r1, #73	; 0x49
    e2d2:	301c      	adds	r0, #28
    e2d4:	f008 fe62 	bl	16f9c <_lv_style_set_color>
    lv_style_set_outline_opa(&styles->cb_bg, LV_STATE_DEFAULT, LV_OPA_TRANSP);
    e2d8:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_OPA, outline_opa, lv_opa_t, _opa, scalar)
    e2da:	2200      	movs	r2, #0
    e2dc:	214c      	movs	r1, #76	; 0x4c
    e2de:	301c      	adds	r0, #28
    e2e0:	f008 fea0 	bl	17024 <_lv_style_set_opa>
    lv_style_set_outline_opa(&styles->cb_bg, LV_STATE_FOCUSED, LV_OPA_50);
    e2e4:	6820      	ldr	r0, [r4, #0]
    e2e6:	227f      	movs	r2, #127	; 0x7f
    e2e8:	f44f 7113 	mov.w	r1, #588	; 0x24c
    e2ec:	301c      	adds	r0, #28
    e2ee:	f008 fe99 	bl	17024 <_lv_style_set_opa>
    lv_style_set_outline_width(&styles->cb_bg, LV_STATE_DEFAULT, OUTLINE_WIDTH);
    e2f2:	6a6d      	ldr	r5, [r5, #36]	; 0x24
    e2f4:	6826      	ldr	r6, [r4, #0]
    e2f6:	f015 0520 	ands.w	r5, r5, #32
    e2fa:	f106 061c 	add.w	r6, r6, #28
    e2fe:	f040 81b4 	bne.w	e66a <lv_theme_material_init+0x114e>
    e302:	4628      	mov	r0, r5
    e304:	f7fe f958 	bl	c5b8 <lv_disp_get_dpi>
    e308:	3028      	adds	r0, #40	; 0x28
    e30a:	0040      	lsls	r0, r0, #1
    e30c:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e310:	f2c0 81ad 	blt.w	e66e <lv_theme_material_init+0x1152>
    e314:	4628      	mov	r0, r5
    e316:	f7fe f94f 	bl	c5b8 <lv_disp_get_dpi>
    e31a:	f100 0228 	add.w	r2, r0, #40	; 0x28
    e31e:	20a0      	movs	r0, #160	; 0xa0
    e320:	0052      	lsls	r2, r2, #1
    e322:	fb92 f2f0 	sdiv	r2, r2, r0
    e326:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_WIDTH, outline_width, lv_style_int_t, _int, scalar)
    e328:	4630      	mov	r0, r6
    e32a:	2140      	movs	r1, #64	; 0x40
    e32c:	f008 fdf2 	bl	16f14 <_lv_style_set_int>
    lv_style_set_outline_pad(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(10));
    e330:	2000      	movs	r0, #0
    e332:	6825      	ldr	r5, [r4, #0]
    e334:	2650      	movs	r6, #80	; 0x50
    e336:	f7fe f93f 	bl	c5b8 <lv_disp_get_dpi>
    e33a:	240a      	movs	r4, #10
    e33c:	fb00 6004 	mla	r0, r0, r4, r6
    e340:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e344:	f105 051c 	add.w	r5, r5, #28
    e348:	f2c0 8193 	blt.w	e672 <lv_theme_material_init+0x1156>
    e34c:	2000      	movs	r0, #0
    e34e:	f7fe f933 	bl	c5b8 <lv_disp_get_dpi>
    e352:	fb00 6204 	mla	r2, r0, r4, r6
    e356:	24a0      	movs	r4, #160	; 0xa0
    e358:	fb92 f2f4 	sdiv	r2, r2, r4
    e35c:	b212      	sxth	r2, r2
    lv_style_set_transition_time(&styles->cb_bg, LV_STATE_DEFAULT, TRANSITION_TIME);
    e35e:	4ccb      	ldr	r4, [pc, #812]	; (e68c <lv_theme_material_init+0x1170>)
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_PAD, outline_pad, lv_style_int_t, _int, scalar)
    e360:	4628      	mov	r0, r5
    e362:	2141      	movs	r1, #65	; 0x41
    e364:	f008 fdd6 	bl	16f14 <_lv_style_set_int>
    e368:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
    e36a:	2200      	movs	r2, #0
    e36c:	21b0      	movs	r1, #176	; 0xb0
    e36e:	301c      	adds	r0, #28
    e370:	f008 fdd0 	bl	16f14 <_lv_style_set_int>
    lv_style_set_transition_prop_6(&styles->cb_bg, LV_STATE_DEFAULT, LV_STYLE_OUTLINE_OPA);
    e374:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_6, transition_prop_6, lv_style_int_t, _int, scalar)
    e376:	224c      	movs	r2, #76	; 0x4c
    e378:	21b7      	movs	r1, #183	; 0xb7
    e37a:	301c      	adds	r0, #28
    e37c:	f008 fdca 	bl	16f14 <_lv_style_set_int>
    style_init_reset(&styles->cb_bullet);
    e380:	6820      	ldr	r0, [r4, #0]
    e382:	3020      	adds	r0, #32
    e384:	f7ff f8c0 	bl	d508 <style_init_reset>
    lv_style_set_outline_opa(&styles->cb_bullet, LV_STATE_FOCUSED, LV_OPA_TRANSP);
    e388:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_OPA, outline_opa, lv_opa_t, _opa, scalar)
    e38a:	2200      	movs	r2, #0
    e38c:	f44f 7113 	mov.w	r1, #588	; 0x24c
    e390:	3020      	adds	r0, #32
    e392:	f008 fe47 	bl	17024 <_lv_style_set_opa>
    lv_style_set_radius(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(4));
    e396:	2000      	movs	r0, #0
    e398:	6825      	ldr	r5, [r4, #0]
    e39a:	f7fe f90d 	bl	c5b8 <lv_disp_get_dpi>
    e39e:	3014      	adds	r0, #20
    e3a0:	0080      	lsls	r0, r0, #2
    e3a2:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e3a6:	f105 0520 	add.w	r5, r5, #32
    e3aa:	f2c0 8164 	blt.w	e676 <lv_theme_material_init+0x115a>
    e3ae:	2000      	movs	r0, #0
    e3b0:	f7fe f902 	bl	c5b8 <lv_disp_get_dpi>
    e3b4:	f100 0214 	add.w	r2, r0, #20
    e3b8:	20a0      	movs	r0, #160	; 0xa0
    e3ba:	0092      	lsls	r2, r2, #2
    e3bc:	fb92 f2f0 	sdiv	r2, r2, r0
    e3c0:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
    e3c2:	4628      	mov	r0, r5
    e3c4:	2101      	movs	r1, #1
    e3c6:	f008 fda5 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pattern_image(&styles->cb_bullet, LV_STATE_CHECKED, LV_SYMBOL_OK);
    e3ca:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_IMAGE, pattern_image, const void *, _ptr, scalar)
    e3cc:	f44f 71b7 	mov.w	r1, #366	; 0x16e
    e3d0:	4aaf      	ldr	r2, [pc, #700]	; (e690 <lv_theme_material_init+0x1174>)
    e3d2:	3020      	adds	r0, #32
    e3d4:	f008 fe6c 	bl	170b0 <_lv_style_set_ptr>
    lv_style_set_pattern_recolor(&styles->cb_bullet, LV_STATE_CHECKED, LV_COLOR_WHITE);
    e3d8:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_RECOLOR, pattern_recolor, lv_color_t, _color, nonscalar)
    e3da:	f04f 32ff 	mov.w	r2, #4294967295
    e3de:	f240 1169 	movw	r1, #361	; 0x169
    e3e2:	3020      	adds	r0, #32
    e3e4:	f008 fdda 	bl	16f9c <_lv_style_set_color>
    lv_style_set_pattern_opa(&styles->cb_bullet, LV_STATE_DEFAULT, LV_OPA_TRANSP);
    e3e8:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_OPA, pattern_opa, lv_opa_t, _opa, scalar)
    e3ea:	2200      	movs	r2, #0
    e3ec:	216c      	movs	r1, #108	; 0x6c
    e3ee:	3020      	adds	r0, #32
    e3f0:	f008 fe18 	bl	17024 <_lv_style_set_opa>
    lv_style_set_pattern_opa(&styles->cb_bullet, LV_STATE_CHECKED, LV_OPA_COVER);
    e3f4:	6820      	ldr	r0, [r4, #0]
    e3f6:	22ff      	movs	r2, #255	; 0xff
    e3f8:	f44f 71b6 	mov.w	r1, #364	; 0x16c
    e3fc:	3020      	adds	r0, #32
    e3fe:	f008 fe11 	bl	17024 <_lv_style_set_opa>
    lv_style_set_transition_prop_3(&styles->cb_bullet, LV_STATE_DEFAULT, LV_STYLE_PATTERN_OPA);
    e402:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_3, transition_prop_3, lv_style_int_t, _int, scalar)
    e404:	226c      	movs	r2, #108	; 0x6c
    e406:	21b4      	movs	r1, #180	; 0xb4
    e408:	3020      	adds	r0, #32
    e40a:	f008 fd83 	bl	16f14 <_lv_style_set_int>
    lv_style_set_text_font(&styles->cb_bullet, LV_STATE_CHECKED, theme.font_small);
    e40e:	4ea1      	ldr	r6, [pc, #644]	; (e694 <lv_theme_material_init+0x1178>)
    e410:	6820      	ldr	r0, [r4, #0]
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
    e412:	f248 118e 	movw	r1, #33166	; 0x818e
    e416:	6972      	ldr	r2, [r6, #20]
    e418:	3020      	adds	r0, #32
    e41a:	f008 fe49 	bl	170b0 <_lv_style_set_ptr>
    lv_style_set_pad_left(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
    e41e:	2000      	movs	r0, #0
    e420:	6827      	ldr	r7, [r4, #0]
    e422:	2503      	movs	r5, #3
    e424:	f7fe f8c8 	bl	c5b8 <lv_disp_get_dpi>
    e428:	f04f 0850 	mov.w	r8, #80	; 0x50
    e42c:	fb00 8005 	mla	r0, r0, r5, r8
    e430:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e434:	f107 0720 	add.w	r7, r7, #32
    e438:	f2c0 811f 	blt.w	e67a <lv_theme_material_init+0x115e>
    e43c:	2000      	movs	r0, #0
    e43e:	f7fe f8bb 	bl	c5b8 <lv_disp_get_dpi>
    e442:	fb00 8205 	mla	r2, r0, r5, r8
    e446:	25a0      	movs	r5, #160	; 0xa0
    e448:	fb92 f2f5 	sdiv	r2, r2, r5
    e44c:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    e44e:	4638      	mov	r0, r7
    e450:	2112      	movs	r1, #18
    e452:	f008 fd5f 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_right(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
    e456:	2000      	movs	r0, #0
    e458:	6827      	ldr	r7, [r4, #0]
    e45a:	2503      	movs	r5, #3
    e45c:	f7fe f8ac 	bl	c5b8 <lv_disp_get_dpi>
    e460:	f04f 0850 	mov.w	r8, #80	; 0x50
    e464:	fb00 8005 	mla	r0, r0, r5, r8
    e468:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e46c:	f107 0720 	add.w	r7, r7, #32
    e470:	f2c0 8105 	blt.w	e67e <lv_theme_material_init+0x1162>
    e474:	2000      	movs	r0, #0
    e476:	f7fe f89f 	bl	c5b8 <lv_disp_get_dpi>
    e47a:	fb00 8205 	mla	r2, r0, r5, r8
    e47e:	25a0      	movs	r5, #160	; 0xa0
    e480:	fb92 f2f5 	sdiv	r2, r2, r5
    e484:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    e486:	4638      	mov	r0, r7
    e488:	2113      	movs	r1, #19
    e48a:	f008 fd43 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_top(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
    e48e:	2000      	movs	r0, #0
    e490:	6827      	ldr	r7, [r4, #0]
    e492:	2503      	movs	r5, #3
    e494:	f7fe f890 	bl	c5b8 <lv_disp_get_dpi>
    e498:	f04f 0850 	mov.w	r8, #80	; 0x50
    e49c:	fb00 8005 	mla	r0, r0, r5, r8
    e4a0:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e4a4:	f107 0720 	add.w	r7, r7, #32
    e4a8:	f2c0 80eb 	blt.w	e682 <lv_theme_material_init+0x1166>
    e4ac:	2000      	movs	r0, #0
    e4ae:	f7fe f883 	bl	c5b8 <lv_disp_get_dpi>
    e4b2:	fb00 8205 	mla	r2, r0, r5, r8
    e4b6:	25a0      	movs	r5, #160	; 0xa0
    e4b8:	fb92 f2f5 	sdiv	r2, r2, r5
    e4bc:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    e4be:	4638      	mov	r0, r7
    e4c0:	2110      	movs	r1, #16
    e4c2:	f008 fd27 	bl	16f14 <_lv_style_set_int>
    lv_style_set_pad_bottom(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
    e4c6:	2000      	movs	r0, #0
    e4c8:	6825      	ldr	r5, [r4, #0]
    e4ca:	2750      	movs	r7, #80	; 0x50
    e4cc:	f7fe f874 	bl	c5b8 <lv_disp_get_dpi>
    e4d0:	2403      	movs	r4, #3
    e4d2:	fb00 7004 	mla	r0, r0, r4, r7
    e4d6:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
    e4da:	f105 0520 	add.w	r5, r5, #32
    e4de:	f2c0 80d2 	blt.w	e686 <lv_theme_material_init+0x116a>
    e4e2:	2000      	movs	r0, #0
    e4e4:	f7fe f868 	bl	c5b8 <lv_disp_get_dpi>
    e4e8:	fb00 7204 	mla	r2, r0, r4, r7
    e4ec:	24a0      	movs	r4, #160	; 0xa0
    e4ee:	fb92 f2f4 	sdiv	r2, r2, r4
    e4f2:	b212      	sxth	r2, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    e4f4:	2111      	movs	r1, #17
    e4f6:	4628      	mov	r0, r5
    e4f8:	f008 fd0c 	bl	16f14 <_lv_style_set_int>
    theme.apply_xcb = NULL;
    e4fc:	2000      	movs	r0, #0
    inited = true;
    e4fe:	2201      	movs	r2, #1
    theme.apply_cb = theme_apply;
    e500:	4b65      	ldr	r3, [pc, #404]	; (e698 <lv_theme_material_init+0x117c>)
    theme.apply_xcb = NULL;
    e502:	6070      	str	r0, [r6, #4]
    theme.apply_cb = theme_apply;
    e504:	6033      	str	r3, [r6, #0]
    inited = true;
    e506:	4b65      	ldr	r3, [pc, #404]	; (e69c <lv_theme_material_init+0x1180>)
    e508:	701a      	strb	r2, [r3, #0]
    lv_obj_report_style_mod(NULL);
    e50a:	f007 fd84 	bl	16016 <lv_obj_report_style_mod>
}
    e50e:	4861      	ldr	r0, [pc, #388]	; (e694 <lv_theme_material_init+0x1178>)
    e510:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    lv_style_set_radius(&styles->bg, LV_STATE_DEFAULT, LV_DPX(8));
    e514:	2201      	movs	r2, #1
    e516:	f7ff b86b 	b.w	d5f0 <lv_theme_material_init+0xd4>
    lv_style_set_border_width(&styles->bg, LV_STATE_DEFAULT, BORDER_WIDTH);
    e51a:	2201      	movs	r2, #1
    e51c:	f7ff b8b6 	b.w	d68c <lv_theme_material_init+0x170>
    lv_style_set_pad_left(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
    e520:	f7fe f84a 	bl	c5b8 <lv_disp_get_dpi>
    e524:	261e      	movs	r6, #30
    e526:	f7ff b913 	b.w	d750 <lv_theme_material_init+0x234>
    e52a:	2000      	movs	r0, #0
    e52c:	f7fe f844 	bl	c5b8 <lv_disp_get_dpi>
    e530:	22a0      	movs	r2, #160	; 0xa0
    e532:	fb00 8606 	mla	r6, r0, r6, r8
    e536:	fb96 f6f2 	sdiv	r6, r6, r2
    e53a:	b236      	sxth	r6, r6
    e53c:	f7ff b911 	b.w	d762 <lv_theme_material_init+0x246>
    e540:	2201      	movs	r2, #1
    e542:	f7ff b921 	b.w	d788 <lv_theme_material_init+0x26c>
    lv_style_set_pad_right(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
    e546:	f7fe f837 	bl	c5b8 <lv_disp_get_dpi>
    e54a:	261e      	movs	r6, #30
    e54c:	f7ff b930 	b.w	d7b0 <lv_theme_material_init+0x294>
    e550:	2000      	movs	r0, #0
    e552:	f7fe f831 	bl	c5b8 <lv_disp_get_dpi>
    e556:	22a0      	movs	r2, #160	; 0xa0
    e558:	fb00 8606 	mla	r6, r0, r6, r8
    e55c:	fb96 f6f2 	sdiv	r6, r6, r2
    e560:	b236      	sxth	r6, r6
    e562:	f7ff b92e 	b.w	d7c2 <lv_theme_material_init+0x2a6>
    e566:	2201      	movs	r2, #1
    e568:	f7ff b93e 	b.w	d7e8 <lv_theme_material_init+0x2cc>
    lv_style_set_pad_top(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
    e56c:	f7fe f824 	bl	c5b8 <lv_disp_get_dpi>
    e570:	261e      	movs	r6, #30
    e572:	f7ff b94d 	b.w	d810 <lv_theme_material_init+0x2f4>
    e576:	2000      	movs	r0, #0
    e578:	f7fe f81e 	bl	c5b8 <lv_disp_get_dpi>
    e57c:	22a0      	movs	r2, #160	; 0xa0
    e57e:	fb00 8606 	mla	r6, r0, r6, r8
    e582:	fb96 f6f2 	sdiv	r6, r6, r2
    e586:	b236      	sxth	r6, r6
    e588:	f7ff b94b 	b.w	d822 <lv_theme_material_init+0x306>
    e58c:	2201      	movs	r2, #1
    e58e:	f7ff b973 	b.w	d878 <lv_theme_material_init+0x35c>
    lv_style_set_pad_bottom(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
    e592:	f7fe f811 	bl	c5b8 <lv_disp_get_dpi>
    e596:	261e      	movs	r6, #30
    e598:	f7ff b982 	b.w	d8a0 <lv_theme_material_init+0x384>
    e59c:	2000      	movs	r0, #0
    e59e:	f7fe f80b 	bl	c5b8 <lv_disp_get_dpi>
    e5a2:	22a0      	movs	r2, #160	; 0xa0
    e5a4:	fb00 8606 	mla	r6, r0, r6, r8
    e5a8:	fb96 f6f2 	sdiv	r6, r6, r2
    e5ac:	b236      	sxth	r6, r6
    e5ae:	f7ff b980 	b.w	d8b2 <lv_theme_material_init+0x396>
    e5b2:	2201      	movs	r2, #1
    e5b4:	f7ff b990 	b.w	d8d8 <lv_theme_material_init+0x3bc>
    lv_style_set_pad_inner(&styles->bg, LV_STATE_DEFAULT, PAD_DEF);
    e5b8:	f7fd fffe 	bl	c5b8 <lv_disp_get_dpi>
    e5bc:	261e      	movs	r6, #30
    e5be:	f7ff b99f 	b.w	d900 <lv_theme_material_init+0x3e4>
    e5c2:	2000      	movs	r0, #0
    e5c4:	f7fd fff8 	bl	c5b8 <lv_disp_get_dpi>
    e5c8:	fb00 8206 	mla	r2, r0, r6, r8
    e5cc:	26a0      	movs	r6, #160	; 0xa0
    e5ce:	fb92 f2f6 	sdiv	r2, r2, r6
    e5d2:	b212      	sxth	r2, r2
    e5d4:	f7ff b99d 	b.w	d912 <lv_theme_material_init+0x3f6>
    e5d8:	23cc      	movs	r3, #204	; 0xcc
    e5da:	20ff      	movs	r0, #255	; 0xff
    e5dc:	4619      	mov	r1, r3
    e5de:	461e      	mov	r6, r3
    e5e0:	f7ff ba61 	b.w	daa6 <lv_theme_material_init+0x58a>
    lv_style_set_bg_color(&styles->btn, LV_STATE_PRESSED, COLOR_BTN_PR);
    e5e4:	482e      	ldr	r0, [pc, #184]	; (e6a0 <lv_theme_material_init+0x1184>)
    e5e6:	f00d f860 	bl	1b6aa <lv_color_hex>
    e5ea:	f04f 0cb3 	mov.w	ip, #179	; 0xb3
    e5ee:	f3c0 4307 	ubfx	r3, r0, #16, #8
    e5f2:	224c      	movs	r2, #76	; 0x4c
    e5f4:	fb13 f30c 	smulbb	r3, r3, ip
    e5f8:	7ba9      	ldrb	r1, [r5, #14]
    e5fa:	f7ff bb66 	b.w	dcca <lv_theme_material_init+0x7ae>
    e5fe:	2388      	movs	r3, #136	; 0x88
    e600:	20ff      	movs	r0, #255	; 0xff
    e602:	4619      	mov	r1, r3
    e604:	461f      	mov	r7, r3
    e606:	f7ff bbdf 	b.w	ddc8 <lv_theme_material_init+0x8ac>
    lv_style_set_border_width(&styles->btn, LV_STATE_DEFAULT, BORDER_WIDTH);
    e60a:	2201      	movs	r2, #1
    e60c:	e400      	b.n	de10 <lv_theme_material_init+0x8f4>
    lv_style_set_pad_left(&styles->btn, LV_STATE_DEFAULT, LV_DPX(40));
    e60e:	2201      	movs	r2, #1
    e610:	e4f2      	b.n	dff8 <lv_theme_material_init+0xadc>
    lv_style_set_pad_right(&styles->btn, LV_STATE_DEFAULT, LV_DPX(40));
    e612:	2201      	movs	r2, #1
    e614:	e50c      	b.n	e030 <lv_theme_material_init+0xb14>
    lv_style_set_pad_top(&styles->btn, LV_STATE_DEFAULT, LV_DPX(15));
    e616:	2201      	movs	r2, #1
    e618:	e526      	b.n	e068 <lv_theme_material_init+0xb4c>
    lv_style_set_pad_bottom(&styles->btn, LV_STATE_DEFAULT, LV_DPX(15));
    e61a:	2201      	movs	r2, #1
    e61c:	e54a      	b.n	e0b4 <lv_theme_material_init+0xb98>
    lv_style_set_pad_inner(&styles->btn, LV_STATE_DEFAULT, LV_DPX(20));
    e61e:	2201      	movs	r2, #1
    e620:	e564      	b.n	e0ec <lv_theme_material_init+0xbd0>
    lv_style_set_outline_width(&styles->btn, LV_STATE_DEFAULT, OUTLINE_WIDTH);
    e622:	2200      	movs	r2, #0
    e624:	e581      	b.n	e12a <lv_theme_material_init+0xc0e>
    e626:	2201      	movs	r2, #1
    e628:	e57f      	b.n	e12a <lv_theme_material_init+0xc0e>
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
    e62a:	f7fd ffc5 	bl	c5b8 <lv_disp_get_dpi>
    e62e:	2628      	movs	r6, #40	; 0x28
    e630:	e5d0      	b.n	e1d4 <lv_theme_material_init+0xcb8>
    e632:	2000      	movs	r0, #0
    e634:	f7fd ffc0 	bl	c5b8 <lv_disp_get_dpi>
    e638:	fb00 8206 	mla	r2, r0, r6, r8
    e63c:	26a0      	movs	r6, #160	; 0xa0
    e63e:	fb92 f2f6 	sdiv	r2, r2, r6
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
    e642:	b212      	sxth	r2, r2
    e644:	e5cf      	b.n	e1e6 <lv_theme_material_init+0xcca>
    lv_style_int_t pad_small_value = lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(10) : LV_DPX(20);
    e646:	f7fd ffb7 	bl	c5b8 <lv_disp_get_dpi>
    e64a:	2614      	movs	r6, #20
    e64c:	e5de      	b.n	e20c <lv_theme_material_init+0xcf0>
    e64e:	2000      	movs	r0, #0
    e650:	f7fd ffb2 	bl	c5b8 <lv_disp_get_dpi>
    e654:	22a0      	movs	r2, #160	; 0xa0
    e656:	fb00 7606 	mla	r6, r0, r6, r7
    e65a:	fb96 f6f2 	sdiv	r6, r6, r2
    e65e:	b236      	sxth	r6, r6
    e660:	e5dc      	b.n	e21c <lv_theme_material_init+0xd00>
    lv_style_set_radius(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(4));
    e662:	2201      	movs	r2, #1
    e664:	e612      	b.n	e28c <lv_theme_material_init+0xd70>
    lv_style_set_pad_inner(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(10));
    e666:	2201      	movs	r2, #1
    e668:	e62c      	b.n	e2c4 <lv_theme_material_init+0xda8>
    lv_style_set_outline_width(&styles->cb_bg, LV_STATE_DEFAULT, OUTLINE_WIDTH);
    e66a:	2200      	movs	r2, #0
    e66c:	e65c      	b.n	e328 <lv_theme_material_init+0xe0c>
    e66e:	2201      	movs	r2, #1
    e670:	e65a      	b.n	e328 <lv_theme_material_init+0xe0c>
    lv_style_set_outline_pad(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(10));
    e672:	2201      	movs	r2, #1
    e674:	e673      	b.n	e35e <lv_theme_material_init+0xe42>
    lv_style_set_radius(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(4));
    e676:	2201      	movs	r2, #1
    e678:	e6a3      	b.n	e3c2 <lv_theme_material_init+0xea6>
    lv_style_set_pad_left(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
    e67a:	2201      	movs	r2, #1
    e67c:	e6e7      	b.n	e44e <lv_theme_material_init+0xf32>
    lv_style_set_pad_right(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
    e67e:	2201      	movs	r2, #1
    e680:	e701      	b.n	e486 <lv_theme_material_init+0xf6a>
    lv_style_set_pad_top(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
    e682:	2201      	movs	r2, #1
    e684:	e71b      	b.n	e4be <lv_theme_material_init+0xfa2>
    lv_style_set_pad_bottom(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
    e686:	2201      	movs	r2, #1
    e688:	e734      	b.n	e4f4 <lv_theme_material_init+0xfd8>
    e68a:	bf00      	nop
    e68c:	20025e80 	.word	0x20025e80
    e690:	000442b6 	.word	0x000442b6
    e694:	20025e84 	.word	0x20025e84
    e698:	0000d485 	.word	0x0000d485
    e69c:	2002a078 	.word	0x2002a078
    e6a0:	00586273 	.word	0x00586273

0000e6a4 <lv_btn_design>:
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return an element of `lv_design_res_t`
 */
static lv_design_res_t lv_btn_design(lv_obj_t * btn, const lv_area_t * clip_area, lv_design_mode_t mode)
{
    if(mode == LV_DESIGN_COVER_CHK) {
    e6a4:	2a02      	cmp	r2, #2
{
    e6a6:	b510      	push	{r4, lr}
    if(mode == LV_DESIGN_COVER_CHK) {
    e6a8:	d104      	bne.n	e6b4 <lv_btn_design+0x10>
    else if(mode == LV_DESIGN_DRAW_POST) {
        ancestor_design(btn, clip_area, mode);
    }

    return LV_DESIGN_RES_OK;
}
    e6aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return ancestor_design(btn, clip_area, mode);
    e6ae:	4b06      	ldr	r3, [pc, #24]	; (e6c8 <lv_btn_design+0x24>)
    e6b0:	681b      	ldr	r3, [r3, #0]
    e6b2:	4718      	bx	r3
    else if(mode == LV_DESIGN_DRAW_MAIN) {
    e6b4:	b91a      	cbnz	r2, e6be <lv_btn_design+0x1a>
        ancestor_design(btn, clip_area, mode);
    e6b6:	4b04      	ldr	r3, [pc, #16]	; (e6c8 <lv_btn_design+0x24>)
    e6b8:	681b      	ldr	r3, [r3, #0]
    e6ba:	4798      	blx	r3
    e6bc:	e001      	b.n	e6c2 <lv_btn_design+0x1e>
    else if(mode == LV_DESIGN_DRAW_POST) {
    e6be:	2a01      	cmp	r2, #1
    e6c0:	d0f9      	beq.n	e6b6 <lv_btn_design+0x12>
}
    e6c2:	2000      	movs	r0, #0
    e6c4:	bd10      	pop	{r4, pc}
    e6c6:	bf00      	nop
    e6c8:	20025eb0 	.word	0x20025eb0

0000e6cc <lv_btn_create>:
{
    e6cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e6ce:	4607      	mov	r7, r0
    e6d0:	460e      	mov	r6, r1
    btn = lv_cont_create(par, copy);
    e6d2:	f000 fa3f 	bl	eb54 <lv_cont_create>
    if(btn == NULL) return NULL;
    e6d6:	4604      	mov	r4, r0
    e6d8:	b1b0      	cbz	r0, e708 <lv_btn_create+0x3c>
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(btn);
    e6da:	4d23      	ldr	r5, [pc, #140]	; (e768 <lv_btn_create+0x9c>)
    e6dc:	682b      	ldr	r3, [r5, #0]
    e6de:	b913      	cbnz	r3, e6e6 <lv_btn_create+0x1a>
    e6e0:	f007 fd28 	bl	16134 <lv_obj_get_signal_cb>
    e6e4:	6028      	str	r0, [r5, #0]
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(btn);
    e6e6:	4d21      	ldr	r5, [pc, #132]	; (e76c <lv_btn_create+0xa0>)
    e6e8:	682b      	ldr	r3, [r5, #0]
    e6ea:	b91b      	cbnz	r3, e6f4 <lv_btn_create+0x28>
    e6ec:	4620      	mov	r0, r4
    e6ee:	f007 fd23 	bl	16138 <lv_obj_get_design_cb>
    e6f2:	6028      	str	r0, [r5, #0]
    lv_btn_ext_t * ext = lv_obj_allocate_ext_attr(btn, sizeof(lv_btn_ext_t));
    e6f4:	2103      	movs	r1, #3
    e6f6:	4620      	mov	r0, r4
    e6f8:	f007 f818 	bl	1572c <lv_obj_allocate_ext_attr>
    if(ext == NULL) {
    e6fc:	4605      	mov	r5, r0
    e6fe:	b928      	cbnz	r0, e70c <lv_btn_create+0x40>
        lv_obj_del(btn);
    e700:	4620      	mov	r0, r4
    e702:	f007 fa05 	bl	15b10 <lv_obj_del>
        return NULL;
    e706:	462c      	mov	r4, r5
}
    e708:	4620      	mov	r0, r4
    e70a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ext->checkable = 0;
    e70c:	7883      	ldrb	r3, [r0, #2]
    lv_obj_set_signal_cb(btn, lv_btn_signal);
    e70e:	4918      	ldr	r1, [pc, #96]	; (e770 <lv_btn_create+0xa4>)
    ext->checkable = 0;
    e710:	f36f 0300 	bfc	r3, #0, #1
    e714:	7083      	strb	r3, [r0, #2]
    lv_obj_set_signal_cb(btn, lv_btn_signal);
    e716:	4620      	mov	r0, r4
    e718:	f006 fffe 	bl	15718 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(btn, lv_btn_design);
    e71c:	4620      	mov	r0, r4
    e71e:	4915      	ldr	r1, [pc, #84]	; (e774 <lv_btn_create+0xa8>)
    e720:	f007 f802 	bl	15728 <lv_obj_set_design_cb>
    if(copy == NULL) {
    e724:	b996      	cbnz	r6, e74c <lv_btn_create+0x80>
        if(par) {
    e726:	b147      	cbz	r7, e73a <lv_btn_create+0x6e>
            lv_obj_set_size(btn, LV_DPI, LV_DPI / 3);
    e728:	2182      	movs	r1, #130	; 0x82
    e72a:	4620      	mov	r0, r4
    e72c:	222b      	movs	r2, #43	; 0x2b
    e72e:	f007 f935 	bl	1599c <lv_obj_set_size>
 * @param btn pointer to a button object
 * @param layout a layout from 'lv_cont_layout_t'
 */
static inline void lv_btn_set_layout(lv_obj_t * btn, lv_layout_t layout)
{
    lv_cont_set_layout(btn, layout);
    e732:	2101      	movs	r1, #1
    e734:	4620      	mov	r0, r4
    e736:	f00d f803 	bl	1b740 <lv_cont_set_layout>
        lv_obj_set_click(btn, true); /*Be sure the button is clickable*/
    e73a:	4620      	mov	r0, r4
    e73c:	2101      	movs	r1, #1
    e73e:	f006 ffc8 	bl	156d2 <lv_obj_set_click>
        lv_theme_apply(btn, LV_THEME_BTN);
    e742:	2103      	movs	r1, #3
    e744:	4620      	mov	r0, r4
    e746:	f7fe fe79 	bl	d43c <lv_theme_apply>
    e74a:	e7dd      	b.n	e708 <lv_btn_create+0x3c>
        lv_btn_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
    e74c:	4630      	mov	r0, r6
    e74e:	f007 fcf5 	bl	1613c <lv_obj_get_ext_attr>
        ext->checkable             = copy_ext->checkable;
    e752:	78ab      	ldrb	r3, [r5, #2]
    e754:	7882      	ldrb	r2, [r0, #2]
        lv_obj_refresh_style(btn, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    e756:	4620      	mov	r0, r4
        ext->checkable             = copy_ext->checkable;
    e758:	f362 0300 	bfi	r3, r2, #0, #1
        lv_obj_refresh_style(btn, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    e75c:	22ff      	movs	r2, #255	; 0xff
        ext->checkable             = copy_ext->checkable;
    e75e:	70ab      	strb	r3, [r5, #2]
        lv_obj_refresh_style(btn, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    e760:	4611      	mov	r1, r2
    e762:	f7fb fb09 	bl	9d78 <lv_obj_refresh_style>
    e766:	e7cf      	b.n	e708 <lv_btn_create+0x3c>
    e768:	20025eb4 	.word	0x20025eb4
    e76c:	20025eb0 	.word	0x20025eb0
    e770:	0000e779 	.word	0x0000e779
    e774:	0000e6a5 	.word	0x0000e6a5

0000e778 <lv_btn_signal>:
static lv_res_t lv_btn_signal(lv_obj_t * btn, lv_signal_t sign, void * param)
{
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(btn, sign, param);
    e778:	4b1e      	ldr	r3, [pc, #120]	; (e7f4 <lv_btn_signal+0x7c>)
{
    e77a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    res = ancestor_signal(btn, sign, param);
    e77e:	681b      	ldr	r3, [r3, #0]
{
    e780:	4605      	mov	r5, r0
    e782:	460f      	mov	r7, r1
    e784:	4616      	mov	r6, r2
    res = ancestor_signal(btn, sign, param);
    e786:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
    e788:	2801      	cmp	r0, #1
    res = ancestor_signal(btn, sign, param);
    e78a:	4604      	mov	r4, r0
    if(res != LV_RES_OK) return res;
    e78c:	d106      	bne.n	e79c <lv_btn_signal+0x24>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    e78e:	2f07      	cmp	r7, #7
    e790:	d108      	bne.n	e7a4 <lv_btn_signal+0x2c>
    e792:	4630      	mov	r0, r6
    e794:	4918      	ldr	r1, [pc, #96]	; (e7f8 <lv_btn_signal+0x80>)
    e796:	f007 fceb 	bl	16170 <lv_obj_handle_get_type_signal>
            else {
                lv_btn_set_state(btn, LV_BTN_STATE_CHECKED_RELEASED);
                toggled = 1;
            }

            res = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &toggled);
    e79a:	4604      	mov	r4, r0
        }
#endif
    }

    return res;
}
    e79c:	4620      	mov	r0, r4
    e79e:	b002      	add	sp, #8
    e7a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bool tgl           = lv_btn_get_checkable(btn);
    e7a4:	4628      	mov	r0, r5
    e7a6:	f00c ffbf 	bl	1b728 <lv_btn_get_checkable>
    if(sign == LV_SIGNAL_RELEASED) {
    e7aa:	2f0e      	cmp	r7, #14
    bool tgl           = lv_btn_get_checkable(btn);
    e7ac:	4680      	mov	r8, r0
    if(sign == LV_SIGNAL_RELEASED) {
    e7ae:	d1f5      	bne.n	e79c <lv_btn_signal+0x24>
        if(lv_indev_is_dragging(param) == false && tgl) {
    e7b0:	4630      	mov	r0, r6
    e7b2:	f006 ff23 	bl	155fc <lv_indev_is_dragging>
    e7b6:	4606      	mov	r6, r0
    e7b8:	2800      	cmp	r0, #0
    e7ba:	d1ef      	bne.n	e79c <lv_btn_signal+0x24>
    e7bc:	f1b8 0f00 	cmp.w	r8, #0
    e7c0:	d0ec      	beq.n	e79c <lv_btn_signal+0x24>
            if(lv_obj_get_state(btn, LV_BTN_PART_MAIN) & LV_STATE_CHECKED) {
    e7c2:	4601      	mov	r1, r0
            uint32_t toggled = 0;
    e7c4:	9001      	str	r0, [sp, #4]
            if(lv_obj_get_state(btn, LV_BTN_PART_MAIN) & LV_STATE_CHECKED) {
    e7c6:	4628      	mov	r0, r5
    e7c8:	f007 fa1e 	bl	15c08 <lv_obj_get_state>
    e7cc:	07c3      	lsls	r3, r0, #31
    e7ce:	d50a      	bpl.n	e7e6 <lv_btn_signal+0x6e>
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_CHECKED | LV_STATE_DISABLED);
    e7d0:	2131      	movs	r1, #49	; 0x31
    e7d2:	4628      	mov	r0, r5
    e7d4:	f008 f82a 	bl	1682c <lv_obj_clear_state>
                toggled = 0;
    e7d8:	9601      	str	r6, [sp, #4]
            res = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &toggled);
    e7da:	2110      	movs	r1, #16
    e7dc:	4628      	mov	r0, r5
    e7de:	aa01      	add	r2, sp, #4
    e7e0:	f006 ff8d 	bl	156fe <lv_event_send>
    e7e4:	e7d9      	b.n	e79a <lv_btn_signal+0x22>
                lv_btn_set_state(btn, LV_BTN_STATE_CHECKED_RELEASED);
    e7e6:	2103      	movs	r1, #3
    e7e8:	4628      	mov	r0, r5
    e7ea:	f00c ff70 	bl	1b6ce <lv_btn_set_state>
                toggled = 1;
    e7ee:	9401      	str	r4, [sp, #4]
    e7f0:	e7f3      	b.n	e7da <lv_btn_signal+0x62>
    e7f2:	bf00      	nop
    e7f4:	20025eb4 	.word	0x20025eb4
    e7f8:	000442ba 	.word	0x000442ba

0000e7fc <lv_cont_refr_autofit>:
/**
 * Handle auto fit. Set the size of the object to involve all children.
 * @param cont pointer to an object which size will be modified
 */
static void lv_cont_refr_autofit(lv_obj_t * cont)
{
    e7fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
    e800:	2101      	movs	r1, #1
{
    e802:	b089      	sub	sp, #36	; 0x24
    e804:	4604      	mov	r4, r0
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
    e806:	f007 f9f8 	bl	15bfa <lv_obj_is_protected>
    e80a:	2800      	cmp	r0, #0
    e80c:	f040 80fa 	bne.w	ea04 <lv_cont_refr_autofit+0x208>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
    e810:	4620      	mov	r0, r4
    e812:	f007 fc93 	bl	1613c <lv_obj_get_ext_attr>

    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
    e816:	7803      	ldrb	r3, [r0, #0]
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
    e818:	4606      	mov	r6, r0
    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
    e81a:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    e81e:	d103      	bne.n	e828 <lv_cont_refr_autofit+0x2c>
    e820:	7843      	ldrb	r3, [r0, #1]
    e822:	0719      	lsls	r1, r3, #28
    e824:	f000 80ee 	beq.w	ea04 <lv_cont_refr_autofit+0x208>

    lv_area_t tight_area;
    lv_area_t ori;
    lv_obj_t * child_i;

    lv_obj_t * par               = lv_obj_get_parent(cont);
    e828:	4620      	mov	r0, r4
    e82a:	f007 f903 	bl	15a34 <lv_obj_get_parent>
    e82e:	4607      	mov	r7, r0
    lv_area_t parent_area;
    lv_area_copy(&parent_area, &par->coords);
    e830:	f100 0110 	add.w	r1, r0, #16
    e834:	a804      	add	r0, sp, #16
    e836:	f00c ff7e 	bl	1b736 <lv_area_copy>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    e83a:	2212      	movs	r2, #18
    e83c:	2100      	movs	r1, #0
    e83e:	4638      	mov	r0, r7
    e840:	f7fa ffe2 	bl	9808 <_lv_obj_get_style_int>
    parent_area.x1 += lv_obj_get_style_pad_left(par, LV_OBJ_PART_MAIN);
    e844:	f8bd 3010 	ldrh.w	r3, [sp, #16]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    e848:	2213      	movs	r2, #19
    e84a:	4418      	add	r0, r3
    e84c:	2100      	movs	r1, #0
    e84e:	f8ad 0010 	strh.w	r0, [sp, #16]
    e852:	4638      	mov	r0, r7
    e854:	f7fa ffd8 	bl	9808 <_lv_obj_get_style_int>
    parent_area.x2 -= lv_obj_get_style_pad_right(par, LV_OBJ_PART_MAIN);
    e858:	f8bd 3014 	ldrh.w	r3, [sp, #20]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    e85c:	2210      	movs	r2, #16
    e85e:	1a1b      	subs	r3, r3, r0
    e860:	2100      	movs	r1, #0
    e862:	4638      	mov	r0, r7
    e864:	f8ad 3014 	strh.w	r3, [sp, #20]
    e868:	f7fa ffce 	bl	9808 <_lv_obj_get_style_int>
    parent_area.y1 += lv_obj_get_style_pad_top(par, LV_OBJ_PART_MAIN);
    e86c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    e870:	2211      	movs	r2, #17
    e872:	4418      	add	r0, r3
    e874:	2100      	movs	r1, #0
    e876:	f8ad 0012 	strh.w	r0, [sp, #18]
    e87a:	4638      	mov	r0, r7
    e87c:	f7fa ffc4 	bl	9808 <_lv_obj_get_style_int>
    parent_area.y2 -= lv_obj_get_style_pad_bottom(par, LV_OBJ_PART_MAIN);
    e880:	f8bd 3016 	ldrh.w	r3, [sp, #22]

    /*Search the side coordinates of the children*/
    lv_obj_get_coords(cont, &ori);
    e884:	a902      	add	r1, sp, #8
    parent_area.y2 -= lv_obj_get_style_pad_bottom(par, LV_OBJ_PART_MAIN);
    e886:	1a1b      	subs	r3, r3, r0
    lv_obj_get_coords(cont, &ori);
    e888:	4620      	mov	r0, r4
    parent_area.y2 -= lv_obj_get_style_pad_bottom(par, LV_OBJ_PART_MAIN);
    e88a:	f8ad 3016 	strh.w	r3, [sp, #22]
    lv_obj_get_coords(cont, &tight_area);

    bool has_children = _lv_ll_is_empty(&cont->child_ll) ? false : true;
    e88e:	f104 0804 	add.w	r8, r4, #4
    lv_obj_get_coords(cont, &ori);
    e892:	f007 f8f2 	bl	15a7a <lv_obj_get_coords>
    lv_obj_get_coords(cont, &tight_area);
    e896:	4669      	mov	r1, sp
    e898:	4620      	mov	r0, r4
    e89a:	f007 f8ee 	bl	15a7a <lv_obj_get_coords>
    bool has_children = _lv_ll_is_empty(&cont->child_ll) ? false : true;
    e89e:	4640      	mov	r0, r8
    e8a0:	f00c fd86 	bl	1b3b0 <_lv_ll_is_empty>
    e8a4:	f080 0901 	eor.w	r9, r0, #1

    if(has_children) {
    e8a8:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
    e8ac:	d032      	beq.n	e914 <lv_cont_refr_autofit+0x118>
        tight_area.x1 = LV_COORD_MAX;
        tight_area.y1 = LV_COORD_MAX;
        tight_area.x2 = LV_COORD_MIN;
    e8ae:	4aa7      	ldr	r2, [pc, #668]	; (eb4c <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xec>)
    e8b0:	4ba7      	ldr	r3, [pc, #668]	; (eb50 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xf0>)
        tight_area.y2 = LV_COORD_MIN;

        _LV_LL_READ(cont->child_ll, child_i) {
    e8b2:	4640      	mov	r0, r8
        tight_area.x2 = LV_COORD_MIN;
    e8b4:	e9cd 2300 	strd	r2, r3, [sp]
        _LV_LL_READ(cont->child_ll, child_i) {
    e8b8:	f00c fca7 	bl	1b20a <_lv_ll_get_head>
    e8bc:	4605      	mov	r5, r0
    e8be:	2800      	cmp	r0, #0
    e8c0:	f040 80a3 	bne.w	ea0a <lv_cont_refr_autofit+0x20e>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    e8c4:	4601      	mov	r1, r0
    e8c6:	2212      	movs	r2, #18
    e8c8:	4620      	mov	r0, r4
    e8ca:	f7fa ff9d 	bl	9808 <_lv_obj_get_style_int>
                lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(child_i, LV_OBJ_PART_MAIN);
                tight_area.y2 = LV_MATH_MAX(tight_area.y2, child_i->coords.y2 + mbottom);
            }
        }

        tight_area.x1 -= lv_obj_get_style_pad_left(cont, LV_CONT_PART_MAIN);
    e8ce:	f8bd 3000 	ldrh.w	r3, [sp]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    e8d2:	2213      	movs	r2, #19
    e8d4:	1a1b      	subs	r3, r3, r0
    e8d6:	4629      	mov	r1, r5
    e8d8:	4620      	mov	r0, r4
    e8da:	f8ad 3000 	strh.w	r3, [sp]
    e8de:	f7fa ff93 	bl	9808 <_lv_obj_get_style_int>
        tight_area.x2 += lv_obj_get_style_pad_right(cont, LV_CONT_PART_MAIN);
    e8e2:	f8bd 3004 	ldrh.w	r3, [sp, #4]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    e8e6:	2210      	movs	r2, #16
    e8e8:	4418      	add	r0, r3
    e8ea:	4629      	mov	r1, r5
    e8ec:	f8ad 0004 	strh.w	r0, [sp, #4]
    e8f0:	4620      	mov	r0, r4
    e8f2:	f7fa ff89 	bl	9808 <_lv_obj_get_style_int>
        tight_area.y1 -= lv_obj_get_style_pad_top(cont, LV_CONT_PART_MAIN);
    e8f6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    e8fa:	2211      	movs	r2, #17
    e8fc:	1a1b      	subs	r3, r3, r0
    e8fe:	4629      	mov	r1, r5
    e900:	4620      	mov	r0, r4
    e902:	f8ad 3002 	strh.w	r3, [sp, #2]
    e906:	f7fa ff7f 	bl	9808 <_lv_obj_get_style_int>
        tight_area.y2 += lv_obj_get_style_pad_bottom(cont, LV_CONT_PART_MAIN);
    e90a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    e90e:	4418      	add	r0, r3
    e910:	f8ad 0006 	strh.w	r0, [sp, #6]
    }

    lv_area_t new_area;
    lv_area_copy(&new_area, &ori);
    e914:	a902      	add	r1, sp, #8
    e916:	a806      	add	r0, sp, #24
    e918:	f00c ff0d 	bl	1b736 <lv_area_copy>

    switch(ext->fit_left) {
    e91c:	7833      	ldrb	r3, [r6, #0]
    e91e:	f3c3 1201 	ubfx	r2, r3, #4, #2
    e922:	2a02      	cmp	r2, #2
    e924:	f000 80cb 	beq.w	eabe <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5e>
    e928:	2a03      	cmp	r2, #3
    e92a:	f000 80cb 	beq.w	eac4 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x64>
    e92e:	2a01      	cmp	r2, #1
    e930:	d103      	bne.n	e93a <lv_cont_refr_autofit+0x13e>
        case LV_FIT_TIGHT:
            new_area.x1 = tight_area.x1;
    e932:	f8bd 2000 	ldrh.w	r2, [sp]
            break;
        case LV_FIT_PARENT:
            new_area.x1 = parent_area.x1;
            break;
        case LV_FIT_MAX:
            new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, parent_area.x1) : parent_area.x1;
    e936:	f8ad 2018 	strh.w	r2, [sp, #24]
            break;
        default:
            break;
    }

    switch(ext->fit_right) {
    e93a:	099b      	lsrs	r3, r3, #6
    e93c:	2b02      	cmp	r3, #2
    e93e:	f000 80cd 	beq.w	eadc <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7c>
    e942:	2b03      	cmp	r3, #3
    e944:	f000 80cd 	beq.w	eae2 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x82>
    e948:	2b01      	cmp	r3, #1
    e94a:	d103      	bne.n	e954 <lv_cont_refr_autofit+0x158>
        case LV_FIT_TIGHT:
            new_area.x2 = tight_area.x2;
    e94c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
            break;
        case LV_FIT_PARENT:
            new_area.x2 = parent_area.x2;
            break;
        case LV_FIT_MAX:
            new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, parent_area.x2) : parent_area.x2;
    e950:	f8ad 301c 	strh.w	r3, [sp, #28]
            break;
        default:
            break;
    }

    switch(ext->fit_top) {
    e954:	7873      	ldrb	r3, [r6, #1]
    e956:	f003 0203 	and.w	r2, r3, #3
    e95a:	2a02      	cmp	r2, #2
    e95c:	f000 80cd 	beq.w	eafa <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x9a>
    e960:	2a03      	cmp	r2, #3
    e962:	f000 80cd 	beq.w	eb00 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa0>
    e966:	2a01      	cmp	r2, #1
    e968:	d103      	bne.n	e972 <lv_cont_refr_autofit+0x176>
        case LV_FIT_TIGHT:
            new_area.y1 = tight_area.y1;
    e96a:	f8bd 2002 	ldrh.w	r2, [sp, #2]
            break;
        case LV_FIT_PARENT:
            new_area.y1 = parent_area.y1;
            break;
        case LV_FIT_MAX:
            new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, parent_area.y1) : parent_area.y1;
    e96e:	f8ad 201a 	strh.w	r2, [sp, #26]
            break;
        default:
            break;
    }

    switch(ext->fit_bottom) {
    e972:	f3c3 0381 	ubfx	r3, r3, #2, #2
    e976:	2b02      	cmp	r3, #2
    e978:	f000 80ce 	beq.w	eb18 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xb8>
    e97c:	2b03      	cmp	r3, #3
    e97e:	f000 80ce 	beq.w	eb1e <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xbe>
    e982:	2b01      	cmp	r3, #1
    e984:	d103      	bne.n	e98e <lv_cont_refr_autofit+0x192>
        case LV_FIT_TIGHT:
            new_area.y2 = tight_area.y2;
    e986:	f8bd 3006 	ldrh.w	r3, [sp, #6]
            break;
        case LV_FIT_PARENT:
            new_area.y2 = parent_area.y2;
            break;
        case LV_FIT_MAX:
            new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, parent_area.y2) : parent_area.y2;
    e98a:	f8ad 301e 	strh.w	r3, [sp, #30]
        default:
            break;
    }

    /*Do nothing if the coordinates are not changed*/
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
    e98e:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
    e992:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
    e996:	429a      	cmp	r2, r3
    e998:	d111      	bne.n	e9be <lv_cont_refr_autofit+0x1c2>
    e99a:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
    e99e:	f9bd 301a 	ldrsh.w	r3, [sp, #26]
    e9a2:	429a      	cmp	r2, r3
    e9a4:	d10b      	bne.n	e9be <lv_cont_refr_autofit+0x1c2>
    e9a6:	f9b4 2014 	ldrsh.w	r2, [r4, #20]
    e9aa:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
    e9ae:	429a      	cmp	r2, r3
    e9b0:	d105      	bne.n	e9be <lv_cont_refr_autofit+0x1c2>
    e9b2:	f9b4 2016 	ldrsh.w	r2, [r4, #22]
    e9b6:	f9bd 301e 	ldrsh.w	r3, [sp, #30]
    e9ba:	429a      	cmp	r2, r3
    e9bc:	d022      	beq.n	ea04 <lv_cont_refr_autofit+0x208>
       cont->coords.y2 != new_area.y2) {

        lv_obj_invalidate(cont);
    e9be:	4620      	mov	r0, r4
    e9c0:	f006 ff2e 	bl	15820 <lv_obj_invalidate>
        lv_area_copy(&cont->coords, &new_area);
    e9c4:	a906      	add	r1, sp, #24
    e9c6:	f104 0010 	add.w	r0, r4, #16
    e9ca:	f00c feb4 	bl	1b736 <lv_area_copy>
        lv_obj_invalidate(cont);
    e9ce:	4620      	mov	r0, r4
    e9d0:	f006 ff26 	bl	15820 <lv_obj_invalidate>

        /*Notify the object about its new coordinates*/
        cont->signal_cb(cont, LV_SIGNAL_COORD_CHG, &ori);
    e9d4:	2102      	movs	r1, #2
    e9d6:	69e3      	ldr	r3, [r4, #28]
    e9d8:	aa02      	add	r2, sp, #8
    e9da:	4620      	mov	r0, r4
    e9dc:	4798      	blx	r3

        /*Inform the parent about the new coordinates*/
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, cont);
    e9de:	4622      	mov	r2, r4
    e9e0:	2101      	movs	r1, #1
    e9e2:	4638      	mov	r0, r7
    e9e4:	69fb      	ldr	r3, [r7, #28]
    e9e6:	4798      	blx	r3

        if(lv_obj_get_auto_realign(cont)) {
    e9e8:	4620      	mov	r0, r4
    e9ea:	f007 f87d 	bl	15ae8 <lv_obj_get_auto_realign>
    e9ee:	b110      	cbz	r0, e9f6 <lv_cont_refr_autofit+0x1fa>
            lv_obj_realign(cont);
    e9f0:	4620      	mov	r0, r4
    e9f2:	f006 fe66 	bl	156c2 <lv_obj_realign>
        }

        /*Tell the children the parent's size has changed*/
        _LV_LL_READ(cont->child_ll, child_i) {
    e9f6:	4640      	mov	r0, r8
    e9f8:	f00c fc07 	bl	1b20a <_lv_ll_get_head>
    e9fc:	4604      	mov	r4, r0
    e9fe:	2800      	cmp	r0, #0
    ea00:	f040 8099 	bne.w	eb36 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xd6>
            child_i->signal_cb(child_i, LV_SIGNAL_PARENT_SIZE_CHG, &ori);
        }
    }
}
    ea04:	b009      	add	sp, #36	; 0x24
    ea06:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            if(lv_obj_get_hidden(child_i) != false) continue;
    ea0a:	4628      	mov	r0, r5
    ea0c:	f007 f8d0 	bl	15bb0 <lv_obj_get_hidden>
    ea10:	4601      	mov	r1, r0
    ea12:	2800      	cmp	r0, #0
    ea14:	d14e      	bne.n	eab4 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x54>
            if(ext->fit_left != LV_FIT_PARENT) {
    ea16:	7833      	ldrb	r3, [r6, #0]
    ea18:	f003 0330 	and.w	r3, r3, #48	; 0x30
    ea1c:	2b20      	cmp	r3, #32
    ea1e:	d00d      	beq.n	ea3c <lv_cont_refr_autofit+0x240>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
    ea20:	2217      	movs	r2, #23
    ea22:	4628      	mov	r0, r5
    ea24:	f7fa fef0 	bl	9808 <_lv_obj_get_style_int>
                tight_area.x1 = LV_MATH_MIN(tight_area.x1, child_i->coords.x1 - mleft);
    ea28:	f9b5 3010 	ldrsh.w	r3, [r5, #16]
    ea2c:	1a1b      	subs	r3, r3, r0
    ea2e:	f9bd 0000 	ldrsh.w	r0, [sp]
    ea32:	4283      	cmp	r3, r0
    ea34:	bfa8      	it	ge
    ea36:	4603      	movge	r3, r0
    ea38:	f8ad 3000 	strh.w	r3, [sp]
            if(ext->fit_right != LV_FIT_PARENT) {
    ea3c:	7833      	ldrb	r3, [r6, #0]
    ea3e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    ea42:	2b80      	cmp	r3, #128	; 0x80
    ea44:	d00e      	beq.n	ea64 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
    ea46:	2218      	movs	r2, #24
    ea48:	2100      	movs	r1, #0
    ea4a:	4628      	mov	r0, r5
    ea4c:	f7fa fedc 	bl	9808 <_lv_obj_get_style_int>
                tight_area.x2 = LV_MATH_MAX(tight_area.x2, child_i->coords.x2 + mright);
    ea50:	f9b5 3014 	ldrsh.w	r3, [r5, #20]
    ea54:	4403      	add	r3, r0
    ea56:	f9bd 0004 	ldrsh.w	r0, [sp, #4]
    ea5a:	4283      	cmp	r3, r0
    ea5c:	bfb8      	it	lt
    ea5e:	4603      	movlt	r3, r0
    ea60:	f8ad 3004 	strh.w	r3, [sp, #4]
            if(ext->fit_top != LV_FIT_PARENT) {
    ea64:	7873      	ldrb	r3, [r6, #1]
    ea66:	f003 0303 	and.w	r3, r3, #3
    ea6a:	2b02      	cmp	r3, #2
    ea6c:	d00e      	beq.n	ea8c <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2c>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
    ea6e:	2215      	movs	r2, #21
    ea70:	2100      	movs	r1, #0
    ea72:	4628      	mov	r0, r5
    ea74:	f7fa fec8 	bl	9808 <_lv_obj_get_style_int>
                tight_area.y1 = LV_MATH_MIN(tight_area.y1, child_i->coords.y1 - mtop);
    ea78:	f9b5 3012 	ldrsh.w	r3, [r5, #18]
    ea7c:	1a1b      	subs	r3, r3, r0
    ea7e:	f9bd 0002 	ldrsh.w	r0, [sp, #2]
    ea82:	4283      	cmp	r3, r0
    ea84:	bfa8      	it	ge
    ea86:	4603      	movge	r3, r0
    ea88:	f8ad 3002 	strh.w	r3, [sp, #2]
            if(ext->fit_bottom != LV_FIT_PARENT) {
    ea8c:	7873      	ldrb	r3, [r6, #1]
    ea8e:	f003 030c 	and.w	r3, r3, #12
    ea92:	2b08      	cmp	r3, #8
    ea94:	d00e      	beq.n	eab4 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x54>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
    ea96:	2216      	movs	r2, #22
    ea98:	2100      	movs	r1, #0
    ea9a:	4628      	mov	r0, r5
    ea9c:	f7fa feb4 	bl	9808 <_lv_obj_get_style_int>
                tight_area.y2 = LV_MATH_MAX(tight_area.y2, child_i->coords.y2 + mbottom);
    eaa0:	f9b5 3016 	ldrsh.w	r3, [r5, #22]
    eaa4:	4403      	add	r3, r0
    eaa6:	f9bd 0006 	ldrsh.w	r0, [sp, #6]
    eaaa:	4283      	cmp	r3, r0
    eaac:	bfb8      	it	lt
    eaae:	4603      	movlt	r3, r0
    eab0:	f8ad 3006 	strh.w	r3, [sp, #6]
        _LV_LL_READ(cont->child_ll, child_i) {
    eab4:	4629      	mov	r1, r5
    eab6:	4640      	mov	r0, r8
    eab8:	f00c fbad 	bl	1b216 <_lv_ll_get_next>
    eabc:	e6fe      	b.n	e8bc <lv_cont_refr_autofit+0xc0>
            new_area.x1 = parent_area.x1;
    eabe:	f8bd 2010 	ldrh.w	r2, [sp, #16]
    eac2:	e738      	b.n	e936 <lv_cont_refr_autofit+0x13a>
            new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, parent_area.x1) : parent_area.x1;
    eac4:	f9bd 2010 	ldrsh.w	r2, [sp, #16]
    eac8:	f1b9 0f00 	cmp.w	r9, #0
    eacc:	f43f af33 	beq.w	e936 <lv_cont_refr_autofit+0x13a>
    ead0:	f9bd 1000 	ldrsh.w	r1, [sp]
    ead4:	428a      	cmp	r2, r1
    ead6:	bfa8      	it	ge
    ead8:	460a      	movge	r2, r1
    eada:	e72c      	b.n	e936 <lv_cont_refr_autofit+0x13a>
            new_area.x2 = parent_area.x2;
    eadc:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    eae0:	e736      	b.n	e950 <lv_cont_refr_autofit+0x154>
            new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, parent_area.x2) : parent_area.x2;
    eae2:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    eae6:	f1b9 0f00 	cmp.w	r9, #0
    eaea:	f43f af31 	beq.w	e950 <lv_cont_refr_autofit+0x154>
    eaee:	f9bd 2004 	ldrsh.w	r2, [sp, #4]
    eaf2:	4293      	cmp	r3, r2
    eaf4:	bfb8      	it	lt
    eaf6:	4613      	movlt	r3, r2
    eaf8:	e72a      	b.n	e950 <lv_cont_refr_autofit+0x154>
            new_area.y1 = parent_area.y1;
    eafa:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    eafe:	e736      	b.n	e96e <lv_cont_refr_autofit+0x172>
            new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, parent_area.y1) : parent_area.y1;
    eb00:	f9bd 2012 	ldrsh.w	r2, [sp, #18]
    eb04:	f1b9 0f00 	cmp.w	r9, #0
    eb08:	f43f af31 	beq.w	e96e <lv_cont_refr_autofit+0x172>
    eb0c:	f9bd 1002 	ldrsh.w	r1, [sp, #2]
    eb10:	428a      	cmp	r2, r1
    eb12:	bfa8      	it	ge
    eb14:	460a      	movge	r2, r1
    eb16:	e72a      	b.n	e96e <lv_cont_refr_autofit+0x172>
            new_area.y2 = parent_area.y2;
    eb18:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    eb1c:	e735      	b.n	e98a <lv_cont_refr_autofit+0x18e>
            new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, parent_area.y2) : parent_area.y2;
    eb1e:	f9bd 3016 	ldrsh.w	r3, [sp, #22]
    eb22:	f1b9 0f00 	cmp.w	r9, #0
    eb26:	f43f af30 	beq.w	e98a <lv_cont_refr_autofit+0x18e>
    eb2a:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
    eb2e:	4293      	cmp	r3, r2
    eb30:	bfb8      	it	lt
    eb32:	4613      	movlt	r3, r2
    eb34:	e729      	b.n	e98a <lv_cont_refr_autofit+0x18e>
            child_i->signal_cb(child_i, LV_SIGNAL_PARENT_SIZE_CHG, &ori);
    eb36:	2103      	movs	r1, #3
    eb38:	4620      	mov	r0, r4
    eb3a:	69e3      	ldr	r3, [r4, #28]
    eb3c:	aa02      	add	r2, sp, #8
    eb3e:	4798      	blx	r3
        _LV_LL_READ(cont->child_ll, child_i) {
    eb40:	4621      	mov	r1, r4
    eb42:	4640      	mov	r0, r8
    eb44:	f00c fb67 	bl	1b216 <_lv_ll_get_next>
    eb48:	e758      	b.n	e9fc <lv_cont_refr_autofit+0x200>
    eb4a:	bf00      	nop
    eb4c:	7c187c18 	.word	0x7c187c18
    eb50:	83e883e8 	.word	0x83e883e8

0000eb54 <lv_cont_create>:
{
    eb54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    eb56:	4607      	mov	r7, r0
    eb58:	460e      	mov	r6, r1
    lv_obj_t * cont = lv_obj_create(par, copy);
    eb5a:	f7fa fc37 	bl	93cc <lv_obj_create>
    if(cont == NULL) return NULL;
    eb5e:	4605      	mov	r5, r0
    eb60:	b1c8      	cbz	r0, eb96 <lv_cont_create+0x42>
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(cont);
    eb62:	4c2a      	ldr	r4, [pc, #168]	; (ec0c <lv_cont_create+0xb8>)
    eb64:	6823      	ldr	r3, [r4, #0]
    eb66:	b913      	cbnz	r3, eb6e <lv_cont_create+0x1a>
    eb68:	f007 fae4 	bl	16134 <lv_obj_get_signal_cb>
    eb6c:	6020      	str	r0, [r4, #0]
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(cont);
    eb6e:	4c28      	ldr	r4, [pc, #160]	; (ec10 <lv_cont_create+0xbc>)
    eb70:	6823      	ldr	r3, [r4, #0]
    eb72:	b91b      	cbnz	r3, eb7c <lv_cont_create+0x28>
    eb74:	4628      	mov	r0, r5
    eb76:	f007 fadf 	bl	16138 <lv_obj_get_design_cb>
    eb7a:	6020      	str	r0, [r4, #0]
    lv_obj_allocate_ext_attr(cont, sizeof(lv_cont_ext_t));
    eb7c:	2102      	movs	r1, #2
    eb7e:	4628      	mov	r0, r5
    eb80:	f006 fdd4 	bl	1572c <lv_obj_allocate_ext_attr>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
    eb84:	4628      	mov	r0, r5
    eb86:	f007 fad9 	bl	1613c <lv_obj_get_ext_attr>
    if(ext == NULL) {
    eb8a:	4604      	mov	r4, r0
    eb8c:	b928      	cbnz	r0, eb9a <lv_cont_create+0x46>
        lv_obj_del(cont);
    eb8e:	4628      	mov	r0, r5
    eb90:	f006 ffbe 	bl	15b10 <lv_obj_del>
        return NULL;
    eb94:	4625      	mov	r5, r4
}
    eb96:	4628      	mov	r0, r5
    eb98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ext->layout     = LV_LAYOUT_OFF;
    eb9a:	2300      	movs	r3, #0
    eb9c:	7003      	strb	r3, [r0, #0]
    ext->fit_top    = LV_FIT_NONE;
    eb9e:	7843      	ldrb	r3, [r0, #1]
    lv_obj_set_signal_cb(cont, lv_cont_signal);
    eba0:	491c      	ldr	r1, [pc, #112]	; (ec14 <lv_cont_create+0xc0>)
    ext->fit_top    = LV_FIT_NONE;
    eba2:	f023 030f 	bic.w	r3, r3, #15
    eba6:	7043      	strb	r3, [r0, #1]
    lv_obj_set_signal_cb(cont, lv_cont_signal);
    eba8:	4628      	mov	r0, r5
    ebaa:	f006 fdb5 	bl	15718 <lv_obj_set_signal_cb>
    if(copy == NULL) {
    ebae:	b936      	cbnz	r6, ebbe <lv_cont_create+0x6a>
        if(par != NULL) {
    ebb0:	2f00      	cmp	r7, #0
    ebb2:	d0f0      	beq.n	eb96 <lv_cont_create+0x42>
            lv_theme_apply(cont, LV_THEME_CONT);
    ebb4:	2105      	movs	r1, #5
    ebb6:	4628      	mov	r0, r5
    ebb8:	f7fe fc40 	bl	d43c <lv_theme_apply>
    ebbc:	e7eb      	b.n	eb96 <lv_cont_create+0x42>
        lv_cont_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
    ebbe:	4630      	mov	r0, r6
    ebc0:	f007 fabc 	bl	1613c <lv_obj_get_ext_attr>
        ext->fit_left            = copy_ext->fit_left;
    ebc4:	7803      	ldrb	r3, [r0, #0]
    ebc6:	7822      	ldrb	r2, [r4, #0]
    ebc8:	f3c3 1301 	ubfx	r3, r3, #4, #2
    ebcc:	f363 1205 	bfi	r2, r3, #4, #2
    ebd0:	7022      	strb	r2, [r4, #0]
        ext->fit_right           = copy_ext->fit_right;
    ebd2:	7803      	ldrb	r3, [r0, #0]
    ebd4:	b2d2      	uxtb	r2, r2
    ebd6:	099b      	lsrs	r3, r3, #6
    ebd8:	f363 1287 	bfi	r2, r3, #6, #2
    ebdc:	7022      	strb	r2, [r4, #0]
        ext->fit_top             = copy_ext->fit_top;
    ebde:	7842      	ldrb	r2, [r0, #1]
    ebe0:	7863      	ldrb	r3, [r4, #1]
    ebe2:	f362 0301 	bfi	r3, r2, #0, #2
    ebe6:	7063      	strb	r3, [r4, #1]
        ext->fit_bottom          = copy_ext->fit_bottom;
    ebe8:	7843      	ldrb	r3, [r0, #1]
    ebea:	7862      	ldrb	r2, [r4, #1]
    ebec:	f3c3 0381 	ubfx	r3, r3, #2, #2
    ebf0:	f363 0283 	bfi	r2, r3, #2, #2
    ebf4:	7062      	strb	r2, [r4, #1]
        ext->layout              = copy_ext->layout;
    ebf6:	7802      	ldrb	r2, [r0, #0]
    ebf8:	7823      	ldrb	r3, [r4, #0]
        lv_obj_refresh_style(cont, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    ebfa:	4628      	mov	r0, r5
        ext->layout              = copy_ext->layout;
    ebfc:	f362 0303 	bfi	r3, r2, #0, #4
        lv_obj_refresh_style(cont, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    ec00:	22ff      	movs	r2, #255	; 0xff
        ext->layout              = copy_ext->layout;
    ec02:	7023      	strb	r3, [r4, #0]
        lv_obj_refresh_style(cont, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    ec04:	4611      	mov	r1, r2
    ec06:	f7fb f8b7 	bl	9d78 <lv_obj_refresh_style>
    ec0a:	e7c4      	b.n	eb96 <lv_cont_create+0x42>
    ec0c:	20025ebc 	.word	0x20025ebc
    ec10:	20025eb8 	.word	0x20025eb8
    ec14:	0000ec19 	.word	0x0000ec19

0000ec18 <lv_cont_signal>:
    if(sign == LV_SIGNAL_GET_STYLE) {
    ec18:	2908      	cmp	r1, #8
{
    ec1a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ec1e:	4605      	mov	r5, r0
    ec20:	460e      	mov	r6, r1
    ec22:	4614      	mov	r4, r2
    if(sign == LV_SIGNAL_GET_STYLE) {
    ec24:	d114      	bne.n	ec50 <lv_cont_signal+0x38>
    switch(type) {
    ec26:	7813      	ldrb	r3, [r2, #0]
    ec28:	b14b      	cbz	r3, ec3e <lv_cont_signal+0x26>
        info->result = lv_cont_get_style(cont, info->part);
    ec2a:	2300      	movs	r3, #0
    ec2c:	6053      	str	r3, [r2, #4]
        else return ancestor_signal(cont, sign, param);
    ec2e:	4b22      	ldr	r3, [pc, #136]	; (ecb8 <lv_cont_signal+0xa0>)
    ec30:	4622      	mov	r2, r4
    ec32:	4628      	mov	r0, r5
}
    ec34:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        else return ancestor_signal(cont, sign, param);
    ec38:	2108      	movs	r1, #8
    ec3a:	681b      	ldr	r3, [r3, #0]
    ec3c:	4718      	bx	r3
            style_dsc_p = &cont->style_list;
    ec3e:	f100 0328 	add.w	r3, r0, #40	; 0x28
        info->result = lv_cont_get_style(cont, info->part);
    ec42:	6053      	str	r3, [r2, #4]
        if(info->result != NULL) return LV_RES_OK;
    ec44:	2b00      	cmp	r3, #0
    ec46:	d0f2      	beq.n	ec2e <lv_cont_signal+0x16>
    ec48:	2701      	movs	r7, #1
}
    ec4a:	4638      	mov	r0, r7
    ec4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    res = ancestor_signal(cont, sign, param);
    ec50:	4b19      	ldr	r3, [pc, #100]	; (ecb8 <lv_cont_signal+0xa0>)
    ec52:	681b      	ldr	r3, [r3, #0]
    ec54:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
    ec56:	2801      	cmp	r0, #1
    res = ancestor_signal(cont, sign, param);
    ec58:	4607      	mov	r7, r0
    if(res != LV_RES_OK) return res;
    ec5a:	d1f6      	bne.n	ec4a <lv_cont_signal+0x32>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    ec5c:	2e07      	cmp	r6, #7
    ec5e:	d105      	bne.n	ec6c <lv_cont_signal+0x54>
    ec60:	4620      	mov	r0, r4
}
    ec62:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    ec66:	4915      	ldr	r1, [pc, #84]	; (ecbc <lv_cont_signal+0xa4>)
    ec68:	f007 ba82 	b.w	16170 <lv_obj_handle_get_type_signal>
    if(sign == LV_SIGNAL_STYLE_CHG) { /*Recalculate the padding if the style changed*/
    ec6c:	2e04      	cmp	r6, #4
    ec6e:	d106      	bne.n	ec7e <lv_cont_signal+0x66>
        lv_cont_refr_layout(cont);
    ec70:	4628      	mov	r0, r5
    ec72:	f00c fd81 	bl	1b778 <lv_cont_refr_layout>
        lv_cont_refr_autofit(cont);
    ec76:	4628      	mov	r0, r5
    ec78:	f7ff fdc0 	bl	e7fc <lv_cont_refr_autofit>
    ec7c:	e7e5      	b.n	ec4a <lv_cont_signal+0x32>
    else if(sign == LV_SIGNAL_CHILD_CHG) {
    ec7e:	2e01      	cmp	r6, #1
    ec80:	d0f6      	beq.n	ec70 <lv_cont_signal+0x58>
    else if(sign == LV_SIGNAL_COORD_CHG) {
    ec82:	2e02      	cmp	r6, #2
    ec84:	d114      	bne.n	ecb0 <lv_cont_signal+0x98>
        if(lv_obj_get_width(cont) != lv_area_get_width(param) || lv_obj_get_height(cont) != lv_area_get_height(param)) {
    ec86:	4628      	mov	r0, r5
    ec88:	f006 ff22 	bl	15ad0 <lv_obj_get_width>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    ec8c:	88a3      	ldrh	r3, [r4, #4]
    ec8e:	8822      	ldrh	r2, [r4, #0]
    ec90:	3301      	adds	r3, #1
    ec92:	1a9b      	subs	r3, r3, r2
    ec94:	b21b      	sxth	r3, r3
    ec96:	4298      	cmp	r0, r3
    ec98:	d1ea      	bne.n	ec70 <lv_cont_signal+0x58>
    ec9a:	4628      	mov	r0, r5
    ec9c:	f006 ff1e 	bl	15adc <lv_obj_get_height>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    eca0:	88e3      	ldrh	r3, [r4, #6]
    eca2:	8862      	ldrh	r2, [r4, #2]
    eca4:	3301      	adds	r3, #1
    eca6:	1a9b      	subs	r3, r3, r2
    eca8:	b21b      	sxth	r3, r3
    ecaa:	4298      	cmp	r0, r3
    ecac:	d1e0      	bne.n	ec70 <lv_cont_signal+0x58>
    ecae:	e7cb      	b.n	ec48 <lv_cont_signal+0x30>
    else if(sign == LV_SIGNAL_PARENT_SIZE_CHG) {
    ecb0:	2e03      	cmp	r6, #3
    ecb2:	d1c9      	bne.n	ec48 <lv_cont_signal+0x30>
    ecb4:	e7df      	b.n	ec76 <lv_cont_signal+0x5e>
    ecb6:	bf00      	nop
    ecb8:	20025ebc 	.word	0x20025ebc
    ecbc:	000442c1 	.word	0x000442c1

0000ecc0 <lv_img_create>:
 * @param par pointer to an object, it will be the parent of the new button
 * @param copy pointer to a image object, if not NULL then the new object will be copied from it
 * @return pointer to the created image
 */
lv_obj_t * lv_img_create(lv_obj_t * par, const lv_obj_t * copy)
{
    ecc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ecc4:	4607      	mov	r7, r0
    ecc6:	460e      	mov	r6, r1
    LV_LOG_TRACE("image create started");

    /*Create a basic object*/
    lv_obj_t * img = lv_obj_create(par, copy);
    ecc8:	f7fa fb80 	bl	93cc <lv_obj_create>
    LV_ASSERT_MEM(img);
    if(img == NULL) return NULL;
    eccc:	4605      	mov	r5, r0
    ecce:	b188      	cbz	r0, ecf4 <lv_img_create+0x34>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(img);
    ecd0:	4c3b      	ldr	r4, [pc, #236]	; (edc0 <lv_img_create+0x100>)
    ecd2:	6823      	ldr	r3, [r4, #0]
    ecd4:	b913      	cbnz	r3, ecdc <lv_img_create+0x1c>
    ecd6:	f007 fa2d 	bl	16134 <lv_obj_get_signal_cb>
    ecda:	6020      	str	r0, [r4, #0]

    /*Extend the basic object to image object*/
    lv_img_ext_t * ext = lv_obj_allocate_ext_attr(img, sizeof(lv_img_ext_t));
    ecdc:	2118      	movs	r1, #24
    ecde:	4628      	mov	r0, r5
    ece0:	f006 fd24 	bl	1572c <lv_obj_allocate_ext_attr>
    LV_ASSERT_MEM(ext);
    if(ext == NULL) {
    ece4:	f04f 0800 	mov.w	r8, #0
    ece8:	4604      	mov	r4, r0
    ecea:	b930      	cbnz	r0, ecfa <lv_img_create+0x3a>
        lv_obj_del(img);
    ecec:	4628      	mov	r0, r5
    ecee:	f006 ff0f 	bl	15b10 <lv_obj_del>
        return NULL;
    ecf2:	4625      	mov	r5, r4
    }

    LV_LOG_INFO("image created");

    return img;
}
    ecf4:	4628      	mov	r0, r5
    ecf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ext->src_type  = LV_IMG_SRC_UNKNOWN;
    ecfa:	7d03      	ldrb	r3, [r0, #20]
    ext->src       = NULL;
    ecfc:	f8c0 8000 	str.w	r8, [r0]
    ext->src_type  = LV_IMG_SRC_UNKNOWN;
    ed00:	f003 0304 	and.w	r3, r3, #4
    ed04:	f043 0303 	orr.w	r3, r3, #3
    ed08:	7503      	strb	r3, [r0, #20]
    ext->w         = lv_obj_get_width(img);
    ed0a:	4628      	mov	r0, r5
    ed0c:	f006 fee0 	bl	15ad0 <lv_obj_get_width>
    ed10:	8120      	strh	r0, [r4, #8]
    ext->h         = lv_obj_get_height(img);
    ed12:	4628      	mov	r0, r5
    ed14:	f006 fee2 	bl	15adc <lv_obj_get_height>
    ext->pivot.y = 0;
    ed18:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    ed1c:	6123      	str	r3, [r4, #16]
    ext->auto_size = 1;
    ed1e:	8aa3      	ldrh	r3, [r4, #20]
    lv_obj_set_signal_cb(img, lv_img_signal);
    ed20:	4928      	ldr	r1, [pc, #160]	; (edc4 <lv_img_create+0x104>)
    ext->auto_size = 1;
    ed22:	f443 7382 	orr.w	r3, r3, #260	; 0x104
    ext->h         = lv_obj_get_height(img);
    ed26:	8160      	strh	r0, [r4, #10]
    ext->offset.x  = 0;
    ed28:	f8c4 8004 	str.w	r8, [r4, #4]
    lv_obj_set_signal_cb(img, lv_img_signal);
    ed2c:	4628      	mov	r0, r5
    ext->angle = 0;
    ed2e:	f8c4 800c 	str.w	r8, [r4, #12]
    ext->auto_size = 1;
    ed32:	82a3      	strh	r3, [r4, #20]
    lv_obj_set_signal_cb(img, lv_img_signal);
    ed34:	f006 fcf0 	bl	15718 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(img, lv_img_design);
    ed38:	4628      	mov	r0, r5
    ed3a:	4923      	ldr	r1, [pc, #140]	; (edc8 <lv_img_create+0x108>)
    ed3c:	f006 fcf4 	bl	15728 <lv_obj_set_design_cb>
    if(copy == NULL) {
    ed40:	b9a6      	cbnz	r6, ed6c <lv_img_create+0xac>
        lv_theme_apply(img, LV_THEME_IMAGE);
    ed42:	2106      	movs	r1, #6
    ed44:	4628      	mov	r0, r5
    ed46:	f7fe fb79 	bl	d43c <lv_theme_apply>
        lv_obj_set_click(img, false);
    ed4a:	4631      	mov	r1, r6
    ed4c:	4628      	mov	r0, r5
    ed4e:	f006 fcc0 	bl	156d2 <lv_obj_set_click>
        lv_obj_set_adv_hittest(img, true); /*Images have fast hit-testing*/
    ed52:	2101      	movs	r1, #1
    ed54:	4628      	mov	r0, r5
    ed56:	f006 fcb5 	bl	156c4 <lv_obj_set_adv_hittest>
        if(par != NULL) {
    ed5a:	7d23      	ldrb	r3, [r4, #20]
    ed5c:	b11f      	cbz	r7, ed66 <lv_img_create+0xa6>
            ext->auto_size = 1;
    ed5e:	f043 0304 	orr.w	r3, r3, #4
            ext->auto_size = 0;
    ed62:	7523      	strb	r3, [r4, #20]
    ed64:	e7c6      	b.n	ecf4 <lv_img_create+0x34>
    ed66:	f367 0382 	bfi	r3, r7, #2, #1
    ed6a:	e7fa      	b.n	ed62 <lv_img_create+0xa2>
        lv_img_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
    ed6c:	4630      	mov	r0, r6
    ed6e:	f007 f9e5 	bl	1613c <lv_obj_get_ext_attr>
        ext->auto_size     = copy_ext->auto_size;
    ed72:	7d03      	ldrb	r3, [r0, #20]
    ed74:	7d22      	ldrb	r2, [r4, #20]
    ed76:	f3c3 0380 	ubfx	r3, r3, #2, #1
    ed7a:	f363 0282 	bfi	r2, r3, #2, #1
    ed7e:	7522      	strb	r2, [r4, #20]
        ext->zoom          = copy_ext->zoom;
    ed80:	8a43      	ldrh	r3, [r0, #18]
        ext->antialias     = copy_ext->antialias;
    ed82:	7d42      	ldrb	r2, [r0, #21]
        ext->zoom          = copy_ext->zoom;
    ed84:	8263      	strh	r3, [r4, #18]
        ext->angle         = copy_ext->angle;
    ed86:	8983      	ldrh	r3, [r0, #12]
    ed88:	81a3      	strh	r3, [r4, #12]
        ext->antialias     = copy_ext->antialias;
    ed8a:	7d63      	ldrb	r3, [r4, #21]
    ed8c:	f362 0300 	bfi	r3, r2, #0, #1
    ed90:	7563      	strb	r3, [r4, #21]
        ext->offset.x     = copy_ext->offset.x;
    ed92:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
        lv_img_set_src(img, copy_ext->src);
    ed96:	6801      	ldr	r1, [r0, #0]
        ext->offset.x     = copy_ext->offset.x;
    ed98:	80a3      	strh	r3, [r4, #4]
        ext->offset.y     = copy_ext->offset.y;
    ed9a:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
    ed9e:	80e3      	strh	r3, [r4, #6]
        ext->pivot.x     = copy_ext->pivot.x;
    eda0:	f9b0 300e 	ldrsh.w	r3, [r0, #14]
    eda4:	81e3      	strh	r3, [r4, #14]
        ext->pivot.y     = copy_ext->pivot.y;
    eda6:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
        lv_img_set_src(img, copy_ext->src);
    edaa:	4628      	mov	r0, r5
        ext->pivot.y     = copy_ext->pivot.y;
    edac:	8223      	strh	r3, [r4, #16]
        lv_img_set_src(img, copy_ext->src);
    edae:	f00d fab5 	bl	1c31c <lv_img_set_src>
        lv_obj_refresh_style(img, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    edb2:	22ff      	movs	r2, #255	; 0xff
    edb4:	4628      	mov	r0, r5
    edb6:	4611      	mov	r1, r2
    edb8:	f7fa ffde 	bl	9d78 <lv_obj_refresh_style>
    edbc:	e79a      	b.n	ecf4 <lv_img_create+0x34>
    edbe:	bf00      	nop
    edc0:	20025ec0 	.word	0x20025ec0
    edc4:	0000edcd 	.word	0x0000edcd
    edc8:	0001bdbb 	.word	0x0001bdbb

0000edcc <lv_img_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_img_signal(lv_obj_t * img, lv_signal_t sign, void * param)
{
    edcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    lv_res_t res;
    if(sign == LV_SIGNAL_GET_STYLE) {
    edd0:	2908      	cmp	r1, #8
{
    edd2:	4604      	mov	r4, r0
    edd4:	4688      	mov	r8, r1
    edd6:	4617      	mov	r7, r2
    edd8:	b087      	sub	sp, #28
    if(sign == LV_SIGNAL_GET_STYLE) {
    edda:	d115      	bne.n	ee08 <lv_img_signal+0x3c>


static lv_style_list_t * lv_img_get_style(lv_obj_t * img, uint8_t type)
{
    lv_style_list_t * style_dsc_p;
    switch(type) {
    eddc:	7813      	ldrb	r3, [r2, #0]
    edde:	b14b      	cbz	r3, edf4 <lv_img_signal+0x28>
        info->result = lv_img_get_style(img, info->part);
    ede0:	2300      	movs	r3, #0
    ede2:	6053      	str	r3, [r2, #4]
        else return ancestor_signal(img, sign, param);
    ede4:	4b9e      	ldr	r3, [pc, #632]	; (f060 <lv_img_signal+0x294>)
    ede6:	463a      	mov	r2, r7
    ede8:	2108      	movs	r1, #8
    edea:	4620      	mov	r0, r4
    edec:	681b      	ldr	r3, [r3, #0]
    edee:	4798      	blx	r3
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    edf0:	4606      	mov	r6, r0
    edf2:	e005      	b.n	ee00 <lv_img_signal+0x34>
        case LV_IMG_PART_MAIN:
            style_dsc_p = &img->style_list;
    edf4:	f100 0328 	add.w	r3, r0, #40	; 0x28
        info->result = lv_img_get_style(img, info->part);
    edf8:	6053      	str	r3, [r2, #4]
        if(info->result != NULL) return LV_RES_OK;
    edfa:	2b00      	cmp	r3, #0
    edfc:	d0f2      	beq.n	ede4 <lv_img_signal+0x18>
    edfe:	2601      	movs	r6, #1
}
    ee00:	4630      	mov	r0, r6
    ee02:	b007      	add	sp, #28
    ee04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    res = ancestor_signal(img, sign, param);
    ee08:	4b95      	ldr	r3, [pc, #596]	; (f060 <lv_img_signal+0x294>)
    ee0a:	681b      	ldr	r3, [r3, #0]
    ee0c:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
    ee0e:	2801      	cmp	r0, #1
    res = ancestor_signal(img, sign, param);
    ee10:	4606      	mov	r6, r0
    if(res != LV_RES_OK) return res;
    ee12:	d1f5      	bne.n	ee00 <lv_img_signal+0x34>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    ee14:	f1b8 0f07 	cmp.w	r8, #7
    ee18:	d104      	bne.n	ee24 <lv_img_signal+0x58>
    ee1a:	4638      	mov	r0, r7
    ee1c:	4991      	ldr	r1, [pc, #580]	; (f064 <lv_img_signal+0x298>)
    ee1e:	f007 f9a7 	bl	16170 <lv_obj_handle_get_type_signal>
    ee22:	e7e5      	b.n	edf0 <lv_img_signal+0x24>
    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
    ee24:	4620      	mov	r0, r4
    ee26:	f007 f989 	bl	1613c <lv_obj_get_ext_attr>
    ee2a:	4605      	mov	r5, r0
    if(sign == LV_SIGNAL_CLEANUP) {
    ee2c:	f1b8 0f00 	cmp.w	r8, #0
    ee30:	d10f      	bne.n	ee52 <lv_img_signal+0x86>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
    ee32:	7d03      	ldrb	r3, [r0, #20]
    ee34:	f003 0303 	and.w	r3, r3, #3
    ee38:	3b01      	subs	r3, #1
    ee3a:	2b01      	cmp	r3, #1
    ee3c:	d8df      	bhi.n	edfe <lv_img_signal+0x32>
            lv_mem_free(ext->src);
    ee3e:	6800      	ldr	r0, [r0, #0]
    ee40:	f7fd fe3e 	bl	cac0 <lv_mem_free>
            ext->src_type = LV_IMG_SRC_UNKNOWN;
    ee44:	7d2b      	ldrb	r3, [r5, #20]
            ext->src      = NULL;
    ee46:	f8c5 8000 	str.w	r8, [r5]
            ext->src_type = LV_IMG_SRC_UNKNOWN;
    ee4a:	f043 0303 	orr.w	r3, r3, #3
    ee4e:	752b      	strb	r3, [r5, #20]
    ee50:	e7d6      	b.n	ee00 <lv_img_signal+0x34>
    else if(sign == LV_SIGNAL_STYLE_CHG) {
    ee52:	f1b8 0f04 	cmp.w	r8, #4
    ee56:	d109      	bne.n	ee6c <lv_img_signal+0xa0>
        if(ext->src_type == LV_IMG_SRC_SYMBOL) {
    ee58:	7d03      	ldrb	r3, [r0, #20]
    ee5a:	f003 0303 	and.w	r3, r3, #3
    ee5e:	2b02      	cmp	r3, #2
    ee60:	d1cd      	bne.n	edfe <lv_img_signal+0x32>
            lv_img_set_src(img, ext->src);
    ee62:	6801      	ldr	r1, [r0, #0]
    ee64:	4620      	mov	r0, r4
    ee66:	f00d fa59 	bl	1c31c <lv_img_set_src>
    ee6a:	e7c9      	b.n	ee00 <lv_img_signal+0x34>
    else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
    ee6c:	f1b8 0f06 	cmp.w	r8, #6
    ee70:	d179      	bne.n	ef66 <lv_img_signal+0x19a>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
    ee72:	2207      	movs	r2, #7
    ee74:	2100      	movs	r1, #0
    ee76:	4620      	mov	r0, r4
    ee78:	f7fa fcc6 	bl	9808 <_lv_obj_get_style_int>
        transf_zoom = (transf_zoom * ext->zoom) >> 8;
    ee7c:	f8b5 9012 	ldrh.w	r9, [r5, #18]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
    ee80:	4642      	mov	r2, r8
    ee82:	fb00 f909 	mul.w	r9, r0, r9
    ee86:	2100      	movs	r1, #0
    ee88:	4620      	mov	r0, r4
    ee8a:	f7fa fcbd 	bl	9808 <_lv_obj_get_style_int>
        transf_angle += ext->angle;
    ee8e:	f8b5 a00c 	ldrh.w	sl, [r5, #12]
        transf_zoom = (transf_zoom * ext->zoom) >> 8;
    ee92:	ea4f 2929 	mov.w	r9, r9, asr #8
        transf_angle += ext->angle;
    ee96:	4482      	add	sl, r0
    ee98:	fa0f fa8a 	sxth.w	sl, sl
        if(transf_angle || transf_zoom != LV_IMG_ZOOM_NONE) {
    ee9c:	f1ba 0f00 	cmp.w	sl, #0
    eea0:	d104      	bne.n	eeac <lv_img_signal+0xe0>
    eea2:	fa0f f389 	sxth.w	r3, r9
    eea6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    eeaa:	d033      	beq.n	ef14 <lv_img_signal+0x148>
            lv_coord_t w = lv_obj_get_width(img);
    eeac:	4620      	mov	r0, r4
    eeae:	f006 fe0f 	bl	15ad0 <lv_obj_get_width>
    eeb2:	4680      	mov	r8, r0
            lv_coord_t h = lv_obj_get_height(img);
    eeb4:	4620      	mov	r0, r4
    eeb6:	f006 fe11 	bl	15adc <lv_obj_get_height>
    eeba:	4607      	mov	r7, r0
            _lv_img_buf_get_transformed_area(&a, w, h, transf_angle, transf_zoom, &ext->pivot);
    eebc:	350e      	adds	r5, #14
    eebe:	fa1f f089 	uxth.w	r0, r9
    eec2:	463a      	mov	r2, r7
    eec4:	4641      	mov	r1, r8
    eec6:	4653      	mov	r3, sl
    eec8:	9000      	str	r0, [sp, #0]
    eeca:	9501      	str	r5, [sp, #4]
    eecc:	a804      	add	r0, sp, #16
    eece:	f00b fd35 	bl	1a93c <_lv_img_buf_get_transformed_area>
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori - a.x1);
    eed2:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
    eed6:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori - a.y1);
    eeda:	f9bd 1012 	ldrsh.w	r1, [sp, #18]
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori - a.x1);
    eede:	1ad3      	subs	r3, r2, r3
    eee0:	4293      	cmp	r3, r2
    eee2:	bfb8      	it	lt
    eee4:	4613      	movlt	r3, r2
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori - a.y1);
    eee6:	1a51      	subs	r1, r2, r1
    eee8:	b21b      	sxth	r3, r3
    eeea:	428b      	cmp	r3, r1
    eeec:	bfb8      	it	lt
    eeee:	460b      	movlt	r3, r1
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori + a.x2 - w);
    eef0:	f9bd 1014 	ldrsh.w	r1, [sp, #20]
    eef4:	b21b      	sxth	r3, r3
    eef6:	4411      	add	r1, r2
    eef8:	eba1 0808 	sub.w	r8, r1, r8
    eefc:	4543      	cmp	r3, r8
    eefe:	bfb8      	it	lt
    ef00:	4643      	movlt	r3, r8
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori + a.y2 - h);
    ef02:	f9bd 0016 	ldrsh.w	r0, [sp, #22]
    ef06:	b21b      	sxth	r3, r3
    ef08:	4410      	add	r0, r2
    ef0a:	1bc7      	subs	r7, r0, r7
    ef0c:	42bb      	cmp	r3, r7
    ef0e:	bfb8      	it	lt
    ef10:	463b      	movlt	r3, r7
    ef12:	8623      	strh	r3, [r4, #48]	; 0x30
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    ef14:	2212      	movs	r2, #18
    ef16:	2100      	movs	r1, #0
    ef18:	4620      	mov	r0, r4
    ef1a:	f7fa fc75 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    ef1e:	2213      	movs	r2, #19
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    ef20:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    ef22:	2100      	movs	r1, #0
    ef24:	4620      	mov	r0, r4
    ef26:	f7fa fc6f 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    ef2a:	2210      	movs	r2, #16
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    ef2c:	4605      	mov	r5, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    ef2e:	2100      	movs	r1, #0
    ef30:	4620      	mov	r0, r4
    ef32:	f7fa fc69 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    ef36:	2211      	movs	r2, #17
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    ef38:	4680      	mov	r8, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    ef3a:	2100      	movs	r1, #0
    ef3c:	4620      	mov	r0, r4
    ef3e:	f7fa fc63 	bl	9808 <_lv_obj_get_style_int>
        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, right);
    ef42:	42bd      	cmp	r5, r7
    ef44:	bfb8      	it	lt
    ef46:	463d      	movlt	r5, r7
    ef48:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
    ef4c:	b22d      	sxth	r5, r5
        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, top);
    ef4e:	42aa      	cmp	r2, r5
    ef50:	bfb8      	it	lt
    ef52:	462a      	movlt	r2, r5
    ef54:	4542      	cmp	r2, r8
    ef56:	bfb8      	it	lt
    ef58:	4642      	movlt	r2, r8
        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, bottom);
    ef5a:	b213      	sxth	r3, r2
    ef5c:	4283      	cmp	r3, r0
    ef5e:	bfb8      	it	lt
    ef60:	4603      	movlt	r3, r0
    ef62:	8623      	strh	r3, [r4, #48]	; 0x30
    ef64:	e74c      	b.n	ee00 <lv_img_signal+0x34>
    else if(sign == LV_SIGNAL_HIT_TEST) {
    ef66:	f1b8 0f0a 	cmp.w	r8, #10
    ef6a:	f47f af48 	bne.w	edfe <lv_img_signal+0x32>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
    ef6e:	2207      	movs	r2, #7
    ef70:	2100      	movs	r1, #0
    ef72:	4620      	mov	r0, r4
    ef74:	f7fa fc48 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
    ef78:	2206      	movs	r2, #6
    ef7a:	2100      	movs	r1, #0
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
    ef7c:	4683      	mov	fp, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
    ef7e:	4620      	mov	r0, r4
        zoom = (zoom * ext->zoom) >> 8;
    ef80:	f8b5 9012 	ldrh.w	r9, [r5, #18]
    ef84:	f7fa fc40 	bl	9808 <_lv_obj_get_style_int>
        if(ext->w == lv_obj_get_width(img) && ext->h == lv_obj_get_height(img) &&
    ef88:	f9b5 3008 	ldrsh.w	r3, [r5, #8]
    ef8c:	4680      	mov	r8, r0
    ef8e:	4620      	mov	r0, r4
    ef90:	9303      	str	r3, [sp, #12]
        angle += ext->angle;
    ef92:	f8b5 a00c 	ldrh.w	sl, [r5, #12]
        if(ext->w == lv_obj_get_width(img) && ext->h == lv_obj_get_height(img) &&
    ef96:	f006 fd9b 	bl	15ad0 <lv_obj_get_width>
    ef9a:	9b03      	ldr	r3, [sp, #12]
    ef9c:	4283      	cmp	r3, r0
    ef9e:	d15a      	bne.n	f056 <lv_img_signal+0x28a>
    efa0:	f9b5 300a 	ldrsh.w	r3, [r5, #10]
    efa4:	4620      	mov	r0, r4
    efa6:	9303      	str	r3, [sp, #12]
    efa8:	f006 fd98 	bl	15adc <lv_obj_get_height>
    efac:	9b03      	ldr	r3, [sp, #12]
    efae:	4283      	cmp	r3, r0
    efb0:	d151      	bne.n	f056 <lv_img_signal+0x28a>
        zoom = (zoom * ext->zoom) >> 8;
    efb2:	fb09 f00b 	mul.w	r0, r9, fp
    efb6:	ea4f 2920 	mov.w	r9, r0, asr #8
        if(ext->w == lv_obj_get_width(img) && ext->h == lv_obj_get_height(img) &&
    efba:	f340 200f 	sbfx	r0, r0, #8, #16
        angle += ext->angle;
    efbe:	44d0      	add	r8, sl
        if(ext->w == lv_obj_get_width(img) && ext->h == lv_obj_get_height(img) &&
    efc0:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
        angle += ext->angle;
    efc4:	fa0f f888 	sxth.w	r8, r8
        if(ext->w == lv_obj_get_width(img) && ext->h == lv_obj_get_height(img) &&
    efc8:	d114      	bne.n	eff4 <lv_img_signal+0x228>
           (zoom != LV_IMG_ZOOM_NONE || angle != 0 || ext->pivot.x != ext->w / 2 || ext->pivot.y != ext->h / 2)) {
    efca:	f1b8 0f00 	cmp.w	r8, #0
    efce:	d111      	bne.n	eff4 <lv_img_signal+0x228>
    efd0:	f9b5 3008 	ldrsh.w	r3, [r5, #8]
    efd4:	f9b5 200e 	ldrsh.w	r2, [r5, #14]
    efd8:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    efdc:	ebb2 0f63 	cmp.w	r2, r3, asr #1
    efe0:	d108      	bne.n	eff4 <lv_img_signal+0x228>
    efe2:	f9b5 300a 	ldrsh.w	r3, [r5, #10]
    efe6:	f9b5 2010 	ldrsh.w	r2, [r5, #16]
    efea:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    efee:	ebb2 0f63 	cmp.w	r2, r3, asr #1
    eff2:	d030      	beq.n	f056 <lv_img_signal+0x28a>
            lv_coord_t w = lv_obj_get_width(img);
    eff4:	4620      	mov	r0, r4
    eff6:	f006 fd6b 	bl	15ad0 <lv_obj_get_width>
    effa:	4682      	mov	sl, r0
            lv_coord_t h = lv_obj_get_height(img);
    effc:	4620      	mov	r0, r4
    effe:	f006 fd6d 	bl	15adc <lv_obj_get_height>
            _lv_img_buf_get_transformed_area(&coords, w, h, angle, zoom, &ext->pivot);
    f002:	350e      	adds	r5, #14
    f004:	fa1f f389 	uxth.w	r3, r9
            lv_coord_t h = lv_obj_get_height(img);
    f008:	4602      	mov	r2, r0
            _lv_img_buf_get_transformed_area(&coords, w, h, angle, zoom, &ext->pivot);
    f00a:	4651      	mov	r1, sl
    f00c:	9300      	str	r3, [sp, #0]
    f00e:	a804      	add	r0, sp, #16
    f010:	4643      	mov	r3, r8
    f012:	9501      	str	r5, [sp, #4]
    f014:	f00b fc92 	bl	1a93c <_lv_img_buf_get_transformed_area>
            coords.x1 += img->coords.x1;
    f018:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
    f01c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
            coords.y1 += img->coords.y1;
    f020:	f8bd 1012 	ldrh.w	r1, [sp, #18]
            coords.x1 += img->coords.x1;
    f024:	4413      	add	r3, r2
    f026:	f8ad 3010 	strh.w	r3, [sp, #16]
            coords.y1 += img->coords.y1;
    f02a:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
            info->result = _lv_area_is_point_on(&coords, info->point, 0);
    f02e:	a804      	add	r0, sp, #16
            coords.y1 += img->coords.y1;
    f030:	4419      	add	r1, r3
    f032:	f8ad 1012 	strh.w	r1, [sp, #18]
            coords.x2 += img->coords.x1;
    f036:	f8bd 1014 	ldrh.w	r1, [sp, #20]
    f03a:	440a      	add	r2, r1
    f03c:	f8ad 2014 	strh.w	r2, [sp, #20]
            coords.y2 += img->coords.y1;
    f040:	f8bd 2016 	ldrh.w	r2, [sp, #22]
            info->result = _lv_area_is_point_on(&coords, info->point, 0);
    f044:	6839      	ldr	r1, [r7, #0]
            coords.y2 += img->coords.y1;
    f046:	4413      	add	r3, r2
            info->result = _lv_area_is_point_on(&coords, info->point, 0);
    f048:	2200      	movs	r2, #0
            coords.y2 += img->coords.y1;
    f04a:	f8ad 3016 	strh.w	r3, [sp, #22]
            info->result = _lv_area_is_point_on(&coords, info->point, 0);
    f04e:	f00b fe72 	bl	1ad36 <_lv_area_is_point_on>
            info->result = lv_obj_is_point_on_coords(img, info->point);
    f052:	7138      	strb	r0, [r7, #4]
    f054:	e6d4      	b.n	ee00 <lv_img_signal+0x34>
    f056:	4620      	mov	r0, r4
    f058:	6839      	ldr	r1, [r7, #0]
    f05a:	f007 f871 	bl	16140 <lv_obj_is_point_on_coords>
    f05e:	e7f8      	b.n	f052 <lv_img_signal+0x286>
    f060:	20025ec0 	.word	0x20025ec0
    f064:	000442c9 	.word	0x000442c9

0000f068 <lv_label_revert_dots>:

    lv_obj_invalidate(label);
}

static void lv_label_revert_dots(lv_obj_t * label)
{
    f068:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f06a:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f06c:	f007 f866 	bl	1613c <lv_obj_get_ext_attr>
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
    f070:	7c83      	ldrb	r3, [r0, #18]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f072:	4604      	mov	r4, r0
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
    f074:	f003 0307 	and.w	r3, r3, #7
    f078:	2b02      	cmp	r3, #2
    f07a:	d12a      	bne.n	f0d2 <lv_label_revert_dots+0x6a>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
    f07c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    f080:	6881      	ldr	r1, [r0, #8]
    f082:	4299      	cmp	r1, r3
    f084:	d025      	beq.n	f0d2 <lv_label_revert_dots+0x6a>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
    uint32_t byte_i   = _lv_txt_encoded_get_byte_id(ext->text, letter_i);
    f086:	4b14      	ldr	r3, [pc, #80]	; (f0d8 <lv_label_revert_dots+0x70>)
    f088:	3903      	subs	r1, #3
    f08a:	681b      	ldr	r3, [r3, #0]
    f08c:	6800      	ldr	r0, [r0, #0]
    f08e:	4798      	blx	r3
    f090:	4607      	mov	r7, r0
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * label)
{
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f092:	4628      	mov	r0, r5
    f094:	f007 f852 	bl	1613c <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc) {
    f098:	7cc2      	ldrb	r2, [r0, #19]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f09a:	4603      	mov	r3, r0
    if(ext->dot_tmp_alloc) {
    f09c:	07d2      	lsls	r2, r2, #31
    while(ext->text[byte_i + i] != '\0') {
    f09e:	f04f 0200 	mov.w	r2, #0
        return ext->dot.tmp_ptr;
    f0a2:	bf4c      	ite	mi
    f0a4:	6843      	ldrmi	r3, [r0, #4]
    }
    else {
        return ext->dot.tmp;
    f0a6:	3304      	addpl	r3, #4
    while(ext->text[byte_i + i] != '\0') {
    f0a8:	6826      	ldr	r6, [r4, #0]
    f0aa:	fa57 f182 	uxtab	r1, r7, r2
    f0ae:	f816 e001 	ldrb.w	lr, [r6, r1]
    f0b2:	b2d0      	uxtb	r0, r2
    f0b4:	5c18      	ldrb	r0, [r3, r0]
    f0b6:	eb06 0c01 	add.w	ip, r6, r1
    f0ba:	3201      	adds	r2, #1
    f0bc:	f1be 0f00 	cmp.w	lr, #0
    f0c0:	d108      	bne.n	f0d4 <lv_label_revert_dots+0x6c>
    ext->text[byte_i + i] = dot_tmp[i];
    f0c2:	f88c 0000 	strb.w	r0, [ip]
    lv_label_dot_tmp_free(label);
    f0c6:	4628      	mov	r0, r5
    f0c8:	f00d f9e2 	bl	1c490 <lv_label_dot_tmp_free>
    ext->dot_end = LV_LABEL_DOT_END_INV;
    f0cc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    f0d0:	60a3      	str	r3, [r4, #8]
}
    f0d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ext->text[byte_i + i] = dot_tmp[i];
    f0d4:	5470      	strb	r0, [r6, r1]
        i++;
    f0d6:	e7e7      	b.n	f0a8 <lv_label_revert_dots+0x40>
    f0d8:	200004bc 	.word	0x200004bc

0000f0dc <lv_label_get_letter_on>:
{
    f0dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    pos.x = pos_in->x - lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
    f0e0:	f9b1 3000 	ldrsh.w	r3, [r1]
{
    f0e4:	b08f      	sub	sp, #60	; 0x3c
    f0e6:	460c      	mov	r4, r1
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    f0e8:	2212      	movs	r2, #18
    f0ea:	2100      	movs	r1, #0
    f0ec:	4606      	mov	r6, r0
    pos.x = pos_in->x - lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
    f0ee:	9305      	str	r3, [sp, #20]
    f0f0:	f7fa fb8a 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    f0f4:	2210      	movs	r2, #16
    f0f6:	2100      	movs	r1, #0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    f0f8:	9008      	str	r0, [sp, #32]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    f0fa:	4630      	mov	r0, r6
    pos.y = pos_in->y - lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN);
    f0fc:	f9b4 4002 	ldrsh.w	r4, [r4, #2]
    f100:	f7fa fb82 	bl	9808 <_lv_obj_get_style_int>
    f104:	1a24      	subs	r4, r4, r0
    f106:	b223      	sxth	r3, r4
    get_txt_coords(label, &txt_coords);
    f108:	a90c      	add	r1, sp, #48	; 0x30
    f10a:	4630      	mov	r0, r6
    pos.y = pos_in->y - lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN);
    f10c:	9306      	str	r3, [sp, #24]
    get_txt_coords(label, &txt_coords);
    f10e:	f00d fa11 	bl	1c534 <get_txt_coords>
    const char * txt         = lv_label_get_text(label);
    f112:	4630      	mov	r0, r6
    f114:	f00d fa4d 	bl	1c5b2 <lv_label_get_text>
    f118:	4607      	mov	r7, r0
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
    f11a:	4630      	mov	r0, r6
    f11c:	f007 f80e 	bl	1613c <lv_obj_get_ext_attr>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    f120:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
    f124:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
    f128:	3301      	adds	r3, #1
    f12a:	1a9b      	subs	r3, r3, r2
    f12c:	b21b      	sxth	r3, r3
    f12e:	4605      	mov	r5, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
    f130:	f248 028e 	movw	r2, #32910	; 0x808e
    f134:	2100      	movs	r1, #0
    f136:	4630      	mov	r0, r6
    f138:	9307      	str	r3, [sp, #28]
    f13a:	f7fa fdbb 	bl	9cb4 <_lv_obj_get_style_ptr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
    f13e:	f248 0281 	movw	r2, #32897	; 0x8081
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
    f142:	4682      	mov	sl, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
    f144:	2100      	movs	r1, #0
    f146:	4630      	mov	r0, r6
    f148:	f7fa fb5e 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
    f14c:	f248 0280 	movw	r2, #32896	; 0x8080
    f150:	2100      	movs	r1, #0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
    f152:	4604      	mov	r4, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
    f154:	4630      	mov	r0, r6
    f156:	f7fa fb57 	bl	9808 <_lv_obj_get_style_int>
    lv_coord_t letter_height    = lv_font_get_line_height(font);
    f15a:	f9ba 3008 	ldrsh.w	r3, [sl, #8]
    f15e:	9003      	str	r0, [sp, #12]
    f160:	9304      	str	r3, [sp, #16]
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    f162:	7cab      	ldrb	r3, [r5, #18]
    lv_label_align_t align = lv_label_get_align(label);
    f164:	4630      	mov	r0, r6
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    f166:	f3c3 1580 	ubfx	r5, r3, #6, #1
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    f16a:	061a      	lsls	r2, r3, #24
    f16c:	bf48      	it	mi
    f16e:	f045 0502 	orrmi.w	r5, r5, #2
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
    f172:	075b      	lsls	r3, r3, #29
    f174:	bf08      	it	eq
    f176:	f045 0510 	orreq.w	r5, r5, #16
    lv_label_align_t align = lv_label_get_align(label);
    f17a:	f00d fa26 	bl	1c5ca <lv_label_get_align>
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
    f17e:	2801      	cmp	r0, #1
    lv_label_align_t align = lv_label_get_align(label);
    f180:	4681      	mov	r9, r0
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
    f182:	d108      	bne.n	f196 <lv_label_get_letter_on+0xba>
    f184:	f045 0504 	orr.w	r5, r5, #4
{
    f188:	f04f 0b00 	mov.w	fp, #0
        y += letter_height + line_space;
    f18c:	9b04      	ldr	r3, [sp, #16]
{
    f18e:	465e      	mov	r6, fp
        y += letter_height + line_space;
    f190:	4423      	add	r3, r4
    f192:	9309      	str	r3, [sp, #36]	; 0x24
    f194:	e07b      	b.n	f28e <lv_label_get_letter_on+0x1b2>
    if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
    f196:	2802      	cmp	r0, #2
    f198:	d1f6      	bne.n	f188 <lv_label_get_letter_on+0xac>
    f19a:	f045 0508 	orr.w	r5, r5, #8
    f19e:	e7f3      	b.n	f188 <lv_label_get_letter_on+0xac>
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
    f1a0:	9b07      	ldr	r3, [sp, #28]
    f1a2:	9a03      	ldr	r2, [sp, #12]
    f1a4:	4651      	mov	r1, sl
    f1a6:	4640      	mov	r0, r8
    f1a8:	9500      	str	r5, [sp, #0]
    f1aa:	f7fd ff2f 	bl	d00c <_lv_txt_get_next_line>
        if(pos.y <= y + letter_height) {
    f1ae:	9b04      	ldr	r3, [sp, #16]
    f1b0:	9a06      	ldr	r2, [sp, #24]
    f1b2:	445b      	add	r3, fp
    f1b4:	429a      	cmp	r2, r3
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
    f1b6:	eb06 0400 	add.w	r4, r6, r0
        if(pos.y <= y + letter_height) {
    f1ba:	dc63      	bgt.n	f284 <lv_label_get_letter_on+0x1a8>
            letter = _lv_txt_encoded_prev(txt, &tmp);
    f1bc:	4b50      	ldr	r3, [pc, #320]	; (f300 <lv_label_get_letter_on+0x224>)
    f1be:	4638      	mov	r0, r7
    f1c0:	681b      	ldr	r3, [r3, #0]
            uint32_t tmp = new_line_start;
    f1c2:	940b      	str	r4, [sp, #44]	; 0x2c
            letter = _lv_txt_encoded_prev(txt, &tmp);
    f1c4:	a90b      	add	r1, sp, #44	; 0x2c
    f1c6:	4798      	blx	r3
            if(letter != '\n' && txt[new_line_start] == '\0') new_line_start++;
    f1c8:	280a      	cmp	r0, #10
    f1ca:	d002      	beq.n	f1d2 <lv_label_get_letter_on+0xf6>
    f1cc:	5d3b      	ldrb	r3, [r7, r4]
    f1ce:	b903      	cbnz	r3, f1d2 <lv_label_get_letter_on+0xf6>
    f1d0:	3401      	adds	r4, #1
    if(align == LV_LABEL_ALIGN_CENTER) {
    f1d2:	f1b9 0f01 	cmp.w	r9, #1
    f1d6:	d161      	bne.n	f29c <lv_label_get_letter_on+0x1c0>
        line_w = _lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);
    f1d8:	4652      	mov	r2, sl
    f1da:	9b03      	ldr	r3, [sp, #12]
    f1dc:	4640      	mov	r0, r8
    f1de:	9500      	str	r5, [sp, #0]
    f1e0:	1ba1      	subs	r1, r4, r6
    f1e2:	f7fd fec1 	bl	cf68 <_lv_txt_get_width>
    f1e6:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
    f1ea:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
    f1ee:	3301      	adds	r3, #1
    f1f0:	1a9b      	subs	r3, r3, r2
        x += lv_area_get_width(&txt_coords) / 2 - line_w / 2;
    f1f2:	f3c3 32c0 	ubfx	r2, r3, #15, #1
    f1f6:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    f1fa:	fa02 f283 	sxtah	r2, r2, r3
    f1fe:	1043      	asrs	r3, r0, #1
    f200:	ebc3 0362 	rsb	r3, r3, r2, asr #1
        x += lv_area_get_width(&txt_coords) - line_w;
    f204:	fa0f f983 	sxth.w	r9, r3
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
    f208:	2200      	movs	r2, #0
    f20a:	f88d 202b 	strb.w	r2, [sp, #43]	; 0x2b
    uint32_t i = 0;
    f20e:	920b      	str	r2, [sp, #44]	; 0x2c
    if(new_line_start > 0) {
    f210:	b354      	cbz	r4, f268 <lv_label_get_letter_on+0x18c>
    pos.x = pos_in->x - lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
    f212:	9b05      	ldr	r3, [sp, #20]
    f214:	9908      	ldr	r1, [sp, #32]
            uint32_t letter = _lv_txt_encoded_next(bidi_txt, &i);
    f216:	f8df b0f0 	ldr.w	fp, [pc, #240]	; f308 <lv_label_get_letter_on+0x22c>
    pos.x = pos_in->x - lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
    f21a:	1a58      	subs	r0, r3, r1
    f21c:	b203      	sxth	r3, r0
    uint32_t i_act = i;
    f21e:	e9cd 2304 	strd	r2, r3, [sp, #16]
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    f222:	f005 0301 	and.w	r3, r5, #1
    f226:	9306      	str	r3, [sp, #24]
        while(i + line_start < new_line_start) {
    f228:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f22a:	4432      	add	r2, r6
    f22c:	42a2      	cmp	r2, r4
    f22e:	d21b      	bcs.n	f268 <lv_label_get_letter_on+0x18c>
            uint32_t letter = _lv_txt_encoded_next(bidi_txt, &i);
    f230:	f8db 2000 	ldr.w	r2, [fp]
    f234:	a90b      	add	r1, sp, #44	; 0x2c
    f236:	4640      	mov	r0, r8
    f238:	4790      	blx	r2
    f23a:	4605      	mov	r5, r0
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
    f23c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    f23e:	f8db 2000 	ldr.w	r2, [fp]
    f242:	2100      	movs	r1, #0
    f244:	4440      	add	r0, r8
    f246:	4790      	blx	r2
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    f248:	9b06      	ldr	r3, [sp, #24]
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
    f24a:	4602      	mov	r2, r0
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
    f24c:	2b00      	cmp	r3, #0
    f24e:	d13a      	bne.n	f2c6 <lv_label_get_letter_on+0x1ea>
            lv_coord_t gw = lv_font_get_glyph_width(font, letter, letter_next);
    f250:	4629      	mov	r1, r5
    f252:	4650      	mov	r0, sl
    f254:	f00c f9eb 	bl	1b62e <lv_font_get_glyph_width>
            if(pos.x < x + gw || i + line_start == new_line_start ||  txt[i_act + line_start] == '\0') {
    f258:	9b05      	ldr	r3, [sp, #20]
            lv_coord_t gw = lv_font_get_glyph_width(font, letter, letter_next);
    f25a:	b201      	sxth	r1, r0
            if(pos.x < x + gw || i + line_start == new_line_start ||  txt[i_act + line_start] == '\0') {
    f25c:	fa09 f080 	sxtah	r0, r9, r0
    f260:	4283      	cmp	r3, r0
    f262:	da3c      	bge.n	f2de <lv_label_get_letter_on+0x202>
                i = i_act;
    f264:	9b04      	ldr	r3, [sp, #16]
    f266:	930b      	str	r3, [sp, #44]	; 0x2c
    logical_pos = _lv_txt_encoded_get_char_id(bidi_txt, i);
    f268:	4d26      	ldr	r5, [pc, #152]	; (f304 <lv_label_get_letter_on+0x228>)
    f26a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    f26c:	682b      	ldr	r3, [r5, #0]
    f26e:	4640      	mov	r0, r8
    f270:	4798      	blx	r3
    return  logical_pos + _lv_txt_encoded_get_char_id(txt, line_start);
    f272:	4631      	mov	r1, r6
    logical_pos = _lv_txt_encoded_get_char_id(bidi_txt, i);
    f274:	4604      	mov	r4, r0
    return  logical_pos + _lv_txt_encoded_get_char_id(txt, line_start);
    f276:	682b      	ldr	r3, [r5, #0]
    f278:	4638      	mov	r0, r7
    f27a:	4798      	blx	r3
}
    f27c:	4420      	add	r0, r4
    f27e:	b00f      	add	sp, #60	; 0x3c
    f280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
    f284:	4626      	mov	r6, r4
        y += letter_height + line_space;
    f286:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f288:	449b      	add	fp, r3
    f28a:	fa0f fb8b 	sxth.w	fp, fp
    while(txt[line_start] != '\0') {
    f28e:	5dbb      	ldrb	r3, [r7, r6]
    f290:	eb07 0806 	add.w	r8, r7, r6
    f294:	2b00      	cmp	r3, #0
    f296:	d183      	bne.n	f1a0 <lv_label_get_letter_on+0xc4>
    f298:	4634      	mov	r4, r6
    f29a:	e79a      	b.n	f1d2 <lv_label_get_letter_on+0xf6>
    else if(align == LV_LABEL_ALIGN_RIGHT) {
    f29c:	f1b9 0f02 	cmp.w	r9, #2
    f2a0:	d10e      	bne.n	f2c0 <lv_label_get_letter_on+0x1e4>
        line_w = _lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);
    f2a2:	4652      	mov	r2, sl
    f2a4:	9b03      	ldr	r3, [sp, #12]
    f2a6:	4640      	mov	r0, r8
    f2a8:	9500      	str	r5, [sp, #0]
    f2aa:	1ba1      	subs	r1, r4, r6
    f2ac:	f7fd fe5c 	bl	cf68 <_lv_txt_get_width>
    f2b0:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
    f2b4:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
    f2b8:	3301      	adds	r3, #1
    f2ba:	1a9b      	subs	r3, r3, r2
        x += lv_area_get_width(&txt_coords) - line_w;
    f2bc:	1a1b      	subs	r3, r3, r0
    f2be:	e7a1      	b.n	f204 <lv_label_get_letter_on+0x128>
    lv_coord_t x = 0;
    f2c0:	f04f 0900 	mov.w	r9, #0
    f2c4:	e7a0      	b.n	f208 <lv_label_get_letter_on+0x12c>
                if(_lv_txt_is_cmd(&cmd_state, bidi_txt[i]) != false) {
    f2c6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    f2c8:	9007      	str	r0, [sp, #28]
    f2ca:	f818 1001 	ldrb.w	r1, [r8, r1]
    f2ce:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
    f2d2:	f00c f909 	bl	1b4e8 <_lv_txt_is_cmd>
    f2d6:	9a07      	ldr	r2, [sp, #28]
    f2d8:	2800      	cmp	r0, #0
    f2da:	d0b9      	beq.n	f250 <lv_label_get_letter_on+0x174>
    f2dc:	e7a4      	b.n	f228 <lv_label_get_letter_on+0x14c>
            if(pos.x < x + gw || i + line_start == new_line_start ||  txt[i_act + line_start] == '\0') {
    f2de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f2e0:	1990      	adds	r0, r2, r6
    f2e2:	42a0      	cmp	r0, r4
    f2e4:	d0be      	beq.n	f264 <lv_label_get_letter_on+0x188>
    f2e6:	9b04      	ldr	r3, [sp, #16]
    f2e8:	19b8      	adds	r0, r7, r6
    f2ea:	5cc0      	ldrb	r0, [r0, r3]
    f2ec:	2800      	cmp	r0, #0
    f2ee:	d0b9      	beq.n	f264 <lv_label_get_letter_on+0x188>
            x += letter_space;
    f2f0:	9b03      	ldr	r3, [sp, #12]
            i_act = i;
    f2f2:	9204      	str	r2, [sp, #16]
    f2f4:	444b      	add	r3, r9
            x += letter_space;
    f2f6:	fa01 f383 	sxtah	r3, r1, r3
    f2fa:	fa0f f983 	sxth.w	r9, r3
            i_act = i;
    f2fe:	e793      	b.n	f228 <lv_label_get_letter_on+0x14c>
    f300:	200004c8 	.word	0x200004c8
    f304:	200004c0 	.word	0x200004c0
    f308:	200004c4 	.word	0x200004c4

0000f30c <lv_label_refr_text>:
{
    f30c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f310:	b09b      	sub	sp, #108	; 0x6c
    f312:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f314:	f006 ff12 	bl	1613c <lv_obj_get_ext_attr>
    if(ext->text == NULL) return;
    f318:	6803      	ldr	r3, [r0, #0]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f31a:	4604      	mov	r4, r0
    if(ext->text == NULL) return;
    f31c:	2b00      	cmp	r3, #0
    f31e:	d063      	beq.n	f3e8 <lv_label_refr_text+0xdc>
    get_txt_coords(label, &txt_coords);
    f320:	4628      	mov	r0, r5
    f322:	a906      	add	r1, sp, #24
    f324:	f00d f906 	bl	1c534 <get_txt_coords>
    f328:	f8bd 601c 	ldrh.w	r6, [sp, #28]
    f32c:	f8bd 3018 	ldrh.w	r3, [sp, #24]
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
    f330:	f248 028e 	movw	r2, #32910	; 0x808e
    f334:	2100      	movs	r1, #0
    f336:	4628      	mov	r0, r5
    f338:	3601      	adds	r6, #1
    f33a:	1af6      	subs	r6, r6, r3
    f33c:	f7fa fcba 	bl	9cb4 <_lv_obj_get_style_ptr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
    f340:	f248 0281 	movw	r2, #32897	; 0x8081
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
    f344:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
    f346:	2100      	movs	r1, #0
    f348:	4628      	mov	r0, r5
    f34a:	f7fa fa5d 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
    f34e:	2100      	movs	r1, #0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
    f350:	4680      	mov	r8, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
    f352:	f248 0280 	movw	r2, #32896	; 0x8080
    f356:	4628      	mov	r0, r5
    f358:	f7fa fa56 	bl	9808 <_lv_obj_get_style_int>
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
    f35c:	7ca2      	ldrb	r2, [r4, #18]
    f35e:	b236      	sxth	r6, r6
    f360:	f3c2 1380 	ubfx	r3, r2, #6, #1
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
    f364:	0611      	lsls	r1, r2, #24
    f366:	bf48      	it	mi
    f368:	f043 0302 	orrmi.w	r3, r3, #2
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
    f36c:	0752      	lsls	r2, r2, #29
    f36e:	bf08      	it	eq
    f370:	f043 0310 	orreq.w	r3, r3, #16
    _lv_txt_get_size(&size, ext->text, font, letter_space, line_space, max_w, flag);
    f374:	e9cd 6301 	strd	r6, r3, [sp, #4]
    f378:	f8cd 8000 	str.w	r8, [sp]
    f37c:	4603      	mov	r3, r0
    f37e:	4681      	mov	r9, r0
    f380:	463a      	mov	r2, r7
    f382:	6821      	ldr	r1, [r4, #0]
    f384:	a804      	add	r0, sp, #16
    f386:	f00c f8cb 	bl	1b520 <_lv_txt_get_size>
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
    f38a:	7ca6      	ldrb	r6, [r4, #18]
    f38c:	f016 0607 	ands.w	r6, r6, #7
    f390:	d12d      	bne.n	f3ee <lv_label_refr_text+0xe2>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    f392:	2212      	movs	r2, #18
    f394:	4631      	mov	r1, r6
    f396:	4628      	mov	r0, r5
    f398:	f7fa fa36 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    f39c:	2213      	movs	r2, #19
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
    f39e:	4604      	mov	r4, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
    f3a0:	4631      	mov	r1, r6
    f3a2:	4628      	mov	r0, r5
    f3a4:	f7fa fa30 	bl	9808 <_lv_obj_get_style_int>
        size.x += lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_right(label, LV_LABEL_PART_MAIN);
    f3a8:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    f3ac:	4420      	add	r0, r4
    f3ae:	4418      	add	r0, r3
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    f3b0:	2210      	movs	r2, #16
    f3b2:	4631      	mov	r1, r6
    f3b4:	f8ad 0010 	strh.w	r0, [sp, #16]
    f3b8:	4628      	mov	r0, r5
    f3ba:	f7fa fa25 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    f3be:	2211      	movs	r2, #17
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    f3c0:	4604      	mov	r4, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    f3c2:	4631      	mov	r1, r6
    f3c4:	4628      	mov	r0, r5
    f3c6:	f7fa fa1f 	bl	9808 <_lv_obj_get_style_int>
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
    f3ca:	1902      	adds	r2, r0, r4
    f3cc:	f8bd 0012 	ldrh.w	r0, [sp, #18]
        lv_obj_set_size(label, size.x, size.y);
    f3d0:	f9bd 1010 	ldrsh.w	r1, [sp, #16]
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
    f3d4:	4402      	add	r2, r0
    f3d6:	b212      	sxth	r2, r2
        lv_obj_set_size(label, size.x, size.y);
    f3d8:	4628      	mov	r0, r5
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
    f3da:	f8ad 2012 	strh.w	r2, [sp, #18]
        lv_obj_set_size(label, size.x, size.y);
    f3de:	f006 fadd 	bl	1599c <lv_obj_set_size>
    lv_obj_invalidate(label);
    f3e2:	4628      	mov	r0, r5
    f3e4:	f006 fa1c 	bl	15820 <lv_obj_invalidate>
}
    f3e8:	b01b      	add	sp, #108	; 0x6c
    f3ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
    f3ee:	2e03      	cmp	r6, #3
    f3f0:	f040 80a5 	bne.w	f53e <lv_label_refr_text+0x232>
        lv_anim_init(&a);
    f3f4:	a808      	add	r0, sp, #32
    f3f6:	f7fd fac1 	bl	c97c <lv_anim_init>
        lv_anim_set_playback_delay(&a, (((lv_font_get_glyph_width(font, ' ', ' ') + letter_space) * 1000) /
    f3fa:	2220      	movs	r2, #32
    a->repeat_cnt       = cnt;
    f3fc:	f64f 73ff 	movw	r3, #65535	; 0xffff
    f400:	4611      	mov	r1, r2
    f402:	4638      	mov	r0, r7
    f404:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
    a->var     = var;
    f408:	9508      	str	r5, [sp, #32]
    f40a:	f00c f910 	bl	1b62e <lv_font_get_glyph_width>
    f40e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    f412:	4448      	add	r0, r9
    f414:	4343      	muls	r3, r0
                                        ext->anim_speed) *
    f416:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
    f41a:	f8bd 201c 	ldrh.w	r2, [sp, #28]
        lv_anim_set_playback_delay(&a, (((lv_font_get_glyph_width(font, ' ', ' ') + letter_space) * 1000) /
    f41e:	fb93 f3fc 	sdiv	r3, r3, ip
    f422:	f8bd 1018 	ldrh.w	r1, [sp, #24]
    f426:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    a->playback_delay = delay;
    f42a:	b29b      	uxth	r3, r3
    f42c:	3201      	adds	r2, #1
    f42e:	9313      	str	r3, [sp, #76]	; 0x4c
    a->repeat_delay = delay;
    f430:	9315      	str	r3, [sp, #84]	; 0x54
    f432:	1a52      	subs	r2, r2, r1
        if(size.x > lv_area_get_width(&txt_coords)) {
    f434:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    f438:	b212      	sxth	r2, r2
    f43a:	4293      	cmp	r3, r2
    f43c:	f04f 0600 	mov.w	r6, #0
    f440:	dd75      	ble.n	f52e <lv_label_refr_text+0x222>
    a->exec_cb = exec_cb;
    f442:	f8df 8338 	ldr.w	r8, [pc, #824]	; f77c <lv_label_refr_text+0x470>
            lv_anim_set_values(&a, 0, lv_area_get_width(&txt_coords) - size.x);
    f446:	1ad2      	subs	r2, r2, r3
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f448:	4631      	mov	r1, r6
            lv_anim_set_values(&a, 0, lv_area_get_width(&txt_coords) - size.x);
    f44a:	b212      	sxth	r2, r2
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f44c:	4660      	mov	r0, ip
    a->current = start;
    f44e:	e9cd 660e 	strd	r6, r6, [sp, #56]	; 0x38
    a->end   = end;
    f452:	9210      	str	r2, [sp, #64]	; 0x40
    a->exec_cb = exec_cb;
    f454:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
    f458:	f00b fbba 	bl	1abd0 <lv_anim_speed_to_time>
            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
    f45c:	4641      	mov	r1, r8
    a->time     = duration;
    f45e:	9011      	str	r0, [sp, #68]	; 0x44
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f460:	9014      	str	r0, [sp, #80]	; 0x50
            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
    f462:	4628      	mov	r0, r5
    f464:	f7fd fb02 	bl	ca6c <lv_anim_get>
            if(anim_cur) {
    f468:	2800      	cmp	r0, #0
    f46a:	d05e      	beq.n	f52a <lv_label_refr_text+0x21e>
                act_time = anim_cur->act_time;
    f46c:	6a83      	ldr	r3, [r0, #40]	; 0x28
                playback_now = anim_cur->playback_now;
    f46e:	f890 0044 	ldrb.w	r0, [r0, #68]	; 0x44
    f472:	f000 0001 	and.w	r0, r0, #1
            if(act_time < a.time) {
    f476:	9a11      	ldr	r2, [sp, #68]	; 0x44
    f478:	429a      	cmp	r2, r3
    f47a:	dd11      	ble.n	f4a0 <lv_label_refr_text+0x194>
                a.act_time = act_time;      /*To keep the old position*/
    f47c:	9312      	str	r3, [sp, #72]	; 0x48
                a.early_apply = 0;
    f47e:	f89d 305a 	ldrb.w	r3, [sp, #90]	; 0x5a
    f482:	f36f 0300 	bfc	r3, #0, #1
    f486:	f88d 305a 	strb.w	r3, [sp, #90]	; 0x5a
                if(playback_now) {
    f48a:	b148      	cbz	r0, f4a0 <lv_label_refr_text+0x194>
                    a.playback_now = 1;
    f48c:	f89d 3064 	ldrb.w	r3, [sp, #100]	; 0x64
                    a.start = a.end;
    f490:	9a10      	ldr	r2, [sp, #64]	; 0x40
                    a.playback_now = 1;
    f492:	f043 0301 	orr.w	r3, r3, #1
    f496:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
                    tmp      = a.start;
    f49a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
                    a.start = a.end;
    f49c:	920e      	str	r2, [sp, #56]	; 0x38
                    a.end   = tmp;
    f49e:	9310      	str	r3, [sp, #64]	; 0x40
            lv_anim_start(&a);
    f4a0:	a808      	add	r0, sp, #32
    f4a2:	f7fd fab3 	bl	ca0c <lv_anim_start>
            hor_anim = true;
    f4a6:	2601      	movs	r6, #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    f4a8:	f8bd 201e 	ldrh.w	r2, [sp, #30]
    f4ac:	f8bd 101a 	ldrh.w	r1, [sp, #26]
    f4b0:	3201      	adds	r2, #1
        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
    f4b2:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    f4b6:	1a52      	subs	r2, r2, r1
    f4b8:	b212      	sxth	r2, r2
    f4ba:	4293      	cmp	r3, r2
    f4bc:	f340 80b0 	ble.w	f620 <lv_label_refr_text+0x314>
    f4c0:	2e00      	cmp	r6, #0
    f4c2:	f040 80ad 	bne.w	f620 <lv_label_refr_text+0x314>
            lv_anim_set_values(&a, 0, lv_area_get_height(&txt_coords) - size.y - (lv_font_get_line_height(font)));
    f4c6:	1ad2      	subs	r2, r2, r3
    f4c8:	893b      	ldrh	r3, [r7, #8]
    a->exec_cb = exec_cb;
    f4ca:	4fab      	ldr	r7, [pc, #684]	; (f778 <lv_label_refr_text+0x46c>)
    f4cc:	1ad2      	subs	r2, r2, r3
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f4ce:	4631      	mov	r1, r6
            lv_anim_set_values(&a, 0, lv_area_get_height(&txt_coords) - size.y - (lv_font_get_line_height(font)));
    f4d0:	b212      	sxth	r2, r2
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f4d2:	89a0      	ldrh	r0, [r4, #12]
    a->current = start;
    f4d4:	e9cd 660e 	strd	r6, r6, [sp, #56]	; 0x38
    a->end   = end;
    f4d8:	9210      	str	r2, [sp, #64]	; 0x40
    a->exec_cb = exec_cb;
    f4da:	9709      	str	r7, [sp, #36]	; 0x24
    f4dc:	f00b fb78 	bl	1abd0 <lv_anim_speed_to_time>
            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
    f4e0:	4639      	mov	r1, r7
    a->time     = duration;
    f4e2:	9011      	str	r0, [sp, #68]	; 0x44
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f4e4:	9014      	str	r0, [sp, #80]	; 0x50
            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
    f4e6:	4628      	mov	r0, r5
    f4e8:	f7fd fac0 	bl	ca6c <lv_anim_get>
            if(anim_cur) {
    f4ec:	b328      	cbz	r0, f53a <lv_label_refr_text+0x22e>
                playback_now = anim_cur->playback_now;
    f4ee:	f890 6044 	ldrb.w	r6, [r0, #68]	; 0x44
                act_time = anim_cur->act_time;
    f4f2:	6a83      	ldr	r3, [r0, #40]	; 0x28
                playback_now = anim_cur->playback_now;
    f4f4:	f006 0601 	and.w	r6, r6, #1
            if(act_time < a.time) {
    f4f8:	9a11      	ldr	r2, [sp, #68]	; 0x44
    f4fa:	429a      	cmp	r2, r3
    f4fc:	dd11      	ble.n	f522 <lv_label_refr_text+0x216>
                a.act_time = act_time;      /*To keep the old position*/
    f4fe:	9312      	str	r3, [sp, #72]	; 0x48
                a.early_apply = 0;
    f500:	f89d 305a 	ldrb.w	r3, [sp, #90]	; 0x5a
    f504:	f36f 0300 	bfc	r3, #0, #1
    f508:	f88d 305a 	strb.w	r3, [sp, #90]	; 0x5a
                if(playback_now) {
    f50c:	b14e      	cbz	r6, f522 <lv_label_refr_text+0x216>
                    a.playback_now = 1;
    f50e:	f89d 3064 	ldrb.w	r3, [sp, #100]	; 0x64
                    a.start = a.end;
    f512:	9a10      	ldr	r2, [sp, #64]	; 0x40
                    a.playback_now = 1;
    f514:	f043 0301 	orr.w	r3, r3, #1
    f518:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
                    tmp      = a.start;
    f51c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
                    a.start = a.end;
    f51e:	920e      	str	r2, [sp, #56]	; 0x38
                    a.end   = tmp;
    f520:	9310      	str	r3, [sp, #64]	; 0x40
            lv_anim_start(&a);
    f522:	a808      	add	r0, sp, #32
    f524:	f7fd fa72 	bl	ca0c <lv_anim_start>
        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
    f528:	e75b      	b.n	f3e2 <lv_label_refr_text+0xd6>
            int32_t act_time = 0;
    f52a:	4603      	mov	r3, r0
    f52c:	e7a3      	b.n	f476 <lv_label_refr_text+0x16a>
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
    f52e:	4628      	mov	r0, r5
    f530:	4992      	ldr	r1, [pc, #584]	; (f77c <lv_label_refr_text+0x470>)
    f532:	f7fd fa3f 	bl	c9b4 <lv_anim_del>
            ext->offset.x = 0;
    f536:	81e6      	strh	r6, [r4, #14]
    f538:	e7b6      	b.n	f4a8 <lv_label_refr_text+0x19c>
            int32_t act_time = 0;
    f53a:	4633      	mov	r3, r6
    f53c:	e7dc      	b.n	f4f8 <lv_label_refr_text+0x1ec>
    else if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
    f53e:	2e04      	cmp	r6, #4
    f540:	d175      	bne.n	f62e <lv_label_refr_text+0x322>
        lv_anim_init(&a);
    f542:	a808      	add	r0, sp, #32
    f544:	f7fd fa1a 	bl	c97c <lv_anim_init>
    a->repeat_cnt       = cnt;
    f548:	f64f 73ff 	movw	r3, #65535	; 0xffff
    f54c:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    f550:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    f554:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    f558:	3301      	adds	r3, #1
    f55a:	1a9b      	subs	r3, r3, r2
        if(size.x > lv_area_get_width(&txt_coords)) {
    f55c:	f9bd 2010 	ldrsh.w	r2, [sp, #16]
    f560:	b21b      	sxth	r3, r3
    f562:	429a      	cmp	r2, r3
    a->var     = var;
    f564:	9508      	str	r5, [sp, #32]
    f566:	dd54      	ble.n	f612 <lv_label_refr_text+0x306>
            lv_anim_set_values(&a, 0, -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT);
    f568:	2220      	movs	r2, #32
    f56a:	4638      	mov	r0, r7
    f56c:	4611      	mov	r1, r2
    f56e:	f00c f85e 	bl	1b62e <lv_font_get_glyph_width>
    a->start = start;
    f572:	2100      	movs	r1, #0
    f574:	f8bd 2010 	ldrh.w	r2, [sp, #16]
    f578:	eba0 0080 	sub.w	r0, r0, r0, lsl #2
    a->exec_cb = exec_cb;
    f57c:	4e7f      	ldr	r6, [pc, #508]	; (f77c <lv_label_refr_text+0x470>)
    f57e:	1a82      	subs	r2, r0, r2
    f580:	b212      	sxth	r2, r2
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f582:	89a0      	ldrh	r0, [r4, #12]
    a->current = start;
    f584:	e9cd 110e 	strd	r1, r1, [sp, #56]	; 0x38
    a->end   = end;
    f588:	9210      	str	r2, [sp, #64]	; 0x40
    a->exec_cb = exec_cb;
    f58a:	9609      	str	r6, [sp, #36]	; 0x24
    f58c:	f00b fb20 	bl	1abd0 <lv_anim_speed_to_time>
            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
    f590:	4631      	mov	r1, r6
    a->time     = duration;
    f592:	9011      	str	r0, [sp, #68]	; 0x44
    f594:	4628      	mov	r0, r5
    f596:	f7fd fa69 	bl	ca6c <lv_anim_get>
            int32_t act_time = anim_cur ? anim_cur->act_time : 0;
    f59a:	b100      	cbz	r0, f59e <lv_label_refr_text+0x292>
    f59c:	6a80      	ldr	r0, [r0, #40]	; 0x28
            if(act_time < a.time) {
    f59e:	9b11      	ldr	r3, [sp, #68]	; 0x44
            hor_anim = true;
    f5a0:	2601      	movs	r6, #1
            if(act_time < a.time) {
    f5a2:	4283      	cmp	r3, r0
                a.early_apply = 0;
    f5a4:	bfc2      	ittt	gt
    f5a6:	f89d 305a 	ldrbgt.w	r3, [sp, #90]	; 0x5a
                a.act_time = act_time;      /*To keep the old position*/
    f5aa:	9012      	strgt	r0, [sp, #72]	; 0x48
                a.early_apply = 0;
    f5ac:	f36f 0300 	bfcgt	r3, #0, #1
            lv_anim_start(&a);
    f5b0:	a808      	add	r0, sp, #32
                a.early_apply = 0;
    f5b2:	bfc8      	it	gt
    f5b4:	f88d 305a 	strbgt.w	r3, [sp, #90]	; 0x5a
            lv_anim_start(&a);
    f5b8:	f7fd fa28 	bl	ca0c <lv_anim_start>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    f5bc:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    f5c0:	f8bd 101a 	ldrh.w	r1, [sp, #26]
    f5c4:	3301      	adds	r3, #1
        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
    f5c6:	f9bd 2012 	ldrsh.w	r2, [sp, #18]
    f5ca:	1a5b      	subs	r3, r3, r1
    f5cc:	b21b      	sxth	r3, r3
    f5ce:	429a      	cmp	r2, r3
    f5d0:	dd26      	ble.n	f620 <lv_label_refr_text+0x314>
    f5d2:	bb2e      	cbnz	r6, f620 <lv_label_refr_text+0x314>
            lv_anim_set_values(&a, 0, -size.y - (lv_font_get_line_height(font)));
    f5d4:	893b      	ldrh	r3, [r7, #8]
    f5d6:	4252      	negs	r2, r2
    a->exec_cb = exec_cb;
    f5d8:	4f67      	ldr	r7, [pc, #412]	; (f778 <lv_label_refr_text+0x46c>)
    f5da:	1ad2      	subs	r2, r2, r3
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f5dc:	4631      	mov	r1, r6
            lv_anim_set_values(&a, 0, -size.y - (lv_font_get_line_height(font)));
    f5de:	b212      	sxth	r2, r2
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
    f5e0:	89a0      	ldrh	r0, [r4, #12]
    a->current = start;
    f5e2:	e9cd 660e 	strd	r6, r6, [sp, #56]	; 0x38
    a->end   = end;
    f5e6:	9210      	str	r2, [sp, #64]	; 0x40
    a->exec_cb = exec_cb;
    f5e8:	9709      	str	r7, [sp, #36]	; 0x24
    f5ea:	f00b faf1 	bl	1abd0 <lv_anim_speed_to_time>
            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
    f5ee:	4639      	mov	r1, r7
    a->time     = duration;
    f5f0:	9011      	str	r0, [sp, #68]	; 0x44
    f5f2:	4628      	mov	r0, r5
    f5f4:	f7fd fa3a 	bl	ca6c <lv_anim_get>
            int32_t act_time = anim_cur ? anim_cur->act_time : 0;
    f5f8:	b100      	cbz	r0, f5fc <lv_label_refr_text+0x2f0>
    f5fa:	6a86      	ldr	r6, [r0, #40]	; 0x28
            if(act_time < a.time) {
    f5fc:	9b11      	ldr	r3, [sp, #68]	; 0x44
    f5fe:	42b3      	cmp	r3, r6
                a.early_apply = 0;
    f600:	bfc1      	itttt	gt
    f602:	f89d 305a 	ldrbgt.w	r3, [sp, #90]	; 0x5a
                a.act_time = act_time;      /*To keep the old position*/
    f606:	9612      	strgt	r6, [sp, #72]	; 0x48
                a.early_apply = 0;
    f608:	f36f 0300 	bfcgt	r3, #0, #1
    f60c:	f88d 305a 	strbgt.w	r3, [sp, #90]	; 0x5a
    f610:	e787      	b.n	f522 <lv_label_refr_text+0x216>
            ext->offset.x = 0;
    f612:	2600      	movs	r6, #0
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
    f614:	4628      	mov	r0, r5
    f616:	4959      	ldr	r1, [pc, #356]	; (f77c <lv_label_refr_text+0x470>)
    f618:	f7fd f9cc 	bl	c9b4 <lv_anim_del>
            ext->offset.x = 0;
    f61c:	81e6      	strh	r6, [r4, #14]
    f61e:	e7cd      	b.n	f5bc <lv_label_refr_text+0x2b0>
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
    f620:	4628      	mov	r0, r5
    f622:	4955      	ldr	r1, [pc, #340]	; (f778 <lv_label_refr_text+0x46c>)
    f624:	f7fd f9c6 	bl	c9b4 <lv_anim_del>
            ext->offset.y = 0;
    f628:	2300      	movs	r3, #0
    f62a:	8223      	strh	r3, [r4, #16]
    f62c:	e6d9      	b.n	f3e2 <lv_label_refr_text+0xd6>
    else if(ext->long_mode == LV_LABEL_LONG_DOT) {
    f62e:	2e02      	cmp	r6, #2
    f630:	f040 8089 	bne.w	f746 <lv_label_refr_text+0x43a>
    f634:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    f638:	f8bd 201a 	ldrh.w	r2, [sp, #26]
    f63c:	3301      	adds	r3, #1
    f63e:	1a9b      	subs	r3, r3, r2
        if(size.y <= lv_area_get_height(&txt_coords)) { /*No dots are required, the text is short enough*/
    f640:	f9bd 2012 	ldrsh.w	r2, [sp, #18]
    f644:	b21b      	sxth	r3, r3
    f646:	429a      	cmp	r2, r3
    f648:	dc03      	bgt.n	f652 <lv_label_refr_text+0x346>
            ext->dot_end = LV_LABEL_DOT_END_INV;
    f64a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    f64e:	60a3      	str	r3, [r4, #8]
    f650:	e6c7      	b.n	f3e2 <lv_label_refr_text+0xd6>
        else if(_lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) {   /*Don't turn to dots all the characters*/
    f652:	4b4b      	ldr	r3, [pc, #300]	; (f780 <lv_label_refr_text+0x474>)
    f654:	6820      	ldr	r0, [r4, #0]
    f656:	681b      	ldr	r3, [r3, #0]
    f658:	4798      	blx	r3
    f65a:	2803      	cmp	r0, #3
    f65c:	d9f5      	bls.n	f64a <lv_label_refr_text+0x33e>
                  (lv_font_get_glyph_width(font, '.', '.') + letter_space) *
    f65e:	222e      	movs	r2, #46	; 0x2e
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    f660:	f8bd 601c 	ldrh.w	r6, [sp, #28]
    f664:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    f668:	4611      	mov	r1, r2
    f66a:	4638      	mov	r0, r7
    f66c:	3601      	adds	r6, #1
    f66e:	1af6      	subs	r6, r6, r3
    f670:	f00b ffdd 	bl	1b62e <lv_font_get_glyph_width>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    f674:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    f678:	f8bd 201a 	ldrh.w	r2, [sp, #26]
    f67c:	3301      	adds	r3, #1
    f67e:	4481      	add	r9, r0
    f680:	1a9b      	subs	r3, r3, r2
                   (lv_font_get_line_height(font) + line_space); /*Round down to the last line*/
    f682:	f9b7 0008 	ldrsh.w	r0, [r7, #8]
    f686:	b21b      	sxth	r3, r3
            p.y -= line_space;                                               /*Trim the last line space*/
    f688:	eba3 0208 	sub.w	r2, r3, r8
                   (lv_font_get_line_height(font) + line_space); /*Round down to the last line*/
    f68c:	4480      	add	r8, r0
            p.y -= p.y %
    f68e:	fb93 f0f8 	sdiv	r0, r3, r8
    f692:	fb08 3810 	mls	r8, r8, r0, r3
            p.x = lv_area_get_width(&txt_coords) -
    f696:	eba9 0989 	sub.w	r9, r9, r9, lsl #2
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
    f69a:	b236      	sxth	r6, r6
            p.y -= line_space;                                               /*Trim the last line space*/
    f69c:	eba2 0808 	sub.w	r8, r2, r8
            p.x = lv_area_get_width(&txt_coords) -
    f6a0:	444e      	add	r6, r9
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
    f6a2:	a905      	add	r1, sp, #20
    f6a4:	4628      	mov	r0, r5
            p.x = lv_area_get_width(&txt_coords) -
    f6a6:	f8ad 6014 	strh.w	r6, [sp, #20]
            p.y -= line_space;                                               /*Trim the last line space*/
    f6aa:	f8ad 8016 	strh.w	r8, [sp, #22]
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
    f6ae:	f7ff fd15 	bl	f0dc <lv_label_get_letter_on>
    f6b2:	4606      	mov	r6, r0
            size_t txt_len = strlen(ext->text);
    f6b4:	6820      	ldr	r0, [r4, #0]
    f6b6:	f7f0 fed5 	bl	464 <strlen>
            uint32_t byte_id     = _lv_txt_encoded_get_byte_id(ext->text, letter_id);
    f6ba:	4b32      	ldr	r3, [pc, #200]	; (f784 <lv_label_refr_text+0x478>)
            size_t txt_len = strlen(ext->text);
    f6bc:	4680      	mov	r8, r0
            uint32_t byte_id     = _lv_txt_encoded_get_byte_id(ext->text, letter_id);
    f6be:	4631      	mov	r1, r6
    f6c0:	681b      	ldr	r3, [r3, #0]
    f6c2:	6820      	ldr	r0, [r4, #0]
    f6c4:	f8df 90c4 	ldr.w	r9, [pc, #196]	; f78c <lv_label_refr_text+0x480>
    f6c8:	4798      	blx	r3
    f6ca:	46ca      	mov	sl, r9
    f6cc:	9008      	str	r0, [sp, #32]
            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {
    f6ce:	9f08      	ldr	r7, [sp, #32]
    f6d0:	6820      	ldr	r0, [r4, #0]
    f6d2:	f107 0b03 	add.w	fp, r7, #3
    f6d6:	45c3      	cmp	fp, r8
    f6d8:	f8d9 3000 	ldr.w	r3, [r9]
    f6dc:	4438      	add	r0, r7
    f6de:	d82c      	bhi.n	f73a <lv_label_refr_text+0x42e>
    f6e0:	f04f 0804 	mov.w	r8, #4
            uint8_t len          = 0;
    f6e4:	f04f 0900 	mov.w	r9, #0
                len += _lv_txt_encoded_size(&ext->text[byte_id]);
    f6e8:	9908      	ldr	r1, [sp, #32]
    f6ea:	6820      	ldr	r0, [r4, #0]
    f6ec:	f8da 3000 	ldr.w	r3, [sl]
    f6f0:	4408      	add	r0, r1
    f6f2:	4798      	blx	r3
                _lv_txt_encoded_next(ext->text, &byte_id);
    f6f4:	4b24      	ldr	r3, [pc, #144]	; (f788 <lv_label_refr_text+0x47c>)
                len += _lv_txt_encoded_size(&ext->text[byte_id]);
    f6f6:	4481      	add	r9, r0
                _lv_txt_encoded_next(ext->text, &byte_id);
    f6f8:	681b      	ldr	r3, [r3, #0]
    f6fa:	6820      	ldr	r0, [r4, #0]
    f6fc:	a908      	add	r1, sp, #32
    f6fe:	4798      	blx	r3
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
    f700:	f1b8 0801 	subs.w	r8, r8, #1
                len += _lv_txt_encoded_size(&ext->text[byte_id]);
    f704:	fa5f f989 	uxtb.w	r9, r9
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
    f708:	d1ee      	bne.n	f6e8 <lv_label_refr_text+0x3dc>
            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
    f70a:	6821      	ldr	r1, [r4, #0]
    f70c:	464a      	mov	r2, r9
    f70e:	4628      	mov	r0, r5
    f710:	4439      	add	r1, r7
    f712:	f00c fee7 	bl	1c4e4 <lv_label_set_dot_tmp>
    f716:	2800      	cmp	r0, #0
    f718:	f43f ae63 	beq.w	f3e2 <lv_label_refr_text+0xd6>
                    ext->text[byte_id_ori + i] = '.';
    f71c:	222e      	movs	r2, #46	; 0x2e
    f71e:	6823      	ldr	r3, [r4, #0]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
    f720:	3603      	adds	r6, #3
                    ext->text[byte_id_ori + i] = '.';
    f722:	55da      	strb	r2, [r3, r7]
    f724:	6823      	ldr	r3, [r4, #0]
    f726:	443b      	add	r3, r7
    f728:	705a      	strb	r2, [r3, #1]
    f72a:	6823      	ldr	r3, [r4, #0]
    f72c:	441f      	add	r7, r3
    f72e:	70ba      	strb	r2, [r7, #2]
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
    f730:	6823      	ldr	r3, [r4, #0]
    f732:	f803 800b 	strb.w	r8, [r3, fp]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
    f736:	60a6      	str	r6, [r4, #8]
    f738:	e653      	b.n	f3e2 <lv_label_refr_text+0xd6>
                byte_id -= _lv_txt_encoded_size(&ext->text[byte_id]);
    f73a:	4798      	blx	r3
    f73c:	9b08      	ldr	r3, [sp, #32]
                letter_id--;
    f73e:	3e01      	subs	r6, #1
                byte_id -= _lv_txt_encoded_size(&ext->text[byte_id]);
    f740:	1a1b      	subs	r3, r3, r0
    f742:	9308      	str	r3, [sp, #32]
                letter_id--;
    f744:	e7c3      	b.n	f6ce <lv_label_refr_text+0x3c2>
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
    f746:	2e01      	cmp	r6, #1
    f748:	f47f ae4b 	bne.w	f3e2 <lv_label_refr_text+0xd6>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    f74c:	2210      	movs	r2, #16
    f74e:	2100      	movs	r1, #0
    f750:	4628      	mov	r0, r5
    f752:	f7fa f859 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    f756:	2211      	movs	r2, #17
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
    f758:	4604      	mov	r4, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
    f75a:	2100      	movs	r1, #0
    f75c:	4628      	mov	r0, r5
    f75e:	f7fa f853 	bl	9808 <_lv_obj_get_style_int>
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
    f762:	1901      	adds	r1, r0, r4
    f764:	f8bd 0012 	ldrh.w	r0, [sp, #18]
    f768:	4401      	add	r1, r0
    f76a:	b209      	sxth	r1, r1
        lv_obj_set_height(label, size.y);
    f76c:	4628      	mov	r0, r5
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
    f76e:	f8ad 1012 	strh.w	r1, [sp, #18]
        lv_obj_set_height(label, size.y);
    f772:	f006 f955 	bl	15a20 <lv_obj_set_height>
    f776:	e634      	b.n	f3e2 <lv_label_refr_text+0xd6>
    f778:	0001c4b5 	.word	0x0001c4b5
    f77c:	0001c4cb 	.word	0x0001c4cb
    f780:	200004d0 	.word	0x200004d0
    f784:	200004bc 	.word	0x200004bc
    f788:	200004c4 	.word	0x200004c4
    f78c:	200004cc 	.word	0x200004cc

0000f790 <lv_label_set_long_mode>:
{
    f790:	b570      	push	{r4, r5, r6, lr}
    f792:	4604      	mov	r4, r0
    f794:	460e      	mov	r6, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f796:	f006 fcd1 	bl	1613c <lv_obj_get_ext_attr>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_x);
    f79a:	4919      	ldr	r1, [pc, #100]	; (f800 <lv_label_set_long_mode+0x70>)
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f79c:	4605      	mov	r5, r0
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_x);
    f79e:	4620      	mov	r0, r4
    f7a0:	f7fd f908 	bl	c9b4 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_y);
    f7a4:	4917      	ldr	r1, [pc, #92]	; (f804 <lv_label_set_long_mode+0x74>)
    f7a6:	4620      	mov	r0, r4
    f7a8:	f7fd f904 	bl	c9b4 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
    f7ac:	4916      	ldr	r1, [pc, #88]	; (f808 <lv_label_set_long_mode+0x78>)
    f7ae:	4620      	mov	r0, r4
    f7b0:	f7fd f900 	bl	c9b4 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
    f7b4:	4915      	ldr	r1, [pc, #84]	; (f80c <lv_label_set_long_mode+0x7c>)
    f7b6:	4620      	mov	r0, r4
    f7b8:	f7fd f8fc 	bl	c9b4 <lv_anim_del>
    ext->offset.x = 0;
    f7bc:	2300      	movs	r3, #0
    f7be:	81eb      	strh	r3, [r5, #14]
    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
    f7c0:	1ef3      	subs	r3, r6, #3
    f7c2:	2b02      	cmp	r3, #2
    f7c4:	bf8c      	ite	hi
    f7c6:	2200      	movhi	r2, #0
    f7c8:	2201      	movls	r2, #1
    ext->offset.y = 0;
    f7ca:	6929      	ldr	r1, [r5, #16]
    f7cc:	4b10      	ldr	r3, [pc, #64]	; (f810 <lv_label_set_long_mode+0x80>)
    f7ce:	400b      	ands	r3, r1
    f7d0:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
    f7d4:	612b      	str	r3, [r5, #16]
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
    f7d6:	f3c3 4302 	ubfx	r3, r3, #16, #3
    f7da:	2b02      	cmp	r3, #2
    f7dc:	d107      	bne.n	f7ee <lv_label_set_long_mode+0x5e>
    f7de:	f64f 73ff 	movw	r3, #65535	; 0xffff
    f7e2:	68aa      	ldr	r2, [r5, #8]
    f7e4:	429a      	cmp	r2, r3
    f7e6:	d002      	beq.n	f7ee <lv_label_set_long_mode+0x5e>
        lv_label_revert_dots(label);
    f7e8:	4620      	mov	r0, r4
    f7ea:	f7ff fc3d 	bl	f068 <lv_label_revert_dots>
    ext->long_mode = long_mode;
    f7ee:	7cab      	ldrb	r3, [r5, #18]
    lv_label_refr_text(label);
    f7f0:	4620      	mov	r0, r4
    ext->long_mode = long_mode;
    f7f2:	f366 0302 	bfi	r3, r6, #0, #3
    f7f6:	74ab      	strb	r3, [r5, #18]
}
    f7f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_label_refr_text(label);
    f7fc:	f7ff bd86 	b.w	f30c <lv_label_refr_text>
    f800:	00015abd 	.word	0x00015abd
    f804:	00015a97 	.word	0x00015a97
    f808:	0001c4cb 	.word	0x0001c4cb
    f80c:	0001c4b5 	.word	0x0001c4b5
    f810:	ff7f0000 	.word	0xff7f0000

0000f814 <lv_label_create>:
{
    f814:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f818:	460f      	mov	r7, r1
    lv_obj_t * new_label = lv_obj_create(par, copy);
    f81a:	f7f9 fdd7 	bl	93cc <lv_obj_create>
    if(new_label == NULL) return NULL;
    f81e:	4604      	mov	r4, r0
    f820:	b918      	cbnz	r0, f82a <lv_label_create+0x16>
    f822:	2400      	movs	r4, #0
}
    f824:	4620      	mov	r0, r4
    f826:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
    f82a:	4d4f      	ldr	r5, [pc, #316]	; (f968 <lv_label_create+0x154>)
    f82c:	682b      	ldr	r3, [r5, #0]
    f82e:	b913      	cbnz	r3, f836 <lv_label_create+0x22>
    f830:	f006 fc80 	bl	16134 <lv_obj_get_signal_cb>
    f834:	6028      	str	r0, [r5, #0]
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
    f836:	2114      	movs	r1, #20
    f838:	4620      	mov	r0, r4
    f83a:	f005 ff77 	bl	1572c <lv_obj_allocate_ext_attr>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
    f83e:	4620      	mov	r0, r4
    f840:	f006 fc7c 	bl	1613c <lv_obj_get_ext_attr>
    if(ext == NULL) {
    f844:	2300      	movs	r3, #0
    f846:	4605      	mov	r5, r0
    f848:	b918      	cbnz	r0, f852 <lv_label_create+0x3e>
        lv_obj_del(new_label);
    f84a:	4620      	mov	r0, r4
    f84c:	f006 f960 	bl	15b10 <lv_obj_del>
        return NULL;
    f850:	e7e7      	b.n	f822 <lv_label_create+0xe>
    ext->dot.tmp_ptr   = NULL;
    f852:	e9c0 3300 	strd	r3, r3, [r0]
    ext->anim_speed = LV_LABEL_DEF_SCROLL_SPEED;
    f856:	f64f 71ff 	movw	r1, #65535	; 0xffff
    f85a:	2319      	movs	r3, #25
    ext->offset.y = 0;
    f85c:	6902      	ldr	r2, [r0, #16]
    ext->anim_speed = LV_LABEL_DEF_SCROLL_SPEED;
    f85e:	e9c0 1302 	strd	r1, r3, [r0, #8]
    ext->offset.y = 0;
    f862:	4b42      	ldr	r3, [pc, #264]	; (f96c <lv_label_create+0x158>)
    lv_obj_set_design_cb(new_label, lv_label_design);
    f864:	4942      	ldr	r1, [pc, #264]	; (f970 <lv_label_create+0x15c>)
    ext->offset.y = 0;
    f866:	4013      	ands	r3, r2
    f868:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    f86c:	6103      	str	r3, [r0, #16]
    lv_obj_set_design_cb(new_label, lv_label_design);
    f86e:	4620      	mov	r0, r4
    f870:	f005 ff5a 	bl	15728 <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
    f874:	4620      	mov	r0, r4
    f876:	493f      	ldr	r1, [pc, #252]	; (f974 <lv_label_create+0x160>)
    f878:	f005 ff4e 	bl	15718 <lv_obj_set_signal_cb>
    if(copy == NULL) {
    f87c:	b987      	cbnz	r7, f8a0 <lv_label_create+0x8c>
        lv_theme_apply(new_label, LV_THEME_LABEL);
    f87e:	4620      	mov	r0, r4
    f880:	2107      	movs	r1, #7
    f882:	f7fd fddb 	bl	d43c <lv_theme_apply>
        lv_obj_set_click(new_label, false);
    f886:	4639      	mov	r1, r7
    f888:	4620      	mov	r0, r4
    f88a:	f005 ff22 	bl	156d2 <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
    f88e:	4639      	mov	r1, r7
    f890:	4620      	mov	r0, r4
    f892:	f7ff ff7d 	bl	f790 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
    f896:	4620      	mov	r0, r4
    f898:	4937      	ldr	r1, [pc, #220]	; (f978 <lv_label_create+0x164>)
    f89a:	f00c ffad 	bl	1c7f8 <lv_label_set_text>
    f89e:	e7c1      	b.n	f824 <lv_label_create+0x10>
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
    f8a0:	4638      	mov	r0, r7
    f8a2:	f006 fc4b 	bl	1613c <lv_obj_get_ext_attr>
    f8a6:	4606      	mov	r6, r0
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
    f8a8:	4638      	mov	r0, r7
    f8aa:	f00c fe87 	bl	1c5bc <lv_label_get_long_mode>
    f8ae:	4601      	mov	r1, r0
    f8b0:	4620      	mov	r0, r4
    f8b2:	f7ff ff6d 	bl	f790 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
    f8b6:	4638      	mov	r0, r7
    f8b8:	f00c ff97 	bl	1c7ea <lv_label_get_recolor>
    f8bc:	4601      	mov	r1, r0
    f8be:	4620      	mov	r0, r4
    f8c0:	f00c fff1 	bl	1c8a6 <lv_label_set_recolor>
        lv_label_set_align(new_label, lv_label_get_align(copy));
    f8c4:	4638      	mov	r0, r7
    f8c6:	f00c fe80 	bl	1c5ca <lv_label_get_align>
    f8ca:	4601      	mov	r1, r0
    f8cc:	4620      	mov	r0, r4
    f8ce:	f00c fe5d 	bl	1c58c <lv_label_set_align>
        if(copy_ext->static_txt == 0)
    f8d2:	7cb3      	ldrb	r3, [r6, #18]
            lv_label_set_text(new_label, lv_label_get_text(copy));
    f8d4:	4638      	mov	r0, r7
        if(copy_ext->static_txt == 0)
    f8d6:	071a      	lsls	r2, r3, #28
    f8d8:	d439      	bmi.n	f94e <lv_label_create+0x13a>
            lv_label_set_text(new_label, lv_label_get_text(copy));
    f8da:	f00c fe6a 	bl	1c5b2 <lv_label_get_text>
    f8de:	4601      	mov	r1, r0
    f8e0:	4620      	mov	r0, r4
    f8e2:	f00c ff89 	bl	1c7f8 <lv_label_set_text>
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
    f8e6:	7cb3      	ldrb	r3, [r6, #18]
    f8e8:	f003 0307 	and.w	r3, r3, #7
    f8ec:	2b02      	cmp	r3, #2
    f8ee:	d115      	bne.n	f91c <lv_label_create+0x108>
            ext->text = lv_mem_realloc(ext->text, _lv_mem_get_size(copy_ext->text));
    f8f0:	6830      	ldr	r0, [r6, #0]
    f8f2:	682f      	ldr	r7, [r5, #0]
    f8f4:	f7fd f8f4 	bl	cae0 <_lv_mem_get_size>
    f8f8:	4601      	mov	r1, r0
    f8fa:	4638      	mov	r0, r7
    f8fc:	f00b fd96 	bl	1b42c <lv_mem_realloc>
    f900:	4607      	mov	r7, r0
    f902:	6028      	str	r0, [r5, #0]
            if(ext->text == NULL) return NULL;
    f904:	2800      	cmp	r0, #0
    f906:	d08c      	beq.n	f822 <lv_label_create+0xe>
            _lv_memcpy(ext->text, copy_ext->text, _lv_mem_get_size(copy_ext->text));
    f908:	f8d6 8000 	ldr.w	r8, [r6]
    f90c:	4640      	mov	r0, r8
    f90e:	f7fd f8e7 	bl	cae0 <_lv_mem_get_size>
    f912:	4641      	mov	r1, r8
    f914:	4602      	mov	r2, r0
    f916:	4638      	mov	r0, r7
    f918:	f00c fde2 	bl	1c4e0 <_lv_memcpy>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
    f91c:	7cf3      	ldrb	r3, [r6, #19]
    f91e:	07db      	lsls	r3, r3, #31
    f920:	d51c      	bpl.n	f95c <lv_label_create+0x148>
    f922:	6870      	ldr	r0, [r6, #4]
    f924:	b1d0      	cbz	r0, f95c <lv_label_create+0x148>
            uint32_t len = (uint32_t)strlen(copy_ext->dot.tmp_ptr);
    f926:	f7f0 fd9d 	bl	464 <strlen>
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
    f92a:	6869      	ldr	r1, [r5, #4]
            uint32_t len = (uint32_t)strlen(copy_ext->dot.tmp_ptr);
    f92c:	4602      	mov	r2, r0
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
    f92e:	4620      	mov	r0, r4
    f930:	f00c fdd8 	bl	1c4e4 <lv_label_set_dot_tmp>
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
    f934:	7cf2      	ldrb	r2, [r6, #19]
    f936:	7ceb      	ldrb	r3, [r5, #19]
        lv_obj_refresh_style(new_label, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    f938:	4620      	mov	r0, r4
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
    f93a:	f362 0300 	bfi	r3, r2, #0, #1
        lv_obj_refresh_style(new_label, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    f93e:	22ff      	movs	r2, #255	; 0xff
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
    f940:	74eb      	strb	r3, [r5, #19]
        ext->dot_end       = copy_ext->dot_end;
    f942:	68b3      	ldr	r3, [r6, #8]
        lv_obj_refresh_style(new_label, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    f944:	4611      	mov	r1, r2
        ext->dot_end       = copy_ext->dot_end;
    f946:	60ab      	str	r3, [r5, #8]
        lv_obj_refresh_style(new_label, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
    f948:	f7fa fa16 	bl	9d78 <lv_obj_refresh_style>
    f94c:	e76a      	b.n	f824 <lv_label_create+0x10>
            lv_label_set_text_static(new_label, lv_label_get_text(copy));
    f94e:	f00c fe30 	bl	1c5b2 <lv_label_get_text>
    f952:	4601      	mov	r1, r0
    f954:	4620      	mov	r0, r4
    f956:	f00c ff8c 	bl	1c872 <lv_label_set_text_static>
    f95a:	e7c4      	b.n	f8e6 <lv_label_create+0xd2>
            _lv_memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
    f95c:	2204      	movs	r2, #4
    f95e:	18b1      	adds	r1, r6, r2
    f960:	18a8      	adds	r0, r5, r2
    f962:	f00c fdbd 	bl	1c4e0 <_lv_memcpy>
    f966:	e7e5      	b.n	f934 <lv_label_create+0x120>
    f968:	20025ec4 	.word	0x20025ec4
    f96c:	fe800000 	.word	0xfe800000
    f970:	0001c5df 	.word	0x0001c5df
    f974:	0000f97d 	.word	0x0000f97d
    f978:	000442d0 	.word	0x000442d0

0000f97c <lv_label_signal>:
    if(sign == LV_SIGNAL_GET_STYLE) {
    f97c:	2908      	cmp	r1, #8
{
    f97e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f982:	4604      	mov	r4, r0
    f984:	460e      	mov	r6, r1
    f986:	4615      	mov	r5, r2
    if(sign == LV_SIGNAL_GET_STYLE) {
    f988:	d114      	bne.n	f9b4 <lv_label_signal+0x38>
    switch(type) {
    f98a:	7813      	ldrb	r3, [r2, #0]
    f98c:	b14b      	cbz	r3, f9a2 <lv_label_signal+0x26>
        info->result = lv_label_get_style(label, info->part);
    f98e:	2300      	movs	r3, #0
    f990:	6053      	str	r3, [r2, #4]
        else return ancestor_signal(label, sign, param);
    f992:	4b28      	ldr	r3, [pc, #160]	; (fa34 <lv_label_signal+0xb8>)
    f994:	462a      	mov	r2, r5
    f996:	4620      	mov	r0, r4
}
    f998:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        else return ancestor_signal(label, sign, param);
    f99c:	2108      	movs	r1, #8
    f99e:	681b      	ldr	r3, [r3, #0]
    f9a0:	4718      	bx	r3
            style_dsc_p = &label->style_list;
    f9a2:	f100 0328 	add.w	r3, r0, #40	; 0x28
        info->result = lv_label_get_style(label, info->part);
    f9a6:	6053      	str	r3, [r2, #4]
        if(info->result != NULL) return LV_RES_OK;
    f9a8:	2b00      	cmp	r3, #0
    f9aa:	d0f2      	beq.n	f992 <lv_label_signal+0x16>
    f9ac:	2701      	movs	r7, #1
}
    f9ae:	4638      	mov	r0, r7
    f9b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    res = ancestor_signal(label, sign, param);
    f9b4:	4b1f      	ldr	r3, [pc, #124]	; (fa34 <lv_label_signal+0xb8>)
    f9b6:	681b      	ldr	r3, [r3, #0]
    f9b8:	4798      	blx	r3
    if(res != LV_RES_OK) return res;
    f9ba:	2801      	cmp	r0, #1
    res = ancestor_signal(label, sign, param);
    f9bc:	4607      	mov	r7, r0
    if(res != LV_RES_OK) return res;
    f9be:	d1f6      	bne.n	f9ae <lv_label_signal+0x32>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    f9c0:	2e07      	cmp	r6, #7
    f9c2:	d105      	bne.n	f9d0 <lv_label_signal+0x54>
    f9c4:	4628      	mov	r0, r5
}
    f9c6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
    f9ca:	491b      	ldr	r1, [pc, #108]	; (fa38 <lv_label_signal+0xbc>)
    f9cc:	f006 bbd0 	b.w	16170 <lv_obj_handle_get_type_signal>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    f9d0:	4620      	mov	r0, r4
    f9d2:	f006 fbb3 	bl	1613c <lv_obj_get_ext_attr>
    f9d6:	4680      	mov	r8, r0
    if(sign == LV_SIGNAL_CLEANUP) {
    f9d8:	b966      	cbnz	r6, f9f4 <lv_label_signal+0x78>
        if(ext->static_txt == 0) {
    f9da:	7c83      	ldrb	r3, [r0, #18]
    f9dc:	f013 0508 	ands.w	r5, r3, #8
    f9e0:	d104      	bne.n	f9ec <lv_label_signal+0x70>
            lv_mem_free(ext->text);
    f9e2:	6800      	ldr	r0, [r0, #0]
    f9e4:	f7fd f86c 	bl	cac0 <lv_mem_free>
            ext->text = NULL;
    f9e8:	f8c8 5000 	str.w	r5, [r8]
        lv_label_dot_tmp_free(label);
    f9ec:	4620      	mov	r0, r4
    f9ee:	f00c fd4f 	bl	1c490 <lv_label_dot_tmp_free>
    f9f2:	e7dc      	b.n	f9ae <lv_label_signal+0x32>
    else if(sign == LV_SIGNAL_STYLE_CHG) {
    f9f4:	2e04      	cmp	r6, #4
    f9f6:	d106      	bne.n	fa06 <lv_label_signal+0x8a>
        lv_label_revert_dots(label);
    f9f8:	4620      	mov	r0, r4
    f9fa:	f7ff fb35 	bl	f068 <lv_label_revert_dots>
        lv_label_refr_text(label);
    f9fe:	4620      	mov	r0, r4
    fa00:	f7ff fc84 	bl	f30c <lv_label_refr_text>
    fa04:	e7d3      	b.n	f9ae <lv_label_signal+0x32>
    else if(sign == LV_SIGNAL_COORD_CHG) {
    fa06:	2e02      	cmp	r6, #2
    fa08:	d1d0      	bne.n	f9ac <lv_label_signal+0x30>
    fa0a:	8a23      	ldrh	r3, [r4, #16]
    fa0c:	8aa2      	ldrh	r2, [r4, #20]
    fa0e:	8829      	ldrh	r1, [r5, #0]
    fa10:	1ad2      	subs	r2, r2, r3
    fa12:	88ab      	ldrh	r3, [r5, #4]
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
    fa14:	b212      	sxth	r2, r2
    fa16:	1a5b      	subs	r3, r3, r1
    fa18:	b21b      	sxth	r3, r3
    fa1a:	429a      	cmp	r2, r3
    fa1c:	d1ec      	bne.n	f9f8 <lv_label_signal+0x7c>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
    fa1e:	8a63      	ldrh	r3, [r4, #18]
    fa20:	8ae2      	ldrh	r2, [r4, #22]
    fa22:	8869      	ldrh	r1, [r5, #2]
    fa24:	1ad2      	subs	r2, r2, r3
    fa26:	88eb      	ldrh	r3, [r5, #6]
    fa28:	b212      	sxth	r2, r2
    fa2a:	1a5b      	subs	r3, r3, r1
    fa2c:	b21b      	sxth	r3, r3
    fa2e:	429a      	cmp	r2, r3
    fa30:	d1e2      	bne.n	f9f8 <lv_label_signal+0x7c>
    fa32:	e7bb      	b.n	f9ac <lv_label_signal+0x30>
    fa34:	20025ec4 	.word	0x20025ec4
    fa38:	000442d5 	.word	0x000442d5

0000fa3c <virtio_create_virtqueues>:
}

int virtio_create_virtqueues(struct virtio_device *vdev, unsigned int flags,
			     unsigned int nvqs, const char *names[],
			     vq_callback callbacks[])
{
    fa3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fa40:	b087      	sub	sp, #28
    fa42:	9305      	str	r3, [sp, #20]
	unsigned int num_vrings, i;
	int ret;
	(void)flags;

	num_vrings = vdev->vrings_num;
	if (nvqs > num_vrings)
    fa44:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
    fa46:	4606      	mov	r6, r0
	if (nvqs > num_vrings)
    fa48:	4293      	cmp	r3, r2
{
    fa4a:	4617      	mov	r7, r2
	if (nvqs > num_vrings)
    fa4c:	d342      	bcc.n	fad4 <virtio_create_virtqueues+0x98>
		return ERROR_VQUEUE_INVLD_PARAM;
	/* Initialize virtqueue for each vring */
	for (i = 0; i < nvqs; i++) {
    fa4e:	2500      	movs	r5, #0
		vring_info = &vdev->vrings_info[i];
    fa50:	f04f 0b18 	mov.w	fp, #24
	for (i = 0; i < nvqs; i++) {
    fa54:	42bd      	cmp	r5, r7
    fa56:	d103      	bne.n	fa60 <virtio_create_virtqueues+0x24>
				       callbacks[i], vdev->func->notify,
				       vring_info->vq);
		if (ret)
			return ret;
	}
	return 0;
    fa58:	2000      	movs	r0, #0
}
    fa5a:	b007      	add	sp, #28
    fa5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		vring_info = &vdev->vrings_info[i];
    fa60:	fb0b f805 	mul.w	r8, fp, r5
    fa64:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
		if (vdev->role == VIRTIO_DEV_MASTER) {
    fa68:	69b2      	ldr	r2, [r6, #24]
		vring_info = &vdev->vrings_info[i];
    fa6a:	eb09 0408 	add.w	r4, r9, r8
		vring_alloc = &vring_info->info;
    fa6e:	f104 0a04 	add.w	sl, r4, #4
		if (vdev->role == VIRTIO_DEV_MASTER) {
    fa72:	b9ca      	cbnz	r2, faa8 <virtio_create_virtqueues+0x6c>
			struct metal_io_region *io = vring_info->io;
    fa74:	6960      	ldr	r0, [r4, #20]
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
    fa76:	6863      	ldr	r3, [r4, #4]
    fa78:	6801      	ldr	r1, [r0, #0]
			metal_io_block_set(io, offset, 0,
    fa7a:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
    fa7e:	1a59      	subs	r1, r3, r1
						      vring_alloc->align));
    fa80:	68a3      	ldr	r3, [r4, #8]
static inline int vring_size(unsigned int num, unsigned long align)
{
	int size;

	size = num * sizeof(struct vring_desc);
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
    fa82:	f10c 0e03 	add.w	lr, ip, #3
	    sizeof(uint16_t);
	size = (size + align - 1) & ~(align - 1);
    fa86:	1e5c      	subs	r4, r3, #1
    fa88:	eb04 140c 	add.w	r4, r4, ip, lsl #4
    fa8c:	eb04 044e 	add.w	r4, r4, lr, lsl #1
    fa90:	425b      	negs	r3, r3
    fa92:	4023      	ands	r3, r4
			metal_io_block_set(io, offset, 0,
    fa94:	6884      	ldr	r4, [r0, #8]
	size += sizeof(struct vring_used) +
    fa96:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
    fa9a:	42a1      	cmp	r1, r4
    fa9c:	bf28      	it	cs
    fa9e:	f04f 31ff 	movcs.w	r1, #4294967295
    faa2:	3306      	adds	r3, #6
    faa4:	f005 fd3e 	bl	15524 <metal_io_block_set>
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
    faa8:	f859 3008 	ldr.w	r3, [r9, r8]
    faac:	9a05      	ldr	r2, [sp, #20]
    faae:	9302      	str	r3, [sp, #8]
    fab0:	6a33      	ldr	r3, [r6, #32]
    fab2:	4630      	mov	r0, r6
    fab4:	6a1b      	ldr	r3, [r3, #32]
    fab6:	b2a9      	uxth	r1, r5
    fab8:	9301      	str	r3, [sp, #4]
    faba:	9b10      	ldr	r3, [sp, #64]	; 0x40
    fabc:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
    fac0:	9300      	str	r3, [sp, #0]
    fac2:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
    fac6:	4653      	mov	r3, sl
    fac8:	f00c ff1b 	bl	1c902 <virtqueue_create>
		if (ret)
    facc:	2800      	cmp	r0, #0
    face:	d1c4      	bne.n	fa5a <virtio_create_virtqueues+0x1e>
	for (i = 0; i < nvqs; i++) {
    fad0:	3501      	adds	r5, #1
    fad2:	e7bf      	b.n	fa54 <virtio_create_virtqueues+0x18>
		return ERROR_VQUEUE_INVLD_PARAM;
    fad4:	4800      	ldr	r0, [pc, #0]	; (fad8 <virtio_create_virtqueues+0x9c>)
    fad6:	e7c0      	b.n	fa5a <virtio_create_virtqueues+0x1e>
    fad8:	fffff440 	.word	0xfffff440

0000fadc <virtqueue_add_consumed_buffer>:
 *
 * @return                       - Function status
 */
int virtqueue_add_consumed_buffer(struct virtqueue *vq, uint16_t head_idx,
				  uint32_t len)
{
    fadc:	b530      	push	{r4, r5, lr}
	struct vring_used_elem *used_desc = NULL;
	uint16_t used_idx;

	if (head_idx > vq->vq_nentries) {
    fade:	8944      	ldrh	r4, [r0, #10]
    fae0:	428c      	cmp	r4, r1
    fae2:	d312      	bcc.n	fb0a <virtqueue_add_consumed_buffer+0x2e>
		return ERROR_VRING_NO_BUFF;
	}

	VQUEUE_BUSY(vq);

	used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
    fae4:	6a03      	ldr	r3, [r0, #32]
    fae6:	3c01      	subs	r4, #1
    fae8:	885d      	ldrh	r5, [r3, #2]
    faea:	402c      	ands	r4, r5
    faec:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
	used_desc = &vq->vq_ring.used->ring[used_idx];
	used_desc->id = head_idx;
	used_desc->len = len;
    faf0:	609a      	str	r2, [r3, #8]
	used_desc->id = head_idx;
    faf2:	6059      	str	r1, [r3, #4]

	atomic_thread_fence(memory_order_seq_cst);
    faf4:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.used->idx++;
    faf8:	6a02      	ldr	r2, [r0, #32]
    fafa:	8853      	ldrh	r3, [r2, #2]
    fafc:	3301      	adds	r3, #1
    fafe:	8053      	strh	r3, [r2, #2]

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
    fb00:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
    fb02:	3301      	adds	r3, #1
    fb04:	84c3      	strh	r3, [r0, #38]	; 0x26

	VQUEUE_IDLE(vq);

	return VQUEUE_SUCCESS;
    fb06:	2000      	movs	r0, #0
}
    fb08:	bd30      	pop	{r4, r5, pc}
		return ERROR_VRING_NO_BUFF;
    fb0a:	4801      	ldr	r0, [pc, #4]	; (fb10 <virtqueue_add_consumed_buffer+0x34>)
    fb0c:	e7fc      	b.n	fb08 <virtqueue_add_consumed_buffer+0x2c>
    fb0e:	bf00      	nop
    fb10:	fffff441 	.word	0xfffff441

0000fb14 <rpmsg_send_offchannel_raw>:
 *
 */
int rpmsg_send_offchannel_raw(struct rpmsg_endpoint *ept, uint32_t src,
			      uint32_t dst, const void *data, int size,
			      int wait)
{
    fb14:	b430      	push	{r4, r5}
    fb16:	4614      	mov	r4, r2
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
    fb18:	b148      	cbz	r0, fb2e <rpmsg_send_offchannel_raw+0x1a>
    fb1a:	6a00      	ldr	r0, [r0, #32]
    fb1c:	b138      	cbz	r0, fb2e <rpmsg_send_offchannel_raw+0x1a>
    fb1e:	b133      	cbz	r3, fb2e <rpmsg_send_offchannel_raw+0x1a>
    fb20:	3401      	adds	r4, #1
    fb22:	d004      	beq.n	fb2e <rpmsg_send_offchannel_raw+0x1a>
		return RPMSG_ERR_PARAM;

	rdev = ept->rdev;

	if (rdev->ops.send_offchannel_raw)
    fb24:	6f44      	ldr	r4, [r0, #116]	; 0x74
    fb26:	b114      	cbz	r4, fb2e <rpmsg_send_offchannel_raw+0x1a>
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
    fb28:	46a4      	mov	ip, r4
						      size, wait);

	return RPMSG_ERR_PARAM;
}
    fb2a:	bc30      	pop	{r4, r5}
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
    fb2c:	4760      	bx	ip
		return RPMSG_ERR_PARAM;
    fb2e:	4801      	ldr	r0, [pc, #4]	; (fb34 <rpmsg_send_offchannel_raw+0x20>)
}
    fb30:	bc30      	pop	{r4, r5}
    fb32:	4770      	bx	lr
    fb34:	fffff82d 	.word	0xfffff82d

0000fb38 <rpmsg_create_ept>:
}

int rpmsg_create_ept(struct rpmsg_endpoint *ept, struct rpmsg_device *rdev,
		     const char *name, uint32_t src, uint32_t dest,
		     rpmsg_ept_cb cb, rpmsg_ns_unbind_cb unbind_cb)
{
    fb38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fb3c:	460e      	mov	r6, r1
    fb3e:	4690      	mov	r8, r2
    fb40:	461c      	mov	r4, r3
	int status = RPMSG_SUCCESS;
	uint32_t addr = src;

	if (!ept)
    fb42:	4605      	mov	r5, r0
    fb44:	2800      	cmp	r0, #0
    fb46:	d06a      	beq.n	fc1e <rpmsg_create_ept+0xe6>
		return RPMSG_ERR_PARAM;

	metal_mutex_acquire(&rdev->lock);
    fb48:	f101 0758 	add.w	r7, r1, #88	; 0x58
 * @brief	Acquire a mutex
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
	__metal_mutex_acquire(mutex);
    fb4c:	4638      	mov	r0, r7
    fb4e:	f00d f871 	bl	1cc34 <__metal_mutex_acquire>
	if (src == RPMSG_ADDR_ANY) {
    fb52:	1c63      	adds	r3, r4, #1
    fb54:	d11a      	bne.n	fb8c <rpmsg_create_ept+0x54>
metal_bitmap_next_clear_bit(unsigned long *bitmap, unsigned int start,
			    unsigned int max)
{
	unsigned int bit;

	for (bit = start;
    fb56:	2300      	movs	r3, #0
		addr = rpmsg_get_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE);
    fb58:	f106 0048 	add.w	r0, r6, #72	; 0x48
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
    fb5c:	095a      	lsrs	r2, r3, #5
    fb5e:	eb00 0c82 	add.w	ip, r0, r2, lsl #2
    fb62:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
    fb66:	f003 011f 	and.w	r1, r3, #31
    fb6a:	fa22 f401 	lsr.w	r4, r2, r1
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
    fb6e:	07e4      	lsls	r4, r4, #31
    fb70:	d407      	bmi.n	fb82 <rpmsg_create_ept+0x4a>
		addr = RPMSG_RESERVED_ADDRESSES + nextbit;
    fb72:	f503 6480 	add.w	r4, r3, #1024	; 0x400
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
    fb76:	2301      	movs	r3, #1
    fb78:	408b      	lsls	r3, r1
	bitmap[bit / METAL_BITS_PER_ULONG] |=
    fb7a:	4313      	orrs	r3, r2
    fb7c:	f8cc 3000 	str.w	r3, [ip]
		if (addr == RPMSG_ADDR_ANY) {
    fb80:	e01d      	b.n	fbbe <rpmsg_create_ept+0x86>
	     bit++)
    fb82:	3301      	adds	r3, #1
	for (bit = start;
    fb84:	2b80      	cmp	r3, #128	; 0x80
    fb86:	d1e9      	bne.n	fb5c <rpmsg_create_ept+0x24>
			status = RPMSG_ERR_ADDR;
    fb88:	4c27      	ldr	r4, [pc, #156]	; (fc28 <rpmsg_create_ept+0xf0>)
    fb8a:	e044      	b.n	fc16 <rpmsg_create_ept+0xde>
			goto ret_status;
		}
	} else if (src >= RPMSG_RESERVED_ADDRESSES) {
    fb8c:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
    fb90:	d315      	bcc.n	fbbe <rpmsg_create_ept+0x86>
	addr -= RPMSG_RESERVED_ADDRESSES;
    fb92:	f5a4 6380 	sub.w	r3, r4, #1024	; 0x400
	if (addr >= 0 && addr < size)
    fb96:	2b7f      	cmp	r3, #127	; 0x7f
		status = rpmsg_is_address_set(rdev->bitmap,
    fb98:	f106 0148 	add.w	r1, r6, #72	; 0x48
	if (addr >= 0 && addr < size)
    fb9c:	d83a      	bhi.n	fc14 <rpmsg_create_ept+0xdc>
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
    fb9e:	0958      	lsrs	r0, r3, #5
    fba0:	f851 c020 	ldr.w	ip, [r1, r0, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
    fba4:	f003 031f 	and.w	r3, r3, #31
    fba8:	fa2c f203 	lsr.w	r2, ip, r3
					      RPMSG_ADDR_BMP_SIZE, src);
		if (!status) {
    fbac:	07d2      	lsls	r2, r2, #31
    fbae:	d4eb      	bmi.n	fb88 <rpmsg_create_ept+0x50>
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
    fbb0:	2201      	movs	r2, #1
    fbb2:	fa02 f303 	lsl.w	r3, r2, r3
	bitmap[bit / METAL_BITS_PER_ULONG] |=
    fbb6:	ea43 030c 	orr.w	r3, r3, ip
    fbba:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
__ssp_bos_icheck2_restrict(strcat, char *, const char *)
__ssp_bos_icheck3_restrict(strncpy, char *, const char *)
    fbbe:	491b      	ldr	r1, [pc, #108]	; (fc2c <rpmsg_create_ept+0xf4>)
    fbc0:	2220      	movs	r2, #32
    fbc2:	f1b8 0f00 	cmp.w	r8, #0
    fbc6:	bf18      	it	ne
    fbc8:	4641      	movne	r1, r8
    fbca:	4628      	mov	r0, r5
    fbcc:	f00d fef8 	bl	1d9c0 <strncpy>
					rpmsg_ept_cb cb,
					rpmsg_ns_unbind_cb ns_unbind_cb)
{
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
	ept->addr = src;
	ept->dest_addr = dest;
    fbd0:	9b06      	ldr	r3, [sp, #24]
		 * 2.Simplify the tracking implementation
		 */
	}

	rpmsg_initialize_ept(ept, name, addr, dest, cb, unbind_cb);
	rpmsg_register_endpoint(rdev, ept);
    fbd2:	4629      	mov	r1, r5
    fbd4:	62ab      	str	r3, [r5, #40]	; 0x28
	ept->cb = cb;
    fbd6:	9b07      	ldr	r3, [sp, #28]
    fbd8:	4630      	mov	r0, r6
    fbda:	62eb      	str	r3, [r5, #44]	; 0x2c
	ept->ns_unbind_cb = ns_unbind_cb;
    fbdc:	9b08      	ldr	r3, [sp, #32]
	ept->addr = src;
    fbde:	626c      	str	r4, [r5, #36]	; 0x24
	ept->ns_unbind_cb = ns_unbind_cb;
    fbe0:	632b      	str	r3, [r5, #48]	; 0x30
    fbe2:	f00d f8a1 	bl	1cd28 <rpmsg_register_endpoint>
	z_impl_k_sem_give(sem);
    fbe6:	4638      	mov	r0, r7
    fbe8:	f001 f8d4 	bl	10d94 <z_impl_k_sem_give>
	metal_mutex_release(&rdev->lock);

	/* Send NS announcement to remote processor */
	if (ept->name[0] && rdev->support_ns &&
    fbec:	782c      	ldrb	r4, [r5, #0]
    fbee:	b174      	cbz	r4, fc0e <rpmsg_create_ept+0xd6>
    fbf0:	f896 4078 	ldrb.w	r4, [r6, #120]	; 0x78
    fbf4:	b15c      	cbz	r4, fc0e <rpmsg_create_ept+0xd6>
    fbf6:	6aab      	ldr	r3, [r5, #40]	; 0x28
    fbf8:	3301      	adds	r3, #1
    fbfa:	d112      	bne.n	fc22 <rpmsg_create_ept+0xea>
	    ept->dest_addr == RPMSG_ADDR_ANY)
		status = rpmsg_send_ns_message(ept, RPMSG_NS_CREATE);
    fbfc:	2100      	movs	r1, #0
    fbfe:	4628      	mov	r0, r5
    fc00:	f00d f849 	bl	1cc96 <rpmsg_send_ns_message>

	if (status)
    fc04:	4604      	mov	r4, r0
    fc06:	b110      	cbz	r0, fc0e <rpmsg_create_ept+0xd6>
		rpmsg_unregister_endpoint(ept);
    fc08:	4628      	mov	r0, r5
    fc0a:	f00d f819 	bl	1cc40 <rpmsg_unregister_endpoint>
	return status;

ret_status:
	metal_mutex_release(&rdev->lock);
	return status;
}
    fc0e:	4620      	mov	r0, r4
    fc10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    fc14:	4c06      	ldr	r4, [pc, #24]	; (fc30 <rpmsg_create_ept+0xf8>)
    fc16:	4638      	mov	r0, r7
    fc18:	f001 f8bc 	bl	10d94 <z_impl_k_sem_give>
}
    fc1c:	e7f7      	b.n	fc0e <rpmsg_create_ept+0xd6>
		return RPMSG_ERR_PARAM;
    fc1e:	4c04      	ldr	r4, [pc, #16]	; (fc30 <rpmsg_create_ept+0xf8>)
    fc20:	e7f5      	b.n	fc0e <rpmsg_create_ept+0xd6>
    fc22:	2400      	movs	r4, #0
    fc24:	e7f3      	b.n	fc0e <rpmsg_create_ept+0xd6>
    fc26:	bf00      	nop
    fc28:	fffff829 	.word	0xfffff829
    fc2c:	0001f585 	.word	0x0001f585
    fc30:	fffff82d 	.word	0xfffff82d

0000fc34 <rpmsg_virtio_send_offchannel_raw>:
 */
static int rpmsg_virtio_send_offchannel_raw(struct rpmsg_device *rdev,
					    uint32_t src, uint32_t dst,
					    const void *data,
					    int size, int wait)
{
    fc34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fc38:	4604      	mov	r4, r0
	struct metal_io_region *io;

	/* Get the associated remote device for channel. */
	rvdev = metal_container_of(rdev, struct rpmsg_virtio_device, rdev);

	status = rpmsg_virtio_get_status(rvdev);
    fc3a:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
{
    fc3c:	469b      	mov	fp, r3
	rvdev->vdev->func->set_status(rvdev->vdev, status);
}

static inline uint8_t rpmsg_virtio_get_status(struct rpmsg_virtio_device *rvdev)
{
	return rvdev->vdev->func->get_status(rvdev->vdev);
    fc3e:	6a03      	ldr	r3, [r0, #32]
    fc40:	b08d      	sub	sp, #52	; 0x34
    fc42:	681b      	ldr	r3, [r3, #0]
    fc44:	4692      	mov	sl, r2
    fc46:	e9dd 6716 	ldrd	r6, r7, [sp, #88]	; 0x58
    fc4a:	9103      	str	r1, [sp, #12]
    fc4c:	4798      	blx	r3
	/* Validate device state */
	if (!(status & VIRTIO_CONFIG_STATUS_DRIVER_OK)) {
    fc4e:	0743      	lsls	r3, r0, #29
    fc50:	f140 8089 	bpl.w	fd66 <rpmsg_virtio_send_offchannel_raw+0x132>
		return RPMSG_ERR_DEV_STATE;
	}

	if (wait)
		tick_count = RPMSG_TICK_COUNT / RPMSG_TICKS_PER_INTERVAL;
    fc54:	f643 2398 	movw	r3, #15000	; 0x3a98
    fc58:	2f00      	cmp	r7, #0
    fc5a:	bf18      	it	ne
    fc5c:	461f      	movne	r7, r3

	while (1) {
		int avail_size;

		/* Lock the device to enable exclusive access to virtqueues */
		metal_mutex_acquire(&rdev->lock);
    fc5e:	f104 0858 	add.w	r8, r4, #88	; 0x58
    fc62:	4640      	mov	r0, r8
    fc64:	f00d f89a 	bl	1cd9c <__metal_mutex_acquire>
	return rvdev->vdev->role;
    fc68:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    fc6a:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
    fc6c:	b373      	cbz	r3, fccc <rpmsg_virtio_send_offchannel_raw+0x98>
	if (role == RPMSG_REMOTE) {
    fc6e:	2b01      	cmp	r3, #1
    fc70:	d108      	bne.n	fc84 <rpmsg_virtio_send_offchannel_raw+0x50>
		    (int)virtqueue_get_desc_size(rvdev->svq) -
    fc72:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    fc76:	f00c ffc5 	bl	1cc04 <virtqueue_get_desc_size>
    fc7a:	3810      	subs	r0, #16
		avail_size = _rpmsg_virtio_get_buffer_size(rvdev);
		if (avail_size && size > avail_size) {
    fc7c:	2800      	cmp	r0, #0
    fc7e:	ea20 79e0 	bic.w	r9, r0, r0, asr #31
    fc82:	dc25      	bgt.n	fcd0 <rpmsg_virtio_send_offchannel_raw+0x9c>
		length = RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr);
    fc84:	f04f 0900 	mov.w	r9, #0
    fc88:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    fc8a:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
    fc8c:	bb3b      	cbnz	r3, fcde <rpmsg_virtio_send_offchannel_raw+0xaa>
		data = virtqueue_get_buffer(rvdev->svq, len, idx);
    fc8e:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    fc92:	f10d 0212 	add.w	r2, sp, #18
    fc96:	a905      	add	r1, sp, #20
    fc98:	f00c fec3 	bl	1ca22 <virtqueue_get_buffer>
		if (!data) {
    fc9c:	4605      	mov	r5, r0
    fc9e:	b948      	cbnz	r0, fcb4 <rpmsg_virtio_send_offchannel_raw+0x80>
			data = rpmsg_virtio_shm_pool_get_buffer(rvdev->shpool,
    fca0:	f44f 7100 	mov.w	r1, #512	; 0x200
    fca4:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
    fca8:	f00d f927 	bl	1cefa <rpmsg_virtio_shm_pool_get_buffer>
			*len = RPMSG_BUFFER_SIZE;
    fcac:	f44f 7300 	mov.w	r3, #512	; 0x200
			data = rpmsg_virtio_shm_pool_get_buffer(rvdev->shpool,
    fcb0:	4605      	mov	r5, r0
			*len = RPMSG_BUFFER_SIZE;
    fcb2:	9305      	str	r3, [sp, #20]
	k_sem_take(m, K_FOREVER);
}

static inline void __metal_mutex_release(metal_mutex_t *m)
{
	k_sem_give(m);
    fcb4:	4640      	mov	r0, r8
    fcb6:	f00d f859 	bl	1cd6c <k_sem_give>
			return RPMSG_ERR_BUFF_SIZE;
		}

		buffer = rpmsg_virtio_get_tx_buffer(rvdev, &buff_len, &idx);
		metal_mutex_release(&rdev->lock);
		if (buffer || !tick_count)
    fcba:	2d00      	cmp	r5, #0
    fcbc:	d157      	bne.n	fd6e <rpmsg_virtio_send_offchannel_raw+0x13a>
    fcbe:	2f00      	cmp	r7, #0
    fcc0:	d053      	beq.n	fd6a <rpmsg_virtio_send_offchannel_raw+0x136>
			break;
		if (avail_size != 0)
    fcc2:	f1b9 0f00 	cmp.w	r9, #0
    fcc6:	d108      	bne.n	fcda <rpmsg_virtio_send_offchannel_raw+0xa6>
			return RPMSG_ERR_BUFF_SIZE;
		metal_sleep_usec(RPMSG_TICKS_PER_INTERVAL);
		tick_count--;
    fcc8:	3f01      	subs	r7, #1
	while (1) {
    fcca:	e7ca      	b.n	fc62 <rpmsg_virtio_send_offchannel_raw+0x2e>
		length = RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr);
    fccc:	f44f 79f8 	mov.w	r9, #496	; 0x1f0
		if (avail_size && size > avail_size) {
    fcd0:	454e      	cmp	r6, r9
    fcd2:	ddd9      	ble.n	fc88 <rpmsg_virtio_send_offchannel_raw+0x54>
    fcd4:	4640      	mov	r0, r8
    fcd6:	f00d f849 	bl	1cd6c <k_sem_give>
			return RPMSG_ERR_BUFF_SIZE;
    fcda:	4e31      	ldr	r6, [pc, #196]	; (fda0 <rpmsg_virtio_send_offchannel_raw+0x16c>)
    fcdc:	e03f      	b.n	fd5e <rpmsg_virtio_send_offchannel_raw+0x12a>
	if (role == RPMSG_REMOTE) {
    fcde:	2b01      	cmp	r3, #1
    fce0:	d108      	bne.n	fcf4 <rpmsg_virtio_send_offchannel_raw+0xc0>
		data = virtqueue_get_available_buffer(rvdev->svq, idx, len);
    fce2:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    fce6:	aa05      	add	r2, sp, #20
    fce8:	f10d 0112 	add.w	r1, sp, #18
    fcec:	f00c fed3 	bl	1ca96 <virtqueue_get_available_buffer>
    fcf0:	4605      	mov	r5, r0
    fcf2:	e7df      	b.n	fcb4 <rpmsg_virtio_send_offchannel_raw+0x80>
	void *data = NULL;
    fcf4:	2500      	movs	r5, #0
    fcf6:	e7dd      	b.n	fcb4 <rpmsg_virtio_send_offchannel_raw+0x80>
    fcf8:	683b      	ldr	r3, [r7, #0]

	return (offset < io->size ? offset : METAL_BAD_OFFSET);
    fcfa:	68b8      	ldr	r0, [r7, #8]
	io = rvdev->shbuf_io;
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
				      &rp_hdr, sizeof(rp_hdr));
	RPMSG_ASSERT(status == sizeof(rp_hdr), "failed to write header\r\n");

	status = metal_io_block_write(io,
    fcfc:	f105 0110 	add.w	r1, r5, #16
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
    fd00:	1ac9      	subs	r1, r1, r3
    fd02:	4281      	cmp	r1, r0
    fd04:	bf28      	it	cs
    fd06:	f04f 31ff 	movcs.w	r1, #4294967295
    fd0a:	4633      	mov	r3, r6
    fd0c:	465a      	mov	r2, fp
    fd0e:	4638      	mov	r0, r7
    fd10:	f005 fbcd 	bl	154ae <metal_io_block_write>
				      metal_io_virt_to_offset(io,
						RPMSG_LOCATE_DATA(buffer)),
				      data, size);
	RPMSG_ASSERT(status == size, "failed to write buffer\r\n");
    fd14:	4286      	cmp	r6, r0
    fd16:	d000      	beq.n	fd1a <rpmsg_virtio_send_offchannel_raw+0xe6>
    fd18:	e7fe      	b.n	fd18 <rpmsg_virtio_send_offchannel_raw+0xe4>
    fd1a:	4640      	mov	r0, r8
    fd1c:	f00d f83e 	bl	1cd9c <__metal_mutex_acquire>
    fd20:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
	metal_mutex_acquire(&rdev->lock);

	/* Enqueue buffer on virtqueue. */
	status = rpmsg_virtio_enqueue_buffer(rvdev, buffer, buff_len, idx);
    fd22:	9a05      	ldr	r2, [sp, #20]
    fd24:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
    fd26:	b953      	cbnz	r3, fd3e <rpmsg_virtio_send_offchannel_raw+0x10a>
		vqbuf.len = len;
    fd28:	e9cd 5206 	strd	r5, r2, [sp, #24]
		return virtqueue_add_buffer(rvdev->svq, &vqbuf, 1, 0, buffer);
    fd2c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    fd30:	2201      	movs	r2, #1
    fd32:	9500      	str	r5, [sp, #0]
    fd34:	a906      	add	r1, sp, #24
    fd36:	f00c fe14 	bl	1c962 <virtqueue_add_buffer>
	RPMSG_ASSERT(status == VQUEUE_SUCCESS, "failed to enqueue buffer\r\n");
    fd3a:	b148      	cbz	r0, fd50 <rpmsg_virtio_send_offchannel_raw+0x11c>
    fd3c:	e7fe      	b.n	fd3c <rpmsg_virtio_send_offchannel_raw+0x108>
	if (role == RPMSG_REMOTE) {
    fd3e:	2b01      	cmp	r3, #1
    fd40:	d106      	bne.n	fd50 <rpmsg_virtio_send_offchannel_raw+0x11c>
		return virtqueue_add_consumed_buffer(rvdev->svq, idx, len);
    fd42:	f8bd 1012 	ldrh.w	r1, [sp, #18]
    fd46:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    fd4a:	f7ff fec7 	bl	fadc <virtqueue_add_consumed_buffer>
    fd4e:	e7f4      	b.n	fd3a <rpmsg_virtio_send_offchannel_raw+0x106>
	/* Let the other side know that there is a job to process. */
	virtqueue_kick(rvdev->svq);
    fd50:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    fd54:	f00c ff1e 	bl	1cb94 <virtqueue_kick>
    fd58:	4640      	mov	r0, r8
    fd5a:	f00d f807 	bl	1cd6c <k_sem_give>

	metal_mutex_release(&rdev->lock);

	return size;
}
    fd5e:	4630      	mov	r0, r6
    fd60:	b00d      	add	sp, #52	; 0x34
    fd62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return RPMSG_ERR_DEV_STATE;
    fd66:	4e0f      	ldr	r6, [pc, #60]	; (fda4 <rpmsg_virtio_send_offchannel_raw+0x170>)
    fd68:	e7f9      	b.n	fd5e <rpmsg_virtio_send_offchannel_raw+0x12a>
		return RPMSG_ERR_NO_BUFF;
    fd6a:	4e0f      	ldr	r6, [pc, #60]	; (fda8 <rpmsg_virtio_send_offchannel_raw+0x174>)
    fd6c:	e7f7      	b.n	fd5e <rpmsg_virtio_send_offchannel_raw+0x12a>
	rp_hdr.src = src;
    fd6e:	9b03      	ldr	r3, [sp, #12]
	io = rvdev->shbuf_io;
    fd70:	f8d4 7088 	ldr.w	r7, [r4, #136]	; 0x88
	rp_hdr.src = src;
    fd74:	9308      	str	r3, [sp, #32]
	rp_hdr.reserved = 0;
    fd76:	2300      	movs	r3, #0
    fd78:	6839      	ldr	r1, [r7, #0]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
    fd7a:	68b8      	ldr	r0, [r7, #8]
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
    fd7c:	1a69      	subs	r1, r5, r1
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
    fd7e:	4281      	cmp	r1, r0
    fd80:	bf28      	it	cs
    fd82:	f04f 31ff 	movcs.w	r1, #4294967295
	rp_hdr.reserved = 0;
    fd86:	930a      	str	r3, [sp, #40]	; 0x28
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
    fd88:	4638      	mov	r0, r7
    fd8a:	2310      	movs	r3, #16
    fd8c:	aa08      	add	r2, sp, #32
	rp_hdr.dst = dst;
    fd8e:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
	rp_hdr.len = size;
    fd92:	f8ad 602c 	strh.w	r6, [sp, #44]	; 0x2c
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
    fd96:	f005 fb8a 	bl	154ae <metal_io_block_write>
	RPMSG_ASSERT(status == sizeof(rp_hdr), "failed to write header\r\n");
    fd9a:	2810      	cmp	r0, #16
    fd9c:	d0ac      	beq.n	fcf8 <rpmsg_virtio_send_offchannel_raw+0xc4>
    fd9e:	e7fe      	b.n	fd9e <rpmsg_virtio_send_offchannel_raw+0x16a>
    fda0:	fffff82b 	.word	0xfffff82b
    fda4:	fffff82c 	.word	0xfffff82c
    fda8:	fffff82e 	.word	0xfffff82e

0000fdac <rpmsg_init_vdev>:
int rpmsg_init_vdev(struct rpmsg_virtio_device *rvdev,
		    struct virtio_device *vdev,
		    rpmsg_ns_bind_cb ns_bind_cb,
		    struct metal_io_region *shm_io,
		    struct rpmsg_virtio_shm_pool *shpool)
{
    fdac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    fdb0:	460d      	mov	r5, r1
    fdb2:	b088      	sub	sp, #32
    fdb4:	4617      	mov	r7, r2
__ssp_bos_icheck3(memset, void *, int)
    fdb6:	2100      	movs	r1, #0
    fdb8:	227c      	movs	r2, #124	; 0x7c
    fdba:	4604      	mov	r4, r0
    fdbc:	461e      	mov	r6, r3
    fdbe:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    fdc2:	f00d fddb 	bl	1d97c <memset>
	return z_impl_k_sem_init(sem, initial_count, limit);
    fdc6:	2201      	movs	r2, #1
    fdc8:	f104 0058 	add.w	r0, r4, #88	; 0x58
    fdcc:	4611      	mov	r1, r2
    fdce:	f00d fb1b 	bl	1d408 <z_impl_k_sem_init>
	memset(rdev, 0, sizeof(*rdev));
	metal_mutex_init(&rdev->lock);
	rvdev->vdev = vdev;
	rdev->ns_bind_cb = ns_bind_cb;
	vdev->priv = rvdev;
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
    fdd2:	4b5e      	ldr	r3, [pc, #376]	; (ff4c <rpmsg_init_vdev+0x1a0>)
	rvdev->vdev = vdev;
    fdd4:	67e5      	str	r5, [r4, #124]	; 0x7c
	rdev->ns_bind_cb = ns_bind_cb;
    fdd6:	6727      	str	r7, [r4, #112]	; 0x70
	vdev->priv = rvdev;
    fdd8:	626c      	str	r4, [r5, #36]	; 0x24
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
    fdda:	6763      	str	r3, [r4, #116]	; 0x74
    fddc:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    fdde:	f8d3 8018 	ldr.w	r8, [r3, #24]
	role = rpmsg_virtio_get_role(rvdev);

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
    fde2:	f1b8 0f01 	cmp.w	r8, #1
    fde6:	d020      	beq.n	fe2a <rpmsg_init_vdev+0x7e>
		/* wait synchro with the master */
		rpmsg_virtio_wait_remote_ready(rvdev);
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	vdev->features = rpmsg_virtio_get_features(rvdev);
    fde8:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
}

static inline uint32_t
rpmsg_virtio_get_features(struct rpmsg_virtio_device *rvdev)
{
	return rvdev->vdev->func->get_features(rvdev->vdev);
    fdea:	6a03      	ldr	r3, [r0, #32]
    fdec:	689b      	ldr	r3, [r3, #8]
    fdee:	4798      	blx	r3
    fdf0:	2300      	movs	r3, #0
    fdf2:	6128      	str	r0, [r5, #16]
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
    fdf4:	f000 0001 	and.w	r0, r0, #1
	vdev->features = rpmsg_virtio_get_features(rvdev);
    fdf8:	616b      	str	r3, [r5, #20]
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
    fdfa:	f884 0078 	strb.w	r0, [r4, #120]	; 0x78

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
    fdfe:	f1b8 0f00 	cmp.w	r8, #0
    fe02:	d01e      	beq.n	fe42 <rpmsg_init_vdev+0x96>
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	(void)shpool;
	if (role == RPMSG_REMOTE) {
    fe04:	f1b8 0f01 	cmp.w	r8, #1
    fe08:	d133      	bne.n	fe72 <rpmsg_init_vdev+0xc6>
		vq_names[0] = "tx_vq";
    fe0a:	4b51      	ldr	r3, [pc, #324]	; (ff50 <rpmsg_init_vdev+0x1a4>)
    fe0c:	9302      	str	r3, [sp, #8]
		vq_names[1] = "rx_vq";
    fe0e:	4b51      	ldr	r3, [pc, #324]	; (ff54 <rpmsg_init_vdev+0x1a8>)
    fe10:	9303      	str	r3, [sp, #12]
		callback[0] = rpmsg_virtio_tx_callback;
    fe12:	4b51      	ldr	r3, [pc, #324]	; (ff58 <rpmsg_init_vdev+0x1ac>)
    fe14:	9304      	str	r3, [sp, #16]
		callback[1] = rpmsg_virtio_rx_callback;
    fe16:	4b51      	ldr	r3, [pc, #324]	; (ff5c <rpmsg_init_vdev+0x1b0>)
    fe18:	9305      	str	r3, [sp, #20]
		rvdev->rvq  = vdev->vrings_info[1].vq;
    fe1a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    fe1c:	699a      	ldr	r2, [r3, #24]
		rvdev->svq  = vdev->vrings_info[0].vq;
    fe1e:	681b      	ldr	r3, [r3, #0]
		rvdev->rvq  = vdev->vrings_info[1].vq;
    fe20:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		rvdev->svq  = vdev->vrings_info[0].vq;
    fe24:	e023      	b.n	fe6e <rpmsg_init_vdev+0xc2>
		} else if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK) {
    fe26:	0743      	lsls	r3, r0, #29
    fe28:	d4de      	bmi.n	fde8 <rpmsg_init_vdev+0x3c>
		status = rpmsg_virtio_get_status(rvdev);
    fe2a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	return rvdev->vdev->func->get_status(rvdev->vdev);
    fe2c:	6a03      	ldr	r3, [r0, #32]
    fe2e:	681b      	ldr	r3, [r3, #0]
    fe30:	4798      	blx	r3
		if (status & VIRTIO_CONFIG_STATUS_NEEDS_RESET) {
    fe32:	0642      	lsls	r2, r0, #25
    fe34:	d5f7      	bpl.n	fe26 <rpmsg_init_vdev+0x7a>
			rpmsg_virtio_set_status(rvdev, 0);
    fe36:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	rvdev->vdev->func->set_status(rvdev->vdev, status);
    fe38:	2100      	movs	r1, #0
    fe3a:	6a03      	ldr	r3, [r0, #32]
    fe3c:	685b      	ldr	r3, [r3, #4]
    fe3e:	4798      	blx	r3
}
    fe40:	e7f3      	b.n	fe2a <rpmsg_init_vdev+0x7e>
		if (!shpool)
    fe42:	f1b9 0f00 	cmp.w	r9, #0
    fe46:	d07d      	beq.n	ff44 <rpmsg_init_vdev+0x198>
		if (!shpool->size)
    fe48:	f8d9 3008 	ldr.w	r3, [r9, #8]
    fe4c:	2b00      	cmp	r3, #0
    fe4e:	d07b      	beq.n	ff48 <rpmsg_init_vdev+0x19c>
		vq_names[0] = "rx_vq";
    fe50:	4b40      	ldr	r3, [pc, #256]	; (ff54 <rpmsg_init_vdev+0x1a8>)
		rvdev->shpool = shpool;
    fe52:	f8c4 908c 	str.w	r9, [r4, #140]	; 0x8c
		vq_names[0] = "rx_vq";
    fe56:	9302      	str	r3, [sp, #8]
		vq_names[1] = "tx_vq";
    fe58:	4b3d      	ldr	r3, [pc, #244]	; (ff50 <rpmsg_init_vdev+0x1a4>)
    fe5a:	9303      	str	r3, [sp, #12]
		callback[0] = rpmsg_virtio_rx_callback;
    fe5c:	4b3f      	ldr	r3, [pc, #252]	; (ff5c <rpmsg_init_vdev+0x1b0>)
    fe5e:	9304      	str	r3, [sp, #16]
		callback[1] = rpmsg_virtio_tx_callback;
    fe60:	4b3d      	ldr	r3, [pc, #244]	; (ff58 <rpmsg_init_vdev+0x1ac>)
    fe62:	9305      	str	r3, [sp, #20]
		rvdev->rvq  = vdev->vrings_info[0].vq;
    fe64:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    fe66:	681a      	ldr	r2, [r3, #0]
		rvdev->svq  = vdev->vrings_info[1].vq;
    fe68:	699b      	ldr	r3, [r3, #24]
		rvdev->rvq  = vdev->vrings_info[0].vq;
    fe6a:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		rvdev->svq  = vdev->vrings_info[0].vq;
    fe6e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
rpmsg_virtio_create_virtqueues(struct rpmsg_virtio_device *rvdev,
			       int flags, unsigned int nvqs,
			       const char *names[],
			       vq_callback *callbacks)
{
	return virtio_create_virtqueues(rvdev->vdev, flags, nvqs, names,
    fe72:	ab04      	add	r3, sp, #16
    fe74:	9300      	str	r3, [sp, #0]
    fe76:	2202      	movs	r2, #2
    fe78:	2100      	movs	r1, #0
    fe7a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	rvdev->shbuf_io = shm_io;
    fe7c:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
    fe80:	ab02      	add	r3, sp, #8
    fe82:	f7ff fddb 	bl	fa3c <virtio_create_virtqueues>

	/* Create virtqueues for remote device */
	status = rpmsg_virtio_create_virtqueues(rvdev, 0, RPMSG_NUM_VRINGS,
						vq_names, callback);
	if (status != RPMSG_SUCCESS)
    fe86:	4607      	mov	r7, r0
    fe88:	2800      	cmp	r0, #0
    fe8a:	d157      	bne.n	ff3c <rpmsg_init_vdev+0x190>

	/*
	 * Suppress "tx-complete" interrupts
	 * since send method use busy loop when buffer pool exhaust
	 */
	virtqueue_disable_cb(rvdev->svq);
    fe8c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    fe90:	f00c fe56 	bl	1cb40 <virtqueue_disable_cb>

	/* TODO: can have a virtio function to set the shared memory I/O */
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
		struct virtqueue *vq;

		vq = vdev->vrings_info[i].vq;
    fe94:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
		vq->shm_io = shm_io;
    fe96:	681a      	ldr	r2, [r3, #0]
    fe98:	699b      	ldr	r3, [r3, #24]
    fe9a:	6296      	str	r6, [r2, #40]	; 0x28
    fe9c:	629e      	str	r6, [r3, #40]	; 0x28
	}

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
    fe9e:	f1b8 0f00 	cmp.w	r8, #0
    fea2:	d108      	bne.n	feb6 <rpmsg_init_vdev+0x10a>
		struct virtqueue_buf vqbuf;
		unsigned int idx;
		void *buffer;

		vqbuf.len = RPMSG_BUFFER_SIZE;
    fea4:	f44f 7300 	mov.w	r3, #512	; 0x200
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
    fea8:	46c2      	mov	sl, r8
		vqbuf.len = RPMSG_BUFFER_SIZE;
    feaa:	9307      	str	r3, [sp, #28]
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
    feac:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    feb0:	895b      	ldrh	r3, [r3, #10]
    feb2:	4553      	cmp	r3, sl
    feb4:	d81f      	bhi.n	fef6 <rpmsg_init_vdev+0x14a>

	/*
	 * Create name service announcement endpoint if device supports name
	 * service announcement feature.
	 */
	if (rdev->support_ns) {
    feb6:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    feba:	e9c4 4400 	strd	r4, r4, [r4]
    febe:	b18b      	cbz	r3, fee4 <rpmsg_init_vdev+0x138>
		rpmsg_initialize_ept(&rdev->ns_ept, "NS",
    fec0:	f104 0308 	add.w	r3, r4, #8
__ssp_bos_icheck3_restrict(strncpy, char *, const char *)
    fec4:	2220      	movs	r2, #32
    fec6:	4926      	ldr	r1, [pc, #152]	; (ff60 <rpmsg_init_vdev+0x1b4>)
    fec8:	4618      	mov	r0, r3
    feca:	f00d fd79 	bl	1d9c0 <strncpy>
	ept->addr = src;
    fece:	2235      	movs	r2, #53	; 0x35
	ept->dest_addr = dest;
    fed0:	e9c4 220b 	strd	r2, r2, [r4, #44]	; 0x2c
	ept->cb = cb;
    fed4:	4a23      	ldr	r2, [pc, #140]	; (ff64 <rpmsg_init_vdev+0x1b8>)
				     RPMSG_NS_EPT_ADDR, RPMSG_NS_EPT_ADDR,
				     rpmsg_virtio_ns_callback, NULL);
		rpmsg_register_endpoint(rdev, &rdev->ns_ept);
    fed6:	4601      	mov	r1, r0
    fed8:	6362      	str	r2, [r4, #52]	; 0x34
	ept->ns_unbind_cb = ns_unbind_cb;
    feda:	2200      	movs	r2, #0
    fedc:	4620      	mov	r0, r4
    fede:	63a2      	str	r2, [r4, #56]	; 0x38
    fee0:	f00c ff22 	bl	1cd28 <rpmsg_register_endpoint>
	}

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER)
    fee4:	f1b8 0f00 	cmp.w	r8, #0
    fee8:	d128      	bne.n	ff3c <rpmsg_init_vdev+0x190>
		rpmsg_virtio_set_status(rvdev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
    feea:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	rvdev->vdev->func->set_status(rvdev->vdev, status);
    feec:	2104      	movs	r1, #4
    feee:	6a03      	ldr	r3, [r0, #32]
    fef0:	685b      	ldr	r3, [r3, #4]
    fef2:	4798      	blx	r3
}
    fef4:	e022      	b.n	ff3c <rpmsg_init_vdev+0x190>
			buffer = rpmsg_virtio_shm_pool_get_buffer(shpool,
    fef6:	f44f 7100 	mov.w	r1, #512	; 0x200
    fefa:	4648      	mov	r0, r9
    fefc:	f00c fffd 	bl	1cefa <rpmsg_virtio_shm_pool_get_buffer>
			if (!buffer) {
    ff00:	4605      	mov	r5, r0
    ff02:	b1c8      	cbz	r0, ff38 <rpmsg_init_vdev+0x18c>
    ff04:	6831      	ldr	r1, [r6, #0]
			vqbuf.buf = buffer;
    ff06:	9006      	str	r0, [sp, #24]
    ff08:	1a41      	subs	r1, r0, r1
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
    ff0a:	68b0      	ldr	r0, [r6, #8]
			metal_io_block_set(shm_io,
    ff0c:	f44f 7300 	mov.w	r3, #512	; 0x200
    ff10:	4281      	cmp	r1, r0
    ff12:	bf28      	it	cs
    ff14:	f04f 31ff 	movcs.w	r1, #4294967295
    ff18:	2200      	movs	r2, #0
    ff1a:	4630      	mov	r0, r6
    ff1c:	f005 fb02 	bl	15524 <metal_io_block_set>
				virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1,
    ff20:	2301      	movs	r3, #1
    ff22:	2200      	movs	r2, #0
    ff24:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
    ff28:	9500      	str	r5, [sp, #0]
    ff2a:	a906      	add	r1, sp, #24
    ff2c:	f00c fd19 	bl	1c962 <virtqueue_add_buffer>
			if (status != RPMSG_SUCCESS) {
    ff30:	b918      	cbnz	r0, ff3a <rpmsg_init_vdev+0x18e>
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
    ff32:	f10a 0a01 	add.w	sl, sl, #1
    ff36:	e7b9      	b.n	feac <rpmsg_init_vdev+0x100>
				return RPMSG_ERR_NO_BUFF;
    ff38:	480b      	ldr	r0, [pc, #44]	; (ff68 <rpmsg_init_vdev+0x1bc>)
    ff3a:	4607      	mov	r7, r0
#endif /*!VIRTIO_SLAVE_ONLY*/

	return status;
}
    ff3c:	4638      	mov	r0, r7
    ff3e:	b008      	add	sp, #32
    ff40:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			return RPMSG_ERR_PARAM;
    ff44:	4f09      	ldr	r7, [pc, #36]	; (ff6c <rpmsg_init_vdev+0x1c0>)
    ff46:	e7f9      	b.n	ff3c <rpmsg_init_vdev+0x190>
			return RPMSG_ERR_NO_BUFF;
    ff48:	4f07      	ldr	r7, [pc, #28]	; (ff68 <rpmsg_init_vdev+0x1bc>)
    ff4a:	e7f7      	b.n	ff3c <rpmsg_init_vdev+0x190>
    ff4c:	0000fc35 	.word	0x0000fc35
    ff50:	000442e4 	.word	0x000442e4
    ff54:	000442de 	.word	0x000442de
    ff58:	0001cd6b 	.word	0x0001cd6b
    ff5c:	0001ce3b 	.word	0x0001ce3b
    ff60:	000442ea 	.word	0x000442ea
    ff64:	0001cda9 	.word	0x0001cda9
    ff68:	fffff82e 	.word	0xfffff82e
    ff6c:	fffff82d 	.word	0xfffff82d

0000ff70 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    ff70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    ff72:	4b10      	ldr	r3, [pc, #64]	; (ffb4 <z_sys_init_run_level+0x44>)
			/* Initialization failed.
			 * Set the init status bit so device is not declared ready.
			 */
			sys_bitfield_set_bit(
				(mem_addr_t) __device_init_status_start,
				(dev - __device_start));
    ff74:	4f10      	ldr	r7, [pc, #64]	; (ffb8 <z_sys_init_run_level+0x48>)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    ff76:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    ff7a:	3001      	adds	r0, #1
    ff7c:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
    ff80:	42ae      	cmp	r6, r5
    ff82:	d800      	bhi.n	ff86 <z_sys_init_run_level+0x16>
		}
	}
}
    ff84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if ((entry->init(dev) != 0) && (dev != NULL)) {
    ff86:	e9d5 3400 	ldrd	r3, r4, [r5]
    ff8a:	4620      	mov	r0, r4
    ff8c:	4798      	blx	r3
    ff8e:	b170      	cbz	r0, ffae <z_sys_init_run_level+0x3e>
    ff90:	b16c      	cbz	r4, ffae <z_sys_init_run_level+0x3e>

static ALWAYS_INLINE void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;

	*(volatile uint32_t *)addr = temp | (1 << bit);
    ff92:	2301      	movs	r3, #1
				(dev - __device_start));
    ff94:	1be4      	subs	r4, r4, r7
	void sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)
{
	/* Doing memory offsets in terms of 32-bit values to prevent
	 * alignment issues
	 */
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ff96:	4a09      	ldr	r2, [pc, #36]	; (ffbc <z_sys_init_run_level+0x4c>)
    ff98:	1124      	asrs	r4, r4, #4
    ff9a:	0961      	lsrs	r1, r4, #5
	uint32_t temp = *(volatile uint32_t *)addr;
    ff9c:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ffa0:	f004 041f 	and.w	r4, r4, #31
	*(volatile uint32_t *)addr = temp | (1 << bit);
    ffa4:	fa03 f404 	lsl.w	r4, r3, r4
    ffa8:	4304      	orrs	r4, r0
    ffaa:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    ffae:	3508      	adds	r5, #8
    ffb0:	e7e6      	b.n	ff80 <z_sys_init_run_level+0x10>
    ffb2:	bf00      	nop
    ffb4:	0001f480 	.word	0x0001f480
    ffb8:	20000648 	.word	0x20000648
    ffbc:	20000708 	.word	0x20000708

0000ffc0 <z_device_ready>:

bool z_device_ready(const struct device *dev)
{
	/* Set bit indicates device failed initialization */
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
					(dev - __device_start)));
    ffc0:	4b08      	ldr	r3, [pc, #32]	; (ffe4 <z_device_ready+0x24>)
    ffc2:	1ac0      	subs	r0, r0, r3
    ffc4:	1100      	asrs	r0, r0, #4
}

static ALWAYS_INLINE
	int sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)
{
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ffc6:	4b08      	ldr	r3, [pc, #32]	; (ffe8 <z_device_ready+0x28>)
    ffc8:	0942      	lsrs	r2, r0, #5
	uint32_t temp = *(volatile uint32_t *)addr;
    ffca:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	return temp & (1 << bit);
    ffce:	2301      	movs	r3, #1
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ffd0:	f000 001f 	and.w	r0, r0, #31
	return temp & (1 << bit);
    ffd4:	fa03 f000 	lsl.w	r0, r3, r0
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
    ffd8:	4210      	tst	r0, r2
}
    ffda:	bf0c      	ite	eq
    ffdc:	4618      	moveq	r0, r3
    ffde:	2000      	movne	r0, #0
    ffe0:	4770      	bx	lr
    ffe2:	bf00      	nop
    ffe4:	20000648 	.word	0x20000648
    ffe8:	20000708 	.word	0x20000708

0000ffec <z_impl_device_get_binding>:
	for (dev = __device_start; dev != __device_end; dev++) {
    ffec:	4911      	ldr	r1, [pc, #68]	; (10034 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x34>)
{
    ffee:	b570      	push	{r4, r5, r6, lr}
    fff0:	4605      	mov	r5, r0
    fff2:	460e      	mov	r6, r1
	for (dev = __device_start; dev != __device_end; dev++) {
    fff4:	4c10      	ldr	r4, [pc, #64]	; (10038 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x38>)
    fff6:	428c      	cmp	r4, r1
    fff8:	d104      	bne.n	10004 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x4>
	for (dev = __device_start; dev != __device_end; dev++) {
    fffa:	4c0f      	ldr	r4, [pc, #60]	; (10038 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x38>)
    fffc:	42b4      	cmp	r4, r6
    fffe:	d10a      	bne.n	10016 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x16>
	return NULL;
   10000:	2400      	movs	r4, #0
   10002:	e014      	b.n	1002e <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x2e>
		if (z_device_ready(dev) && (dev->name == name)) {
   10004:	4620      	mov	r0, r4
   10006:	f7ff ffdb 	bl	ffc0 <z_device_ready>
   1000a:	b110      	cbz	r0, 10012 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x12>
   1000c:	6823      	ldr	r3, [r4, #0]
   1000e:	42ab      	cmp	r3, r5
   10010:	d00d      	beq.n	1002e <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x2e>
	for (dev = __device_start; dev != __device_end; dev++) {
   10012:	3410      	adds	r4, #16
   10014:	e7ef      	b.n	fff6 <z_impl_device_get_binding+0xa>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
   10016:	4620      	mov	r0, r4
   10018:	f7ff ffd2 	bl	ffc0 <z_device_ready>
   1001c:	b908      	cbnz	r0, 10022 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x22>
	for (dev = __device_start; dev != __device_end; dev++) {
   1001e:	3410      	adds	r4, #16
   10020:	e7ec      	b.n	fffc <z_impl_device_get_binding+0x10>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
   10022:	4628      	mov	r0, r5
   10024:	6821      	ldr	r1, [r4, #0]
   10026:	f7f0 fa13 	bl	450 <strcmp>
   1002a:	2800      	cmp	r0, #0
   1002c:	d1f7      	bne.n	1001e <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x1e>
}
   1002e:	4620      	mov	r0, r4
   10030:	bd70      	pop	{r4, r5, r6, pc}
   10032:	bf00      	nop
   10034:	20000708 	.word	0x20000708
   10038:	20000648 	.word	0x20000648

0001003c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *p1, void *unused2, void *unused3)
{
   1003c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1003e:	4605      	mov	r5, r0
		 */
		int key = arch_irq_lock();
		struct k_thread *to_abort = cpu->pending_abort;

		if (to_abort) {
			cpu->pending_abort = NULL;
   10040:	2700      	movs	r7, #0
		 * saves no power and does not improve latency.  But it's an
		 * API we need to honor...
		 */
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
#ifdef CONFIG_PM
		_kernel.idle = ticks;
   10042:	4e15      	ldr	r6, [pc, #84]	; (10098 <idle+0x5c>)
	__asm__ volatile(
   10044:	f04f 0220 	mov.w	r2, #32
   10048:	f3ef 8311 	mrs	r3, BASEPRI
   1004c:	f382 8811 	msr	BASEPRI, r2
   10050:	f3bf 8f6f 	isb	sy
		struct k_thread *to_abort = cpu->pending_abort;
   10054:	6928      	ldr	r0, [r5, #16]
		if (to_abort) {
   10056:	b188      	cbz	r0, 1007c <idle+0x40>
			cpu->pending_abort = NULL;
   10058:	612f      	str	r7, [r5, #16]
	__asm__ volatile(
   1005a:	f383 8811 	msr	BASEPRI, r3
   1005e:	f3bf 8f6f 	isb	sy
			z_thread_single_abort(to_abort);
   10062:	f000 fcc1 	bl	109e8 <z_thread_single_abort>
	__asm__ volatile(
   10066:	f04f 0320 	mov.w	r3, #32
   1006a:	f3ef 8011 	mrs	r0, BASEPRI
   1006e:	f383 8811 	msr	BASEPRI, r3
   10072:	f3bf 8f6f 	isb	sy
   10076:	f00d f8f5 	bl	1d264 <z_reschedule_irqlock>
			continue;
   1007a:	e7e3      	b.n	10044 <idle+0x8>
		int32_t ticks = z_get_next_timeout_expiry();
   1007c:	f00d fa65 	bl	1d54a <z_get_next_timeout_expiry>
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   10080:	2101      	movs	r1, #1
		int32_t ticks = z_get_next_timeout_expiry();
   10082:	4604      	mov	r4, r0
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   10084:	2802      	cmp	r0, #2
   10086:	bfd8      	it	le
   10088:	4608      	movle	r0, r1
   1008a:	f00d fa6e 	bl	1d56a <z_set_timeout_expiry>
		_kernel.idle = ticks;
   1008e:	6274      	str	r4, [r6, #36]	; 0x24
	arch_cpu_idle();
   10090:	f7f2 fc52 	bl	2938 <arch_cpu_idle>
}
   10094:	e7d6      	b.n	10044 <idle+0x8>
   10096:	bf00      	nop
   10098:	20025ec8 	.word	0x20025ec8

0001009c <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   1009c:	4802      	ldr	r0, [pc, #8]	; (100a8 <z_bss_zero+0xc>)
__ssp_bos_icheck3(memset, void *, int)
   1009e:	4a03      	ldr	r2, [pc, #12]	; (100ac <z_bss_zero+0x10>)
   100a0:	2100      	movs	r1, #0
   100a2:	1a12      	subs	r2, r2, r0
   100a4:	f00d bc6a 	b.w	1d97c <memset>
   100a8:	200009b0 	.word	0x200009b0
   100ac:	2002a07c 	.word	0x2002a07c

000100b0 <bg_thread_main>:
{
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	z_sys_post_kernel = true;
   100b0:	2201      	movs	r2, #1
{
   100b2:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   100b4:	4b09      	ldr	r3, [pc, #36]	; (100dc <bg_thread_main+0x2c>)

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   100b6:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   100b8:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   100ba:	f7ff ff59 	bl	ff70 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
   100be:	f001 f805 	bl	110cc <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   100c2:	2003      	movs	r0, #3
   100c4:	f7ff ff54 	bl	ff70 <z_sys_init_run_level>

	z_init_static_threads();
   100c8:	f000 ff28 	bl	10f1c <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   100cc:	f7f0 fe6c 	bl	da8 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   100d0:	4a03      	ldr	r2, [pc, #12]	; (100e0 <bg_thread_main+0x30>)
   100d2:	7b13      	ldrb	r3, [r2, #12]
   100d4:	f023 0301 	bic.w	r3, r3, #1
   100d8:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   100da:	bd08      	pop	{r3, pc}
   100dc:	2002a079 	.word	0x2002a079
   100e0:	200010e0 	.word	0x200010e0

000100e4 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   100e4:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   100e8:	4b34      	ldr	r3, [pc, #208]	; (101bc <z_cstart+0xd8>)
   100ea:	b0a9      	sub	sp, #164	; 0xa4
	uint32_t msp =
   100ec:	f503 6900 	add.w	r9, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   100f0:	f389 8808 	msr	MSP, r9
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   100f4:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   100f8:	2400      	movs	r4, #0
   100fa:	23e0      	movs	r3, #224	; 0xe0
   100fc:	4d30      	ldr	r5, [pc, #192]	; (101c0 <z_cstart+0xdc>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   100fe:	f04f 0b01 	mov.w	fp, #1
   10102:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   10106:	77ec      	strb	r4, [r5, #31]
   10108:	762c      	strb	r4, [r5, #24]
   1010a:	766c      	strb	r4, [r5, #25]
   1010c:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   1010e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	_kernel.ready_q.cache = &z_main_thread;
   10110:	4e2c      	ldr	r6, [pc, #176]	; (101c4 <z_cstart+0xe0>)
   10112:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   10116:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   10118:	f7f2 fd4a 	bl	2bb0 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   1011c:	f7f2 fc06 	bl	292c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   10120:	f04f 33ff 	mov.w	r3, #4294967295
   10124:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   10126:	62eb      	str	r3, [r5, #44]	; 0x2c
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
   10128:	f240 1301 	movw	r3, #257	; 0x101
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
   1012c:	4d26      	ldr	r5, [pc, #152]	; (101c8 <z_cstart+0xe4>)
	dummy_thread->base.user_options = K_ESSENTIAL;
   1012e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   10132:	ab06      	add	r3, sp, #24
   10134:	60ab      	str	r3, [r5, #8]

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   10136:	4620      	mov	r0, r4
	dummy_thread->stack_info.size = 0U;
   10138:	e9cd 4421 	strd	r4, r4, [sp, #132]	; 0x84
   1013c:	f7ff ff18 	bl	ff70 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   10140:	2001      	movs	r0, #1
   10142:	f7ff ff15 	bl	ff70 <z_sys_init_run_level>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   10146:	f8df a098 	ldr.w	sl, [pc, #152]	; 101e0 <z_cstart+0xfc>
	z_sched_init();
   1014a:	f000 fda1 	bl	10c90 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   1014e:	4b1f      	ldr	r3, [pc, #124]	; (101cc <z_cstart+0xe8>)
	_kernel.ready_q.cache = &z_main_thread;
   10150:	62ae      	str	r6, [r5, #40]	; 0x28
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   10152:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   10156:	491e      	ldr	r1, [pc, #120]	; (101d0 <z_cstart+0xec>)
   10158:	9305      	str	r3, [sp, #20]
   1015a:	4630      	mov	r0, r6
   1015c:	4653      	mov	r3, sl
   1015e:	e9cd 4b03 	strd	r4, fp, [sp, #12]
   10162:	e9cd 4401 	strd	r4, r4, [sp, #4]
   10166:	9400      	str	r4, [sp, #0]
   10168:	f000 fe7c 	bl	10e64 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1016c:	7b73      	ldrb	r3, [r6, #13]
   1016e:	4680      	mov	r8, r0
   10170:	f023 0304 	bic.w	r3, r3, #4
	z_ready_thread(&z_main_thread);
   10174:	4630      	mov	r0, r6
   10176:	7373      	strb	r3, [r6, #13]
   10178:	f00d f8b6 	bl	1d2e8 <z_ready_thread>
	z_setup_new_thread(thread, stack,
   1017c:	230f      	movs	r3, #15
   1017e:	4f15      	ldr	r7, [pc, #84]	; (101d4 <z_cstart+0xf0>)
   10180:	f44f 72a0 	mov.w	r2, #320	; 0x140
   10184:	e9cd 4302 	strd	r4, r3, [sp, #8]
   10188:	4913      	ldr	r1, [pc, #76]	; (101d8 <z_cstart+0xf4>)
   1018a:	4b14      	ldr	r3, [pc, #80]	; (101dc <z_cstart+0xf8>)
   1018c:	4638      	mov	r0, r7
   1018e:	e9cd b404 	strd	fp, r4, [sp, #16]
   10192:	e9cd 5400 	strd	r5, r4, [sp]
   10196:	f000 fe65 	bl	10e64 <z_setup_new_thread>
   1019a:	7b7b      	ldrb	r3, [r7, #13]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   1019c:	4652      	mov	r2, sl
   1019e:	f023 0304 	bic.w	r3, r3, #4
   101a2:	737b      	strb	r3, [r7, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   101a4:	f105 031c 	add.w	r3, r5, #28
   101a8:	4641      	mov	r1, r8
   101aa:	4630      	mov	r0, r6
	list->tail = (sys_dnode_t *)list;
   101ac:	e9c5 3307 	strd	r3, r3, [r5, #28]
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   101b0:	60ef      	str	r7, [r5, #12]
		_kernel.cpus[i].id = i;
   101b2:	762c      	strb	r4, [r5, #24]
		_kernel.cpus[i].irq_stack =
   101b4:	f8c5 9004 	str.w	r9, [r5, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   101b8:	f7f2 fb40 	bl	283c <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   101bc:	2002d2f0 	.word	0x2002d2f0
   101c0:	e000ed00 	.word	0xe000ed00
   101c4:	200010e0 	.word	0x200010e0
   101c8:	20025ec8 	.word	0x20025ec8
   101cc:	000442ed 	.word	0x000442ed
   101d0:	2002c1b0 	.word	0x2002c1b0
   101d4:	20001058 	.word	0x20001058
   101d8:	2002d1b0 	.word	0x2002d1b0
   101dc:	0001003d 	.word	0x0001003d
   101e0:	000100b1 	.word	0x000100b1

000101e4 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(const struct device *unused)
{
   101e4:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   101e6:	4c06      	ldr	r4, [pc, #24]	; (10200 <statics_init+0x1c>)
   101e8:	4d06      	ldr	r5, [pc, #24]	; (10204 <statics_init+0x20>)
   101ea:	42ac      	cmp	r4, r5
   101ec:	d301      	bcc.n	101f2 <statics_init+0xe>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
   101ee:	2000      	movs	r0, #0
   101f0:	bd38      	pop	{r3, r4, r5, pc}
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   101f2:	4620      	mov	r0, r4
   101f4:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   101f8:	f00c feaf 	bl	1cf5a <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   101fc:	3414      	adds	r4, #20
   101fe:	e7f4      	b.n	101ea <statics_init+0x6>
   10200:	200007cc 	.word	0x200007cc
   10204:	200007e0 	.word	0x200007e0

00010208 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
   10208:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   1020a:	4b0e      	ldr	r3, [pc, #56]	; (10244 <init_mem_slab_module+0x3c>)
   1020c:	4c0e      	ldr	r4, [pc, #56]	; (10248 <init_mem_slab_module+0x40>)
   1020e:	42a3      	cmp	r3, r4
   10210:	d301      	bcc.n	10216 <init_mem_slab_module+0xe>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   10212:	2000      	movs	r0, #0
	return rc;
}
   10214:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   10216:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   1021a:	ea41 0200 	orr.w	r2, r1, r0
   1021e:	f012 0203 	ands.w	r2, r2, #3
   10222:	d10b      	bne.n	1023c <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   10224:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   10226:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   10228:	42aa      	cmp	r2, r5
   1022a:	d101      	bne.n	10230 <init_mem_slab_module+0x28>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   1022c:	331c      	adds	r3, #28
   1022e:	e7ee      	b.n	1020e <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   10230:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   10232:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
   10234:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
   10236:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   10238:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   1023a:	e7f5      	b.n	10228 <init_mem_slab_module+0x20>
		return -EINVAL;
   1023c:	f06f 0015 	mvn.w	r0, #21
	return rc;
   10240:	e7e8      	b.n	10214 <init_mem_slab_module+0xc>
   10242:	bf00      	nop
   10244:	20000778 	.word	0x20000778
   10248:	200007cc 	.word	0x200007cc

0001024c <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   1024c:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   1024e:	460c      	mov	r4, r1
   10250:	4616      	mov	r6, r2
   10252:	461f      	mov	r7, r3
   10254:	f04f 0320 	mov.w	r3, #32
   10258:	f3ef 8111 	mrs	r1, BASEPRI
   1025c:	f383 8811 	msr	BASEPRI, r3
   10260:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   10264:	6943      	ldr	r3, [r0, #20]
   10266:	b15b      	cbz	r3, 10280 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
   10268:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   1026a:	681b      	ldr	r3, [r3, #0]
   1026c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   1026e:	6983      	ldr	r3, [r0, #24]
   10270:	3301      	adds	r3, #1
   10272:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   10274:	2000      	movs	r0, #0
	__asm__ volatile(
   10276:	f381 8811 	msr	BASEPRI, r1
   1027a:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   1027e:	e011      	b.n	102a4 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   10280:	ea56 0207 	orrs.w	r2, r6, r7
   10284:	d103      	bne.n	1028e <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
   10286:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   1028a:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   1028c:	e7f3      	b.n	10276 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   1028e:	4602      	mov	r2, r0
   10290:	e9cd 6700 	strd	r6, r7, [sp]
   10294:	4804      	ldr	r0, [pc, #16]	; (102a8 <k_mem_slab_alloc+0x5c>)
   10296:	f000 fc69 	bl	10b6c <z_pend_curr>
		if (result == 0) {
   1029a:	b918      	cbnz	r0, 102a4 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
   1029c:	4b03      	ldr	r3, [pc, #12]	; (102ac <k_mem_slab_alloc+0x60>)
   1029e:	689b      	ldr	r3, [r3, #8]
   102a0:	695b      	ldr	r3, [r3, #20]
   102a2:	6023      	str	r3, [r4, #0]
}
   102a4:	b002      	add	sp, #8
   102a6:	bdd0      	pop	{r4, r6, r7, pc}
   102a8:	2002a07a 	.word	0x2002a07a
   102ac:	20025ec8 	.word	0x20025ec8

000102b0 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   102b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   102b2:	4604      	mov	r4, r0
   102b4:	460d      	mov	r5, r1
	__asm__ volatile(
   102b6:	f04f 0320 	mov.w	r3, #32
   102ba:	f3ef 8611 	mrs	r6, BASEPRI
   102be:	f383 8811 	msr	BASEPRI, r3
   102c2:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (slab->free_list == NULL) {
   102c6:	6947      	ldr	r7, [r0, #20]
   102c8:	b977      	cbnz	r7, 102e8 <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   102ca:	f00d f868 	bl	1d39e <z_unpend_first_thread>

		if (pending_thread != NULL) {
   102ce:	b158      	cbz	r0, 102e8 <k_mem_slab_free+0x38>
			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   102d0:	682a      	ldr	r2, [r5, #0]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   102d2:	f8c0 7080 	str.w	r7, [r0, #128]	; 0x80
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   102d6:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   102d8:	f00d f806 	bl	1d2e8 <z_ready_thread>
			z_reschedule(&lock, key);
   102dc:	4631      	mov	r1, r6
	}
	**(char ***) mem = slab->free_list;
	slab->free_list = *(char **) mem;
	slab->num_used--;
	k_spin_unlock(&lock, key);
}
   102de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&lock, key);
   102e2:	4808      	ldr	r0, [pc, #32]	; (10304 <k_mem_slab_free+0x54>)
   102e4:	f000 b9fa 	b.w	106dc <z_reschedule>
	**(char ***) mem = slab->free_list;
   102e8:	682b      	ldr	r3, [r5, #0]
   102ea:	6962      	ldr	r2, [r4, #20]
   102ec:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   102ee:	682b      	ldr	r3, [r5, #0]
   102f0:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   102f2:	69a3      	ldr	r3, [r4, #24]
   102f4:	3b01      	subs	r3, #1
   102f6:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   102f8:	f386 8811 	msr	BASEPRI, r6
   102fc:	f3bf 8f6f 	isb	sy
}
   10300:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10302:	bf00      	nop
   10304:	2002a07a 	.word	0x2002a07a

00010308 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
   10308:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1030c:	4604      	mov	r4, r0
   1030e:	468a      	mov	sl, r1
   10310:	4616      	mov	r6, r2
   10312:	461f      	mov	r7, r3

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   10314:	f100 0908 	add.w	r9, r0, #8
	__asm__ volatile(
   10318:	f04f 0320 	mov.w	r3, #32
   1031c:	f3ef 8811 	mrs	r8, BASEPRI
   10320:	f383 8811 	msr	BASEPRI, r3
   10324:	f3bf 8f6f 	isb	sy

	if (msgq->used_msgs < msgq->max_msgs) {
   10328:	6a02      	ldr	r2, [r0, #32]
   1032a:	68c3      	ldr	r3, [r0, #12]
   1032c:	429a      	cmp	r2, r3
   1032e:	d22b      	bcs.n	10388 <z_impl_k_msgq_put+0x80>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   10330:	f00d f835 	bl	1d39e <z_unpend_first_thread>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   10334:	4651      	mov	r1, sl
		if (pending_thread != NULL) {
   10336:	4605      	mov	r5, r0
   10338:	68a2      	ldr	r2, [r4, #8]
   1033a:	b180      	cbz	r0, 1035e <z_impl_k_msgq_put+0x56>
   1033c:	2400      	movs	r4, #0
   1033e:	6940      	ldr	r0, [r0, #20]
   10340:	f00d fb0f 	bl	1d962 <memcpy>
			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   10344:	4628      	mov	r0, r5
   10346:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
   1034a:	f00c ffcd 	bl	1d2e8 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   1034e:	4648      	mov	r0, r9
   10350:	4641      	mov	r1, r8
   10352:	f000 f9c3 	bl	106dc <z_reschedule>
			return 0;
   10356:	4620      	mov	r0, r4
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   10358:	b002      	add	sp, #8
   1035a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1035e:	69e0      	ldr	r0, [r4, #28]
   10360:	f00d faff 	bl	1d962 <memcpy>
		result = 0;
   10364:	2000      	movs	r0, #0
			msgq->write_ptr += msgq->msg_size;
   10366:	69e3      	ldr	r3, [r4, #28]
   10368:	68a2      	ldr	r2, [r4, #8]
   1036a:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   1036c:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
   1036e:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
   10370:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   10372:	bf04      	itt	eq
   10374:	6923      	ldreq	r3, [r4, #16]
   10376:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
   10378:	6a23      	ldr	r3, [r4, #32]
   1037a:	3301      	adds	r3, #1
   1037c:	6223      	str	r3, [r4, #32]
	__asm__ volatile(
   1037e:	f388 8811 	msr	BASEPRI, r8
   10382:	f3bf 8f6f 	isb	sy
	return result;
   10386:	e7e7      	b.n	10358 <z_impl_k_msgq_put+0x50>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   10388:	ea56 0307 	orrs.w	r3, r6, r7
   1038c:	d00a      	beq.n	103a4 <z_impl_k_msgq_put+0x9c>
		_current->base.swap_data = (void *) data;
   1038e:	4b07      	ldr	r3, [pc, #28]	; (103ac <z_impl_k_msgq_put+0xa4>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   10390:	4602      	mov	r2, r0
		_current->base.swap_data = (void *) data;
   10392:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   10394:	4648      	mov	r0, r9
		_current->base.swap_data = (void *) data;
   10396:	6159      	str	r1, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   10398:	4641      	mov	r1, r8
   1039a:	e9cd 6700 	strd	r6, r7, [sp]
   1039e:	f000 fbe5 	bl	10b6c <z_pend_curr>
   103a2:	e7d9      	b.n	10358 <z_impl_k_msgq_put+0x50>
		result = -ENOMSG;
   103a4:	f06f 0022 	mvn.w	r0, #34	; 0x22
   103a8:	e7e9      	b.n	1037e <z_impl_k_msgq_put+0x76>
   103aa:	bf00      	nop
   103ac:	20025ec8 	.word	0x20025ec8

000103b0 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
   103b0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   103b4:	4604      	mov	r4, r0
   103b6:	4616      	mov	r6, r2
   103b8:	4608      	mov	r0, r1
   103ba:	461f      	mov	r7, r3

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   103bc:	f104 0908 	add.w	r9, r4, #8
	__asm__ volatile(
   103c0:	f04f 0320 	mov.w	r3, #32
   103c4:	f3ef 8811 	mrs	r8, BASEPRI
   103c8:	f383 8811 	msr	BASEPRI, r3
   103cc:	f3bf 8f6f 	isb	sy

	if (msgq->used_msgs > 0) {
   103d0:	6a23      	ldr	r3, [r4, #32]
   103d2:	2b00      	cmp	r3, #0
   103d4:	d034      	beq.n	10440 <z_impl_k_msgq_get+0x90>
   103d6:	68a2      	ldr	r2, [r4, #8]
   103d8:	69a1      	ldr	r1, [r4, #24]
   103da:	f00d fac2 	bl	1d962 <memcpy>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
   103de:	69a3      	ldr	r3, [r4, #24]
   103e0:	68a2      	ldr	r2, [r4, #8]
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   103e2:	4620      	mov	r0, r4
		msgq->read_ptr += msgq->msg_size;
   103e4:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
   103e6:	6962      	ldr	r2, [r4, #20]
		msgq->read_ptr += msgq->msg_size;
   103e8:	61a3      	str	r3, [r4, #24]
		if (msgq->read_ptr == msgq->buffer_end) {
   103ea:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
   103ec:	bf04      	itt	eq
   103ee:	6923      	ldreq	r3, [r4, #16]
   103f0:	61a3      	streq	r3, [r4, #24]
		msgq->used_msgs--;
   103f2:	6a23      	ldr	r3, [r4, #32]
   103f4:	3b01      	subs	r3, #1
   103f6:	6223      	str	r3, [r4, #32]
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   103f8:	f00c ffd1 	bl	1d39e <z_unpend_first_thread>
		if (pending_thread != NULL) {
   103fc:	4605      	mov	r5, r0
   103fe:	2800      	cmp	r0, #0
   10400:	d02e      	beq.n	10460 <z_impl_k_msgq_get+0xb0>
   10402:	6941      	ldr	r1, [r0, #20]
   10404:	68a2      	ldr	r2, [r4, #8]
   10406:	69e0      	ldr	r0, [r4, #28]
   10408:	f00d faab 	bl	1d962 <memcpy>
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   1040c:	69e3      	ldr	r3, [r4, #28]
   1040e:	68a2      	ldr	r2, [r4, #8]
			}
			msgq->used_msgs++;

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   10410:	4628      	mov	r0, r5
			msgq->write_ptr += msgq->msg_size;
   10412:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   10414:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
   10416:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
   10418:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   1041a:	bf04      	itt	eq
   1041c:	6923      	ldreq	r3, [r4, #16]
   1041e:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
   10420:	6a23      	ldr	r3, [r4, #32]
   10422:	3301      	adds	r3, #1
   10424:	6223      	str	r3, [r4, #32]
   10426:	2400      	movs	r4, #0
   10428:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
			z_ready_thread(pending_thread);
   1042c:	f00c ff5c 	bl	1d2e8 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   10430:	4648      	mov	r0, r9
   10432:	4641      	mov	r1, r8
   10434:	f000 f952 	bl	106dc <z_reschedule>
			return 0;
   10438:	4620      	mov	r0, r4
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   1043a:	b003      	add	sp, #12
   1043c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   10440:	ea56 0307 	orrs.w	r3, r6, r7
   10444:	d00a      	beq.n	1045c <z_impl_k_msgq_get+0xac>
		_current->base.swap_data = data;
   10446:	4b09      	ldr	r3, [pc, #36]	; (1046c <z_impl_k_msgq_get+0xbc>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   10448:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   1044a:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   1044c:	4648      	mov	r0, r9
		_current->base.swap_data = data;
   1044e:	6159      	str	r1, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   10450:	4641      	mov	r1, r8
   10452:	e9cd 6700 	strd	r6, r7, [sp]
   10456:	f000 fb89 	bl	10b6c <z_pend_curr>
   1045a:	e7ee      	b.n	1043a <z_impl_k_msgq_get+0x8a>
		result = -ENOMSG;
   1045c:	f06f 0022 	mvn.w	r0, #34	; 0x22
	__asm__ volatile(
   10460:	f388 8811 	msr	BASEPRI, r8
   10464:	f3bf 8f6f 	isb	sy
	return result;
   10468:	e7e7      	b.n	1043a <z_impl_k_msgq_get+0x8a>
   1046a:	bf00      	nop
   1046c:	20025ec8 	.word	0x20025ec8

00010470 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   10470:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   10474:	4604      	mov	r4, r0
   10476:	4616      	mov	r6, r2
   10478:	461f      	mov	r7, r3
	__asm__ volatile(
   1047a:	f04f 0320 	mov.w	r3, #32
   1047e:	f3ef 8811 	mrs	r8, BASEPRI
   10482:	f383 8811 	msr	BASEPRI, r3
   10486:	f3bf 8f6f 	isb	sy
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	sys_trace_mutex_lock(mutex);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   1048a:	68c3      	ldr	r3, [r0, #12]
   1048c:	4a32      	ldr	r2, [pc, #200]	; (10558 <z_impl_k_mutex_lock+0xe8>)
   1048e:	b16b      	cbz	r3, 104ac <z_impl_k_mutex_lock+0x3c>
   10490:	6880      	ldr	r0, [r0, #8]
   10492:	6891      	ldr	r1, [r2, #8]
   10494:	4288      	cmp	r0, r1
   10496:	d019      	beq.n	104cc <z_impl_k_mutex_lock+0x5c>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   10498:	ea56 0307 	orrs.w	r3, r6, r7
   1049c:	d118      	bne.n	104d0 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   1049e:	f388 8811 	msr	BASEPRI, r8
   104a2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   104a6:	f06f 000f 	mvn.w	r0, #15
   104aa:	e00c      	b.n	104c6 <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   104ac:	6891      	ldr	r1, [r2, #8]
   104ae:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   104b2:	3301      	adds	r3, #1
   104b4:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   104b6:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   104b8:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   104ba:	60a3      	str	r3, [r4, #8]
   104bc:	f388 8811 	msr	BASEPRI, r8
   104c0:	f3bf 8f6f 	isb	sy
		return 0;
   104c4:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   104c6:	b002      	add	sp, #8
   104c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   104cc:	6921      	ldr	r1, [r4, #16]
   104ce:	e7f0      	b.n	104b2 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   104d0:	f990 300e 	ldrsb.w	r3, [r0, #14]
   104d4:	f991 100e 	ldrsb.w	r1, [r1, #14]
   104d8:	4299      	cmp	r1, r3
   104da:	bfa8      	it	ge
   104dc:	4619      	movge	r1, r3
   104de:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   104e2:	4299      	cmp	r1, r3
   104e4:	da2c      	bge.n	10540 <z_impl_k_mutex_lock+0xd0>
		return z_set_prio(mutex->owner, new_prio);
   104e6:	f000 fb8f 	bl	10c08 <z_set_prio>
   104ea:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   104ec:	4622      	mov	r2, r4
   104ee:	4641      	mov	r1, r8
   104f0:	e9cd 6700 	strd	r6, r7, [sp]
   104f4:	4819      	ldr	r0, [pc, #100]	; (1055c <z_impl_k_mutex_lock+0xec>)
   104f6:	f000 fb39 	bl	10b6c <z_pend_curr>
	if (got_mutex == 0) {
   104fa:	2800      	cmp	r0, #0
   104fc:	d0e3      	beq.n	104c6 <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   104fe:	f04f 0320 	mov.w	r3, #32
   10502:	f3ef 8611 	mrs	r6, BASEPRI
   10506:	f383 8811 	msr	BASEPRI, r3
   1050a:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   1050e:	6823      	ldr	r3, [r4, #0]
   10510:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   10512:	42a3      	cmp	r3, r4
   10514:	d007      	beq.n	10526 <z_impl_k_mutex_lock+0xb6>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   10516:	b133      	cbz	r3, 10526 <z_impl_k_mutex_lock+0xb6>
   10518:	f993 300e 	ldrsb.w	r3, [r3, #14]
   1051c:	4299      	cmp	r1, r3
   1051e:	bfa8      	it	ge
   10520:	4619      	movge	r1, r3
   10522:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   10526:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   10528:	f990 300e 	ldrsb.w	r3, [r0, #14]
   1052c:	4299      	cmp	r1, r3
   1052e:	d109      	bne.n	10544 <z_impl_k_mutex_lock+0xd4>
	if (resched) {
   10530:	b16d      	cbz	r5, 1054e <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
   10532:	4631      	mov	r1, r6
   10534:	4809      	ldr	r0, [pc, #36]	; (1055c <z_impl_k_mutex_lock+0xec>)
   10536:	f000 f8d1 	bl	106dc <z_reschedule>
	return -EAGAIN;
   1053a:	f06f 000a 	mvn.w	r0, #10
   1053e:	e7c2      	b.n	104c6 <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   10540:	2500      	movs	r5, #0
   10542:	e7d3      	b.n	104ec <z_impl_k_mutex_lock+0x7c>
		return z_set_prio(mutex->owner, new_prio);
   10544:	f000 fb60 	bl	10c08 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   10548:	2800      	cmp	r0, #0
   1054a:	d1f2      	bne.n	10532 <z_impl_k_mutex_lock+0xc2>
   1054c:	e7f0      	b.n	10530 <z_impl_k_mutex_lock+0xc0>
	__asm__ volatile(
   1054e:	f386 8811 	msr	BASEPRI, r6
   10552:	f3bf 8f6f 	isb	sy
   10556:	e7f0      	b.n	1053a <z_impl_k_mutex_lock+0xca>
   10558:	20025ec8 	.word	0x20025ec8
   1055c:	2002a07a 	.word	0x2002a07a

00010560 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   10560:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	CHECKIF(mutex->owner == NULL) {
   10562:	6883      	ldr	r3, [r0, #8]
{
   10564:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   10566:	2b00      	cmp	r3, #0
   10568:	d037      	beq.n	105da <z_impl_k_mutex_unlock+0x7a>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   1056a:	4a1f      	ldr	r2, [pc, #124]	; (105e8 <z_impl_k_mutex_unlock+0x88>)
   1056c:	6892      	ldr	r2, [r2, #8]
   1056e:	4293      	cmp	r3, r2
   10570:	d136      	bne.n	105e0 <z_impl_k_mutex_unlock+0x80>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
   10572:	7bda      	ldrb	r2, [r3, #15]
   10574:	3a01      	subs	r2, #1
   10576:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   10578:	68c3      	ldr	r3, [r0, #12]
   1057a:	2b01      	cmp	r3, #1
   1057c:	d005      	beq.n	1058a <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   1057e:	3b01      	subs	r3, #1
   10580:	60c3      	str	r3, [r0, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   10582:	f000 f90f 	bl	107a4 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
   10586:	2000      	movs	r0, #0
}
   10588:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   1058a:	f04f 0320 	mov.w	r3, #32
   1058e:	f3ef 8511 	mrs	r5, BASEPRI
   10592:	f383 8811 	msr	BASEPRI, r3
   10596:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   1059a:	6901      	ldr	r1, [r0, #16]
   1059c:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   1059e:	f990 300e 	ldrsb.w	r3, [r0, #14]
   105a2:	4299      	cmp	r1, r3
   105a4:	d001      	beq.n	105aa <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   105a6:	f000 fb2f 	bl	10c08 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   105aa:	4620      	mov	r0, r4
   105ac:	f00c fef7 	bl	1d39e <z_unpend_first_thread>
	mutex->owner = new_owner;
   105b0:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   105b2:	b160      	cbz	r0, 105ce <z_impl_k_mutex_unlock+0x6e>
		mutex->owner_orig_prio = new_owner->base.prio;
   105b4:	f990 200e 	ldrsb.w	r2, [r0, #14]
   105b8:	6122      	str	r2, [r4, #16]
   105ba:	2200      	movs	r2, #0
   105bc:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		z_ready_thread(new_owner);
   105c0:	f00c fe92 	bl	1d2e8 <z_ready_thread>
		z_reschedule(&lock, key);
   105c4:	4629      	mov	r1, r5
   105c6:	4809      	ldr	r0, [pc, #36]	; (105ec <z_impl_k_mutex_unlock+0x8c>)
   105c8:	f000 f888 	bl	106dc <z_reschedule>
   105cc:	e7d9      	b.n	10582 <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   105ce:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   105d0:	f385 8811 	msr	BASEPRI, r5
   105d4:	f3bf 8f6f 	isb	sy
   105d8:	e7d3      	b.n	10582 <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   105da:	f06f 0015 	mvn.w	r0, #21
   105de:	e7d3      	b.n	10588 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   105e0:	f04f 30ff 	mov.w	r0, #4294967295
   105e4:	e7d0      	b.n	10588 <z_impl_k_mutex_unlock+0x28>
   105e6:	bf00      	nop
   105e8:	20025ec8 	.word	0x20025ec8
   105ec:	2002a07a 	.word	0x2002a07a

000105f0 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   105f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   105f2:	4616      	mov	r6, r2
   105f4:	461f      	mov	r7, r3
	__asm__ volatile(
   105f6:	f04f 0320 	mov.w	r3, #32
   105fa:	f3ef 8511 	mrs	r5, BASEPRI
   105fe:	f383 8811 	msr	BASEPRI, r3
   10602:	f3bf 8f6f 	isb	sy
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
   10606:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   10608:	b19c      	cbz	r4, 10632 <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1060a:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   1060c:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1060e:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   10612:	4294      	cmp	r4, r2
	list->head = node;
   10614:	6003      	str	r3, [r0, #0]
	list->tail = node;
   10616:	bf08      	it	eq
   10618:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   1061a:	2101      	movs	r1, #1
   1061c:	4620      	mov	r0, r4
   1061e:	f00c fd8f 	bl	1d140 <z_queue_node_peek>
   10622:	4604      	mov	r4, r0
	__asm__ volatile(
   10624:	f385 8811 	msr	BASEPRI, r5
   10628:	f3bf 8f6f 	isb	sy
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   1062c:	4620      	mov	r0, r4
   1062e:	b003      	add	sp, #12
   10630:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   10632:	ea56 0307 	orrs.w	r3, r6, r7
   10636:	d0f5      	beq.n	10624 <z_impl_k_queue_get+0x34>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   10638:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   1063c:	4629      	mov	r1, r5
   1063e:	4610      	mov	r0, r2
   10640:	e9cd 6700 	strd	r6, r7, [sp]
   10644:	f000 fa92 	bl	10b6c <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   10648:	2800      	cmp	r0, #0
   1064a:	d1ef      	bne.n	1062c <z_impl_k_queue_get+0x3c>
   1064c:	4b01      	ldr	r3, [pc, #4]	; (10654 <z_impl_k_queue_get+0x64>)
   1064e:	689b      	ldr	r3, [r3, #8]
   10650:	695c      	ldr	r4, [r3, #20]
   10652:	e7eb      	b.n	1062c <z_impl_k_queue_get+0x3c>
   10654:	20025ec8 	.word	0x20025ec8

00010658 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   10658:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   1065a:	4c08      	ldr	r4, [pc, #32]	; (1067c <z_reset_time_slice+0x24>)
   1065c:	6823      	ldr	r3, [r4, #0]
   1065e:	b15b      	cbz	r3, 10678 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   10660:	f7f1 fd7a 	bl	2158 <z_clock_elapsed>
   10664:	4603      	mov	r3, r0
   10666:	6820      	ldr	r0, [r4, #0]
   10668:	4a05      	ldr	r2, [pc, #20]	; (10680 <z_reset_time_slice+0x28>)
   1066a:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
   1066c:	2100      	movs	r1, #0
	}
}
   1066e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   10672:	6153      	str	r3, [r2, #20]
		z_set_timeout_expiry(slice_time, false);
   10674:	f00c bf79 	b.w	1d56a <z_set_timeout_expiry>
}
   10678:	bd10      	pop	{r4, pc}
   1067a:	bf00      	nop
   1067c:	20025f04 	.word	0x20025f04
   10680:	20025ec8 	.word	0x20025ec8

00010684 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   10684:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10686:	4605      	mov	r5, r0
   10688:	460c      	mov	r4, r1
	__asm__ volatile(
   1068a:	f04f 0320 	mov.w	r3, #32
   1068e:	f3ef 8611 	mrs	r6, BASEPRI
   10692:	f383 8811 	msr	BASEPRI, r3
   10696:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   1069a:	2200      	movs	r2, #0
			return (uint32_t)((t * to_hz + off) / from_hz);
   1069c:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   106a0:	f240 30e7 	movw	r0, #999	; 0x3e7
   106a4:	2100      	movs	r1, #0
   106a6:	4b0a      	ldr	r3, [pc, #40]	; (106d0 <k_sched_time_slice_set+0x4c>)
   106a8:	fbe7 0105 	umlal	r0, r1, r7, r5
   106ac:	615a      	str	r2, [r3, #20]
   106ae:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   106b2:	2300      	movs	r3, #0
   106b4:	f7ef fd4e 	bl	154 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   106b8:	4b06      	ldr	r3, [pc, #24]	; (106d4 <k_sched_time_slice_set+0x50>)
   106ba:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   106bc:	4b06      	ldr	r3, [pc, #24]	; (106d8 <k_sched_time_slice_set+0x54>)
   106be:	601c      	str	r4, [r3, #0]
		z_reset_time_slice();
   106c0:	f7ff ffca 	bl	10658 <z_reset_time_slice>
	__asm__ volatile(
   106c4:	f386 8811 	msr	BASEPRI, r6
   106c8:	f3bf 8f6f 	isb	sy
	}
}
   106cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   106ce:	bf00      	nop
   106d0:	20025ec8 	.word	0x20025ec8
   106d4:	20025f04 	.word	0x20025f04
   106d8:	20025f00 	.word	0x20025f00

000106dc <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   106dc:	b949      	cbnz	r1, 106f2 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   106de:	f3ef 8005 	mrs	r0, IPSR
   106e2:	b930      	cbnz	r0, 106f2 <z_reschedule+0x16>
	return _kernel.ready_q.cache;
   106e4:	4b05      	ldr	r3, [pc, #20]	; (106fc <z_reschedule+0x20>)
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   106e6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   106e8:	689b      	ldr	r3, [r3, #8]
   106ea:	429a      	cmp	r2, r3
   106ec:	d001      	beq.n	106f2 <z_reschedule+0x16>
	ret = arch_swap(key);
   106ee:	f7f2 b839 	b.w	2764 <arch_swap>
   106f2:	f381 8811 	msr	BASEPRI, r1
   106f6:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   106fa:	4770      	bx	lr
   106fc:	20025ec8 	.word	0x20025ec8

00010700 <k_sched_lock>:
	__asm__ volatile(
   10700:	f04f 0320 	mov.w	r3, #32
   10704:	f3ef 8111 	mrs	r1, BASEPRI
   10708:	f383 8811 	msr	BASEPRI, r3
   1070c:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   10710:	4b04      	ldr	r3, [pc, #16]	; (10724 <k_sched_lock+0x24>)
   10712:	689a      	ldr	r2, [r3, #8]
   10714:	7bd3      	ldrb	r3, [r2, #15]
   10716:	3b01      	subs	r3, #1
   10718:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   1071a:	f381 8811 	msr	BASEPRI, r1
   1071e:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   10722:	4770      	bx	lr
   10724:	20025ec8 	.word	0x20025ec8

00010728 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   10728:	4b09      	ldr	r3, [pc, #36]	; (10750 <z_priq_dumb_remove+0x28>)
   1072a:	f103 022c 	add.w	r2, r3, #44	; 0x2c
   1072e:	4282      	cmp	r2, r0
   10730:	d105      	bne.n	1073e <z_priq_dumb_remove+0x16>
   10732:	689b      	ldr	r3, [r3, #8]
   10734:	428b      	cmp	r3, r1
   10736:	d102      	bne.n	1073e <z_priq_dumb_remove+0x16>
   10738:	7b4b      	ldrb	r3, [r1, #13]
   1073a:	06db      	lsls	r3, r3, #27
   1073c:	d106      	bne.n	1074c <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   1073e:	e9d1 3200 	ldrd	r3, r2, [r1]
   10742:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   10744:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   10746:	2300      	movs	r3, #0
	node->prev = NULL;
   10748:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   1074c:	4770      	bx	lr
   1074e:	bf00      	nop
   10750:	20025ec8 	.word	0x20025ec8

00010754 <update_cache>:
{
   10754:	b538      	push	{r3, r4, r5, lr}
   10756:	4c12      	ldr	r4, [pc, #72]	; (107a0 <update_cache+0x4c>)
   10758:	4601      	mov	r1, r0
	if (_current_cpu->pending_abort != NULL) {
   1075a:	6923      	ldr	r3, [r4, #16]
   1075c:	68a2      	ldr	r2, [r4, #8]
   1075e:	b10b      	cbz	r3, 10764 <update_cache+0x10>
	return thread ? thread : _current_cpu->idle_thread;
   10760:	68e5      	ldr	r5, [r4, #12]
   10762:	e00c      	b.n	1077e <update_cache+0x2a>
	thread = _priq_run_best(&_kernel.ready_q.runq);
   10764:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   10768:	f00c fdb4 	bl	1d2d4 <z_priq_dumb_best>
   1076c:	4605      	mov	r5, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
   1076e:	7b53      	ldrb	r3, [r2, #13]
   10770:	0698      	lsls	r0, r3, #26
		_current->base.thread_state |= _THREAD_DEAD;
   10772:	bf44      	itt	mi
   10774:	f043 0308 	orrmi.w	r3, r3, #8
   10778:	7353      	strbmi	r3, [r2, #13]
	return thread ? thread : _current_cpu->idle_thread;
   1077a:	2d00      	cmp	r5, #0
   1077c:	d0f0      	beq.n	10760 <update_cache+0xc>
	if (preempt_ok != 0) {
   1077e:	b949      	cbnz	r1, 10794 <update_cache+0x40>
	if (z_is_thread_prevented_from_running(_current)) {
   10780:	7b53      	ldrb	r3, [r2, #13]
   10782:	06db      	lsls	r3, r3, #27
   10784:	d106      	bne.n	10794 <update_cache+0x40>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   10786:	69ab      	ldr	r3, [r5, #24]
   10788:	b923      	cbnz	r3, 10794 <update_cache+0x40>
	if (is_preempt(_current) || is_metairq(thread)) {
   1078a:	89d3      	ldrh	r3, [r2, #14]
   1078c:	2b7f      	cmp	r3, #127	; 0x7f
   1078e:	d901      	bls.n	10794 <update_cache+0x40>
		_kernel.ready_q.cache = _current;
   10790:	62a2      	str	r2, [r4, #40]	; 0x28
}
   10792:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   10794:	4295      	cmp	r5, r2
   10796:	d001      	beq.n	1079c <update_cache+0x48>
			z_reset_time_slice();
   10798:	f7ff ff5e 	bl	10658 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   1079c:	62a5      	str	r5, [r4, #40]	; 0x28
}
   1079e:	e7f8      	b.n	10792 <update_cache+0x3e>
   107a0:	20025ec8 	.word	0x20025ec8

000107a4 <k_sched_unlock>:
{
   107a4:	b510      	push	{r4, lr}
	__asm__ volatile(
   107a6:	f04f 0320 	mov.w	r3, #32
   107aa:	f3ef 8411 	mrs	r4, BASEPRI
   107ae:	f383 8811 	msr	BASEPRI, r3
   107b2:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   107b6:	4b08      	ldr	r3, [pc, #32]	; (107d8 <k_sched_unlock+0x34>)
		update_cache(0);
   107b8:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   107ba:	689a      	ldr	r2, [r3, #8]
   107bc:	7bd3      	ldrb	r3, [r2, #15]
   107be:	3301      	adds	r3, #1
   107c0:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   107c2:	f7ff ffc7 	bl	10754 <update_cache>
	__asm__ volatile(
   107c6:	f384 8811 	msr	BASEPRI, r4
   107ca:	f3bf 8f6f 	isb	sy
}
   107ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   107d2:	f00c bd53 	b.w	1d27c <z_reschedule_unlocked>
   107d6:	bf00      	nop
   107d8:	20025ec8 	.word	0x20025ec8

000107dc <ready_thread>:
{
   107dc:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   107de:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   107e2:	7b43      	ldrb	r3, [r0, #13]
   107e4:	2a00      	cmp	r2, #0
   107e6:	db2c      	blt.n	10842 <ready_thread+0x66>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   107e8:	06db      	lsls	r3, r3, #27
   107ea:	d12a      	bne.n	10842 <ready_thread+0x66>

int z_abort_timeout(struct _timeout *to);

static inline bool z_is_inactive_timeout(const struct _timeout *t)
{
	return !sys_dnode_is_linked(&t->node);
   107ec:	6983      	ldr	r3, [r0, #24]
   107ee:	bb43      	cbnz	r3, 10842 <ready_thread+0x66>
	return list->head == list;
   107f0:	4a15      	ldr	r2, [pc, #84]	; (10848 <ready_thread+0x6c>)
   107f2:	4611      	mov	r1, r2
   107f4:	f851 4f2c 	ldr.w	r4, [r1, #44]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   107f8:	428c      	cmp	r4, r1
   107fa:	bf18      	it	ne
   107fc:	4623      	movne	r3, r4
   107fe:	2b00      	cmp	r3, #0
   10800:	bf38      	it	cc
   10802:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   10804:	6b14      	ldr	r4, [r2, #48]	; 0x30
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10806:	b1b3      	cbz	r3, 10836 <ready_thread+0x5a>
	if (thread_1->base.prio < thread_2->base.prio) {
   10808:	f990 600e 	ldrsb.w	r6, [r0, #14]
   1080c:	f993 500e 	ldrsb.w	r5, [r3, #14]
   10810:	42ae      	cmp	r6, r5
   10812:	db03      	blt.n	1081c <ready_thread+0x40>
	return (node == list->tail) ? NULL : node->next;
   10814:	42a3      	cmp	r3, r4
   10816:	d00e      	beq.n	10836 <ready_thread+0x5a>
   10818:	681b      	ldr	r3, [r3, #0]
   1081a:	e7f4      	b.n	10806 <ready_thread+0x2a>
	node->prev = successor->prev;
   1081c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1081e:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
   10822:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   10824:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
   10826:	7b43      	ldrb	r3, [r0, #13]
   10828:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1082c:	7343      	strb	r3, [r0, #13]
}
   1082e:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   10830:	2000      	movs	r0, #0
   10832:	f7ff bf8f 	b.w	10754 <update_cache>
	node->prev = list->tail;
   10836:	e9c0 1400 	strd	r1, r4, [r0]
	list->tail->next = node;
   1083a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   1083c:	6018      	str	r0, [r3, #0]
	list->tail = node;
   1083e:	6310      	str	r0, [r2, #48]	; 0x30
}
   10840:	e7f1      	b.n	10826 <ready_thread+0x4a>
}
   10842:	bc70      	pop	{r4, r5, r6}
   10844:	4770      	bx	lr
   10846:	bf00      	nop
   10848:	20025ec8 	.word	0x20025ec8

0001084c <z_sched_start>:
{
   1084c:	b510      	push	{r4, lr}
	__asm__ volatile(
   1084e:	f04f 0220 	mov.w	r2, #32
   10852:	f3ef 8411 	mrs	r4, BASEPRI
   10856:	f382 8811 	msr	BASEPRI, r2
   1085a:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   1085e:	7b42      	ldrb	r2, [r0, #13]
   10860:	0751      	lsls	r1, r2, #29
   10862:	d404      	bmi.n	1086e <z_sched_start+0x22>
	__asm__ volatile(
   10864:	f384 8811 	msr	BASEPRI, r4
   10868:	f3bf 8f6f 	isb	sy
}
   1086c:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1086e:	f022 0204 	bic.w	r2, r2, #4
   10872:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   10874:	f7ff ffb2 	bl	107dc <ready_thread>
	z_reschedule(&sched_spinlock, key);
   10878:	4621      	mov	r1, r4
}
   1087a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   1087e:	4801      	ldr	r0, [pc, #4]	; (10884 <z_sched_start+0x38>)
   10880:	f7ff bf2c 	b.w	106dc <z_reschedule>
   10884:	2002a07a 	.word	0x2002a07a

00010888 <move_thread_to_end_of_prio_q>:
{
   10888:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   1088a:	f990 300d 	ldrsb.w	r3, [r0, #13]
{
   1088e:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   10890:	2b00      	cmp	r3, #0
   10892:	da02      	bge.n	1089a <move_thread_to_end_of_prio_q+0x12>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   10894:	4817      	ldr	r0, [pc, #92]	; (108f4 <move_thread_to_end_of_prio_q+0x6c>)
   10896:	f7ff ff47 	bl	10728 <z_priq_dumb_remove>
	return list->head == list;
   1089a:	4a17      	ldr	r2, [pc, #92]	; (108f8 <move_thread_to_end_of_prio_q+0x70>)
   1089c:	4610      	mov	r0, r2
   1089e:	f850 3f2c 	ldr.w	r3, [r0, #44]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   108a2:	6b14      	ldr	r4, [r2, #48]	; 0x30
	return sys_dlist_is_empty(list) ? NULL : list->head;
   108a4:	4283      	cmp	r3, r0
   108a6:	bf08      	it	eq
   108a8:	2300      	moveq	r3, #0
   108aa:	2b00      	cmp	r3, #0
   108ac:	bf38      	it	cc
   108ae:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   108b0:	b1d3      	cbz	r3, 108e8 <move_thread_to_end_of_prio_q+0x60>
	if (thread_1->base.prio < thread_2->base.prio) {
   108b2:	f991 600e 	ldrsb.w	r6, [r1, #14]
   108b6:	f993 500e 	ldrsb.w	r5, [r3, #14]
   108ba:	42ae      	cmp	r6, r5
   108bc:	db03      	blt.n	108c6 <move_thread_to_end_of_prio_q+0x3e>
	return (node == list->tail) ? NULL : node->next;
   108be:	42a3      	cmp	r3, r4
   108c0:	d012      	beq.n	108e8 <move_thread_to_end_of_prio_q+0x60>
   108c2:	681b      	ldr	r3, [r3, #0]
   108c4:	e7f4      	b.n	108b0 <move_thread_to_end_of_prio_q+0x28>
	node->prev = successor->prev;
   108c6:	6858      	ldr	r0, [r3, #4]
	node->next = successor;
   108c8:	e9c1 3000 	strd	r3, r0, [r1]
	successor->prev->next = node;
   108cc:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   108ce:	6059      	str	r1, [r3, #4]
	thread->base.thread_state |= states;
   108d0:	7b4b      	ldrb	r3, [r1, #13]
	update_cache(thread == _current);
   108d2:	6890      	ldr	r0, [r2, #8]
   108d4:	f063 037f 	orn	r3, r3, #127	; 0x7f
   108d8:	734b      	strb	r3, [r1, #13]
   108da:	1a43      	subs	r3, r0, r1
   108dc:	4258      	negs	r0, r3
   108de:	4158      	adcs	r0, r3
}
   108e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   108e4:	f7ff bf36 	b.w	10754 <update_cache>
	node->prev = list->tail;
   108e8:	e9c1 0400 	strd	r0, r4, [r1]
	list->tail->next = node;
   108ec:	6b13      	ldr	r3, [r2, #48]	; 0x30
   108ee:	6019      	str	r1, [r3, #0]
	list->tail = node;
   108f0:	6311      	str	r1, [r2, #48]	; 0x30
}
   108f2:	e7ed      	b.n	108d0 <move_thread_to_end_of_prio_q+0x48>
   108f4:	20025ef4 	.word	0x20025ef4
   108f8:	20025ec8 	.word	0x20025ec8

000108fc <z_time_slice>:
{
   108fc:	4601      	mov	r1, r0
   108fe:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
   10900:	f04f 0320 	mov.w	r3, #32
   10904:	f3ef 8411 	mrs	r4, BASEPRI
   10908:	f383 8811 	msr	BASEPRI, r3
   1090c:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   10910:	4b16      	ldr	r3, [pc, #88]	; (1096c <z_time_slice+0x70>)
   10912:	4a17      	ldr	r2, [pc, #92]	; (10970 <z_time_slice+0x74>)
   10914:	6898      	ldr	r0, [r3, #8]
   10916:	6815      	ldr	r5, [r2, #0]
   10918:	42a8      	cmp	r0, r5
   1091a:	461d      	mov	r5, r3
   1091c:	d106      	bne.n	1092c <z_time_slice+0x30>
			z_reset_time_slice();
   1091e:	f7ff fe9b 	bl	10658 <z_reset_time_slice>
	__asm__ volatile(
   10922:	f384 8811 	msr	BASEPRI, r4
   10926:	f3bf 8f6f 	isb	sy
}
   1092a:	bd70      	pop	{r4, r5, r6, pc}
	pending_current = NULL;
   1092c:	2600      	movs	r6, #0
   1092e:	6016      	str	r6, [r2, #0]
	if (slice_time && sliceable(_current)) {
   10930:	4a10      	ldr	r2, [pc, #64]	; (10974 <z_time_slice+0x78>)
   10932:	6812      	ldr	r2, [r2, #0]
   10934:	b1ba      	cbz	r2, 10966 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   10936:	89c2      	ldrh	r2, [r0, #14]
   10938:	2a7f      	cmp	r2, #127	; 0x7f
   1093a:	d814      	bhi.n	10966 <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
   1093c:	7b42      	ldrb	r2, [r0, #13]
   1093e:	06d2      	lsls	r2, r2, #27
   10940:	d111      	bne.n	10966 <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   10942:	4a0d      	ldr	r2, [pc, #52]	; (10978 <z_time_slice+0x7c>)
   10944:	f990 600e 	ldrsb.w	r6, [r0, #14]
   10948:	6812      	ldr	r2, [r2, #0]
   1094a:	4296      	cmp	r6, r2
   1094c:	db0b      	blt.n	10966 <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   1094e:	4a0b      	ldr	r2, [pc, #44]	; (1097c <z_time_slice+0x80>)
   10950:	4290      	cmp	r0, r2
   10952:	d008      	beq.n	10966 <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
   10954:	695a      	ldr	r2, [r3, #20]
   10956:	428a      	cmp	r2, r1
   10958:	dc02      	bgt.n	10960 <z_time_slice+0x64>
			move_thread_to_end_of_prio_q(_current);
   1095a:	f7ff ff95 	bl	10888 <move_thread_to_end_of_prio_q>
   1095e:	e7de      	b.n	1091e <z_time_slice+0x22>
			_current_cpu->slice_ticks -= ticks;
   10960:	1a52      	subs	r2, r2, r1
   10962:	615a      	str	r2, [r3, #20]
   10964:	e7dd      	b.n	10922 <z_time_slice+0x26>
		_current_cpu->slice_ticks = 0;
   10966:	2300      	movs	r3, #0
   10968:	616b      	str	r3, [r5, #20]
   1096a:	e7da      	b.n	10922 <z_time_slice+0x26>
   1096c:	20025ec8 	.word	0x20025ec8
   10970:	20025efc 	.word	0x20025efc
   10974:	20025f04 	.word	0x20025f04
   10978:	20025f00 	.word	0x20025f00
   1097c:	20001058 	.word	0x20001058

00010980 <z_impl_k_thread_suspend>:
{
   10980:	b570      	push	{r4, r5, r6, lr}
   10982:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   10984:	3018      	adds	r0, #24
   10986:	f00c fdca 	bl	1d51e <z_abort_timeout>
	__asm__ volatile(
   1098a:	f04f 0320 	mov.w	r3, #32
   1098e:	f3ef 8611 	mrs	r6, BASEPRI
   10992:	f383 8811 	msr	BASEPRI, r3
   10996:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   1099a:	f994 300d 	ldrsb.w	r3, [r4, #13]
   1099e:	2b00      	cmp	r3, #0
   109a0:	da07      	bge.n	109b2 <z_impl_k_thread_suspend+0x32>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   109a2:	4621      	mov	r1, r4
   109a4:	480e      	ldr	r0, [pc, #56]	; (109e0 <z_impl_k_thread_suspend+0x60>)
   109a6:	f7ff febf 	bl	10728 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   109aa:	7b63      	ldrb	r3, [r4, #13]
   109ac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   109b0:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   109b2:	4d0c      	ldr	r5, [pc, #48]	; (109e4 <z_impl_k_thread_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   109b4:	7b63      	ldrb	r3, [r4, #13]
   109b6:	68a8      	ldr	r0, [r5, #8]
   109b8:	f043 0310 	orr.w	r3, r3, #16
   109bc:	7363      	strb	r3, [r4, #13]
   109be:	1b03      	subs	r3, r0, r4
   109c0:	4258      	negs	r0, r3
   109c2:	4158      	adcs	r0, r3
   109c4:	f7ff fec6 	bl	10754 <update_cache>
	__asm__ volatile(
   109c8:	f386 8811 	msr	BASEPRI, r6
   109cc:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   109d0:	68ab      	ldr	r3, [r5, #8]
   109d2:	42a3      	cmp	r3, r4
   109d4:	d103      	bne.n	109de <z_impl_k_thread_suspend+0x5e>
}
   109d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   109da:	f00c bc4f 	b.w	1d27c <z_reschedule_unlocked>
}
   109de:	bd70      	pop	{r4, r5, r6, pc}
   109e0:	20025ef4 	.word	0x20025ef4
   109e4:	20025ec8 	.word	0x20025ec8

000109e8 <z_thread_single_abort>:
{
   109e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   109ec:	4604      	mov	r4, r0
	__asm__ volatile(
   109ee:	f04f 0320 	mov.w	r3, #32
   109f2:	f3ef 8211 	mrs	r2, BASEPRI
   109f6:	f383 8811 	msr	BASEPRI, r3
   109fa:	f3bf 8f6f 	isb	sy
	if ((thread->base.thread_state &
   109fe:	7b43      	ldrb	r3, [r0, #13]
   10a00:	f013 0f28 	tst.w	r3, #40	; 0x28
   10a04:	d005      	beq.n	10a12 <z_thread_single_abort+0x2a>
	__asm__ volatile(
   10a06:	f382 8811 	msr	BASEPRI, r2
   10a0a:	f3bf 8f6f 	isb	sy
}
   10a0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	thread->base.thread_state |= _THREAD_ABORTING;
   10a12:	f043 0320 	orr.w	r3, r3, #32
   10a16:	7343      	strb	r3, [r0, #13]
   10a18:	f382 8811 	msr	BASEPRI, r2
   10a1c:	f3bf 8f6f 	isb	sy
   10a20:	3018      	adds	r0, #24
   10a22:	f00c fd7c 	bl	1d51e <z_abort_timeout>
	__asm__ volatile(
   10a26:	f04f 0320 	mov.w	r3, #32
   10a2a:	f3ef 8611 	mrs	r6, BASEPRI
   10a2e:	f383 8811 	msr	BASEPRI, r3
   10a32:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   10a36:	7b63      	ldrb	r3, [r4, #13]
   10a38:	06d8      	lsls	r0, r3, #27
   10a3a:	d116      	bne.n	10a6a <z_thread_single_abort+0x82>
		if (z_is_thread_ready(thread)) {
   10a3c:	69a2      	ldr	r2, [r4, #24]
   10a3e:	b9a2      	cbnz	r2, 10a6a <z_thread_single_abort+0x82>
			if (z_is_thread_queued(thread)) {
   10a40:	0619      	lsls	r1, r3, #24
   10a42:	d507      	bpl.n	10a54 <z_thread_single_abort+0x6c>
				_priq_run_remove(&_kernel.ready_q.runq,
   10a44:	4621      	mov	r1, r4
   10a46:	4826      	ldr	r0, [pc, #152]	; (10ae0 <z_thread_single_abort+0xf8>)
   10a48:	f7ff fe6e 	bl	10728 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   10a4c:	7b63      	ldrb	r3, [r4, #13]
   10a4e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   10a52:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   10a54:	4b23      	ldr	r3, [pc, #140]	; (10ae4 <z_thread_single_abort+0xfc>)
   10a56:	6898      	ldr	r0, [r3, #8]
   10a58:	1b02      	subs	r2, r0, r4
   10a5a:	4250      	negs	r0, r2
   10a5c:	4150      	adcs	r0, r2
   10a5e:	f7ff fe79 	bl	10754 <update_cache>
			waiter->base.pended_on = NULL;
   10a62:	2700      	movs	r7, #0
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   10a64:	f104 0830 	add.w	r8, r4, #48	; 0x30
   10a68:	e01e      	b.n	10aa8 <z_thread_single_abort+0xc0>
			if (z_is_thread_pending(thread)) {
   10a6a:	079b      	lsls	r3, r3, #30
   10a6c:	d5f9      	bpl.n	10a62 <z_thread_single_abort+0x7a>
				_priq_wait_remove(&pended_on(thread)->waitq,
   10a6e:	4621      	mov	r1, r4
   10a70:	68a0      	ldr	r0, [r4, #8]
   10a72:	f7ff fe59 	bl	10728 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   10a76:	7b63      	ldrb	r3, [r4, #13]
   10a78:	f023 0302 	bic.w	r3, r3, #2
   10a7c:	7363      	strb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   10a7e:	2300      	movs	r3, #0
   10a80:	60a3      	str	r3, [r4, #8]
   10a82:	e7ee      	b.n	10a62 <z_thread_single_abort+0x7a>
   10a84:	f105 0018 	add.w	r0, r5, #24
   10a88:	f00c fd49 	bl	1d51e <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
   10a8c:	68a8      	ldr	r0, [r5, #8]
   10a8e:	4629      	mov	r1, r5
   10a90:	f7ff fe4a 	bl	10728 <z_priq_dumb_remove>
   10a94:	7b6b      	ldrb	r3, [r5, #13]
			ready_thread(waiter);
   10a96:	4628      	mov	r0, r5
   10a98:	f023 0302 	bic.w	r3, r3, #2
   10a9c:	736b      	strb	r3, [r5, #13]
			waiter->base.pended_on = NULL;
   10a9e:	60af      	str	r7, [r5, #8]
   10aa0:	f8c5 7080 	str.w	r7, [r5, #128]	; 0x80
			ready_thread(waiter);
   10aa4:	f7ff fe9a 	bl	107dc <ready_thread>
	return list->head == list;
   10aa8:	6b25      	ldr	r5, [r4, #48]	; 0x30
	return sys_dlist_is_empty(list) ? NULL : list->head;
   10aaa:	4545      	cmp	r5, r8
   10aac:	d001      	beq.n	10ab2 <z_thread_single_abort+0xca>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
   10aae:	2d00      	cmp	r5, #0
   10ab0:	d1e8      	bne.n	10a84 <z_thread_single_abort+0x9c>
		if (z_is_idle_thread_object(_current)) {
   10ab2:	4b0c      	ldr	r3, [pc, #48]	; (10ae4 <z_thread_single_abort+0xfc>)
   10ab4:	689a      	ldr	r2, [r3, #8]
   10ab6:	4b0c      	ldr	r3, [pc, #48]	; (10ae8 <z_thread_single_abort+0x100>)
   10ab8:	429a      	cmp	r2, r3
   10aba:	d102      	bne.n	10ac2 <z_thread_single_abort+0xda>
			update_cache(1);
   10abc:	2001      	movs	r0, #1
   10abe:	f7ff fe49 	bl	10754 <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
   10ac2:	7b63      	ldrb	r3, [r4, #13]
   10ac4:	f043 0308 	orr.w	r3, r3, #8
   10ac8:	7363      	strb	r3, [r4, #13]
		fn_abort = thread->fn_abort;
   10aca:	6e23      	ldr	r3, [r4, #96]	; 0x60
	__asm__ volatile(
   10acc:	f386 8811 	msr	BASEPRI, r6
   10ad0:	f3bf 8f6f 	isb	sy
	if (fn_abort != NULL) {
   10ad4:	2b00      	cmp	r3, #0
   10ad6:	d09a      	beq.n	10a0e <z_thread_single_abort+0x26>
		fn_abort(thread);
   10ad8:	4620      	mov	r0, r4
}
   10ada:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		fn_abort(thread);
   10ade:	4718      	bx	r3
   10ae0:	20025ef4 	.word	0x20025ef4
   10ae4:	20025ec8 	.word	0x20025ec8
   10ae8:	20001058 	.word	0x20001058

00010aec <unready_thread>:
{
   10aec:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   10aee:	f990 300d 	ldrsb.w	r3, [r0, #13]
{
   10af2:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   10af4:	2b00      	cmp	r3, #0
   10af6:	da06      	bge.n	10b06 <unready_thread+0x1a>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   10af8:	4807      	ldr	r0, [pc, #28]	; (10b18 <unready_thread+0x2c>)
   10afa:	f7ff fe15 	bl	10728 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   10afe:	7b4b      	ldrb	r3, [r1, #13]
   10b00:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   10b04:	734b      	strb	r3, [r1, #13]
	update_cache(thread == _current);
   10b06:	4b05      	ldr	r3, [pc, #20]	; (10b1c <unready_thread+0x30>)
   10b08:	6898      	ldr	r0, [r3, #8]
   10b0a:	1a43      	subs	r3, r0, r1
   10b0c:	4258      	negs	r0, r3
   10b0e:	4158      	adcs	r0, r3
}
   10b10:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   10b14:	f7ff be1e 	b.w	10754 <update_cache>
   10b18:	20025ef4 	.word	0x20025ef4
   10b1c:	20025ec8 	.word	0x20025ec8

00010b20 <pend>:
{
   10b20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10b24:	4606      	mov	r6, r0
   10b26:	4614      	mov	r4, r2
   10b28:	461d      	mov	r5, r3
	__asm__ volatile(
   10b2a:	f04f 0320 	mov.w	r3, #32
   10b2e:	f3ef 8711 	mrs	r7, BASEPRI
   10b32:	f383 8811 	msr	BASEPRI, r3
   10b36:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   10b3a:	f00c fc05 	bl	1d348 <add_to_waitq_locked>
	__asm__ volatile(
   10b3e:	f387 8811 	msr	BASEPRI, r7
   10b42:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   10b46:	1c6b      	adds	r3, r5, #1
   10b48:	bf08      	it	eq
   10b4a:	f1b4 3fff 	cmpeq.w	r4, #4294967295
   10b4e:	d008      	beq.n	10b62 <pend+0x42>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   10b50:	4622      	mov	r2, r4
   10b52:	462b      	mov	r3, r5
   10b54:	f106 0018 	add.w	r0, r6, #24
   10b58:	4903      	ldr	r1, [pc, #12]	; (10b68 <pend+0x48>)
}
   10b5a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10b5e:	f000 bb2b 	b.w	111b8 <z_add_timeout>
   10b62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10b66:	bf00      	nop
   10b68:	0001d309 	.word	0x0001d309

00010b6c <z_pend_curr>:
{
   10b6c:	b510      	push	{r4, lr}
   10b6e:	460c      	mov	r4, r1
	pending_current = _current;
   10b70:	4b06      	ldr	r3, [pc, #24]	; (10b8c <z_pend_curr+0x20>)
{
   10b72:	4611      	mov	r1, r2
	pending_current = _current;
   10b74:	6898      	ldr	r0, [r3, #8]
   10b76:	4b06      	ldr	r3, [pc, #24]	; (10b90 <z_pend_curr+0x24>)
   10b78:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   10b7a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   10b7e:	f7ff ffcf 	bl	10b20 <pend>
   10b82:	4620      	mov	r0, r4
}
   10b84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10b88:	f7f1 bdec 	b.w	2764 <arch_swap>
   10b8c:	20025ec8 	.word	0x20025ec8
   10b90:	20025efc 	.word	0x20025efc

00010b94 <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
   10b94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10b98:	4605      	mov	r5, r0
   10b9a:	460f      	mov	r7, r1
		return 0;
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);

	expected_wakeup_ticks = ticks + z_tick_get_32();
   10b9c:	f00c fcff 	bl	1d59e <z_tick_get_32>
   10ba0:	4604      	mov	r4, r0
	__asm__ volatile(
   10ba2:	f04f 0320 	mov.w	r3, #32
   10ba6:	f3ef 8811 	mrs	r8, BASEPRI
   10baa:	f383 8811 	msr	BASEPRI, r3
   10bae:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   10bb2:	4e12      	ldr	r6, [pc, #72]	; (10bfc <z_tick_sleep.part.0+0x68>)
   10bb4:	4b12      	ldr	r3, [pc, #72]	; (10c00 <z_tick_sleep.part.0+0x6c>)
   10bb6:	68b0      	ldr	r0, [r6, #8]
	expected_wakeup_ticks = ticks + z_tick_get_32();
   10bb8:	442c      	add	r4, r5
	pending_current = _current;
   10bba:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
   10bbc:	f7ff ff96 	bl	10aec <unready_thread>
	z_add_thread_timeout(_current, timeout);
   10bc0:	68b0      	ldr	r0, [r6, #8]
   10bc2:	4910      	ldr	r1, [pc, #64]	; (10c04 <z_tick_sleep.part.0+0x70>)
   10bc4:	462a      	mov	r2, r5
   10bc6:	463b      	mov	r3, r7
   10bc8:	3018      	adds	r0, #24
   10bca:	f000 faf5 	bl	111b8 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   10bce:	68b2      	ldr	r2, [r6, #8]
   10bd0:	4640      	mov	r0, r8
	thread->base.thread_state |= _THREAD_SUSPENDED;
   10bd2:	7b53      	ldrb	r3, [r2, #13]

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - z_tick_get_32();
   10bd4:	2500      	movs	r5, #0
   10bd6:	f043 0310 	orr.w	r3, r3, #16
   10bda:	7353      	strb	r3, [r2, #13]
   10bdc:	f7f1 fdc2 	bl	2764 <arch_swap>
   10be0:	f00c fcdd 	bl	1d59e <z_tick_get_32>
   10be4:	1a24      	subs	r4, r4, r0
   10be6:	f165 0500 	sbc.w	r5, r5, #0
   10bea:	2c00      	cmp	r4, #0
   10bec:	f175 0300 	sbcs.w	r3, r5, #0
   10bf0:	bfb8      	it	lt
   10bf2:	2400      	movlt	r4, #0
		return ticks;
	}
#endif

	return 0;
}
   10bf4:	4620      	mov	r0, r4
   10bf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10bfa:	bf00      	nop
   10bfc:	20025ec8 	.word	0x20025ec8
   10c00:	20025efc 	.word	0x20025efc
   10c04:	0001d309 	.word	0x0001d309

00010c08 <z_set_prio>:
{
   10c08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10c0c:	4604      	mov	r4, r0
   10c0e:	f04f 0320 	mov.w	r3, #32
   10c12:	f3ef 8811 	mrs	r8, BASEPRI
   10c16:	f383 8811 	msr	BASEPRI, r3
   10c1a:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   10c1e:	7b43      	ldrb	r3, [r0, #13]
   10c20:	b24e      	sxtb	r6, r1
   10c22:	06db      	lsls	r3, r3, #27
   10c24:	d12e      	bne.n	10c84 <z_set_prio+0x7c>
	return !sys_dnode_is_linked(&t->node);
   10c26:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   10c28:	bb65      	cbnz	r5, 10c84 <z_set_prio+0x7c>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   10c2a:	4f18      	ldr	r7, [pc, #96]	; (10c8c <z_set_prio+0x84>)
   10c2c:	4621      	mov	r1, r4
   10c2e:	f107 002c 	add.w	r0, r7, #44	; 0x2c
   10c32:	f7ff fd79 	bl	10728 <z_priq_dumb_remove>
	return list->head == list;
   10c36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   10c38:	6b3a      	ldr	r2, [r7, #48]	; 0x30
	return sys_dlist_is_empty(list) ? NULL : list->head;
   10c3a:	4283      	cmp	r3, r0
   10c3c:	bf18      	it	ne
   10c3e:	461d      	movne	r5, r3
   10c40:	2d00      	cmp	r5, #0
   10c42:	bf38      	it	cc
   10c44:	2500      	movcc	r5, #0
				thread->base.prio = prio;
   10c46:	73a6      	strb	r6, [r4, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10c48:	b1b5      	cbz	r5, 10c78 <z_set_prio+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
   10c4a:	f995 100e 	ldrsb.w	r1, [r5, #14]
   10c4e:	42b1      	cmp	r1, r6
   10c50:	dc03      	bgt.n	10c5a <z_set_prio+0x52>
	return (node == list->tail) ? NULL : node->next;
   10c52:	42aa      	cmp	r2, r5
   10c54:	d010      	beq.n	10c78 <z_set_prio+0x70>
   10c56:	682d      	ldr	r5, [r5, #0]
   10c58:	e7f6      	b.n	10c48 <z_set_prio+0x40>
	node->prev = successor->prev;
   10c5a:	686a      	ldr	r2, [r5, #4]
	node->next = successor;
   10c5c:	e9c4 5200 	strd	r5, r2, [r4]
	successor->prev->next = node;
   10c60:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   10c62:	606c      	str	r4, [r5, #4]
			update_cache(1);
   10c64:	2001      	movs	r0, #1
   10c66:	f7ff fd75 	bl	10754 <update_cache>
   10c6a:	2001      	movs	r0, #1
	__asm__ volatile(
   10c6c:	f388 8811 	msr	BASEPRI, r8
   10c70:	f3bf 8f6f 	isb	sy
}
   10c74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	node->prev = list->tail;
   10c78:	e9c4 0200 	strd	r0, r2, [r4]
	list->tail->next = node;
   10c7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   10c7e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   10c80:	633c      	str	r4, [r7, #48]	; 0x30
}
   10c82:	e7ef      	b.n	10c64 <z_set_prio+0x5c>
			thread->base.prio = prio;
   10c84:	2000      	movs	r0, #0
   10c86:	73a6      	strb	r6, [r4, #14]
   10c88:	e7f0      	b.n	10c6c <z_set_prio+0x64>
   10c8a:	bf00      	nop
   10c8c:	20025ec8 	.word	0x20025ec8

00010c90 <z_sched_init>:
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   10c90:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   10c92:	4b04      	ldr	r3, [pc, #16]	; (10ca4 <z_sched_init+0x14>)
   10c94:	4608      	mov	r0, r1
   10c96:	f103 022c 	add.w	r2, r3, #44	; 0x2c
	list->tail = (sys_dnode_t *)list;
   10c9a:	e9c3 220b 	strd	r2, r2, [r3, #44]	; 0x2c
   10c9e:	f7ff bcf1 	b.w	10684 <k_sched_time_slice_set>
   10ca2:	bf00      	nop
   10ca4:	20025ec8 	.word	0x20025ec8

00010ca8 <z_impl_k_yield>:
{
   10ca8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
   10caa:	4c24      	ldr	r4, [pc, #144]	; (10d3c <z_impl_k_yield+0x94>)
   10cac:	4b24      	ldr	r3, [pc, #144]	; (10d40 <z_impl_k_yield+0x98>)
   10cae:	68a2      	ldr	r2, [r4, #8]
   10cb0:	429a      	cmp	r2, r3
   10cb2:	d030      	beq.n	10d16 <z_impl_k_yield+0x6e>
	__asm__ volatile(
   10cb4:	f04f 0320 	mov.w	r3, #32
   10cb8:	f3ef 8511 	mrs	r5, BASEPRI
   10cbc:	f383 8811 	msr	BASEPRI, r3
   10cc0:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
   10cc4:	68a1      	ldr	r1, [r4, #8]
   10cc6:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   10cca:	f7ff fd2d 	bl	10728 <z_priq_dumb_remove>
	return list->head == list;
   10cce:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			_priq_run_add(&_kernel.ready_q.runq, _current);
   10cd0:	68a2      	ldr	r2, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   10cd2:	4283      	cmp	r3, r0
   10cd4:	bf08      	it	eq
   10cd6:	2300      	moveq	r3, #0
   10cd8:	2b00      	cmp	r3, #0
   10cda:	bf38      	it	cc
   10cdc:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   10cde:	6b21      	ldr	r1, [r4, #48]	; 0x30
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10ce0:	b32b      	cbz	r3, 10d2e <z_impl_k_yield+0x86>
	if (thread_1->base.prio < thread_2->base.prio) {
   10ce2:	f992 700e 	ldrsb.w	r7, [r2, #14]
   10ce6:	f993 600e 	ldrsb.w	r6, [r3, #14]
   10cea:	42b7      	cmp	r7, r6
   10cec:	db03      	blt.n	10cf6 <z_impl_k_yield+0x4e>
	return (node == list->tail) ? NULL : node->next;
   10cee:	428b      	cmp	r3, r1
   10cf0:	d01d      	beq.n	10d2e <z_impl_k_yield+0x86>
   10cf2:	681b      	ldr	r3, [r3, #0]
   10cf4:	e7f4      	b.n	10ce0 <z_impl_k_yield+0x38>
	node->prev = successor->prev;
   10cf6:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   10cf8:	e9c2 3100 	strd	r3, r1, [r2]
	successor->prev->next = node;
   10cfc:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   10cfe:	605a      	str	r2, [r3, #4]
	thread->base.thread_state |= states;
   10d00:	7b53      	ldrb	r3, [r2, #13]
			update_cache(1);
   10d02:	2001      	movs	r0, #1
   10d04:	f063 037f 	orn	r3, r3, #127	; 0x7f
   10d08:	7353      	strb	r3, [r2, #13]
   10d0a:	f7ff fd23 	bl	10754 <update_cache>
	__asm__ volatile(
   10d0e:	f385 8811 	msr	BASEPRI, r5
   10d12:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   10d16:	f04f 0320 	mov.w	r3, #32
   10d1a:	f3ef 8011 	mrs	r0, BASEPRI
   10d1e:	f383 8811 	msr	BASEPRI, r3
   10d22:	f3bf 8f6f 	isb	sy
}
   10d26:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   10d2a:	f7f1 bd1b 	b.w	2764 <arch_swap>
	node->prev = list->tail;
   10d2e:	e9c2 0100 	strd	r0, r1, [r2]
	list->tail->next = node;
   10d32:	6b23      	ldr	r3, [r4, #48]	; 0x30
   10d34:	601a      	str	r2, [r3, #0]
	list->tail = node;
   10d36:	6322      	str	r2, [r4, #48]	; 0x30
}
   10d38:	e7e2      	b.n	10d00 <z_impl_k_yield+0x58>
   10d3a:	bf00      	nop
   10d3c:	20025ec8 	.word	0x20025ec8
   10d40:	20001058 	.word	0x20001058

00010d44 <z_impl_k_sleep>:

	__ASSERT(!arch_is_in_isr(), "");
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   10d44:	f1b1 3fff 	cmp.w	r1, #4294967295
   10d48:	bf08      	it	eq
   10d4a:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
   10d4e:	b508      	push	{r3, lr}
   10d50:	4602      	mov	r2, r0
   10d52:	460b      	mov	r3, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   10d54:	d106      	bne.n	10d64 <z_impl_k_sleep+0x20>
		k_thread_suspend(_current);
   10d56:	4b0b      	ldr	r3, [pc, #44]	; (10d84 <z_impl_k_sleep+0x40>)
   10d58:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   10d5a:	f7ff fe11 	bl	10980 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
   10d5e:	f04f 30ff 	mov.w	r0, #4294967295
	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
}
   10d62:	bd08      	pop	{r3, pc}
	if (ticks == 0) {
   10d64:	4313      	orrs	r3, r2
   10d66:	d10a      	bne.n	10d7e <z_impl_k_sleep+0x3a>
	z_impl_k_yield();
   10d68:	f7ff ff9e 	bl	10ca8 <z_impl_k_yield>
		return 0;
   10d6c:	2000      	movs	r0, #0
			return (t * to_hz + off) / from_hz;
   10d6e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   10d72:	fb80 2303 	smull	r2, r3, r0, r3
   10d76:	0bd0      	lsrs	r0, r2, #15
   10d78:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   10d7c:	e7f1      	b.n	10d62 <z_impl_k_sleep+0x1e>
   10d7e:	f7ff ff09 	bl	10b94 <z_tick_sleep.part.0>
   10d82:	e7f4      	b.n	10d6e <z_impl_k_sleep+0x2a>
   10d84:	20025ec8 	.word	0x20025ec8

00010d88 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   10d88:	4b01      	ldr	r3, [pc, #4]	; (10d90 <z_impl_k_current_get+0x8>)
   10d8a:	6898      	ldr	r0, [r3, #8]
   10d8c:	4770      	bx	lr
   10d8e:	bf00      	nop
   10d90:	20025ec8 	.word	0x20025ec8

00010d94 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   10d94:	b538      	push	{r3, r4, r5, lr}
   10d96:	4604      	mov	r4, r0
   10d98:	f04f 0320 	mov.w	r3, #32
   10d9c:	f3ef 8511 	mrs	r5, BASEPRI
   10da0:	f383 8811 	msr	BASEPRI, r3
   10da4:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	sys_trace_semaphore_give(sem);
	thread = z_unpend_first_thread(&sem->wait_q);
   10da8:	f00c faf9 	bl	1d39e <z_unpend_first_thread>

	if (thread != NULL) {
   10dac:	b150      	cbz	r0, 10dc4 <z_impl_k_sem_give+0x30>
   10dae:	2200      	movs	r2, #0
   10db0:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   10db4:	f00c fa98 	bl	1d2e8 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   10db8:	4629      	mov	r1, r5
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
}
   10dba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   10dbe:	4807      	ldr	r0, [pc, #28]	; (10ddc <z_impl_k_sem_give+0x48>)
   10dc0:	f7ff bc8c 	b.w	106dc <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   10dc4:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   10dc8:	429a      	cmp	r2, r3
   10dca:	bf18      	it	ne
   10dcc:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   10dce:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   10dd0:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   10dd2:	f104 0010 	add.w	r0, r4, #16
   10dd6:	f00c fd7f 	bl	1d8d8 <z_handle_obj_poll_events>
}
   10dda:	e7ed      	b.n	10db8 <z_impl_k_sem_give+0x24>
   10ddc:	2002a07a 	.word	0x2002a07a

00010de0 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   10de0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   10de2:	4614      	mov	r4, r2
   10de4:	461d      	mov	r5, r3
   10de6:	f04f 0320 	mov.w	r3, #32
   10dea:	f3ef 8111 	mrs	r1, BASEPRI
   10dee:	f383 8811 	msr	BASEPRI, r3
   10df2:	f3bf 8f6f 	isb	sy
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	sys_trace_semaphore_take(sem);

	if (likely(sem->count > 0U)) {
   10df6:	6883      	ldr	r3, [r0, #8]
   10df8:	b143      	cbz	r3, 10e0c <z_impl_k_sem_take+0x2c>
		sem->count--;
   10dfa:	3b01      	subs	r3, #1
   10dfc:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
   10dfe:	f381 8811 	msr	BASEPRI, r1
   10e02:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   10e06:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   10e08:	b003      	add	sp, #12
   10e0a:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   10e0c:	ea54 0305 	orrs.w	r3, r4, r5
   10e10:	d106      	bne.n	10e20 <z_impl_k_sem_take+0x40>
   10e12:	f381 8811 	msr	BASEPRI, r1
   10e16:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   10e1a:	f06f 000f 	mvn.w	r0, #15
   10e1e:	e7f3      	b.n	10e08 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   10e20:	4602      	mov	r2, r0
   10e22:	e9cd 4500 	strd	r4, r5, [sp]
   10e26:	4802      	ldr	r0, [pc, #8]	; (10e30 <z_impl_k_sem_take+0x50>)
   10e28:	f7ff fea0 	bl	10b6c <z_pend_curr>
	return ret;
   10e2c:	e7ec      	b.n	10e08 <z_impl_k_sem_take+0x28>
   10e2e:	bf00      	nop
   10e30:	2002a07a 	.word	0x2002a07a

00010e34 <k_sys_work_q_init>:
K_KERNEL_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
   10e34:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   10e36:	4c08      	ldr	r4, [pc, #32]	; (10e58 <k_sys_work_q_init+0x24>)
   10e38:	f04f 33ff 	mov.w	r3, #4294967295
   10e3c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   10e40:	4620      	mov	r0, r4
   10e42:	4906      	ldr	r1, [pc, #24]	; (10e5c <k_sys_work_q_init+0x28>)
   10e44:	f000 f8dc 	bl	11000 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   10e48:	4905      	ldr	r1, [pc, #20]	; (10e60 <k_sys_work_q_init+0x2c>)
   10e4a:	f104 0018 	add.w	r0, r4, #24
   10e4e:	f00c faf5 	bl	1d43c <z_impl_k_thread_name_set>
		       K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   10e52:	2000      	movs	r0, #0
   10e54:	bd10      	pop	{r4, pc}
   10e56:	bf00      	nop
   10e58:	20001168 	.word	0x20001168
   10e5c:	2002daf0 	.word	0x2002daf0
   10e60:	000442f2 	.word	0x000442f2

00010e64 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   10e64:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	sys_dlist_init(&w->waitq);
   10e68:	f100 0530 	add.w	r5, r0, #48	; 0x30
	list->tail = (sys_dnode_t *)list;
   10e6c:	e9c0 550c 	strd	r5, r5, [r0, #48]	; 0x30
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
   10e70:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
   10e72:	4604      	mov	r4, r0
	thread_base->user_options = (uint8_t)options;
   10e74:	7305      	strb	r5, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   10e76:	2504      	movs	r5, #4
   10e78:	7345      	strb	r5, [r0, #13]

	thread_base->prio = priority;
   10e7a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   10e7c:	1dd6      	adds	r6, r2, #7
	thread_base->prio = priority;
   10e7e:	7385      	strb	r5, [r0, #14]

	thread_base->sched_locked = 0U;
   10e80:	2500      	movs	r5, #0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   10e82:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   10e84:	f026 0607 	bic.w	r6, r6, #7
	node->prev = NULL;
   10e88:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
   10e8c:	e9c0 161b 	strd	r1, r6, [r0, #108]	; 0x6c
	thread_base->sched_locked = 0U;
   10e90:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   10e92:	6745      	str	r5, [r0, #116]	; 0x74
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   10e94:	9202      	str	r2, [sp, #8]
   10e96:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   10e98:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   10e9c:	9201      	str	r2, [sp, #4]
   10e9e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   10ea0:	9200      	str	r2, [sp, #0]
   10ea2:	4642      	mov	r2, r8
   10ea4:	f7f1 fcae 	bl	2804 <arch_new_thread>
	if (!_current) {
   10ea8:	4b05      	ldr	r3, [pc, #20]	; (10ec0 <z_setup_new_thread+0x5c>)
	new_thread->fn_abort = NULL;
   10eaa:	e9c4 5517 	strd	r5, r5, [r4, #92]	; 0x5c
	if (!_current) {
   10eae:	689b      	ldr	r3, [r3, #8]
   10eb0:	b103      	cbz	r3, 10eb4 <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   10eb2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
}
   10eb4:	4640      	mov	r0, r8
   10eb6:	67a3      	str	r3, [r4, #120]	; 0x78
   10eb8:	b004      	add	sp, #16
   10eba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10ebe:	bf00      	nop
   10ec0:	20025ec8 	.word	0x20025ec8

00010ec4 <z_impl_k_thread_create>:
{
   10ec4:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   10ec6:	2500      	movs	r5, #0
{
   10ec8:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   10eca:	9505      	str	r5, [sp, #20]
   10ecc:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   10ece:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   10ed2:	9504      	str	r5, [sp, #16]
   10ed4:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   10ed6:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   10ed8:	9503      	str	r5, [sp, #12]
   10eda:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   10edc:	9502      	str	r5, [sp, #8]
   10ede:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   10ee0:	9501      	str	r5, [sp, #4]
   10ee2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   10ee4:	9500      	str	r5, [sp, #0]
   10ee6:	f7ff ffbd 	bl	10e64 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   10eea:	1c7b      	adds	r3, r7, #1
   10eec:	bf08      	it	eq
   10eee:	f1b6 3fff 	cmpeq.w	r6, #4294967295
   10ef2:	d005      	beq.n	10f00 <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   10ef4:	ea56 0307 	orrs.w	r3, r6, r7
   10ef8:	d105      	bne.n	10f06 <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
   10efa:	4620      	mov	r0, r4
   10efc:	f7ff fca6 	bl	1084c <z_sched_start>
}
   10f00:	4620      	mov	r0, r4
   10f02:	b007      	add	sp, #28
   10f04:	bdf0      	pop	{r4, r5, r6, r7, pc}
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   10f06:	4632      	mov	r2, r6
   10f08:	463b      	mov	r3, r7
   10f0a:	4903      	ldr	r1, [pc, #12]	; (10f18 <z_impl_k_thread_create+0x54>)
   10f0c:	f104 0018 	add.w	r0, r4, #24
   10f10:	f000 f952 	bl	111b8 <z_add_timeout>
   10f14:	e7f4      	b.n	10f00 <z_impl_k_thread_create+0x3c>
   10f16:	bf00      	nop
   10f18:	0001d309 	.word	0x0001d309

00010f1c <z_init_static_threads>:
{
   10f1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   10f20:	4e2a      	ldr	r6, [pc, #168]	; (10fcc <z_init_static_threads+0xb0>)
   10f22:	4d2b      	ldr	r5, [pc, #172]	; (10fd0 <z_init_static_threads+0xb4>)
   10f24:	46b0      	mov	r8, r6
{
   10f26:	b086      	sub	sp, #24
	_FOREACH_STATIC_THREAD(thread_data) {
   10f28:	42b5      	cmp	r5, r6
   10f2a:	f105 0430 	add.w	r4, r5, #48	; 0x30
   10f2e:	d310      	bcc.n	10f52 <z_init_static_threads+0x36>
	k_sched_lock();
   10f30:	f7ff fbe6 	bl	10700 <k_sched_lock>
   10f34:	f44f 4900 	mov.w	r9, #32768	; 0x8000
   10f38:	f240 36e7 	movw	r6, #999	; 0x3e7
   10f3c:	2700      	movs	r7, #0
	_FOREACH_STATIC_THREAD(thread_data) {
   10f3e:	4c24      	ldr	r4, [pc, #144]	; (10fd0 <z_init_static_threads+0xb4>)
   10f40:	f8df a090 	ldr.w	sl, [pc, #144]	; 10fd4 <z_init_static_threads+0xb8>
   10f44:	4544      	cmp	r4, r8
   10f46:	d321      	bcc.n	10f8c <z_init_static_threads+0x70>
}
   10f48:	b006      	add	sp, #24
   10f4a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	k_sched_unlock();
   10f4e:	f7ff bc29 	b.w	107a4 <k_sched_unlock>
		z_setup_new_thread(
   10f52:	f854 3c04 	ldr.w	r3, [r4, #-4]
   10f56:	9305      	str	r3, [sp, #20]
   10f58:	f854 3c10 	ldr.w	r3, [r4, #-16]
   10f5c:	9304      	str	r3, [sp, #16]
   10f5e:	f854 3c14 	ldr.w	r3, [r4, #-20]
   10f62:	9303      	str	r3, [sp, #12]
   10f64:	f854 3c18 	ldr.w	r3, [r4, #-24]
   10f68:	9302      	str	r3, [sp, #8]
   10f6a:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   10f6e:	9301      	str	r3, [sp, #4]
   10f70:	f854 3c20 	ldr.w	r3, [r4, #-32]
   10f74:	9300      	str	r3, [sp, #0]
   10f76:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   10f7a:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   10f7e:	f7ff ff71 	bl	10e64 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   10f82:	f854 3c30 	ldr.w	r3, [r4, #-48]
   10f86:	65dd      	str	r5, [r3, #92]	; 0x5c
   10f88:	4625      	mov	r5, r4
   10f8a:	e7cd      	b.n	10f28 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   10f8c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   10f8e:	1c5a      	adds	r2, r3, #1
   10f90:	d00d      	beq.n	10fae <z_init_static_threads+0x92>
   10f92:	4630      	mov	r0, r6
   10f94:	4639      	mov	r1, r7
					    K_MSEC(thread_data->init_delay));
   10f96:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   10f9a:	fbc9 0103 	smlal	r0, r1, r9, r3
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   10f9e:	42b9      	cmp	r1, r7
   10fa0:	bf08      	it	eq
   10fa2:	42b0      	cmpeq	r0, r6
			schedule_new_thread(thread_data->init_thread,
   10fa4:	6825      	ldr	r5, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   10fa6:	d104      	bne.n	10fb2 <z_init_static_threads+0x96>
	z_sched_start(thread);
   10fa8:	4628      	mov	r0, r5
   10faa:	f7ff fc4f 	bl	1084c <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   10fae:	3430      	adds	r4, #48	; 0x30
   10fb0:	e7c8      	b.n	10f44 <z_init_static_threads+0x28>
   10fb2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   10fb6:	2300      	movs	r3, #0
   10fb8:	f7ef f8cc 	bl	154 <__aeabi_uldivmod>
   10fbc:	4602      	mov	r2, r0
   10fbe:	460b      	mov	r3, r1
   10fc0:	f105 0018 	add.w	r0, r5, #24
   10fc4:	4651      	mov	r1, sl
   10fc6:	f000 f8f7 	bl	111b8 <z_add_timeout>
   10fca:	e7f0      	b.n	10fae <z_init_static_threads+0x92>
   10fcc:	2000073c 	.word	0x2000073c
   10fd0:	2000070c 	.word	0x2000070c
   10fd4:	0001d309 	.word	0x0001d309

00010fd8 <z_self_abort>:
#include <syscall_handler.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_self_abort(void)
{
   10fd8:	b508      	push	{r3, lr}
	__asm__ volatile(
   10fda:	f04f 0320 	mov.w	r3, #32
   10fde:	f3ef 8411 	mrs	r4, BASEPRI
   10fe2:	f383 8811 	msr	BASEPRI, r3
   10fe6:	f3bf 8f6f 	isb	sy
	 * while we set this up
	 */
	key = arch_irq_lock();
	cpu = _current_cpu;
	__ASSERT(cpu->pending_abort == NULL, "already have a thread to abort");
	cpu->pending_abort = _current;
   10fea:	4b04      	ldr	r3, [pc, #16]	; (10ffc <z_self_abort+0x24>)
   10fec:	6898      	ldr	r0, [r3, #8]
   10fee:	6118      	str	r0, [r3, #16]
	z_impl_k_thread_suspend(thread);
   10ff0:	f7ff fcc6 	bl	10980 <z_impl_k_thread_suspend>
   10ff4:	4620      	mov	r0, r4
   10ff6:	f7f1 fbb5 	bl	2764 <arch_swap>
		_current, cpu->idle_thread);

	k_thread_suspend(_current);
	z_swap_irqlock(key);
	__ASSERT(false, "should never get here");
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   10ffa:	bf00      	nop
   10ffc:	20025ec8 	.word	0x20025ec8

00011000 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   11000:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11004:	4604      	mov	r4, r0
   11006:	b088      	sub	sp, #32
   11008:	460d      	mov	r5, r1
   1100a:	4616      	mov	r6, r2
   1100c:	461f      	mov	r7, r3
	z_impl_k_queue_init(queue);
   1100e:	f00c f8a3 	bl	1d158 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   11012:	f104 0818 	add.w	r8, r4, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   11016:	2200      	movs	r2, #0
   11018:	2300      	movs	r3, #0
   1101a:	e9cd 7203 	strd	r7, r2, [sp, #12]
   1101e:	e9cd 2306 	strd	r2, r3, [sp, #24]
   11022:	e9cd 2201 	strd	r2, r2, [sp, #4]
   11026:	4629      	mov	r1, r5
   11028:	4632      	mov	r2, r6
   1102a:	4640      	mov	r0, r8
   1102c:	4b05      	ldr	r3, [pc, #20]	; (11044 <k_work_q_start+0x44>)
   1102e:	9400      	str	r4, [sp, #0]
   11030:	f7ff ff48 	bl	10ec4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   11034:	4640      	mov	r0, r8
   11036:	4904      	ldr	r1, [pc, #16]	; (11048 <k_work_q_start+0x48>)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   11038:	b008      	add	sp, #32
   1103a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1103e:	f00c b9fd 	b.w	1d43c <z_impl_k_thread_name_set>
   11042:	bf00      	nop
   11044:	00011ac5 	.word	0x00011ac5
   11048:	000442fb 	.word	0x000442fb

0001104c <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   k_timeout_t delay)
{
   1104c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11050:	4606      	mov	r6, r0
   11052:	460d      	mov	r5, r1
   11054:	4690      	mov	r8, r2
   11056:	4699      	mov	r9, r3
   11058:	f04f 0320 	mov.w	r3, #32
   1105c:	f3ef 8711 	mrs	r7, BASEPRI
   11060:	f383 8811 	msr	BASEPRI, r3
   11064:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   11068:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   1106a:	b17b      	cbz	r3, 1108c <k_delayed_work_submit_to_queue+0x40>
   1106c:	4283      	cmp	r3, r0
   1106e:	d128      	bne.n	110c2 <k_delayed_work_submit_to_queue+0x76>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   11070:	4628      	mov	r0, r5
   11072:	f00c f9ff 	bl	1d474 <work_cancel>
		/* -EALREADY may indicate the work has already completed so
		 * this is likely a recurring work.  It may also indicate that
		 * the work handler is still executing.  But it's neither
		 * delayed nor pending, so it can be rescheduled.
		 */
		if (err == -EALREADY) {
   11076:	f110 0f78 	cmn.w	r0, #120	; 0x78
		err = work_cancel(work);
   1107a:	4604      	mov	r4, r0
		if (err == -EALREADY) {
   1107c:	d008      	beq.n	11090 <k_delayed_work_submit_to_queue+0x44>
			err = 0;
		} else if (err < 0) {
   1107e:	2800      	cmp	r0, #0
   11080:	da07      	bge.n	11092 <k_delayed_work_submit_to_queue+0x46>
	__asm__ volatile(
   11082:	f387 8811 	msr	BASEPRI, r7
   11086:	f3bf 8f6f 	isb	sy
	/* Add timeout */
	z_add_timeout(&work->timeout, work_timeout, delay);

done:
	k_spin_unlock(&lock, key);
	return err;
   1108a:	e00f      	b.n	110ac <k_delayed_work_submit_to_queue+0x60>
	if (work->work_q == work_q) {
   1108c:	2800      	cmp	r0, #0
   1108e:	d0ef      	beq.n	11070 <k_delayed_work_submit_to_queue+0x24>
	int err = 0;
   11090:	2400      	movs	r4, #0
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   11092:	ea58 0309 	orrs.w	r3, r8, r9
	work->work_q = work_q;
   11096:	62ae      	str	r6, [r5, #40]	; 0x28
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   11098:	d10b      	bne.n	110b2 <k_delayed_work_submit_to_queue+0x66>
   1109a:	f387 8811 	msr	BASEPRI, r7
   1109e:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   110a2:	4629      	mov	r1, r5
   110a4:	4630      	mov	r0, r6
   110a6:	f00c f9cc 	bl	1d442 <k_work_submit_to_queue>
		return 0;
   110aa:	2400      	movs	r4, #0
}
   110ac:	4620      	mov	r0, r4
   110ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	z_add_timeout(&work->timeout, work_timeout, delay);
   110b2:	4642      	mov	r2, r8
   110b4:	464b      	mov	r3, r9
   110b6:	4904      	ldr	r1, [pc, #16]	; (110c8 <k_delayed_work_submit_to_queue+0x7c>)
   110b8:	f105 0010 	add.w	r0, r5, #16
   110bc:	f000 f87c 	bl	111b8 <z_add_timeout>
   110c0:	e7df      	b.n	11082 <k_delayed_work_submit_to_queue+0x36>
		err = -EADDRINUSE;
   110c2:	f06f 046f 	mvn.w	r4, #111	; 0x6f
   110c6:	e7dc      	b.n	11082 <k_delayed_work_submit_to_queue+0x36>
   110c8:	0001d46b 	.word	0x0001d46b

000110cc <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   110cc:	4a02      	ldr	r2, [pc, #8]	; (110d8 <boot_banner+0xc>)
   110ce:	4903      	ldr	r1, [pc, #12]	; (110dc <boot_banner+0x10>)
   110d0:	4803      	ldr	r0, [pc, #12]	; (110e0 <boot_banner+0x14>)
   110d2:	f000 bc35 	b.w	11940 <printk>
   110d6:	bf00      	nop
   110d8:	0001f585 	.word	0x0001f585
   110dc:	00044305 	.word	0x00044305
   110e0:	00044312 	.word	0x00044312

000110e4 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   110e4:	b508      	push	{r3, lr}
   110e6:	4806      	ldr	r0, [pc, #24]	; (11100 <z_data_copy+0x1c>)
   110e8:	4a06      	ldr	r2, [pc, #24]	; (11104 <z_data_copy+0x20>)
   110ea:	4907      	ldr	r1, [pc, #28]	; (11108 <z_data_copy+0x24>)
   110ec:	1a12      	subs	r2, r2, r0
   110ee:	f00c fc38 	bl	1d962 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   110f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   110f6:	4a05      	ldr	r2, [pc, #20]	; (1110c <z_data_copy+0x28>)
   110f8:	4905      	ldr	r1, [pc, #20]	; (11110 <z_data_copy+0x2c>)
   110fa:	4806      	ldr	r0, [pc, #24]	; (11114 <z_data_copy+0x30>)
   110fc:	f00c bc31 	b.w	1d962 <memcpy>
   11100:	20000000 	.word	0x20000000
   11104:	200009b0 	.word	0x200009b0
   11108:	0004443c 	.word	0x0004443c
   1110c:	00000000 	.word	0x00000000
   11110:	0004443c 	.word	0x0004443c
   11114:	20000000 	.word	0x20000000

00011118 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0U;
   11118:	4b03      	ldr	r3, [pc, #12]	; (11128 <elapsed+0x10>)
   1111a:	681b      	ldr	r3, [r3, #0]
   1111c:	b90b      	cbnz	r3, 11122 <elapsed+0xa>
   1111e:	f7f1 b81b 	b.w	2158 <z_clock_elapsed>
}
   11122:	2000      	movs	r0, #0
   11124:	4770      	bx	lr
   11126:	bf00      	nop
   11128:	20025f08 	.word	0x20025f08

0001112c <remove_timeout>:
{
   1112c:	b530      	push	{r4, r5, lr}
   1112e:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   11130:	b168      	cbz	r0, 1114e <remove_timeout+0x22>
   11132:	4a0a      	ldr	r2, [pc, #40]	; (1115c <remove_timeout+0x30>)
	return (node == list->tail) ? NULL : node->next;
   11134:	6852      	ldr	r2, [r2, #4]
   11136:	4290      	cmp	r0, r2
   11138:	d009      	beq.n	1114e <remove_timeout+0x22>
	if (next(t) != NULL) {
   1113a:	b143      	cbz	r3, 1114e <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   1113c:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   11140:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   11144:	1912      	adds	r2, r2, r4
   11146:	eb45 0101 	adc.w	r1, r5, r1
   1114a:	e9c3 2104 	strd	r2, r1, [r3, #16]
	node->prev->next = node->next;
   1114e:	6842      	ldr	r2, [r0, #4]
   11150:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   11152:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   11154:	2300      	movs	r3, #0
	node->prev = NULL;
   11156:	e9c0 3300 	strd	r3, r3, [r0]
}
   1115a:	bd30      	pop	{r4, r5, pc}
   1115c:	2000050c 	.word	0x2000050c

00011160 <next_timeout>:

static int32_t next_timeout(void)
{
   11160:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   11162:	4b13      	ldr	r3, [pc, #76]	; (111b0 <next_timeout+0x50>)
   11164:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   11166:	429c      	cmp	r4, r3
   11168:	bf08      	it	eq
   1116a:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   1116c:	f7ff ffd4 	bl	11118 <elapsed>
   11170:	4605      	mov	r5, r0
	int32_t ret = to == NULL ? MAX_WAIT
   11172:	b1bc      	cbz	r4, 111a4 <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   11174:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
   11178:	1b40      	subs	r0, r0, r5
   1117a:	eb61 71e5 	sbc.w	r1, r1, r5, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
   1117e:	2801      	cmp	r0, #1
   11180:	f171 0300 	sbcs.w	r3, r1, #0
   11184:	db11      	blt.n	111aa <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   11186:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   1118a:	2300      	movs	r3, #0
   1118c:	4282      	cmp	r2, r0
   1118e:	eb73 0401 	sbcs.w	r4, r3, r1
   11192:	da00      	bge.n	11196 <next_timeout+0x36>
   11194:	4610      	mov	r0, r2

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   11196:	4b07      	ldr	r3, [pc, #28]	; (111b4 <next_timeout+0x54>)
   11198:	695b      	ldr	r3, [r3, #20]
   1119a:	b113      	cbz	r3, 111a2 <next_timeout+0x42>
   1119c:	4298      	cmp	r0, r3
   1119e:	bfa8      	it	ge
   111a0:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   111a2:	bd38      	pop	{r3, r4, r5, pc}
	int32_t ret = to == NULL ? MAX_WAIT
   111a4:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   111a8:	e7f5      	b.n	11196 <next_timeout+0x36>
   111aa:	2000      	movs	r0, #0
   111ac:	e7f3      	b.n	11196 <next_timeout+0x36>
   111ae:	bf00      	nop
   111b0:	2000050c 	.word	0x2000050c
   111b4:	20025ec8 	.word	0x20025ec8

000111b8 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
   111b8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   111bc:	9101      	str	r1, [sp, #4]
   111be:	4619      	mov	r1, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   111c0:	1c4b      	adds	r3, r1, #1
   111c2:	bf08      	it	eq
   111c4:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
   111c8:	4682      	mov	sl, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   111ca:	d070      	beq.n	112ae <z_add_timeout+0xf6>
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
   111cc:	f06f 0301 	mvn.w	r3, #1
   111d0:	f04f 3bff 	mov.w	fp, #4294967295
	k_ticks_t ticks = timeout.ticks + 1;
   111d4:	1c54      	adds	r4, r2, #1
   111d6:	f141 0500 	adc.w	r5, r1, #0
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
   111da:	ebb3 0804 	subs.w	r8, r3, r4
   111de:	eb6b 0905 	sbc.w	r9, fp, r5
   111e2:	f1b8 0f00 	cmp.w	r8, #0
   111e6:	f179 0300 	sbcs.w	r3, r9, #0
   111ea:	db0f      	blt.n	1120c <z_add_timeout+0x54>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
   111ec:	f7ff ff94 	bl	11118 <elapsed>
   111f0:	f06f 0301 	mvn.w	r3, #1
   111f4:	4a34      	ldr	r2, [pc, #208]	; (112c8 <z_add_timeout+0x110>)
   111f6:	e9d2 1c00 	ldrd	r1, ip, [r2]
   111fa:	1a5b      	subs	r3, r3, r1
   111fc:	eb6b 020c 	sbc.w	r2, fp, ip
   11200:	1b1e      	subs	r6, r3, r4
   11202:	eb62 0705 	sbc.w	r7, r2, r5
   11206:	1a34      	subs	r4, r6, r0
   11208:	eb67 75e0 	sbc.w	r5, r7, r0, asr #31
	}

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   1120c:	9b01      	ldr	r3, [sp, #4]
   1120e:	f8ca 3008 	str.w	r3, [sl, #8]
	__asm__ volatile(
   11212:	f04f 0320 	mov.w	r3, #32
   11216:	f3ef 8611 	mrs	r6, BASEPRI
   1121a:	f383 8811 	msr	BASEPRI, r3
   1121e:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   11222:	f7ff ff79 	bl	11118 <elapsed>
	ticks = MAX(1, ticks);
   11226:	2c01      	cmp	r4, #1
   11228:	f175 0300 	sbcs.w	r3, r5, #0
   1122c:	bfbc      	itt	lt
   1122e:	2401      	movlt	r4, #1
   11230:	2500      	movlt	r5, #0
	return list->head == list;
   11232:	4b26      	ldr	r3, [pc, #152]	; (112cc <z_add_timeout+0x114>)
		to->dticks = ticks + elapsed();
   11234:	1824      	adds	r4, r4, r0
   11236:	681a      	ldr	r2, [r3, #0]
   11238:	eb45 75e0 	adc.w	r5, r5, r0, asr #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1123c:	429a      	cmp	r2, r3
   1123e:	e9ca 4504 	strd	r4, r5, [sl, #16]
   11242:	d001      	beq.n	11248 <z_add_timeout+0x90>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   11244:	685f      	ldr	r7, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
   11246:	b952      	cbnz	r2, 1125e <z_add_timeout+0xa6>
	node->prev = list->tail;
   11248:	685a      	ldr	r2, [r3, #4]
	node->next = list;
   1124a:	f8ca 3000 	str.w	r3, [sl]
	node->prev = list->tail;
   1124e:	f8ca 2004 	str.w	r2, [sl, #4]
	list->tail->next = node;
   11252:	685a      	ldr	r2, [r3, #4]
   11254:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
   11258:	f8c3 a004 	str.w	sl, [r3, #4]
}
   1125c:	e014      	b.n	11288 <z_add_timeout+0xd0>
			if (t->dticks > to->dticks) {
   1125e:	e9d2 8904 	ldrd	r8, r9, [r2, #16]
   11262:	e9da 4504 	ldrd	r4, r5, [sl, #16]
   11266:	4544      	cmp	r4, r8
   11268:	eb75 0109 	sbcs.w	r1, r5, r9
   1126c:	da22      	bge.n	112b4 <z_add_timeout+0xfc>
				t->dticks -= to->dticks;
   1126e:	ebb8 0004 	subs.w	r0, r8, r4
   11272:	eb69 0105 	sbc.w	r1, r9, r5
   11276:	e9c2 0104 	strd	r0, r1, [r2, #16]
	node->prev = successor->prev;
   1127a:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   1127c:	e9ca 2100 	strd	r2, r1, [sl]
	successor->prev->next = node;
   11280:	f8c1 a000 	str.w	sl, [r1]
	successor->prev = node;
   11284:	f8c2 a004 	str.w	sl, [r2, #4]
	return list->head == list;
   11288:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1128a:	429a      	cmp	r2, r3
   1128c:	d00b      	beq.n	112a6 <z_add_timeout+0xee>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   1128e:	4592      	cmp	sl, r2
   11290:	d109      	bne.n	112a6 <z_add_timeout+0xee>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   11292:	f7ff ff65 	bl	11160 <next_timeout>

			if (next_time == 0 ||
   11296:	b118      	cbz	r0, 112a0 <z_add_timeout+0xe8>
			    _current_cpu->slice_ticks != next_time) {
   11298:	4b0d      	ldr	r3, [pc, #52]	; (112d0 <z_add_timeout+0x118>)
			if (next_time == 0 ||
   1129a:	695b      	ldr	r3, [r3, #20]
   1129c:	4283      	cmp	r3, r0
   1129e:	d002      	beq.n	112a6 <z_add_timeout+0xee>
				z_clock_set_timeout(next_time, false);
   112a0:	2100      	movs	r1, #0
   112a2:	f7f0 ff27 	bl	20f4 <z_clock_set_timeout>
	__asm__ volatile(
   112a6:	f386 8811 	msr	BASEPRI, r6
   112aa:	f3bf 8f6f 	isb	sy
#else
			z_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   112ae:	b003      	add	sp, #12
   112b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			to->dticks -= t->dticks;
   112b4:	ebb4 0008 	subs.w	r0, r4, r8
   112b8:	eb65 0109 	sbc.w	r1, r5, r9
	return (node == list->tail) ? NULL : node->next;
   112bc:	42ba      	cmp	r2, r7
   112be:	e9ca 0104 	strd	r0, r1, [sl, #16]
   112c2:	d0c1      	beq.n	11248 <z_add_timeout+0x90>
   112c4:	6812      	ldr	r2, [r2, #0]
   112c6:	e7be      	b.n	11246 <z_add_timeout+0x8e>
   112c8:	20001208 	.word	0x20001208
   112cc:	2000050c 	.word	0x2000050c
   112d0:	20025ec8 	.word	0x20025ec8

000112d4 <z_clock_announce>:
		}
	}
}

void z_clock_announce(int32_t ticks)
{
   112d4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   112d8:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   112da:	f7ff fb0f 	bl	108fc <z_time_slice>
	__asm__ volatile(
   112de:	f04f 0320 	mov.w	r3, #32
   112e2:	f3ef 8411 	mrs	r4, BASEPRI
   112e6:	f383 8811 	msr	BASEPRI, r3
   112ea:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   112ee:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 113a0 <z_clock_announce+0xcc>
   112f2:	4d2a      	ldr	r5, [pc, #168]	; (1139c <z_clock_announce+0xc8>)
   112f4:	4651      	mov	r1, sl
	return list->head == list;
   112f6:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 113a4 <z_clock_announce+0xd0>
   112fa:	602e      	str	r6, [r5, #0]
   112fc:	f8d5 c000 	ldr.w	ip, [r5]
   11300:	f8db 0000 	ldr.w	r0, [fp]
   11304:	4662      	mov	r2, ip
   11306:	e9da 8900 	ldrd	r8, r9, [sl]
   1130a:	17d3      	asrs	r3, r2, #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1130c:	4558      	cmp	r0, fp
   1130e:	e9cd 2300 	strd	r2, r3, [sp]
   11312:	d00d      	beq.n	11330 <z_clock_announce+0x5c>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   11314:	b160      	cbz	r0, 11330 <z_clock_announce+0x5c>
   11316:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
   1131a:	45b4      	cmp	ip, r6
   1131c:	41bb      	sbcs	r3, r7
   1131e:	da1d      	bge.n	1135c <z_clock_announce+0x88>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   11320:	9b00      	ldr	r3, [sp, #0]
   11322:	ebb6 0c03 	subs.w	ip, r6, r3
   11326:	9b01      	ldr	r3, [sp, #4]
   11328:	eb67 0603 	sbc.w	r6, r7, r3
   1132c:	e9c0 c604 	strd	ip, r6, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   11330:	2600      	movs	r6, #0
	curr_tick += announce_remaining;
   11332:	9b00      	ldr	r3, [sp, #0]
	announce_remaining = 0;
   11334:	602e      	str	r6, [r5, #0]
	curr_tick += announce_remaining;
   11336:	eb13 0208 	adds.w	r2, r3, r8
   1133a:	9b01      	ldr	r3, [sp, #4]
   1133c:	eb43 0309 	adc.w	r3, r3, r9
   11340:	e9c1 2300 	strd	r2, r3, [r1]

	z_clock_set_timeout(next_timeout(), false);
   11344:	f7ff ff0c 	bl	11160 <next_timeout>
   11348:	4631      	mov	r1, r6
   1134a:	f7f0 fed3 	bl	20f4 <z_clock_set_timeout>
	__asm__ volatile(
   1134e:	f384 8811 	msr	BASEPRI, r4
   11352:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   11356:	b003      	add	sp, #12
   11358:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		t->dticks = 0;
   1135c:	2200      	movs	r2, #0
   1135e:	2300      	movs	r3, #0
		curr_tick += dt;
   11360:	eb18 0806 	adds.w	r8, r8, r6
   11364:	eb49 79e6 	adc.w	r9, r9, r6, asr #31
		t->dticks = 0;
   11368:	e9c0 2304 	strd	r2, r3, [r0, #16]
		announce_remaining -= dt;
   1136c:	ebac 0606 	sub.w	r6, ip, r6
		curr_tick += dt;
   11370:	e9ca 8900 	strd	r8, r9, [sl]
		announce_remaining -= dt;
   11374:	602e      	str	r6, [r5, #0]
		remove_timeout(t);
   11376:	f7ff fed9 	bl	1112c <remove_timeout>
   1137a:	f384 8811 	msr	BASEPRI, r4
   1137e:	f3bf 8f6f 	isb	sy
		t->fn(t);
   11382:	6883      	ldr	r3, [r0, #8]
   11384:	4798      	blx	r3
	__asm__ volatile(
   11386:	f04f 0320 	mov.w	r3, #32
   1138a:	f3ef 8411 	mrs	r4, BASEPRI
   1138e:	f383 8811 	msr	BASEPRI, r3
   11392:	f3bf 8f6f 	isb	sy

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
   11396:	4902      	ldr	r1, [pc, #8]	; (113a0 <z_clock_announce+0xcc>)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   11398:	e7b0      	b.n	112fc <z_clock_announce+0x28>
   1139a:	bf00      	nop
   1139c:	20025f08 	.word	0x20025f08
   113a0:	20001208 	.word	0x20001208
   113a4:	2000050c 	.word	0x2000050c

000113a8 <z_tick_get>:

int64_t z_tick_get(void)
{
   113a8:	b510      	push	{r4, lr}
   113aa:	f04f 0320 	mov.w	r3, #32
   113ae:	f3ef 8411 	mrs	r4, BASEPRI
   113b2:	f383 8811 	msr	BASEPRI, r3
   113b6:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   113ba:	f7f0 fecd 	bl	2158 <z_clock_elapsed>
   113be:	4b06      	ldr	r3, [pc, #24]	; (113d8 <z_tick_get+0x30>)
   113c0:	e9d3 2300 	ldrd	r2, r3, [r3]
   113c4:	1812      	adds	r2, r2, r0
   113c6:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   113ca:	f384 8811 	msr	BASEPRI, r4
   113ce:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   113d2:	4610      	mov	r0, r2
   113d4:	4619      	mov	r1, r3
   113d6:	bd10      	pop	{r4, pc}
   113d8:	20001208 	.word	0x20001208

000113dc <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   113dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   113de:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
   113e2:	1c56      	adds	r6, r2, #1
   113e4:	f143 0700 	adc.w	r7, r3, #0
   113e8:	2f00      	cmp	r7, #0
   113ea:	bf08      	it	eq
   113ec:	2e02      	cmpeq	r6, #2
{
   113ee:	4604      	mov	r4, r0
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   113f0:	d302      	bcc.n	113f8 <z_timer_expiration_handler+0x1c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   113f2:	490c      	ldr	r1, [pc, #48]	; (11424 <z_timer_expiration_handler+0x48>)
   113f4:	f7ff fee0 	bl	111b8 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   113f8:	6b23      	ldr	r3, [r4, #48]	; 0x30
   113fa:	3301      	adds	r3, #1
   113fc:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   113fe:	6a23      	ldr	r3, [r4, #32]
   11400:	b10b      	cbz	r3, 11406 <z_timer_expiration_handler+0x2a>
		timer->expiry_fn(timer);
   11402:	4620      	mov	r0, r4
   11404:	4798      	blx	r3
	return list->head == list;
   11406:	f854 5f18 	ldr.w	r5, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1140a:	42a5      	cmp	r5, r4
   1140c:	d009      	beq.n	11422 <z_timer_expiration_handler+0x46>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   1140e:	b145      	cbz	r5, 11422 <z_timer_expiration_handler+0x46>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   11410:	4628      	mov	r0, r5
   11412:	f00b ff17 	bl	1d244 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
   11416:	4628      	mov	r0, r5
   11418:	f00b ff66 	bl	1d2e8 <z_ready_thread>
   1141c:	2300      	movs	r3, #0
   1141e:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80

	arch_thread_return_value_set(thread, 0);
}
   11422:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   11424:	000113dd 	.word	0x000113dd

00011428 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   11428:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
   1142c:	4619      	mov	r1, r3
   1142e:	4606      	mov	r6, r0
   11430:	4610      	mov	r0, r2
   11432:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   11436:	1c4c      	adds	r4, r1, #1
   11438:	bf08      	it	eq
   1143a:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   1143e:	4680      	mov	r8, r0
   11440:	4689      	mov	r9, r1
   11442:	d047      	beq.n	114d4 <z_impl_k_timer_start+0xac>
   11444:	4614      	mov	r4, r2
   11446:	461d      	mov	r5, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
   11448:	ea54 0305 	orrs.w	r3, r4, r5
   1144c:	d016      	beq.n	1147c <z_impl_k_timer_start+0x54>
   1144e:	f06f 0301 	mvn.w	r3, #1
   11452:	ebb3 0a02 	subs.w	sl, r3, r2
   11456:	f04f 33ff 	mov.w	r3, #4294967295
   1145a:	eb63 0b05 	sbc.w	fp, r3, r5
   1145e:	f1ba 0f00 	cmp.w	sl, #0
   11462:	f17b 0300 	sbcs.w	r3, fp, #0
   11466:	da09      	bge.n	1147c <z_impl_k_timer_start+0x54>
		period.ticks = MAX(period.ticks - 1, 1);
   11468:	f112 34ff 	adds.w	r4, r2, #4294967295
   1146c:	f145 35ff 	adc.w	r5, r5, #4294967295
   11470:	2c01      	cmp	r4, #1
   11472:	f175 0300 	sbcs.w	r3, r5, #0
   11476:	bfbc      	itt	lt
   11478:	2401      	movlt	r4, #1
   1147a:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   1147c:	f06f 0301 	mvn.w	r3, #1
   11480:	1a1b      	subs	r3, r3, r0
   11482:	9300      	str	r3, [sp, #0]
   11484:	f04f 33ff 	mov.w	r3, #4294967295
   11488:	eb63 0301 	sbc.w	r3, r3, r1
   1148c:	9301      	str	r3, [sp, #4]
   1148e:	e9dd 2300 	ldrd	r2, r3, [sp]
   11492:	2a00      	cmp	r2, #0
   11494:	f173 0300 	sbcs.w	r3, r3, #0
   11498:	da0c      	bge.n	114b4 <z_impl_k_timer_start+0x8c>
		duration.ticks = MAX(duration.ticks - 1, 0);
   1149a:	f110 38ff 	adds.w	r8, r0, #4294967295
   1149e:	f141 39ff 	adc.w	r9, r1, #4294967295
   114a2:	f1b8 0f00 	cmp.w	r8, #0
   114a6:	f179 0300 	sbcs.w	r3, r9, #0
   114aa:	bfbc      	itt	lt
   114ac:	f04f 0800 	movlt.w	r8, #0
   114b0:	f04f 0900 	movlt.w	r9, #0
	}

	(void)z_abort_timeout(&timer->timeout);
   114b4:	4630      	mov	r0, r6
   114b6:	f00c f832 	bl	1d51e <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   114ba:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   114bc:	4642      	mov	r2, r8
	timer->status = 0U;
   114be:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   114c0:	4630      	mov	r0, r6
   114c2:	464b      	mov	r3, r9
   114c4:	4905      	ldr	r1, [pc, #20]	; (114dc <z_impl_k_timer_start+0xb4>)
	timer->period = period;
   114c6:	e9c6 450a 	strd	r4, r5, [r6, #40]	; 0x28
		     duration);
}
   114ca:	b002      	add	sp, #8
   114cc:	e8bd 4f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   114d0:	f7ff be72 	b.w	111b8 <z_add_timeout>
}
   114d4:	b002      	add	sp, #8
   114d6:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
   114da:	bf00      	nop
   114dc:	000113dd 	.word	0x000113dd

000114e0 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
   114e0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   114e4:	461f      	mov	r7, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
   114e6:	4b2a      	ldr	r3, [pc, #168]	; (11590 <z_impl_k_poll+0xb0>)
{
   114e8:	4616      	mov	r6, r2
	struct z_poller *poller = &_current->poller;
   114ea:	689d      	ldr	r5, [r3, #8]

	poller->is_polling = true;
   114ec:	2301      	movs	r3, #1
   114ee:	f885 3064 	strb.w	r3, [r5, #100]	; 0x64
	poller->mode = MODE_POLL;
   114f2:	f885 3065 	strb.w	r3, [r5, #101]	; 0x65

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	events_registered = register_events(events, num_events, poller,
   114f6:	ea52 0307 	orrs.w	r3, r2, r7
   114fa:	bf0c      	ite	eq
   114fc:	2301      	moveq	r3, #1
   114fe:	2300      	movne	r3, #0
   11500:	f105 0264 	add.w	r2, r5, #100	; 0x64
{
   11504:	4680      	mov	r8, r0
	events_registered = register_events(events, num_events, poller,
   11506:	f00c f977 	bl	1d7f8 <register_events>
   1150a:	4681      	mov	r9, r0
	__asm__ volatile(
   1150c:	f04f 0320 	mov.w	r3, #32
   11510:	f3ef 8a11 	mrs	sl, BASEPRI
   11514:	f383 8811 	msr	BASEPRI, r3
   11518:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
   1151c:	f895 4064 	ldrb.w	r4, [r5, #100]	; 0x64
   11520:	b964      	cbnz	r4, 1153c <z_impl_k_poll+0x5c>
		clear_event_registrations(events, events_registered, key);
   11522:	4601      	mov	r1, r0
   11524:	4652      	mov	r2, sl
   11526:	4640      	mov	r0, r8
   11528:	f00c f896 	bl	1d658 <clear_event_registrations>
	__asm__ volatile(
   1152c:	f38a 8811 	msr	BASEPRI, sl
   11530:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
   11534:	4620      	mov	r0, r4
   11536:	b004      	add	sp, #16
   11538:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	poller->is_polling = false;
   1153c:	2300      	movs	r3, #0
   1153e:	f885 3064 	strb.w	r3, [r5, #100]	; 0x64
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   11542:	ea56 0307 	orrs.w	r3, r6, r7
   11546:	d106      	bne.n	11556 <z_impl_k_poll+0x76>
   11548:	f38a 8811 	msr	BASEPRI, sl
   1154c:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   11550:	f06f 040a 	mvn.w	r4, #10
   11554:	e7ee      	b.n	11534 <z_impl_k_poll+0x54>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   11556:	aa02      	add	r2, sp, #8
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   11558:	4651      	mov	r1, sl
   1155a:	e9cd 6700 	strd	r6, r7, [sp]
   1155e:	480d      	ldr	r0, [pc, #52]	; (11594 <z_impl_k_poll+0xb4>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   11560:	e9cd 2202 	strd	r2, r2, [sp, #8]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   11564:	f7ff fb02 	bl	10b6c <z_pend_curr>
   11568:	4604      	mov	r4, r0
	__asm__ volatile(
   1156a:	f04f 0320 	mov.w	r3, #32
   1156e:	f3ef 8511 	mrs	r5, BASEPRI
   11572:	f383 8811 	msr	BASEPRI, r3
   11576:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
   1157a:	462a      	mov	r2, r5
   1157c:	4649      	mov	r1, r9
   1157e:	4640      	mov	r0, r8
   11580:	f00c f86a 	bl	1d658 <clear_event_registrations>
	__asm__ volatile(
   11584:	f385 8811 	msr	BASEPRI, r5
   11588:	f3bf 8f6f 	isb	sy
	return swap_rc;
   1158c:	e7d2      	b.n	11534 <z_impl_k_poll+0x54>
   1158e:	bf00      	nop
   11590:	20025ec8 	.word	0x20025ec8
   11594:	2002a07a 	.word	0x2002a07a

00011598 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
   11598:	b538      	push	{r3, r4, r5, lr}
   1159a:	4603      	mov	r3, r0
	__asm__ volatile(
   1159c:	f04f 0220 	mov.w	r2, #32
   115a0:	f3ef 8511 	mrs	r5, BASEPRI
   115a4:	f382 8811 	msr	BASEPRI, r2
   115a8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
   115ac:	60c1      	str	r1, [r0, #12]
	signal->signaled = 1U;
   115ae:	2101      	movs	r1, #1
   115b0:	6081      	str	r1, [r0, #8]
	return list->head == list;
   115b2:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   115b4:	4283      	cmp	r3, r0
   115b6:	d106      	bne.n	115c6 <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
   115b8:	f385 8811 	msr	BASEPRI, r5
   115bc:	f3bf 8f6f 	isb	sy

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
   115c0:	2400      	movs	r4, #0

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);

	z_reschedule(&lock, key);
	return rc;
}
   115c2:	4620      	mov	r0, r4
   115c4:	bd38      	pop	{r3, r4, r5, pc}
	node->prev->next = node->next;
   115c6:	e9d0 3200 	ldrd	r3, r2, [r0]
   115ca:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   115cc:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   115ce:	2300      	movs	r3, #0
	node->prev = NULL;
   115d0:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   115d4:	f00c f87f 	bl	1d6d6 <signal_poll_event>
	z_reschedule(&lock, key);
   115d8:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   115da:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
   115dc:	4801      	ldr	r0, [pc, #4]	; (115e4 <z_impl_k_poll_signal_raise+0x4c>)
   115de:	f7ff f87d 	bl	106dc <z_reschedule>
	return rc;
   115e2:	e7ee      	b.n	115c2 <z_impl_k_poll_signal_raise+0x2a>
   115e4:	2002a07a 	.word	0x2002a07a

000115e8 <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
   115e8:	460a      	mov	r2, r1
		"align must be a multiple of sizeof(void *)");

	__ASSERT((align & (align - 1)) == 0,
		"align must be a power of 2");

	return z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
   115ea:	4601      	mov	r1, r0
   115ec:	4801      	ldr	r0, [pc, #4]	; (115f4 <k_aligned_alloc+0xc>)
   115ee:	f00c b981 	b.w	1d8f4 <z_heap_aligned_alloc>
   115f2:	bf00      	nop
   115f4:	200007cc 	.word	0x200007cc

000115f8 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   115f8:	b538      	push	{r3, r4, r5, lr}
   115fa:	4604      	mov	r4, r0
   115fc:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   115fe:	f00b ff13 	bl	1d428 <k_is_in_isr>
   11602:	b950      	cbnz	r0, 1161a <z_thread_aligned_alloc+0x22>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   11604:	4b06      	ldr	r3, [pc, #24]	; (11620 <z_thread_aligned_alloc+0x28>)
   11606:	689b      	ldr	r3, [r3, #8]
   11608:	6f9b      	ldr	r3, [r3, #120]	; 0x78
	}

	if (heap) {
   1160a:	b143      	cbz	r3, 1161e <z_thread_aligned_alloc+0x26>
		ret = z_heap_aligned_alloc(heap, align, size);
   1160c:	462a      	mov	r2, r5
   1160e:	4621      	mov	r1, r4
   11610:	4618      	mov	r0, r3
	} else {
		ret = NULL;
	}

	return ret;
}
   11612:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		ret = z_heap_aligned_alloc(heap, align, size);
   11616:	f00c b96d 	b.w	1d8f4 <z_heap_aligned_alloc>
		heap = _SYSTEM_HEAP;
   1161a:	4b02      	ldr	r3, [pc, #8]	; (11624 <z_thread_aligned_alloc+0x2c>)
   1161c:	e7f6      	b.n	1160c <z_thread_aligned_alloc+0x14>
}
   1161e:	bd38      	pop	{r3, r4, r5, pc}
   11620:	20025ec8 	.word	0x20025ec8
   11624:	200007cc 	.word	0x200007cc

00011628 <nrf_cc3xx_platform_init_no_rng>:
   11628:	b510      	push	{r4, lr}
   1162a:	4c0a      	ldr	r4, [pc, #40]	; (11654 <nrf_cc3xx_platform_init_no_rng+0x2c>)
   1162c:	6823      	ldr	r3, [r4, #0]
   1162e:	b11b      	cbz	r3, 11638 <nrf_cc3xx_platform_init_no_rng+0x10>
   11630:	2301      	movs	r3, #1
   11632:	2000      	movs	r0, #0
   11634:	6023      	str	r3, [r4, #0]
   11636:	bd10      	pop	{r4, pc}
   11638:	f000 f8b2 	bl	117a0 <CC_LibInitNoRng>
   1163c:	2800      	cmp	r0, #0
   1163e:	d0f7      	beq.n	11630 <nrf_cc3xx_platform_init_no_rng+0x8>
   11640:	3801      	subs	r0, #1
   11642:	2807      	cmp	r0, #7
   11644:	d803      	bhi.n	1164e <nrf_cc3xx_platform_init_no_rng+0x26>
   11646:	4b04      	ldr	r3, [pc, #16]	; (11658 <nrf_cc3xx_platform_init_no_rng+0x30>)
   11648:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   1164c:	bd10      	pop	{r4, pc}
   1164e:	4803      	ldr	r0, [pc, #12]	; (1165c <nrf_cc3xx_platform_init_no_rng+0x34>)
   11650:	bd10      	pop	{r4, pc}
   11652:	bf00      	nop
   11654:	20029f0c 	.word	0x20029f0c
   11658:	0001f498 	.word	0x0001f498
   1165c:	ffff8ffe 	.word	0xffff8ffe

00011660 <nrf_cc3xx_platform_abort>:
   11660:	f3bf 8f4f 	dsb	sy
   11664:	4905      	ldr	r1, [pc, #20]	; (1167c <nrf_cc3xx_platform_abort+0x1c>)
   11666:	4b06      	ldr	r3, [pc, #24]	; (11680 <nrf_cc3xx_platform_abort+0x20>)
   11668:	68ca      	ldr	r2, [r1, #12]
   1166a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1166e:	4313      	orrs	r3, r2
   11670:	60cb      	str	r3, [r1, #12]
   11672:	f3bf 8f4f 	dsb	sy
   11676:	bf00      	nop
   11678:	e7fd      	b.n	11676 <nrf_cc3xx_platform_abort+0x16>
   1167a:	bf00      	nop
   1167c:	e000ed00 	.word	0xe000ed00
   11680:	05fa0004 	.word	0x05fa0004

00011684 <CC_PalAbort>:
   11684:	f04f 33fe 	mov.w	r3, #4278124286	; 0xfefefefe
   11688:	2100      	movs	r1, #0
   1168a:	b430      	push	{r4, r5}
   1168c:	4a08      	ldr	r2, [pc, #32]	; (116b0 <CC_PalAbort+0x2c>)
   1168e:	4c09      	ldr	r4, [pc, #36]	; (116b4 <CC_PalAbort+0x30>)
   11690:	4d09      	ldr	r5, [pc, #36]	; (116b8 <CC_PalAbort+0x34>)
   11692:	6023      	str	r3, [r4, #0]
   11694:	602b      	str	r3, [r5, #0]
   11696:	6013      	str	r3, [r2, #0]
   11698:	60e3      	str	r3, [r4, #12]
   1169a:	60eb      	str	r3, [r5, #12]
   1169c:	60d3      	str	r3, [r2, #12]
   1169e:	61a3      	str	r3, [r4, #24]
   116a0:	4a06      	ldr	r2, [pc, #24]	; (116bc <CC_PalAbort+0x38>)
   116a2:	4c07      	ldr	r4, [pc, #28]	; (116c0 <CC_PalAbort+0x3c>)
   116a4:	61ab      	str	r3, [r5, #24]
   116a6:	6863      	ldr	r3, [r4, #4]
   116a8:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
   116ac:	bc30      	pop	{r4, r5}
   116ae:	4718      	bx	r3
   116b0:	50845408 	.word	0x50845408
   116b4:	50845400 	.word	0x50845400
   116b8:	50845404 	.word	0x50845404
   116bc:	50844000 	.word	0x50844000
   116c0:	20000514 	.word	0x20000514

000116c4 <nrf_cc3xx_platform_set_abort>:
   116c4:	4b02      	ldr	r3, [pc, #8]	; (116d0 <nrf_cc3xx_platform_set_abort+0xc>)
   116c6:	e9d0 1200 	ldrd	r1, r2, [r0]
   116ca:	e9c3 1200 	strd	r1, r2, [r3]
   116ce:	4770      	bx	lr
   116d0:	20000514 	.word	0x20000514

000116d4 <mutex_unlock>:
   116d4:	b148      	cbz	r0, 116ea <mutex_unlock+0x16>
   116d6:	6843      	ldr	r3, [r0, #4]
   116d8:	b12b      	cbz	r3, 116e6 <mutex_unlock+0x12>
   116da:	f3bf 8f5f 	dmb	sy
   116de:	2300      	movs	r3, #0
   116e0:	6003      	str	r3, [r0, #0]
   116e2:	4618      	mov	r0, r3
   116e4:	4770      	bx	lr
   116e6:	4802      	ldr	r0, [pc, #8]	; (116f0 <mutex_unlock+0x1c>)
   116e8:	4770      	bx	lr
   116ea:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
   116ee:	4770      	bx	lr
   116f0:	ffff8fea 	.word	0xffff8fea

000116f4 <mutex_free>:
   116f4:	b510      	push	{r4, lr}
   116f6:	4604      	mov	r4, r0
   116f8:	b128      	cbz	r0, 11706 <mutex_free+0x12>
   116fa:	6863      	ldr	r3, [r4, #4]
   116fc:	b113      	cbz	r3, 11704 <mutex_free+0x10>
   116fe:	2300      	movs	r3, #0
   11700:	6023      	str	r3, [r4, #0]
   11702:	6063      	str	r3, [r4, #4]
   11704:	bd10      	pop	{r4, pc}
   11706:	4b02      	ldr	r3, [pc, #8]	; (11710 <mutex_free+0x1c>)
   11708:	4802      	ldr	r0, [pc, #8]	; (11714 <mutex_free+0x20>)
   1170a:	685b      	ldr	r3, [r3, #4]
   1170c:	4798      	blx	r3
   1170e:	e7f4      	b.n	116fa <mutex_free+0x6>
   11710:	20000514 	.word	0x20000514
   11714:	0001f4b8 	.word	0x0001f4b8

00011718 <mutex_init>:
   11718:	b510      	push	{r4, lr}
   1171a:	4604      	mov	r4, r0
   1171c:	b130      	cbz	r0, 1172c <mutex_init+0x14>
   1171e:	2200      	movs	r2, #0
   11720:	6863      	ldr	r3, [r4, #4]
   11722:	6022      	str	r2, [r4, #0]
   11724:	f043 0301 	orr.w	r3, r3, #1
   11728:	6063      	str	r3, [r4, #4]
   1172a:	bd10      	pop	{r4, pc}
   1172c:	4801      	ldr	r0, [pc, #4]	; (11734 <mutex_init+0x1c>)
   1172e:	f7ff ffa9 	bl	11684 <CC_PalAbort>
   11732:	e7f4      	b.n	1171e <mutex_init+0x6>
   11734:	0001f4e0 	.word	0x0001f4e0

00011738 <mutex_lock>:
   11738:	b180      	cbz	r0, 1175c <mutex_lock+0x24>
   1173a:	6843      	ldr	r3, [r0, #4]
   1173c:	b163      	cbz	r3, 11758 <mutex_lock+0x20>
   1173e:	2201      	movs	r2, #1
   11740:	e8d0 3fef 	ldaex	r3, [r0]
   11744:	e8c0 2fe1 	stlex	r1, r2, [r0]
   11748:	2900      	cmp	r1, #0
   1174a:	d1f9      	bne.n	11740 <mutex_lock+0x8>
   1174c:	2b01      	cmp	r3, #1
   1174e:	d0f7      	beq.n	11740 <mutex_lock+0x8>
   11750:	f3bf 8f5f 	dmb	sy
   11754:	2000      	movs	r0, #0
   11756:	4770      	bx	lr
   11758:	4802      	ldr	r0, [pc, #8]	; (11764 <mutex_lock+0x2c>)
   1175a:	4770      	bx	lr
   1175c:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
   11760:	4770      	bx	lr
   11762:	bf00      	nop
   11764:	ffff8fea 	.word	0xffff8fea

00011768 <nrf_cc3xx_platform_set_mutexes>:
   11768:	b470      	push	{r4, r5, r6}
   1176a:	4b0b      	ldr	r3, [pc, #44]	; (11798 <nrf_cc3xx_platform_set_mutexes+0x30>)
   1176c:	6806      	ldr	r6, [r0, #0]
   1176e:	68c2      	ldr	r2, [r0, #12]
   11770:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
   11774:	e9c3 4202 	strd	r4, r2, [r3, #8]
   11778:	e9c3 6500 	strd	r6, r5, [r3]
   1177c:	e9d1 0203 	ldrd	r0, r2, [r1, #12]
   11780:	680e      	ldr	r6, [r1, #0]
   11782:	4b06      	ldr	r3, [pc, #24]	; (1179c <nrf_cc3xx_platform_set_mutexes+0x34>)
   11784:	e9d1 5401 	ldrd	r5, r4, [r1, #4]
   11788:	e9c3 6500 	strd	r6, r5, [r3]
   1178c:	e9c3 4002 	strd	r4, r0, [r3, #8]
   11790:	611a      	str	r2, [r3, #16]
   11792:	bc70      	pop	{r4, r5, r6}
   11794:	4770      	bx	lr
   11796:	bf00      	nop
   11798:	20000524 	.word	0x20000524
   1179c:	20000534 	.word	0x20000534

000117a0 <CC_LibInitNoRng>:
   117a0:	b508      	push	{r3, lr}
   117a2:	f000 f80f 	bl	117c4 <CC_HalInit>
   117a6:	b928      	cbnz	r0, 117b4 <CC_LibInitNoRng+0x14>
   117a8:	f000 f80e 	bl	117c8 <CC_PalInit>
   117ac:	b930      	cbnz	r0, 117bc <CC_LibInitNoRng+0x1c>
   117ae:	4a04      	ldr	r2, [pc, #16]	; (117c0 <CC_LibInitNoRng+0x20>)
   117b0:	6010      	str	r0, [r2, #0]
   117b2:	bd08      	pop	{r3, pc}
   117b4:	f000 f836 	bl	11824 <CC_PalTerminate>
   117b8:	2003      	movs	r0, #3
   117ba:	bd08      	pop	{r3, pc}
   117bc:	2004      	movs	r0, #4
   117be:	bd08      	pop	{r3, pc}
   117c0:	50845a0c 	.word	0x50845a0c

000117c4 <CC_HalInit>:
   117c4:	2000      	movs	r0, #0
   117c6:	4770      	bx	lr

000117c8 <CC_PalInit>:
   117c8:	b510      	push	{r4, lr}
   117ca:	4811      	ldr	r0, [pc, #68]	; (11810 <CC_PalInit+0x48>)
   117cc:	f000 f848 	bl	11860 <CC_PalMutexCreate>
   117d0:	b100      	cbz	r0, 117d4 <CC_PalInit+0xc>
   117d2:	bd10      	pop	{r4, pc}
   117d4:	480f      	ldr	r0, [pc, #60]	; (11814 <CC_PalInit+0x4c>)
   117d6:	f000 f843 	bl	11860 <CC_PalMutexCreate>
   117da:	2800      	cmp	r0, #0
   117dc:	d1f9      	bne.n	117d2 <CC_PalInit+0xa>
   117de:	4c0e      	ldr	r4, [pc, #56]	; (11818 <CC_PalInit+0x50>)
   117e0:	4620      	mov	r0, r4
   117e2:	f000 f83d 	bl	11860 <CC_PalMutexCreate>
   117e6:	2800      	cmp	r0, #0
   117e8:	d1f3      	bne.n	117d2 <CC_PalInit+0xa>
   117ea:	4b0c      	ldr	r3, [pc, #48]	; (1181c <CC_PalInit+0x54>)
   117ec:	480c      	ldr	r0, [pc, #48]	; (11820 <CC_PalInit+0x58>)
   117ee:	601c      	str	r4, [r3, #0]
   117f0:	f000 f836 	bl	11860 <CC_PalMutexCreate>
   117f4:	4601      	mov	r1, r0
   117f6:	2800      	cmp	r0, #0
   117f8:	d1eb      	bne.n	117d2 <CC_PalInit+0xa>
   117fa:	f000 f82d 	bl	11858 <CC_PalDmaInit>
   117fe:	4604      	mov	r4, r0
   11800:	b108      	cbz	r0, 11806 <CC_PalInit+0x3e>
   11802:	4620      	mov	r0, r4
   11804:	bd10      	pop	{r4, pc}
   11806:	f000 f83f 	bl	11888 <CC_PalPowerSaveModeInit>
   1180a:	4620      	mov	r0, r4
   1180c:	e7fa      	b.n	11804 <CC_PalInit+0x3c>
   1180e:	bf00      	nop
   11810:	2000056c 	.word	0x2000056c
   11814:	20000560 	.word	0x20000560
   11818:	20000568 	.word	0x20000568
   1181c:	20000570 	.word	0x20000570
   11820:	20000564 	.word	0x20000564

00011824 <CC_PalTerminate>:
   11824:	b508      	push	{r3, lr}
   11826:	4808      	ldr	r0, [pc, #32]	; (11848 <CC_PalTerminate+0x24>)
   11828:	f000 f824 	bl	11874 <CC_PalMutexDestroy>
   1182c:	4807      	ldr	r0, [pc, #28]	; (1184c <CC_PalTerminate+0x28>)
   1182e:	f000 f821 	bl	11874 <CC_PalMutexDestroy>
   11832:	4807      	ldr	r0, [pc, #28]	; (11850 <CC_PalTerminate+0x2c>)
   11834:	f000 f81e 	bl	11874 <CC_PalMutexDestroy>
   11838:	4806      	ldr	r0, [pc, #24]	; (11854 <CC_PalTerminate+0x30>)
   1183a:	f000 f81b 	bl	11874 <CC_PalMutexDestroy>
   1183e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   11842:	f000 b80b 	b.w	1185c <CC_PalDmaTerminate>
   11846:	bf00      	nop
   11848:	2000056c 	.word	0x2000056c
   1184c:	20000560 	.word	0x20000560
   11850:	20000568 	.word	0x20000568
   11854:	20000564 	.word	0x20000564

00011858 <CC_PalDmaInit>:
   11858:	2000      	movs	r0, #0
   1185a:	4770      	bx	lr

0001185c <CC_PalDmaTerminate>:
   1185c:	4770      	bx	lr
   1185e:	bf00      	nop

00011860 <CC_PalMutexCreate>:
   11860:	b508      	push	{r3, lr}
   11862:	4b03      	ldr	r3, [pc, #12]	; (11870 <CC_PalMutexCreate+0x10>)
   11864:	6802      	ldr	r2, [r0, #0]
   11866:	681b      	ldr	r3, [r3, #0]
   11868:	6810      	ldr	r0, [r2, #0]
   1186a:	4798      	blx	r3
   1186c:	2000      	movs	r0, #0
   1186e:	bd08      	pop	{r3, pc}
   11870:	20000524 	.word	0x20000524

00011874 <CC_PalMutexDestroy>:
   11874:	b508      	push	{r3, lr}
   11876:	4b03      	ldr	r3, [pc, #12]	; (11884 <CC_PalMutexDestroy+0x10>)
   11878:	6802      	ldr	r2, [r0, #0]
   1187a:	685b      	ldr	r3, [r3, #4]
   1187c:	6810      	ldr	r0, [r2, #0]
   1187e:	4798      	blx	r3
   11880:	2000      	movs	r0, #0
   11882:	bd08      	pop	{r3, pc}
   11884:	20000524 	.word	0x20000524

00011888 <CC_PalPowerSaveModeInit>:
   11888:	b570      	push	{r4, r5, r6, lr}
   1188a:	4c09      	ldr	r4, [pc, #36]	; (118b0 <CC_PalPowerSaveModeInit+0x28>)
   1188c:	4d09      	ldr	r5, [pc, #36]	; (118b4 <CC_PalPowerSaveModeInit+0x2c>)
   1188e:	6920      	ldr	r0, [r4, #16]
   11890:	68ab      	ldr	r3, [r5, #8]
   11892:	4798      	blx	r3
   11894:	b118      	cbz	r0, 1189e <CC_PalPowerSaveModeInit+0x16>
   11896:	4b08      	ldr	r3, [pc, #32]	; (118b8 <CC_PalPowerSaveModeInit+0x30>)
   11898:	4808      	ldr	r0, [pc, #32]	; (118bc <CC_PalPowerSaveModeInit+0x34>)
   1189a:	685b      	ldr	r3, [r3, #4]
   1189c:	4798      	blx	r3
   1189e:	2100      	movs	r1, #0
   118a0:	4a07      	ldr	r2, [pc, #28]	; (118c0 <CC_PalPowerSaveModeInit+0x38>)
   118a2:	68eb      	ldr	r3, [r5, #12]
   118a4:	6011      	str	r1, [r2, #0]
   118a6:	6920      	ldr	r0, [r4, #16]
   118a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   118ac:	4718      	bx	r3
   118ae:	bf00      	nop
   118b0:	20000534 	.word	0x20000534
   118b4:	20000524 	.word	0x20000524
   118b8:	20000514 	.word	0x20000514
   118bc:	0001f504 	.word	0x0001f504
   118c0:	20029f20 	.word	0x20029f20

000118c4 <app_button_cb>:
}
   118c4:	2000      	movs	r0, #0
   118c6:	4770      	bx	lr

000118c8 <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
   118c8:	b508      	push	{r3, lr}
    return lv_disp_get_scr_act(lv_disp_get_default());
   118ca:	f7fa fe4d 	bl	c568 <lv_disp_get_default>
}
   118ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return lv_disp_get_scr_act(lv_disp_get_default());
   118d2:	f003 be62 	b.w	1559a <lv_disp_get_scr_act>

000118d6 <on_gui_event>:
	switch(event->evt_type) {
   118d6:	7803      	ldrb	r3, [r0, #0]
   118d8:	b913      	cbnz	r3, 118e0 <on_gui_event+0xa>
			app_ble_send_button_state(event->button_checked);
   118da:	7840      	ldrb	r0, [r0, #1]
   118dc:	f7ee be14 	b.w	508 <app_ble_send_button_state>
}
   118e0:	4770      	bx	lr

000118e2 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   118e2:	4603      	mov	r3, r0
   118e4:	b140      	cbz	r0, 118f8 <sys_notify_validate+0x16>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   118e6:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   118e8:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   118ec:	2a02      	cmp	r2, #2
   118ee:	d006      	beq.n	118fe <sys_notify_validate+0x1c>
   118f0:	2a03      	cmp	r2, #3
   118f2:	d004      	beq.n	118fe <sys_notify_validate+0x1c>
   118f4:	2a01      	cmp	r2, #1
   118f6:	d005      	beq.n	11904 <sys_notify_validate+0x22>
		return -EINVAL;
   118f8:	f06f 0015 	mvn.w	r0, #21
	if (rv == 0) {
		notify->result = 0;
	}

	return rv;
}
   118fc:	4770      	bx	lr
		if (notify->method.signal == NULL) {
   118fe:	681a      	ldr	r2, [r3, #0]
   11900:	2a00      	cmp	r2, #0
   11902:	d0f9      	beq.n	118f8 <sys_notify_validate+0x16>
		notify->result = 0;
   11904:	2000      	movs	r0, #0
   11906:	6098      	str	r0, [r3, #8]
   11908:	4770      	bx	lr

0001190a <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   1190a:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   1190c:	b510      	push	{r4, lr}
	return method & SYS_NOTIFY_METHOD_MASK;
   1190e:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   11912:	2a02      	cmp	r2, #2
{
   11914:	4603      	mov	r3, r0
	notify->result = res;
   11916:	6081      	str	r1, [r0, #8]
	switch (method) {
   11918:	d00a      	beq.n	11930 <sys_notify_finalize+0x26>
   1191a:	2a03      	cmp	r2, #3
   1191c:	d10b      	bne.n	11936 <sys_notify_finalize+0x2c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   1191e:	6804      	ldr	r4, [r0, #0]
	struct k_poll_signal *sig = NULL;
   11920:	2000      	movs	r0, #0
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   11922:	2200      	movs	r2, #0
   11924:	605a      	str	r2, [r3, #4]

	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
   11926:	b108      	cbz	r0, 1192c <sys_notify_finalize+0x22>
	return z_impl_k_poll_signal_raise(signal, result);
   11928:	f7ff fe36 	bl	11598 <z_impl_k_poll_signal_raise>
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   1192c:	4620      	mov	r0, r4
   1192e:	bd10      	pop	{r4, pc}
	sys_notify_generic_callback rv = 0;
   11930:	2400      	movs	r4, #0
		sig = notify->method.signal;
   11932:	6800      	ldr	r0, [r0, #0]
		break;
   11934:	e7f5      	b.n	11922 <sys_notify_finalize+0x18>
	switch (method) {
   11936:	2400      	movs	r4, #0
   11938:	4620      	mov	r0, r4
   1193a:	e7f2      	b.n	11922 <sys_notify_finalize+0x18>

0001193c <arch_printk_char_out>:
}
   1193c:	2000      	movs	r0, #0
   1193e:	4770      	bx	lr

00011940 <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
   11940:	b40f      	push	{r0, r1, r2, r3}
   11942:	b507      	push	{r0, r1, r2, lr}
   11944:	a904      	add	r1, sp, #16
   11946:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
   1194a:	9101      	str	r1, [sp, #4]

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
   1194c:	f7ef fa5a 	bl	e04 <vprintk>
	}
	va_end(ap);
}
   11950:	b003      	add	sp, #12
   11952:	f85d eb04 	ldr.w	lr, [sp], #4
   11956:	b004      	add	sp, #16
   11958:	4770      	bx	lr

0001195a <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1195a:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   1195c:	f013 0307 	ands.w	r3, r3, #7
   11960:	d105      	bne.n	1196e <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   11962:	6803      	ldr	r3, [r0, #0]
   11964:	2b00      	cmp	r3, #0
		evt = EVT_START;
   11966:	bf0c      	ite	eq
   11968:	2000      	moveq	r0, #0
   1196a:	2003      	movne	r0, #3
   1196c:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   1196e:	2b02      	cmp	r3, #2
   11970:	d105      	bne.n	1197e <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   11972:	8b43      	ldrh	r3, [r0, #26]
   11974:	2b00      	cmp	r3, #0
		evt = EVT_STOP;
   11976:	bf14      	ite	ne
   11978:	2000      	movne	r0, #0
   1197a:	2004      	moveq	r0, #4
   1197c:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   1197e:	2b01      	cmp	r3, #1
   11980:	d105      	bne.n	1198e <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   11982:	6803      	ldr	r3, [r0, #0]
   11984:	2b00      	cmp	r3, #0
		evt = EVT_RESET;
   11986:	bf0c      	ite	eq
   11988:	2000      	moveq	r0, #0
   1198a:	2005      	movne	r0, #5
   1198c:	4770      	bx	lr
	int evt = EVT_NOP;
   1198e:	2000      	movs	r0, #0
}
   11990:	4770      	bx	lr

00011992 <notify_one>:
{
   11992:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11996:	460d      	mov	r5, r1
   11998:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   1199a:	4619      	mov	r1, r3
   1199c:	1d28      	adds	r0, r5, #4
{
   1199e:	4690      	mov	r8, r2
   119a0:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   119a2:	f7ff ffb2 	bl	1190a <sys_notify_finalize>
	if (cb) {
   119a6:	4604      	mov	r4, r0
   119a8:	b138      	cbz	r0, 119ba <notify_one+0x28>
		cb(mgr, cli, state, res);
   119aa:	4633      	mov	r3, r6
   119ac:	4642      	mov	r2, r8
   119ae:	4629      	mov	r1, r5
   119b0:	4638      	mov	r0, r7
   119b2:	46a4      	mov	ip, r4
}
   119b4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   119b8:	4760      	bx	ip
}
   119ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000119be <transition_complete>:
{
   119be:	b410      	push	{r4}
	__asm__ volatile(
   119c0:	f04f 0420 	mov.w	r4, #32
   119c4:	f3ef 8211 	mrs	r2, BASEPRI
   119c8:	f384 8811 	msr	BASEPRI, r4
   119cc:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   119d0:	6141      	str	r1, [r0, #20]
}
   119d2:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   119d4:	2101      	movs	r1, #1
   119d6:	f7ef ba23 	b.w	e20 <process_event>

000119da <validate_args>:
{
   119da:	b510      	push	{r4, lr}
   119dc:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   119de:	b140      	cbz	r0, 119f2 <validate_args+0x18>
   119e0:	b139      	cbz	r1, 119f2 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   119e2:	1d08      	adds	r0, r1, #4
   119e4:	f7ff ff7d 	bl	118e2 <sys_notify_validate>
	if ((rv == 0)
   119e8:	b928      	cbnz	r0, 119f6 <validate_args+0x1c>
	    && ((cli->notify.flags
   119ea:	68a3      	ldr	r3, [r4, #8]
   119ec:	f033 0303 	bics.w	r3, r3, #3
   119f0:	d001      	beq.n	119f6 <validate_args+0x1c>
		rv = -EINVAL;
   119f2:	f06f 0015 	mvn.w	r0, #21
}
   119f6:	bd10      	pop	{r4, pc}

000119f8 <onoff_manager_init>:
{
   119f8:	b538      	push	{r3, r4, r5, lr}
   119fa:	460c      	mov	r4, r1
	if ((mgr == NULL)
   119fc:	4605      	mov	r5, r0
   119fe:	b158      	cbz	r0, 11a18 <onoff_manager_init+0x20>
	    || (transitions == NULL)
   11a00:	b151      	cbz	r1, 11a18 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   11a02:	680b      	ldr	r3, [r1, #0]
   11a04:	b143      	cbz	r3, 11a18 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   11a06:	684b      	ldr	r3, [r1, #4]
   11a08:	b133      	cbz	r3, 11a18 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   11a0a:	221c      	movs	r2, #28
   11a0c:	2100      	movs	r1, #0
   11a0e:	f00b ffb5 	bl	1d97c <memset>
	return 0;
   11a12:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   11a14:	612c      	str	r4, [r5, #16]
}
   11a16:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   11a18:	f06f 0015 	mvn.w	r0, #21
   11a1c:	e7fb      	b.n	11a16 <onoff_manager_init+0x1e>

00011a1e <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   11a1e:	b570      	push	{r4, r5, r6, lr}
   11a20:	4604      	mov	r4, r0
   11a22:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   11a24:	f7ff ffd9 	bl	119da <validate_args>

	if (rv < 0) {
   11a28:	1e05      	subs	r5, r0, #0
   11a2a:	db31      	blt.n	11a90 <onoff_request+0x72>
   11a2c:	f04f 0320 	mov.w	r3, #32
   11a30:	f3ef 8111 	mrs	r1, BASEPRI
   11a34:	f383 8811 	msr	BASEPRI, r3
   11a38:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   11a3c:	f64f 75ff 	movw	r5, #65535	; 0xffff
   11a40:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   11a42:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   11a44:	42ab      	cmp	r3, r5
   11a46:	f000 0207 	and.w	r2, r0, #7
   11a4a:	d02e      	beq.n	11aaa <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   11a4c:	2a02      	cmp	r2, #2
   11a4e:	d10e      	bne.n	11a6e <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   11a50:	3301      	adds	r3, #1
   11a52:	8363      	strh	r3, [r4, #26]
	rv = state;
   11a54:	4615      	mov	r5, r2
		notify = true;
   11a56:	2301      	movs	r3, #1
	__asm__ volatile(
   11a58:	f381 8811 	msr	BASEPRI, r1
   11a5c:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   11a60:	b1b3      	cbz	r3, 11a90 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   11a62:	2300      	movs	r3, #0
   11a64:	4631      	mov	r1, r6
   11a66:	4620      	mov	r0, r4
   11a68:	f7ff ff93 	bl	11992 <notify_one>
   11a6c:	e010      	b.n	11a90 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   11a6e:	0783      	lsls	r3, r0, #30
   11a70:	d001      	beq.n	11a76 <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   11a72:	2a06      	cmp	r2, #6
   11a74:	d10e      	bne.n	11a94 <onoff_request+0x76>
	parent->next = child;
   11a76:	2300      	movs	r3, #0
   11a78:	6033      	str	r3, [r6, #0]
Z_GENLIST_APPEND(slist, snode)
   11a7a:	6863      	ldr	r3, [r4, #4]
   11a7c:	b993      	cbnz	r3, 11aa4 <onoff_request+0x86>
	list->head = node;
   11a7e:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   11a82:	4615      	mov	r5, r2
   11a84:	b962      	cbnz	r2, 11aa0 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   11a86:	460a      	mov	r2, r1
   11a88:	4620      	mov	r0, r4
   11a8a:	2102      	movs	r1, #2
   11a8c:	f7ef f9c8 	bl	e20 <process_event>
		}
	}

	return rv;
}
   11a90:	4628      	mov	r0, r5
   11a92:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   11a94:	2a05      	cmp	r2, #5
   11a96:	bf0c      	ite	eq
   11a98:	f06f 0585 	mvneq.w	r5, #133	; 0x85
   11a9c:	f06f 0504 	mvnne.w	r5, #4
   11aa0:	2300      	movs	r3, #0
   11aa2:	e7d9      	b.n	11a58 <onoff_request+0x3a>
	parent->next = child;
   11aa4:	601e      	str	r6, [r3, #0]
	list->tail = node;
   11aa6:	6066      	str	r6, [r4, #4]
}
   11aa8:	e7eb      	b.n	11a82 <onoff_request+0x64>
		rv = -EAGAIN;
   11aaa:	f06f 050a 	mvn.w	r5, #10
   11aae:	e7f7      	b.n	11aa0 <onoff_request+0x82>

00011ab0 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   11ab0:	4604      	mov	r4, r0
   11ab2:	b508      	push	{r3, lr}
   11ab4:	4608      	mov	r0, r1
   11ab6:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   11ab8:	461a      	mov	r2, r3
   11aba:	47a0      	blx	r4
	return z_impl_k_current_get();
   11abc:	f7ff f964 	bl	10d88 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   11ac0:	f7f1 f8a0 	bl	2c04 <z_impl_k_thread_abort>

00011ac4 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   11ac4:	b510      	push	{r4, lr}
   11ac6:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   11ac8:	f04f 33ff 	mov.w	r3, #4294967295
   11acc:	f04f 32ff 	mov.w	r2, #4294967295
   11ad0:	4620      	mov	r0, r4
   11ad2:	f7fe fd8d 	bl	105f0 <z_impl_k_queue_get>
   11ad6:	4603      	mov	r3, r0
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   11ad8:	2800      	cmp	r0, #0
   11ada:	d0f5      	beq.n	11ac8 <z_work_q_main+0x4>
			continue;
		}

		handler = work->handler;
   11adc:	6842      	ldr	r2, [r0, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   11ade:	3308      	adds	r3, #8
   11ae0:	e8d3 1fef 	ldaex	r1, [r3]
   11ae4:	f021 0c01 	bic.w	ip, r1, #1
   11ae8:	e8c3 cfee 	stlex	lr, ip, [r3]
   11aec:	f1be 0f00 	cmp.w	lr, #0
   11af0:	d1f6      	bne.n	11ae0 <z_work_q_main+0x1c>
		__ASSERT(handler != NULL, "handler must be provided");

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   11af2:	07cb      	lsls	r3, r1, #31
   11af4:	d500      	bpl.n	11af8 <z_work_q_main+0x34>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   11af6:	4790      	blx	r2
	z_impl_k_yield();
   11af8:	f7ff f8d6 	bl	10ca8 <z_impl_k_yield>
   11afc:	e7e4      	b.n	11ac8 <z_work_q_main+0x4>

00011afe <chunk_field>:
				 enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
   11afe:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
   11b00:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
   11b04:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((uint32_t *)cmem)[f];
   11b08:	bf2c      	ite	cs
   11b0a:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((uint16_t *)cmem)[f];
   11b0e:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
   11b12:	4770      	bx	lr

00011b14 <chunk_set>:
			     enum chunk_fields f, chunkid_t val)
{
	CHECK(c <= h->len);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
   11b14:	eb00 01c1 	add.w	r1, r0, r1, lsl #3

	if (big_heap(h)) {
   11b18:	6880      	ldr	r0, [r0, #8]
   11b1a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
   11b1e:	bf2c      	ite	cs
   11b20:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
   11b24:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
   11b28:	4770      	bx	lr

00011b2a <chunk_size>:
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline size_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   11b2a:	2201      	movs	r2, #1
{
   11b2c:	b508      	push	{r3, lr}
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   11b2e:	f7ff ffe6 	bl	11afe <chunk_field>
}
   11b32:	0840      	lsrs	r0, r0, #1
   11b34:	bd08      	pop	{r3, pc}

00011b36 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
   11b36:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
   11b38:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
   11b3c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11b40:	d308      	bcc.n	11b54 <set_chunk_used+0x1e>
		if (used) {
   11b42:	684b      	ldr	r3, [r1, #4]
   11b44:	b11a      	cbz	r2, 11b4e <set_chunk_used+0x18>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
   11b46:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
   11b4a:	604b      	str	r3, [r1, #4]
   11b4c:	4770      	bx	lr
   11b4e:	f023 0301 	bic.w	r3, r3, #1
   11b52:	e7fa      	b.n	11b4a <set_chunk_used+0x14>
		}
	} else {
		if (used) {
   11b54:	884b      	ldrh	r3, [r1, #2]
   11b56:	b11a      	cbz	r2, 11b60 <set_chunk_used+0x2a>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   11b58:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   11b5c:	804b      	strh	r3, [r1, #2]
		}
	}
}
   11b5e:	4770      	bx	lr
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   11b60:	f023 0301 	bic.w	r3, r3, #1
   11b64:	e7fa      	b.n	11b5c <set_chunk_used+0x26>

00011b66 <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, size_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   11b66:	0053      	lsls	r3, r2, #1
   11b68:	2201      	movs	r2, #1
   11b6a:	f7ff bfd3 	b.w	11b14 <chunk_set>

00011b6e <bucket_idx>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
   11b6e:	6880      	ldr	r0, [r0, #8]
	return bytes_to_chunksz(h, 1);
}

static inline int bucket_idx(struct z_heap *h, size_t sz)
{
	size_t usable_sz = sz - min_chunk_size(h) + 1;
   11b70:	3101      	adds	r1, #1
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   11b72:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
   11b76:	bf2c      	ite	cs
   11b78:	2002      	movcs	r0, #2
   11b7a:	2001      	movcc	r0, #1
	size_t usable_sz = sz - min_chunk_size(h) + 1;
   11b7c:	1a08      	subs	r0, r1, r0
	return 31 - __builtin_clz(usable_sz);
   11b7e:	fab0 f080 	clz	r0, r0
}
   11b82:	f1c0 001f 	rsb	r0, r0, #31
   11b86:	4770      	bx	lr

00011b88 <merge_chunks>:
	set_left_chunk_size(h, right_chunk(h, rc), rsz);
}

/* Does not modify free list */
static void merge_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
   11b88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11b8c:	4616      	mov	r6, r2
   11b8e:	4604      	mov	r4, r0
   11b90:	460f      	mov	r7, r1
	size_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   11b92:	f7ff ffca 	bl	11b2a <chunk_size>
   11b96:	4631      	mov	r1, r6
   11b98:	4605      	mov	r5, r0
   11b9a:	4620      	mov	r0, r4
   11b9c:	f7ff ffc5 	bl	11b2a <chunk_size>
   11ba0:	4405      	add	r5, r0

	set_chunk_size(h, lc, newsz);
   11ba2:	462a      	mov	r2, r5
   11ba4:	4639      	mov	r1, r7
   11ba6:	4620      	mov	r0, r4
   11ba8:	f7ff ffdd 	bl	11b66 <set_chunk_size>
	return c + chunk_size(h, c);
   11bac:	4631      	mov	r1, r6
   11bae:	4620      	mov	r0, r4
   11bb0:	f7ff ffbb 	bl	11b2a <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
   11bb4:	462b      	mov	r3, r5
   11bb6:	1831      	adds	r1, r6, r0
   11bb8:	2200      	movs	r2, #0
   11bba:	4620      	mov	r0, r4
	set_left_chunk_size(h, right_chunk(h, rc), newsz);
}
   11bbc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   11bc0:	f7ff bfa8 	b.w	11b14 <chunk_set>

00011bc4 <split_chunks>:
{
   11bc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11bc8:	4614      	mov	r4, r2
   11bca:	460e      	mov	r6, r1
   11bcc:	4605      	mov	r5, r0
	size_t sz0 = chunk_size(h, lc);
   11bce:	f7ff ffac 	bl	11b2a <chunk_size>
	size_t lsz = rc - lc;
   11bd2:	eba4 0806 	sub.w	r8, r4, r6
	size_t rsz = sz0 - lsz;
   11bd6:	1b37      	subs	r7, r6, r4
   11bd8:	4407      	add	r7, r0
	set_chunk_size(h, lc, lsz);
   11bda:	4642      	mov	r2, r8
   11bdc:	4631      	mov	r1, r6
   11bde:	4628      	mov	r0, r5
   11be0:	f7ff ffc1 	bl	11b66 <set_chunk_size>
	set_chunk_size(h, rc, rsz);
   11be4:	463a      	mov	r2, r7
   11be6:	4621      	mov	r1, r4
   11be8:	4628      	mov	r0, r5
   11bea:	f7ff ffbc 	bl	11b66 <set_chunk_size>
   11bee:	4643      	mov	r3, r8
   11bf0:	2200      	movs	r2, #0
   11bf2:	4621      	mov	r1, r4
   11bf4:	4628      	mov	r0, r5
   11bf6:	f7ff ff8d 	bl	11b14 <chunk_set>
	return c + chunk_size(h, c);
   11bfa:	4621      	mov	r1, r4
   11bfc:	4628      	mov	r0, r5
   11bfe:	f7ff ff94 	bl	11b2a <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
   11c02:	463b      	mov	r3, r7
   11c04:	1821      	adds	r1, r4, r0
   11c06:	2200      	movs	r2, #0
   11c08:	4628      	mov	r0, r5
}
   11c0a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   11c0e:	f7ff bf81 	b.w	11b14 <chunk_set>

00011c12 <free_list_remove_bidx>:
{
   11c12:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11c16:	4617      	mov	r7, r2
	return chunk_field(h, c, FREE_NEXT);
   11c18:	2203      	movs	r2, #3
   11c1a:	460e      	mov	r6, r1
   11c1c:	4604      	mov	r4, r0
   11c1e:	f7ff ff6e 	bl	11afe <chunk_field>
	if (next_free_chunk(h, c) == c) {
   11c22:	4286      	cmp	r6, r0
   11c24:	4605      	mov	r5, r0
   11c26:	f107 0804 	add.w	r8, r7, #4
   11c2a:	d10b      	bne.n	11c44 <free_list_remove_bidx+0x32>
		h->avail_buckets &= ~(1 << bidx);
   11c2c:	2301      	movs	r3, #1
   11c2e:	fa03 f707 	lsl.w	r7, r3, r7
   11c32:	68e3      	ldr	r3, [r4, #12]
   11c34:	ea23 0307 	bic.w	r3, r3, r7
   11c38:	60e3      	str	r3, [r4, #12]
		b->next = 0;
   11c3a:	2300      	movs	r3, #0
   11c3c:	f844 3028 	str.w	r3, [r4, r8, lsl #2]
}
   11c40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return chunk_field(h, c, FREE_PREV);
   11c44:	4631      	mov	r1, r6
   11c46:	2202      	movs	r2, #2
   11c48:	4620      	mov	r0, r4
   11c4a:	f7ff ff58 	bl	11afe <chunk_field>
   11c4e:	4606      	mov	r6, r0
	chunk_set(h, c, FREE_NEXT, next);
   11c50:	462b      	mov	r3, r5
   11c52:	4601      	mov	r1, r0
   11c54:	2203      	movs	r2, #3
   11c56:	4620      	mov	r0, r4
		b->next = second;
   11c58:	f844 5028 	str.w	r5, [r4, r8, lsl #2]
   11c5c:	f7ff ff5a 	bl	11b14 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
   11c60:	4633      	mov	r3, r6
   11c62:	4629      	mov	r1, r5
   11c64:	4620      	mov	r0, r4
}
   11c66:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   11c6a:	2202      	movs	r2, #2
   11c6c:	f7ff bf52 	b.w	11b14 <chunk_set>

00011c70 <alloc_chunk>:
	set_chunk_used(h, c, false);
	free_chunk(h, c);
}

static chunkid_t alloc_chunk(struct z_heap *h, size_t sz)
{
   11c70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11c74:	4604      	mov	r4, r0
   11c76:	4688      	mov	r8, r1
	int bi = bucket_idx(h, sz);
   11c78:	f7ff ff79 	bl	11b6e <bucket_idx>
	struct z_heap_bucket *b = &h->buckets[bi];

	if (bi > bucket_idx(h, h->len)) {
   11c7c:	68a1      	ldr	r1, [r4, #8]
	int bi = bucket_idx(h, sz);
   11c7e:	4605      	mov	r5, r0
	if (bi > bucket_idx(h, h->len)) {
   11c80:	4620      	mov	r0, r4
   11c82:	f7ff ff74 	bl	11b6e <bucket_idx>
   11c86:	42a8      	cmp	r0, r5
   11c88:	da03      	bge.n	11c92 <alloc_chunk+0x22>
		return 0;
   11c8a:	2600      	movs	r6, #0
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   11c8c:	4630      	mov	r0, r6
   11c8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (b->next) {
   11c92:	eb04 0a85 	add.w	sl, r4, r5, lsl #2
   11c96:	f8da 9010 	ldr.w	r9, [sl, #16]
   11c9a:	f1b9 0f00 	cmp.w	r9, #0
   11c9e:	d019      	beq.n	11cd4 <alloc_chunk+0x64>
   11ca0:	2703      	movs	r7, #3
			chunkid_t c = b->next;
   11ca2:	f8da 6010 	ldr.w	r6, [sl, #16]
			if (chunk_size(h, c) >= sz) {
   11ca6:	4620      	mov	r0, r4
   11ca8:	4631      	mov	r1, r6
   11caa:	f7ff ff3e 	bl	11b2a <chunk_size>
   11cae:	4540      	cmp	r0, r8
   11cb0:	d305      	bcc.n	11cbe <alloc_chunk+0x4e>
				free_list_remove_bidx(h, c, bi);
   11cb2:	462a      	mov	r2, r5
		free_list_remove_bidx(h, c, minbucket);
   11cb4:	4631      	mov	r1, r6
   11cb6:	4620      	mov	r0, r4
   11cb8:	f7ff ffab 	bl	11c12 <free_list_remove_bidx>
		return c;
   11cbc:	e7e6      	b.n	11c8c <alloc_chunk+0x1c>
	return chunk_field(h, c, FREE_NEXT);
   11cbe:	2203      	movs	r2, #3
   11cc0:	4631      	mov	r1, r6
   11cc2:	4620      	mov	r0, r4
   11cc4:	f7ff ff1b 	bl	11afe <chunk_field>
		} while (--i && b->next != first);
   11cc8:	3f01      	subs	r7, #1
			b->next = next_free_chunk(h, c);
   11cca:	f8ca 0010 	str.w	r0, [sl, #16]
		} while (--i && b->next != first);
   11cce:	d001      	beq.n	11cd4 <alloc_chunk+0x64>
   11cd0:	4581      	cmp	r9, r0
   11cd2:	d1e6      	bne.n	11ca2 <alloc_chunk+0x32>
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
   11cd4:	f04f 32ff 	mov.w	r2, #4294967295
   11cd8:	68e3      	ldr	r3, [r4, #12]
   11cda:	3501      	adds	r5, #1
   11cdc:	40aa      	lsls	r2, r5
	if ((bmask & h->avail_buckets) != 0U) {
   11cde:	401a      	ands	r2, r3
   11ce0:	d0d3      	beq.n	11c8a <alloc_chunk+0x1a>
		int minbucket = __builtin_ctz(bmask & h->avail_buckets);
   11ce2:	fa92 f2a2 	rbit	r2, r2
   11ce6:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   11cea:	1d13      	adds	r3, r2, #4
   11cec:	f854 6023 	ldr.w	r6, [r4, r3, lsl #2]
   11cf0:	e7e0      	b.n	11cb4 <alloc_chunk+0x44>

00011cf2 <free_list_add>:
{
   11cf2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11cf6:	4604      	mov	r4, r0
   11cf8:	460d      	mov	r5, r1
	return sizeof(void *) > 4U || chunks > 0x7fffU;
   11cfa:	f7ff ff16 	bl	11b2a <chunk_size>
	return big_heap(h) && chunk_size(h, c) == 1U;
   11cfe:	68a3      	ldr	r3, [r4, #8]
   11d00:	4601      	mov	r1, r0
   11d02:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11d06:	d301      	bcc.n	11d0c <free_list_add+0x1a>
	if (!solo_free_header(h, c)) {
   11d08:	2801      	cmp	r0, #1
   11d0a:	d035      	beq.n	11d78 <free_list_add+0x86>
		int bidx = bucket_idx(h, chunk_size(h, c));
   11d0c:	4620      	mov	r0, r4
   11d0e:	f7ff ff2e 	bl	11b6e <bucket_idx>
	if (b->next == 0U) {
   11d12:	eb04 0280 	add.w	r2, r4, r0, lsl #2
   11d16:	6916      	ldr	r6, [r2, #16]
   11d18:	b99e      	cbnz	r6, 11d42 <free_list_add+0x50>
		h->avail_buckets |= (1 << bidx);
   11d1a:	2301      	movs	r3, #1
   11d1c:	fa03 f000 	lsl.w	r0, r3, r0
   11d20:	68e3      	ldr	r3, [r4, #12]
	chunk_set(h, c, FREE_PREV, prev);
   11d22:	4629      	mov	r1, r5
   11d24:	4303      	orrs	r3, r0
   11d26:	60e3      	str	r3, [r4, #12]
   11d28:	4620      	mov	r0, r4
		b->next = c;
   11d2a:	6115      	str	r5, [r2, #16]
   11d2c:	462b      	mov	r3, r5
   11d2e:	2202      	movs	r2, #2
   11d30:	f7ff fef0 	bl	11b14 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
   11d34:	2203      	movs	r2, #3
   11d36:	4629      	mov	r1, r5
	chunk_set(h, c, FREE_PREV, prev);
   11d38:	4620      	mov	r0, r4
}
   11d3a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   11d3e:	f7ff bee9 	b.w	11b14 <chunk_set>
	return chunk_field(h, c, FREE_PREV);
   11d42:	2202      	movs	r2, #2
   11d44:	4631      	mov	r1, r6
   11d46:	4620      	mov	r0, r4
   11d48:	f7ff fed9 	bl	11afe <chunk_field>
   11d4c:	4607      	mov	r7, r0
	chunk_set(h, c, FREE_PREV, prev);
   11d4e:	4603      	mov	r3, r0
   11d50:	2202      	movs	r2, #2
   11d52:	4629      	mov	r1, r5
   11d54:	4620      	mov	r0, r4
   11d56:	f7ff fedd 	bl	11b14 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
   11d5a:	4633      	mov	r3, r6
   11d5c:	2203      	movs	r2, #3
   11d5e:	4629      	mov	r1, r5
   11d60:	4620      	mov	r0, r4
   11d62:	f7ff fed7 	bl	11b14 <chunk_set>
   11d66:	2203      	movs	r2, #3
   11d68:	4639      	mov	r1, r7
   11d6a:	462b      	mov	r3, r5
   11d6c:	4620      	mov	r0, r4
   11d6e:	f7ff fed1 	bl	11b14 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
   11d72:	2202      	movs	r2, #2
   11d74:	4631      	mov	r1, r6
   11d76:	e7df      	b.n	11d38 <free_list_add+0x46>
   11d78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00011d7c <free_list_remove>:
{
   11d7c:	b538      	push	{r3, r4, r5, lr}
   11d7e:	4604      	mov	r4, r0
   11d80:	460d      	mov	r5, r1
	return sizeof(void *) > 4U || chunks > 0x7fffU;
   11d82:	f7ff fed2 	bl	11b2a <chunk_size>
	return big_heap(h) && chunk_size(h, c) == 1U;
   11d86:	68a3      	ldr	r3, [r4, #8]
   11d88:	4601      	mov	r1, r0
   11d8a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11d8e:	d301      	bcc.n	11d94 <free_list_remove+0x18>
	if (!solo_free_header(h, c)) {
   11d90:	2801      	cmp	r0, #1
   11d92:	d009      	beq.n	11da8 <free_list_remove+0x2c>
		int bidx = bucket_idx(h, chunk_size(h, c));
   11d94:	4620      	mov	r0, r4
   11d96:	f7ff feea 	bl	11b6e <bucket_idx>
		free_list_remove_bidx(h, c, bidx);
   11d9a:	4629      	mov	r1, r5
		int bidx = bucket_idx(h, chunk_size(h, c));
   11d9c:	4602      	mov	r2, r0
		free_list_remove_bidx(h, c, bidx);
   11d9e:	4620      	mov	r0, r4
}
   11da0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		free_list_remove_bidx(h, c, bidx);
   11da4:	f7ff bf35 	b.w	11c12 <free_list_remove_bidx>
}
   11da8:	bd38      	pop	{r3, r4, r5, pc}

00011daa <free_chunk>:
{
   11daa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   11dac:	460c      	mov	r4, r1
   11dae:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
   11db0:	f7ff febb 	bl	11b2a <chunk_size>
   11db4:	1826      	adds	r6, r4, r0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   11db6:	2201      	movs	r2, #1
   11db8:	4631      	mov	r1, r6
   11dba:	4628      	mov	r0, r5
   11dbc:	f7ff fe9f 	bl	11afe <chunk_field>
	if (!chunk_used(h, right_chunk(h, c))) {
   11dc0:	07c3      	lsls	r3, r0, #31
   11dc2:	d40c      	bmi.n	11dde <free_chunk+0x34>
		free_list_remove(h, right_chunk(h, c));
   11dc4:	4631      	mov	r1, r6
   11dc6:	4628      	mov	r0, r5
   11dc8:	f7ff ffd8 	bl	11d7c <free_list_remove>
	return c + chunk_size(h, c);
   11dcc:	4621      	mov	r1, r4
   11dce:	4628      	mov	r0, r5
   11dd0:	f7ff feab 	bl	11b2a <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   11dd4:	4621      	mov	r1, r4
   11dd6:	1822      	adds	r2, r4, r0
   11dd8:	4628      	mov	r0, r5
   11dda:	f7ff fed5 	bl	11b88 <merge_chunks>
	return c - chunk_field(h, c, LEFT_SIZE);
   11dde:	2200      	movs	r2, #0
   11de0:	4621      	mov	r1, r4
   11de2:	4628      	mov	r0, r5
   11de4:	f7ff fe8b 	bl	11afe <chunk_field>
   11de8:	1a27      	subs	r7, r4, r0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   11dea:	2201      	movs	r2, #1
   11dec:	4639      	mov	r1, r7
   11dee:	4628      	mov	r0, r5
   11df0:	f7ff fe85 	bl	11afe <chunk_field>
	if (!chunk_used(h, left_chunk(h, c))) {
   11df4:	f010 0601 	ands.w	r6, r0, #1
   11df8:	d113      	bne.n	11e22 <free_chunk+0x78>
		free_list_remove(h, left_chunk(h, c));
   11dfa:	4639      	mov	r1, r7
   11dfc:	4628      	mov	r0, r5
   11dfe:	f7ff ffbd 	bl	11d7c <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
   11e02:	4621      	mov	r1, r4
   11e04:	4632      	mov	r2, r6
   11e06:	4628      	mov	r0, r5
   11e08:	f7ff fe79 	bl	11afe <chunk_field>
		merge_chunks(h, left_chunk(h, c), c);
   11e0c:	4622      	mov	r2, r4
   11e0e:	1a21      	subs	r1, r4, r0
   11e10:	4628      	mov	r0, r5
   11e12:	f7ff feb9 	bl	11b88 <merge_chunks>
   11e16:	4621      	mov	r1, r4
   11e18:	4632      	mov	r2, r6
   11e1a:	4628      	mov	r0, r5
   11e1c:	f7ff fe6f 	bl	11afe <chunk_field>
   11e20:	1a24      	subs	r4, r4, r0
	free_list_add(h, c);
   11e22:	4621      	mov	r1, r4
   11e24:	4628      	mov	r0, r5
}
   11e26:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, c);
   11e2a:	f7ff bf62 	b.w	11cf2 <free_list_add>

00011e2e <sys_heap_free>:
{
   11e2e:	b510      	push	{r4, lr}
	if (mem == NULL) {
   11e30:	b191      	cbz	r1, 11e58 <sys_heap_free+0x2a>
	struct z_heap *h = heap->heap;
   11e32:	6800      	ldr	r0, [r0, #0]
	set_chunk_used(h, c, false);
   11e34:	2200      	movs	r2, #0
	return big_heap(h) ? 8 : 4;
   11e36:	6883      	ldr	r3, [r0, #8]
   11e38:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11e3c:	bf2c      	ite	cs
   11e3e:	2408      	movcs	r4, #8
   11e40:	2404      	movcc	r4, #4
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   11e42:	1b0c      	subs	r4, r1, r4
   11e44:	1a24      	subs	r4, r4, r0
   11e46:	08e4      	lsrs	r4, r4, #3
	set_chunk_used(h, c, false);
   11e48:	4621      	mov	r1, r4
   11e4a:	f7ff fe74 	bl	11b36 <set_chunk_used>
	free_chunk(h, c);
   11e4e:	4621      	mov	r1, r4
}
   11e50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	free_chunk(h, c);
   11e54:	f7ff bfa9 	b.w	11daa <free_chunk>
}
   11e58:	bd10      	pop	{r4, pc}

00011e5a <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   11e5a:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   11e5c:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
   11e5e:	b909      	cbnz	r1, 11e64 <sys_heap_alloc+0xa>
		return NULL;
   11e60:	2000      	movs	r0, #0
		free_list_add(h, c + chunk_sz);
	}

	set_chunk_used(h, c, true);
	return chunk_mem(h, c);
}
   11e62:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   11e64:	68ab      	ldr	r3, [r5, #8]
   11e66:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   11e6a:	d9f9      	bls.n	11e60 <sys_heap_alloc+0x6>
   11e6c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11e70:	bf2c      	ite	cs
   11e72:	2208      	movcs	r2, #8
   11e74:	2204      	movcc	r2, #4
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   11e76:	1dcc      	adds	r4, r1, #7
   11e78:	4414      	add	r4, r2
   11e7a:	08e4      	lsrs	r4, r4, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   11e7c:	4621      	mov	r1, r4
   11e7e:	4628      	mov	r0, r5
   11e80:	f7ff fef6 	bl	11c70 <alloc_chunk>
	if (c == 0U) {
   11e84:	4606      	mov	r6, r0
   11e86:	2800      	cmp	r0, #0
   11e88:	d0ea      	beq.n	11e60 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   11e8a:	4601      	mov	r1, r0
   11e8c:	4628      	mov	r0, r5
   11e8e:	f7ff fe4c 	bl	11b2a <chunk_size>
   11e92:	42a0      	cmp	r0, r4
   11e94:	d909      	bls.n	11eaa <sys_heap_alloc+0x50>
		split_chunks(h, c, c + chunk_sz);
   11e96:	4434      	add	r4, r6
   11e98:	4631      	mov	r1, r6
   11e9a:	4628      	mov	r0, r5
   11e9c:	4622      	mov	r2, r4
   11e9e:	f7ff fe91 	bl	11bc4 <split_chunks>
		free_list_add(h, c + chunk_sz);
   11ea2:	4621      	mov	r1, r4
   11ea4:	4628      	mov	r0, r5
   11ea6:	f7ff ff24 	bl	11cf2 <free_list_add>
	set_chunk_used(h, c, true);
   11eaa:	4628      	mov	r0, r5
   11eac:	2201      	movs	r2, #1
   11eae:	4631      	mov	r1, r6
   11eb0:	f7ff fe41 	bl	11b36 <set_chunk_used>
	return big_heap(h) ? 8 : 4;
   11eb4:	68ab      	ldr	r3, [r5, #8]
   11eb6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11eba:	bf2c      	ite	cs
   11ebc:	2008      	movcs	r0, #8
   11ebe:	2004      	movcc	r0, #4
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   11ec0:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
   11ec4:	4428      	add	r0, r5
	return chunk_mem(h, c);
   11ec6:	e7cc      	b.n	11e62 <sys_heap_alloc+0x8>

00011ec8 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   11ec8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct z_heap *h = heap->heap;
   11ecc:	6805      	ldr	r5, [r0, #0]
{
   11ece:	4614      	mov	r4, r2
   11ed0:	68ab      	ldr	r3, [r5, #8]
   11ed2:	460f      	mov	r7, r1
   11ed4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11ed8:	bf2c      	ite	cs
   11eda:	2208      	movcs	r2, #8
   11edc:	2204      	movcc	r2, #4

	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (align <= chunk_header_bytes(h)) {
   11ede:	4291      	cmp	r1, r2
   11ee0:	d804      	bhi.n	11eec <sys_heap_aligned_alloc+0x24>
		return sys_heap_alloc(heap, bytes);
   11ee2:	4621      	mov	r1, r4
		free_list_add(h, c_end);
	}

	set_chunk_used(h, c, true);
	return mem;
}
   11ee4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return sys_heap_alloc(heap, bytes);
   11ee8:	f7ff bfb7 	b.w	11e5a <sys_heap_alloc>
	if (bytes == 0 || size_too_big(h, bytes)) {
   11eec:	b91c      	cbnz	r4, 11ef6 <sys_heap_aligned_alloc+0x2e>
		return NULL;
   11eee:	2600      	movs	r6, #0
}
   11ef0:	4630      	mov	r0, r6
   11ef2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (bytes == 0 || size_too_big(h, bytes)) {
   11ef6:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   11efa:	d9f8      	bls.n	11eee <sys_heap_aligned_alloc+0x26>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   11efc:	1de1      	adds	r1, r4, #7
   11efe:	4439      	add	r1, r7
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   11f00:	4628      	mov	r0, r5
   11f02:	08c9      	lsrs	r1, r1, #3
   11f04:	f7ff feb4 	bl	11c70 <alloc_chunk>
	if (c0 == 0) {
   11f08:	4680      	mov	r8, r0
   11f0a:	2800      	cmp	r0, #0
   11f0c:	d0ef      	beq.n	11eee <sys_heap_aligned_alloc+0x26>
	return big_heap(h) ? 8 : 4;
   11f0e:	68ab      	ldr	r3, [r5, #8]
	uint8_t *mem = (uint8_t *) ROUND_UP(chunk_mem(h, c0), align);
   11f10:	1e7a      	subs	r2, r7, #1
   11f12:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   11f16:	bf2c      	ite	cs
   11f18:	2308      	movcs	r3, #8
   11f1a:	2304      	movcc	r3, #4
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   11f1c:	eb03 06c0 	add.w	r6, r3, r0, lsl #3
   11f20:	442e      	add	r6, r5
	uint8_t *mem = (uint8_t *) ROUND_UP(chunk_mem(h, c0), align);
   11f22:	427f      	negs	r7, r7
   11f24:	4416      	add	r6, r2
   11f26:	403e      	ands	r6, r7
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   11f28:	4434      	add	r4, r6
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   11f2a:	1af3      	subs	r3, r6, r3
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   11f2c:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   11f2e:	1b5b      	subs	r3, r3, r5
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   11f30:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   11f34:	1b64      	subs	r4, r4, r5
	if (c > c0) {
   11f36:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   11f3a:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   11f3e:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   11f42:	d208      	bcs.n	11f56 <sys_heap_aligned_alloc+0x8e>
		split_chunks(h, c0, c);
   11f44:	4601      	mov	r1, r0
   11f46:	463a      	mov	r2, r7
   11f48:	4628      	mov	r0, r5
   11f4a:	f7ff fe3b 	bl	11bc4 <split_chunks>
		free_list_add(h, c0);
   11f4e:	4641      	mov	r1, r8
   11f50:	4628      	mov	r0, r5
   11f52:	f7ff fece 	bl	11cf2 <free_list_add>
	return c + chunk_size(h, c);
   11f56:	4639      	mov	r1, r7
   11f58:	4628      	mov	r0, r5
   11f5a:	f7ff fde6 	bl	11b2a <chunk_size>
   11f5e:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   11f60:	4284      	cmp	r4, r0
   11f62:	d208      	bcs.n	11f76 <sys_heap_aligned_alloc+0xae>
		split_chunks(h, c, c_end);
   11f64:	4639      	mov	r1, r7
   11f66:	4628      	mov	r0, r5
   11f68:	4622      	mov	r2, r4
   11f6a:	f7ff fe2b 	bl	11bc4 <split_chunks>
		free_list_add(h, c_end);
   11f6e:	4621      	mov	r1, r4
   11f70:	4628      	mov	r0, r5
   11f72:	f7ff febe 	bl	11cf2 <free_list_add>
	set_chunk_used(h, c, true);
   11f76:	2201      	movs	r2, #1
   11f78:	4639      	mov	r1, r7
   11f7a:	4628      	mov	r0, r5
   11f7c:	f7ff fddb 	bl	11b36 <set_chunk_used>
	return mem;
   11f80:	e7b6      	b.n	11ef0 <sys_heap_aligned_alloc+0x28>

00011f82 <sys_heap_init>:
	return big_heap_bytes(size) ? 8 : 4;
   11f82:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
		return ptr2;
	}
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   11f86:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   11f88:	bf2c      	ite	cs
   11f8a:	2508      	movcs	r5, #8
   11f8c:	2504      	movcc	r5, #4
	CHECK(end > addr);
	__ASSERT(buf_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->chunk0_hdr_area = 0;
   11f8e:	2300      	movs	r3, #0
	bytes -= heap_footer_bytes(bytes);
   11f90:	1b55      	subs	r5, r2, r5
	h->chunk0_hdr_area = 0;
   11f92:	2200      	movs	r2, #0
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   11f94:	1dcc      	adds	r4, r1, #7
   11f96:	f024 0407 	bic.w	r4, r4, #7
	heap->heap = h;
   11f9a:	6004      	str	r4, [r0, #0]
	h->chunk0_hdr_area = 0;
   11f9c:	e9c4 2300 	strd	r2, r3, [r4]
	h->len = buf_sz;
	h->avail_buckets = 0;
   11fa0:	2300      	movs	r3, #0
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   11fa2:	440d      	add	r5, r1
   11fa4:	f025 0507 	bic.w	r5, r5, #7
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
   11fa8:	1b2d      	subs	r5, r5, r4
   11faa:	08ed      	lsrs	r5, r5, #3

	int nb_buckets = bucket_idx(h, buf_sz) + 1;
   11fac:	4629      	mov	r1, r5
   11fae:	4620      	mov	r0, r4
	h->len = buf_sz;
   11fb0:	60a5      	str	r5, [r4, #8]
	h->avail_buckets = 0;
   11fb2:	60e3      	str	r3, [r4, #12]
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
   11fb4:	f7ff fddb 	bl	11b6e <bucket_idx>
	size_t chunk0_size = chunksz(sizeof(struct z_heap) +
   11fb8:	0086      	lsls	r6, r0, #2
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
   11fba:	1c41      	adds	r1, r0, #1
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < buf_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
   11fbc:	4618      	mov	r0, r3
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   11fbe:	361b      	adds	r6, #27
   11fc0:	08f6      	lsrs	r6, r6, #3
	for (int i = 0; i < nb_buckets; i++) {
   11fc2:	f104 0210 	add.w	r2, r4, #16
   11fc6:	428b      	cmp	r3, r1
   11fc8:	db29      	blt.n	1201e <sys_heap_init+0x9c>
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
   11fca:	4632      	mov	r2, r6
   11fcc:	4620      	mov	r0, r4
   11fce:	2100      	movs	r1, #0
   11fd0:	f7ff fdc9 	bl	11b66 <set_chunk_size>
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
   11fd4:	1baf      	subs	r7, r5, r6
	set_chunk_used(h, 0, true);
   11fd6:	4620      	mov	r0, r4
   11fd8:	2201      	movs	r2, #1
   11fda:	2100      	movs	r1, #0
   11fdc:	f7ff fdab 	bl	11b36 <set_chunk_used>
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
   11fe0:	463a      	mov	r2, r7
   11fe2:	4631      	mov	r1, r6
   11fe4:	f7ff fdbf 	bl	11b66 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
   11fe8:	4633      	mov	r3, r6
   11fea:	4631      	mov	r1, r6
   11fec:	4620      	mov	r0, r4
   11fee:	2200      	movs	r2, #0
   11ff0:	f7ff fd90 	bl	11b14 <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, buf_sz, 0);
   11ff4:	4629      	mov	r1, r5
   11ff6:	4620      	mov	r0, r4
   11ff8:	2200      	movs	r2, #0
   11ffa:	f7ff fdb4 	bl	11b66 <set_chunk_size>
   11ffe:	463b      	mov	r3, r7
   12000:	4629      	mov	r1, r5
   12002:	4620      	mov	r0, r4
   12004:	2200      	movs	r2, #0
   12006:	f7ff fd85 	bl	11b14 <chunk_set>
	set_left_chunk_size(h, buf_sz, buf_sz - chunk0_size);
	set_chunk_used(h, buf_sz, true);
   1200a:	4629      	mov	r1, r5
   1200c:	4620      	mov	r0, r4
   1200e:	2201      	movs	r2, #1
   12010:	f7ff fd91 	bl	11b36 <set_chunk_used>

	free_list_add(h, chunk0_size);
   12014:	4631      	mov	r1, r6
}
   12016:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, chunk0_size);
   1201a:	f7ff be6a 	b.w	11cf2 <free_list_add>
		h->buckets[i].next = 0;
   1201e:	f842 0b04 	str.w	r0, [r2], #4
	for (int i = 0; i < nb_buckets; i++) {
   12022:	3301      	adds	r3, #1
   12024:	e7cf      	b.n	11fc6 <sys_heap_init+0x44>

00012026 <outs>:
{
   12026:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1202a:	4607      	mov	r7, r0
   1202c:	4688      	mov	r8, r1
   1202e:	4615      	mov	r5, r2
   12030:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   12032:	4614      	mov	r4, r2
   12034:	42b4      	cmp	r4, r6
   12036:	eba4 0005 	sub.w	r0, r4, r5
   1203a:	d302      	bcc.n	12042 <outs+0x1c>
   1203c:	b93e      	cbnz	r6, 1204e <outs+0x28>
   1203e:	7823      	ldrb	r3, [r4, #0]
   12040:	b12b      	cbz	r3, 1204e <outs+0x28>
		int rc = out((int)*sp++, ctx);
   12042:	4641      	mov	r1, r8
   12044:	f814 0b01 	ldrb.w	r0, [r4], #1
   12048:	47b8      	blx	r7
		if (rc < 0) {
   1204a:	2800      	cmp	r0, #0
   1204c:	daf2      	bge.n	12034 <outs+0xe>
}
   1204e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00012052 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   12052:	4770      	bx	lr

00012054 <z_platform_init>:
	SystemInit();
   12054:	f7f5 bb44 	b.w	76e0 <SystemInit>

00012058 <virtio_get_status>:
}
   12058:	2004      	movs	r0, #4
   1205a:	4770      	bx	lr

0001205c <virtio_get_features>:
}
   1205c:	2001      	movs	r0, #1
   1205e:	4770      	bx	lr

00012060 <virtio_set_features>:
}
   12060:	4770      	bx	lr

00012062 <virtqueue_allocate.constprop.0>:

int virtqueue_enable_cb(struct virtqueue *vq);

void virtqueue_kick(struct virtqueue *vq);

static inline struct virtqueue *virtqueue_allocate(unsigned int num_desc_extra)
   12062:	b510      	push	{r4, lr}
	return k_aligned_alloc(sizeof(void *), size);
   12064:	21b4      	movs	r1, #180	; 0xb4
   12066:	2004      	movs	r0, #4
   12068:	f7ff fabe 	bl	115e8 <k_aligned_alloc>
	struct virtqueue *vqs;
	uint32_t vq_size = sizeof(struct virtqueue) +
		 num_desc_extra * sizeof(struct vq_desc_extra);

	vqs = (struct virtqueue *)metal_allocate_memory(vq_size);
	if (vqs) {
   1206c:	4604      	mov	r4, r0
   1206e:	b118      	cbz	r0, 12078 <virtqueue_allocate.constprop.0+0x16>
__ssp_bos_icheck3(memset, void *, int)
   12070:	22b4      	movs	r2, #180	; 0xb4
   12072:	2100      	movs	r1, #0
   12074:	f00b fc82 	bl	1d97c <memset>
		memset(vqs, 0x00, vq_size);
	}

	return vqs;
}
   12078:	4620      	mov	r0, r4
   1207a:	bd10      	pop	{r4, pc}

0001207c <rpmsg_service_unbind>:
	rpmsg_destroy_ept(ep);
   1207c:	f00a be5e 	b.w	1cd3c <rpmsg_destroy_ept>

00012080 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   12080:	b2cb      	uxtb	r3, r1
   12082:	210c      	movs	r1, #12
   12084:	68c2      	ldr	r2, [r0, #12]
   12086:	fb03 2101 	mla	r1, r3, r1, r2
   1208a:	6f88      	ldr	r0, [r1, #120]	; 0x78
}
   1208c:	f000 0007 	and.w	r0, r0, #7
   12090:	4770      	bx	lr

00012092 <set_off_state>:
	__asm__ volatile(
   12092:	f04f 0320 	mov.w	r3, #32
   12096:	f3ef 8211 	mrs	r2, BASEPRI
   1209a:	f383 8811 	msr	BASEPRI, r3
   1209e:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   120a2:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   120a4:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   120a8:	d001      	beq.n	120ae <set_off_state+0x1c>
   120aa:	428b      	cmp	r3, r1
   120ac:	d107      	bne.n	120be <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   120ae:	2301      	movs	r3, #1
   120b0:	6003      	str	r3, [r0, #0]
	int err = 0;
   120b2:	2000      	movs	r0, #0
	__asm__ volatile(
   120b4:	f382 8811 	msr	BASEPRI, r2
   120b8:	f3bf 8f6f 	isb	sy
}
   120bc:	4770      	bx	lr
		err = -EPERM;
   120be:	f04f 30ff 	mov.w	r0, #4294967295
   120c2:	e7f7      	b.n	120b4 <set_off_state+0x22>

000120c4 <set_starting_state>:
{
   120c4:	b510      	push	{r4, lr}
	__asm__ volatile(
   120c6:	f04f 0320 	mov.w	r3, #32
   120ca:	f3ef 8211 	mrs	r2, BASEPRI
   120ce:	f383 8811 	msr	BASEPRI, r3
   120d2:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   120d6:	6803      	ldr	r3, [r0, #0]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   120d8:	f003 0407 	and.w	r4, r3, #7
   120dc:	2c01      	cmp	r4, #1
   120de:	d106      	bne.n	120ee <set_starting_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   120e0:	6001      	str	r1, [r0, #0]
	int err = 0;
   120e2:	2000      	movs	r0, #0
	__asm__ volatile(
   120e4:	f382 8811 	msr	BASEPRI, r2
   120e8:	f3bf 8f6f 	isb	sy
}
   120ec:	bd10      	pop	{r4, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   120ee:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
	} else if (current_ctx != ctx) {
   120f2:	428b      	cmp	r3, r1
		err = -EALREADY;
   120f4:	bf14      	ite	ne
   120f6:	f04f 30ff 	movne.w	r0, #4294967295
   120fa:	f06f 0077 	mvneq.w	r0, #119	; 0x77
   120fe:	e7f1      	b.n	120e4 <set_starting_state+0x20>

00012100 <set_on_state>:
	__asm__ volatile(
   12100:	f04f 0320 	mov.w	r3, #32
   12104:	f3ef 8211 	mrs	r2, BASEPRI
   12108:	f383 8811 	msr	BASEPRI, r3
   1210c:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   12110:	6803      	ldr	r3, [r0, #0]
   12112:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   12116:	f043 0302 	orr.w	r3, r3, #2
   1211a:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   1211c:	f382 8811 	msr	BASEPRI, r2
   12120:	f3bf 8f6f 	isb	sy
}
   12124:	4770      	bx	lr

00012126 <onoff_started_callback>:
{
   12126:	b410      	push	{r4}
	notify(mgr, 0);
   12128:	241c      	movs	r4, #28
	return &data->mgr[type];
   1212a:	68c0      	ldr	r0, [r0, #12]
   1212c:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   1212e:	fb03 0004 	mla	r0, r3, r4, r0
   12132:	2100      	movs	r1, #0
}
   12134:	bc10      	pop	{r4}
	notify(mgr, 0);
   12136:	4710      	bx	r2

00012138 <hfclkaudio_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   12138:	2003      	movs	r0, #3
   1213a:	f7f5 bb63 	b.w	7804 <nrfx_clock_start>

0001213e <hfclk192m_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK192M);
   1213e:	2002      	movs	r0, #2
   12140:	f7f5 bb60 	b.w	7804 <nrfx_clock_start>

00012144 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   12144:	2000      	movs	r0, #0
   12146:	f7f5 bb5d 	b.w	7804 <nrfx_clock_start>

0001214a <hfclkaudio_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   1214a:	2003      	movs	r0, #3
   1214c:	f7f5 bbae 	b.w	78ac <nrfx_clock_stop>

00012150 <hfclk192m_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK192M);
   12150:	2002      	movs	r0, #2
   12152:	f7f5 bbab 	b.w	78ac <nrfx_clock_stop>

00012156 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   12156:	2000      	movs	r0, #0
   12158:	f7f5 bba8 	b.w	78ac <nrfx_clock_stop>

0001215c <blocking_start_callback>:
{
   1215c:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   1215e:	f7fe be19 	b.w	10d94 <z_impl_k_sem_give>

00012162 <api_stop>:
{
   12162:	b538      	push	{r3, r4, r5, lr}
	err = set_off_state(&subdata->flags, ctx);
   12164:	230c      	movs	r3, #12
   12166:	b2cc      	uxtb	r4, r1
   12168:	4363      	muls	r3, r4
{
   1216a:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   1216c:	68c0      	ldr	r0, [r0, #12]
   1216e:	3378      	adds	r3, #120	; 0x78
   12170:	2180      	movs	r1, #128	; 0x80
   12172:	4418      	add	r0, r3
   12174:	f7ff ff8d 	bl	12092 <set_off_state>
	if (err < 0) {
   12178:	2800      	cmp	r0, #0
   1217a:	db05      	blt.n	12188 <api_stop+0x26>
	get_sub_config(dev, type)->stop();
   1217c:	6869      	ldr	r1, [r5, #4]
   1217e:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
   12182:	6863      	ldr	r3, [r4, #4]
   12184:	4798      	blx	r3
	return 0;
   12186:	2000      	movs	r0, #0
}
   12188:	bd38      	pop	{r3, r4, r5, pc}

0001218a <api_start>:
{
   1218a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	err = set_starting_state(&subdata->flags, ctx);
   1218e:	270c      	movs	r7, #12
   12190:	b2cd      	uxtb	r5, r1
   12192:	436f      	muls	r7, r5
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   12194:	68c4      	ldr	r4, [r0, #12]
{
   12196:	4606      	mov	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
   12198:	f107 0078 	add.w	r0, r7, #120	; 0x78
   1219c:	2180      	movs	r1, #128	; 0x80
   1219e:	4420      	add	r0, r4
{
   121a0:	4690      	mov	r8, r2
   121a2:	4699      	mov	r9, r3
	err = set_starting_state(&subdata->flags, ctx);
   121a4:	f7ff ff8e 	bl	120c4 <set_starting_state>
	if (err < 0) {
   121a8:	2800      	cmp	r0, #0
   121aa:	db07      	blt.n	121bc <api_start+0x32>
	subdata->cb = cb;
   121ac:	443c      	add	r4, r7
	subdata->user_data = user_data;
   121ae:	e9c4 891c 	strd	r8, r9, [r4, #112]	; 0x70
	 get_sub_config(dev, type)->start();
   121b2:	6873      	ldr	r3, [r6, #4]
   121b4:	f853 3035 	ldr.w	r3, [r3, r5, lsl #3]
   121b8:	4798      	blx	r3
	return 0;
   121ba:	2000      	movs	r0, #0
}
   121bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000121c0 <gpio_pin_configure>:
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   121c0:	04d3      	lsls	r3, r2, #19
{
   121c2:	b570      	push	{r4, r5, r6, lr}
   121c4:	460e      	mov	r6, r1
   121c6:	4614      	mov	r4, r2
	struct gpio_driver_data *data =
   121c8:	68c5      	ldr	r5, [r0, #12]
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   121ca:	d506      	bpl.n	121da <gpio_pin_configure+0x1a>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   121cc:	f412 6f40 	tst.w	r2, #3072	; 0xc00
   121d0:	d003      	beq.n	121da <gpio_pin_configure+0x1a>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   121d2:	07d1      	lsls	r1, r2, #31
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH
   121d4:	bf48      	it	mi
   121d6:	f482 54e0 	eormi.w	r4, r2, #7168	; 0x1c00
	return api->pin_configure(port, pin, flags);
   121da:	6883      	ldr	r3, [r0, #8]
   121dc:	4622      	mov	r2, r4
   121de:	4631      	mov	r1, r6
   121e0:	681b      	ldr	r3, [r3, #0]
   121e2:	4798      	blx	r3
	if (ret != 0) {
   121e4:	b940      	cbnz	r0, 121f8 <gpio_pin_configure+0x38>
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   121e6:	2201      	movs	r2, #1
   121e8:	682b      	ldr	r3, [r5, #0]
   121ea:	fa02 f106 	lsl.w	r1, r2, r6
   121ee:	07e2      	lsls	r2, r4, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   121f0:	bf4c      	ite	mi
   121f2:	430b      	orrmi	r3, r1
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   121f4:	438b      	bicpl	r3, r1
   121f6:	602b      	str	r3, [r5, #0]
		flags &= ~GPIO_INT_DEBOUNCE;
		ret = z_impl_gpio_pin_interrupt_configure(port, pin, flags);
	}

	return ret;
}
   121f8:	bd70      	pop	{r4, r5, r6, pc}

000121fa <gpio_pin_set>:

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   121fa:	2301      	movs	r3, #1
   121fc:	fa03 f101 	lsl.w	r1, r3, r1
   12200:	68c3      	ldr	r3, [r0, #12]
   12202:	681b      	ldr	r3, [r3, #0]
   12204:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   12206:	bf18      	it	ne
   12208:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   1220c:	b112      	cbz	r2, 12214 <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   1220e:	6883      	ldr	r3, [r0, #8]
   12210:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   12212:	4718      	bx	r3
   12214:	6883      	ldr	r3, [r0, #8]
   12216:	691b      	ldr	r3, [r3, #16]
   12218:	e7fb      	b.n	12212 <gpio_pin_set+0x18>

0001221a <ili9xxx_read>:
			const uint16_t y,
			const struct display_buffer_descriptor *desc, void *buf)
{
	LOG_ERR("Reading not supported");
	return -ENOTSUP;
}
   1221a:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1221e:	4770      	bx	lr

00012220 <ili9xxx_get_framebuffer>:

static void *ili9xxx_get_framebuffer(const struct device *dev)
{
	LOG_ERR("Direct framebuffer access not supported");
	return NULL;
}
   12220:	2000      	movs	r0, #0
   12222:	4770      	bx	lr

00012224 <ili9xxx_set_brightness>:
static int ili9xxx_set_brightness(const struct device *dev,
				  const uint8_t brightness)
{
	LOG_ERR("Set brightness not implemented");
	return -ENOTSUP;
}
   12224:	f06f 0085 	mvn.w	r0, #133	; 0x85
   12228:	4770      	bx	lr

0001222a <ili9xxx_get_capabilities>:
	return 0;
}

static void ili9xxx_get_capabilities(const struct device *dev,
				     struct display_capabilities *capabilities)
{
   1222a:	b538      	push	{r3, r4, r5, lr}
   1222c:	460b      	mov	r3, r1
	struct ili9xxx_data *data = (struct ili9xxx_data *)dev->data;
   1222e:	68c5      	ldr	r5, [r0, #12]
	const struct ili9xxx_config *config =
   12230:	6844      	ldr	r4, [r0, #4]
   12232:	2210      	movs	r2, #16
   12234:	2100      	movs	r1, #0
   12236:	4618      	mov	r0, r3
   12238:	f00b fba0 	bl	1d97c <memset>
		(struct ili9xxx_config *)dev->config;

	memset(capabilities, 0, sizeof(struct display_capabilities));

	capabilities->supported_pixel_formats =
   1223c:	2211      	movs	r2, #17
   1223e:	4603      	mov	r3, r0
   12240:	6042      	str	r2, [r0, #4]
		PIXEL_FORMAT_RGB_565 | PIXEL_FORMAT_RGB_888;
	capabilities->current_pixel_format = data->pixel_format;
   12242:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   12246:	7302      	strb	r2, [r0, #12]

	if (data->orientation == DISPLAY_ORIENTATION_NORMAL ||
   12248:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   1224c:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
   1224e:	8d20      	ldrh	r0, [r4, #40]	; 0x28
   12250:	f012 0ffd 	tst.w	r2, #253	; 0xfd
	} else {
		capabilities->x_resolution = config->y_resolution;
		capabilities->y_resolution = config->x_resolution;
	}

	capabilities->current_orientation = data->orientation;
   12254:	735a      	strb	r2, [r3, #13]
		capabilities->x_resolution = config->x_resolution;
   12256:	bf07      	ittee	eq
   12258:	8019      	strheq	r1, [r3, #0]
		capabilities->y_resolution = config->y_resolution;
   1225a:	8058      	strheq	r0, [r3, #2]
		capabilities->x_resolution = config->y_resolution;
   1225c:	8018      	strhne	r0, [r3, #0]
		capabilities->y_resolution = config->x_resolution;
   1225e:	8059      	strhne	r1, [r3, #2]
}
   12260:	bd38      	pop	{r3, r4, r5, pc}

00012262 <ili9xxx_set_contrast>:
   12262:	f06f 0085 	mvn.w	r0, #133	; 0x85
   12266:	4770      	bx	lr

00012268 <ili9xxx_transmit>:
{
   12268:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1226c:	4614      	mov	r4, r2
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1U };
   1226e:	2201      	movs	r2, #1
{
   12270:	b087      	sub	sp, #28
	struct ili9xxx_data *data = (struct ili9xxx_data *)dev->data;
   12272:	68c5      	ldr	r5, [r0, #12]
	const struct ili9xxx_config *config =
   12274:	6847      	ldr	r7, [r0, #4]
{
   12276:	461e      	mov	r6, r3
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1U };
   12278:	ab02      	add	r3, sp, #8
{
   1227a:	f88d 1007 	strb.w	r1, [sp, #7]
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1U };
   1227e:	9304      	str	r3, [sp, #16]
	gpio_pin_set(data->command_data_gpio, config->cmd_data_pin,
   12280:	7e39      	ldrb	r1, [r7, #24]
	tx_buf.buf = &cmd;
   12282:	f10d 0307 	add.w	r3, sp, #7
	gpio_pin_set(data->command_data_gpio, config->cmd_data_pin,
   12286:	6868      	ldr	r0, [r5, #4]
	tx_buf.len = 1U;
   12288:	e9cd 3202 	strd	r3, r2, [sp, #8]
	struct spi_buf_set tx_bufs = { .buffers = &tx_buf, .count = 1U };
   1228c:	9205      	str	r2, [sp, #20]
	r = spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   1228e:	f105 080c 	add.w	r8, r5, #12
	gpio_pin_set(data->command_data_gpio, config->cmd_data_pin,
   12292:	f7ff ffb2 	bl	121fa <gpio_pin_set>
	r = spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   12296:	68a8      	ldr	r0, [r5, #8]
					const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
		(const struct spi_driver_api *)dev->api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
   12298:	6883      	ldr	r3, [r0, #8]
   1229a:	4641      	mov	r1, r8
   1229c:	f8d3 9000 	ldr.w	r9, [r3]
   122a0:	aa04      	add	r2, sp, #16
   122a2:	2300      	movs	r3, #0
   122a4:	47c8      	blx	r9
	if (r < 0) {
   122a6:	2800      	cmp	r0, #0
   122a8:	db10      	blt.n	122cc <ili9xxx_transmit+0x64>
	if (tx_data != NULL) {
   122aa:	b194      	cbz	r4, 122d2 <ili9xxx_transmit+0x6a>
		gpio_pin_set(data->command_data_gpio, config->cmd_data_pin,
   122ac:	2200      	movs	r2, #0
   122ae:	7e39      	ldrb	r1, [r7, #24]
   122b0:	6868      	ldr	r0, [r5, #4]
		tx_buf.len = tx_len;
   122b2:	e9cd 4602 	strd	r4, r6, [sp, #8]
		gpio_pin_set(data->command_data_gpio, config->cmd_data_pin,
   122b6:	f7ff ffa0 	bl	121fa <gpio_pin_set>
		r = spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   122ba:	68a8      	ldr	r0, [r5, #8]
   122bc:	6883      	ldr	r3, [r0, #8]
   122be:	4641      	mov	r1, r8
   122c0:	681c      	ldr	r4, [r3, #0]
   122c2:	aa04      	add	r2, sp, #16
   122c4:	2300      	movs	r3, #0
   122c6:	47a0      	blx	r4
		if (r < 0) {
   122c8:	ea00 70e0 	and.w	r0, r0, r0, asr #31
}
   122cc:	b007      	add	sp, #28
   122ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return 0;
   122d2:	4620      	mov	r0, r4
   122d4:	e7fa      	b.n	122cc <ili9xxx_transmit+0x64>

000122d6 <ili9xxx_set_orientation>:
{
   122d6:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (orientation == DISPLAY_ORIENTATION_NORMAL) {
   122d8:	460c      	mov	r4, r1
	struct ili9xxx_data *data = (struct ili9xxx_data *)dev->data;
   122da:	68c5      	ldr	r5, [r0, #12]
	if (orientation == DISPLAY_ORIENTATION_NORMAL) {
   122dc:	b979      	cbnz	r1, 122fe <ili9xxx_set_orientation+0x28>
		tx_data |= ILI9XXX_MADCTL_MX;
   122de:	2348      	movs	r3, #72	; 0x48
		tx_data |= ILI9XXX_MADCTL_MV | ILI9XXX_MADCTL_MX |
   122e0:	f88d 3007 	strb.w	r3, [sp, #7]
	r = ili9xxx_transmit(dev, ILI9XXX_MADCTL, &tx_data, 1U);
   122e4:	2136      	movs	r1, #54	; 0x36
   122e6:	2301      	movs	r3, #1
   122e8:	f10d 0207 	add.w	r2, sp, #7
   122ec:	f7ff ffbc 	bl	12268 <ili9xxx_transmit>
	if (r < 0) {
   122f0:	2800      	cmp	r0, #0
	return 0;
   122f2:	bfa4      	itt	ge
   122f4:	2000      	movge	r0, #0
	data->orientation = orientation;
   122f6:	f885 4026 	strbge.w	r4, [r5, #38]	; 0x26
}
   122fa:	b003      	add	sp, #12
   122fc:	bd30      	pop	{r4, r5, pc}
	} else if (orientation == DISPLAY_ORIENTATION_ROTATED_90) {
   122fe:	2901      	cmp	r1, #1
   12300:	d101      	bne.n	12306 <ili9xxx_set_orientation+0x30>
		tx_data |= ILI9XXX_MADCTL_MV;
   12302:	2328      	movs	r3, #40	; 0x28
   12304:	e7ec      	b.n	122e0 <ili9xxx_set_orientation+0xa>
	} else if (orientation == DISPLAY_ORIENTATION_ROTATED_180) {
   12306:	2902      	cmp	r1, #2
   12308:	d101      	bne.n	1230e <ili9xxx_set_orientation+0x38>
		tx_data |= ILI9XXX_MADCTL_MY;
   1230a:	2388      	movs	r3, #136	; 0x88
   1230c:	e7e8      	b.n	122e0 <ili9xxx_set_orientation+0xa>
	} else if (orientation == DISPLAY_ORIENTATION_ROTATED_270) {
   1230e:	2903      	cmp	r1, #3
	uint8_t tx_data = ILI9XXX_MADCTL_BGR;
   12310:	bf14      	ite	ne
   12312:	2308      	movne	r3, #8
		tx_data |= ILI9XXX_MADCTL_MV | ILI9XXX_MADCTL_MX |
   12314:	23e8      	moveq	r3, #232	; 0xe8
   12316:	e7e3      	b.n	122e0 <ili9xxx_set_orientation+0xa>

00012318 <ili9xxx_set_pixel_format>:
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
   12318:	2910      	cmp	r1, #16
{
   1231a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1231c:	460c      	mov	r4, r1
	struct ili9xxx_data *data = (struct ili9xxx_data *)dev->data;
   1231e:	68c5      	ldr	r5, [r0, #12]
	if (pixel_format == PIXEL_FORMAT_RGB_565) {
   12320:	d112      	bne.n	12348 <ili9xxx_set_pixel_format+0x30>
		tx_data = ILI9XXX_PIXSET_MCU_16_BIT | ILI9XXX_PIXSET_RGB_16_BIT;
   12322:	2355      	movs	r3, #85	; 0x55
		bytes_per_pixel = 2U;
   12324:	2602      	movs	r6, #2
		tx_data = ILI9XXX_PIXSET_MCU_16_BIT | ILI9XXX_PIXSET_RGB_16_BIT;
   12326:	f88d 3007 	strb.w	r3, [sp, #7]
	r = ili9xxx_transmit(dev, ILI9XXX_PIXSET, &tx_data, 1U);
   1232a:	2301      	movs	r3, #1
   1232c:	213a      	movs	r1, #58	; 0x3a
   1232e:	f10d 0207 	add.w	r2, sp, #7
   12332:	f7ff ff99 	bl	12268 <ili9xxx_transmit>
	if (r < 0) {
   12336:	2800      	cmp	r0, #0
   12338:	db04      	blt.n	12344 <ili9xxx_set_pixel_format+0x2c>
	return 0;
   1233a:	2000      	movs	r0, #0
	data->pixel_format = pixel_format;
   1233c:	f885 4025 	strb.w	r4, [r5, #37]	; 0x25
	data->bytes_per_pixel = bytes_per_pixel;
   12340:	f885 6024 	strb.w	r6, [r5, #36]	; 0x24
}
   12344:	b002      	add	sp, #8
   12346:	bd70      	pop	{r4, r5, r6, pc}
	} else if (pixel_format == PIXEL_FORMAT_RGB_888) {
   12348:	2901      	cmp	r1, #1
   1234a:	d104      	bne.n	12356 <ili9xxx_set_pixel_format+0x3e>
		tx_data = ILI9XXX_PIXSET_MCU_18_BIT | ILI9XXX_PIXSET_RGB_18_BIT;
   1234c:	2366      	movs	r3, #102	; 0x66
		bytes_per_pixel = 3U;
   1234e:	2603      	movs	r6, #3
		tx_data = ILI9XXX_PIXSET_MCU_18_BIT | ILI9XXX_PIXSET_RGB_18_BIT;
   12350:	f88d 3007 	strb.w	r3, [sp, #7]
   12354:	e7e9      	b.n	1232a <ili9xxx_set_pixel_format+0x12>
		return -ENOTSUP;
   12356:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1235a:	e7f3      	b.n	12344 <ili9xxx_set_pixel_format+0x2c>

0001235c <ili9xxx_write>:
{
   1235c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12360:	4616      	mov	r6, r2
	r = ili9xxx_set_mem_area(dev, x, y, desc->width, desc->height);
   12362:	889a      	ldrh	r2, [r3, #4]
{
   12364:	b085      	sub	sp, #20
	r = ili9xxx_set_mem_area(dev, x, y, desc->width, desc->height);
   12366:	88df      	ldrh	r7, [r3, #6]
{
   12368:	461c      	mov	r4, r3
	spi_data[0] = sys_cpu_to_be16(x);
   1236a:	ba4b      	rev16	r3, r1
   1236c:	f8ad 3008 	strh.w	r3, [sp, #8]
	spi_data[1] = sys_cpu_to_be16(x + w - 1U);
   12370:	188b      	adds	r3, r1, r2
   12372:	3b01      	subs	r3, #1
   12374:	3901      	subs	r1, #1
   12376:	4411      	add	r1, r2
   12378:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1237c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   12380:	f8ad 300a 	strh.w	r3, [sp, #10]
	r = ili9xxx_transmit(dev, ILI9XXX_CASET, &spi_data[0], 4U);
   12384:	212a      	movs	r1, #42	; 0x2a
   12386:	2304      	movs	r3, #4
   12388:	aa02      	add	r2, sp, #8
{
   1238a:	4681      	mov	r9, r0
   1238c:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
	struct ili9xxx_data *data = (struct ili9xxx_data *)dev->data;
   12390:	68c5      	ldr	r5, [r0, #12]
	r = ili9xxx_transmit(dev, ILI9XXX_CASET, &spi_data[0], 4U);
   12392:	f7ff ff69 	bl	12268 <ili9xxx_transmit>
	if (r < 0) {
   12396:	2800      	cmp	r0, #0
   12398:	db3a      	blt.n	12410 <ili9xxx_write+0xb4>
	spi_data[0] = sys_cpu_to_be16(y);
   1239a:	ba73      	rev16	r3, r6
   1239c:	f8ad 3008 	strh.w	r3, [sp, #8]
	spi_data[1] = sys_cpu_to_be16(y + h - 1U);
   123a0:	19f3      	adds	r3, r6, r7
   123a2:	3b01      	subs	r3, #1
   123a4:	3e01      	subs	r6, #1
   123a6:	f3c3 2307 	ubfx	r3, r3, #8, #8
   123aa:	443e      	add	r6, r7
   123ac:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
   123b0:	f8ad 300a 	strh.w	r3, [sp, #10]
	r = ili9xxx_transmit(dev, ILI9XXX_PASET, &spi_data[0], 4U);
   123b4:	212b      	movs	r1, #43	; 0x2b
   123b6:	2304      	movs	r3, #4
   123b8:	4648      	mov	r0, r9
   123ba:	aa02      	add	r2, sp, #8
   123bc:	f7ff ff54 	bl	12268 <ili9xxx_transmit>
	if (r < 0) {
   123c0:	2800      	cmp	r0, #0
   123c2:	db25      	blt.n	12410 <ili9xxx_write+0xb4>
	if (desc->pitch > desc->width) {
   123c4:	88a3      	ldrh	r3, [r4, #4]
   123c6:	8922      	ldrh	r2, [r4, #8]
   123c8:	88e6      	ldrh	r6, [r4, #6]
   123ca:	429a      	cmp	r2, r3
		write_h = desc->height;
   123cc:	bf94      	ite	ls
   123ce:	4637      	movls	r7, r6
		write_h = 1U;
   123d0:	2701      	movhi	r7, #1
			     desc->width * data->bytes_per_pixel * write_h);
   123d2:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
	r = ili9xxx_transmit(dev, ILI9XXX_RAMWR, write_data_start,
   123d6:	f04f 012c 	mov.w	r1, #44	; 0x2c
			     desc->width * data->bytes_per_pixel * write_h);
   123da:	fb03 f302 	mul.w	r3, r3, r2
	r = ili9xxx_transmit(dev, ILI9XXX_RAMWR, write_data_start,
   123de:	4648      	mov	r0, r9
   123e0:	4642      	mov	r2, r8
   123e2:	fb07 f303 	mul.w	r3, r7, r3
		nbr_of_writes = 1U;
   123e6:	bf98      	it	ls
   123e8:	2601      	movls	r6, #1
	r = ili9xxx_transmit(dev, ILI9XXX_RAMWR, write_data_start,
   123ea:	f7ff ff3d 	bl	12268 <ili9xxx_transmit>
	if (r < 0) {
   123ee:	2800      	cmp	r0, #0
   123f0:	db0e      	blt.n	12410 <ili9xxx_write+0xb4>
	tx_bufs.count = 1;
   123f2:	2301      	movs	r3, #1
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
   123f4:	4699      	mov	r9, r3
	tx_bufs.buffers = &tx_buf;
   123f6:	f8cd d008 	str.w	sp, [sp, #8]
	tx_bufs.count = 1;
   123fa:	9303      	str	r3, [sp, #12]
	write_data_start += desc->pitch * data->bytes_per_pixel;
   123fc:	8922      	ldrh	r2, [r4, #8]
   123fe:	f895 1024 	ldrb.w	r1, [r5, #36]	; 0x24
		r = spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   12402:	f105 0a0c 	add.w	sl, r5, #12
	write_data_start += desc->pitch * data->bytes_per_pixel;
   12406:	fb01 8802 	mla	r8, r1, r2, r8
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
   1240a:	45b1      	cmp	r9, r6
   1240c:	d303      	bcc.n	12416 <ili9xxx_write+0xba>
	return 0;
   1240e:	2000      	movs	r0, #0
}
   12410:	b005      	add	sp, #20
   12412:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tx_buf.len = desc->width * data->bytes_per_pixel * write_h;
   12416:	88a2      	ldrh	r2, [r4, #4]
   12418:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
		r = spi_write(data->spi_dev, &data->spi_config, &tx_bufs);
   1241c:	68a8      	ldr	r0, [r5, #8]
		tx_buf.len = desc->width * data->bytes_per_pixel * write_h;
   1241e:	4353      	muls	r3, r2
   12420:	437b      	muls	r3, r7
		tx_buf.buf = (void *)write_data_start;
   12422:	f8cd 8000 	str.w	r8, [sp]
		tx_buf.len = desc->width * data->bytes_per_pixel * write_h;
   12426:	9301      	str	r3, [sp, #4]
   12428:	6883      	ldr	r3, [r0, #8]
   1242a:	4651      	mov	r1, sl
   1242c:	f8d3 b000 	ldr.w	fp, [r3]
   12430:	aa02      	add	r2, sp, #8
   12432:	2300      	movs	r3, #0
   12434:	47d8      	blx	fp
		if (r < 0) {
   12436:	2800      	cmp	r0, #0
   12438:	dbea      	blt.n	12410 <ili9xxx_write+0xb4>
		write_data_start += desc->pitch * data->bytes_per_pixel;
   1243a:	8923      	ldrh	r3, [r4, #8]
   1243c:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
   12440:	f109 0901 	add.w	r9, r9, #1
		write_data_start += desc->pitch * data->bytes_per_pixel;
   12444:	fb02 8803 	mla	r8, r2, r3, r8
	for (write_cnt = 1U; write_cnt < nbr_of_writes; ++write_cnt) {
   12448:	fa1f f989 	uxth.w	r9, r9
   1244c:	e7dd      	b.n	1240a <ili9xxx_write+0xae>

0001244e <ili9xxx_display_blanking_off>:
	return ili9xxx_transmit(dev, ILI9XXX_DISPON, NULL, 0);
   1244e:	2300      	movs	r3, #0
   12450:	2129      	movs	r1, #41	; 0x29
   12452:	461a      	mov	r2, r3
   12454:	f7ff bf08 	b.w	12268 <ili9xxx_transmit>

00012458 <ili9xxx_display_blanking_on>:
	return ili9xxx_transmit(dev, ILI9XXX_DISPOFF, NULL, 0);
   12458:	2300      	movs	r3, #0
   1245a:	2128      	movs	r1, #40	; 0x28
   1245c:	461a      	mov	r2, r3
   1245e:	f7ff bf03 	b.w	12268 <ili9xxx_transmit>

00012462 <ili9xxx_init>:

	return 0;
}

static int ili9xxx_init(const struct device *dev)
{
   12462:	b570      	push	{r4, r5, r6, lr}
	const struct ili9xxx_config *config =
   12464:	6845      	ldr	r5, [r0, #4]
{
   12466:	4604      	mov	r4, r0
		(struct ili9xxx_config *)dev->config;
	struct ili9xxx_data *data = (struct ili9xxx_data *)dev->data;
   12468:	68c6      	ldr	r6, [r0, #12]

	int r;

	data->spi_dev = device_get_binding(config->spi_name);
   1246a:	6828      	ldr	r0, [r5, #0]
   1246c:	f7fd fdbe 	bl	ffec <z_impl_device_get_binding>
   12470:	60b0      	str	r0, [r6, #8]
	if (data->spi_dev == NULL) {
   12472:	b910      	cbnz	r0, 1247a <ili9xxx_init+0x18>
		LOG_ERR("Could not get SPI device %s", config->spi_name);
		return -ENODEV;
   12474:	f06f 0012 	mvn.w	r0, #18
		LOG_ERR("Could not exit sleep mode (%d)", r);
		return r;
	}

	return 0;
}
   12478:	bd70      	pop	{r4, r5, r6, pc}
	data->spi_config.frequency = config->spi_max_freq;
   1247a:	68ab      	ldr	r3, [r5, #8]
	data->cs_ctrl.gpio_dev = device_get_binding(config->spi_cs_label);
   1247c:	68e8      	ldr	r0, [r5, #12]
	data->spi_config.frequency = config->spi_max_freq;
   1247e:	60f3      	str	r3, [r6, #12]
	data->spi_config.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8U);
   12480:	f44f 7380 	mov.w	r3, #256	; 0x100
   12484:	8233      	strh	r3, [r6, #16]
	data->spi_config.slave = config->spi_addr;
   12486:	88ab      	ldrh	r3, [r5, #4]
   12488:	8273      	strh	r3, [r6, #18]
   1248a:	f7fd fdaf 	bl	ffec <z_impl_device_get_binding>
	data->cs_ctrl.gpio_dev = device_get_binding(config->spi_cs_label);
   1248e:	61b0      	str	r0, [r6, #24]
	if (data->cs_ctrl.gpio_dev != NULL) {
   12490:	b150      	cbz	r0, 124a8 <ili9xxx_init+0x46>
		data->cs_ctrl.gpio_pin = config->spi_cs_pin;
   12492:	7c2b      	ldrb	r3, [r5, #16]
   12494:	f886 3020 	strb.w	r3, [r6, #32]
		data->cs_ctrl.gpio_dt_flags = config->spi_cs_flags;
   12498:	7c6b      	ldrb	r3, [r5, #17]
   1249a:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
		data->cs_ctrl.delay = 0U;
   1249e:	2300      	movs	r3, #0
   124a0:	61f3      	str	r3, [r6, #28]
		data->spi_config.cs = &data->cs_ctrl;
   124a2:	f106 0318 	add.w	r3, r6, #24
   124a6:	6173      	str	r3, [r6, #20]
	data->command_data_gpio = device_get_binding(config->cmd_data_label);
   124a8:	6968      	ldr	r0, [r5, #20]
   124aa:	f7fd fd9f 	bl	ffec <z_impl_device_get_binding>
   124ae:	6070      	str	r0, [r6, #4]
	if (data->command_data_gpio == NULL) {
   124b0:	2800      	cmp	r0, #0
   124b2:	d0df      	beq.n	12474 <ili9xxx_init+0x12>
			       GPIO_OUTPUT | config->cmd_data_flags);
   124b4:	7e6a      	ldrb	r2, [r5, #25]
	r = gpio_pin_configure(data->command_data_gpio, config->cmd_data_pin,
   124b6:	7e29      	ldrb	r1, [r5, #24]
   124b8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
   124bc:	f7ff fe80 	bl	121c0 <gpio_pin_configure>
	if (r < 0) {
   124c0:	2800      	cmp	r0, #0
   124c2:	dbd9      	blt.n	12478 <ili9xxx_init+0x16>
	data->reset_gpio = device_get_binding(config->reset_label);
   124c4:	69e8      	ldr	r0, [r5, #28]
   124c6:	f7fd fd91 	bl	ffec <z_impl_device_get_binding>
   124ca:	6030      	str	r0, [r6, #0]
	if (data->reset_gpio != NULL) {
   124cc:	2800      	cmp	r0, #0
   124ce:	d133      	bne.n	12538 <ili9xxx_init+0xd6>
	struct ili9xxx_data *data = (struct ili9xxx_data *)dev->data;
   124d0:	68e5      	ldr	r5, [r4, #12]
	if (data->reset_gpio == NULL) {
   124d2:	6828      	ldr	r0, [r5, #0]
   124d4:	2800      	cmp	r0, #0
   124d6:	d13a      	bne.n	1254e <ili9xxx_init+0xec>
	const struct ili9xxx_config *config =
   124d8:	6865      	ldr	r5, [r4, #4]
	r = ili9xxx_set_pixel_format(dev, pixel_format);
   124da:	4620      	mov	r0, r4
	if (config->pixel_format == ILI9XXX_PIXEL_FORMAT_RGB565) {
   124dc:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
		pixel_format = PIXEL_FORMAT_RGB_888;
   124e0:	2b00      	cmp	r3, #0
	r = ili9xxx_set_pixel_format(dev, pixel_format);
   124e2:	bf0c      	ite	eq
   124e4:	2110      	moveq	r1, #16
   124e6:	2101      	movne	r1, #1
   124e8:	f7ff ff16 	bl	12318 <ili9xxx_set_pixel_format>
	if (r < 0) {
   124ec:	2800      	cmp	r0, #0
   124ee:	dbc3      	blt.n	12478 <ili9xxx_init+0x16>
	if (config->rotation == 0U) {
   124f0:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   124f2:	b129      	cbz	r1, 12500 <ili9xxx_init+0x9e>
	} else if (config->rotation == 90U) {
   124f4:	295a      	cmp	r1, #90	; 0x5a
   124f6:	d03f      	beq.n	12578 <ili9xxx_init+0x116>
		orientation = DISPLAY_ORIENTATION_ROTATED_270;
   124f8:	29b4      	cmp	r1, #180	; 0xb4
   124fa:	bf0c      	ite	eq
   124fc:	2102      	moveq	r1, #2
   124fe:	2103      	movne	r1, #3
	r = ili9xxx_set_orientation(dev, orientation);
   12500:	4620      	mov	r0, r4
   12502:	f7ff fee8 	bl	122d6 <ili9xxx_set_orientation>
	if (r < 0) {
   12506:	2800      	cmp	r0, #0
   12508:	dbb6      	blt.n	12478 <ili9xxx_init+0x16>
	if (config->inversion) {
   1250a:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
   1250e:	bbab      	cbnz	r3, 1257c <ili9xxx_init+0x11a>
	r = config->regs_init_fn(dev);
   12510:	4620      	mov	r0, r4
   12512:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   12514:	4798      	blx	r3
	if (r < 0) {
   12516:	2800      	cmp	r0, #0
   12518:	dbae      	blt.n	12478 <ili9xxx_init+0x16>
	r = ili9xxx_transmit(dev, ILI9XXX_SLPOUT, NULL, 0);
   1251a:	2300      	movs	r3, #0
   1251c:	2111      	movs	r1, #17
   1251e:	461a      	mov	r2, r3
   12520:	4620      	mov	r0, r4
   12522:	f7ff fea1 	bl	12268 <ili9xxx_transmit>
	if (r < 0) {
   12526:	2800      	cmp	r0, #0
   12528:	dba6      	blt.n	12478 <ili9xxx_init+0x16>
	return z_impl_k_sleep(timeout);
   1252a:	f640 705d 	movw	r0, #3933	; 0xf5d
   1252e:	2100      	movs	r1, #0
   12530:	f7fe fc08 	bl	10d44 <z_impl_k_sleep>
	return 0;
   12534:	2000      	movs	r0, #0
   12536:	e79f      	b.n	12478 <ili9xxx_init+0x16>
					       config->reset_flags);
   12538:	f895 2021 	ldrb.w	r2, [r5, #33]	; 0x21
		r = gpio_pin_configure(data->reset_gpio, config->reset_pin,
   1253c:	f895 1020 	ldrb.w	r1, [r5, #32]
   12540:	f442 52b0 	orr.w	r2, r2, #5632	; 0x1600
   12544:	f7ff fe3c 	bl	121c0 <gpio_pin_configure>
		if (r < 0) {
   12548:	2800      	cmp	r0, #0
   1254a:	dac1      	bge.n	124d0 <ili9xxx_init+0x6e>
   1254c:	e794      	b.n	12478 <ili9xxx_init+0x16>
	const struct ili9xxx_config *config =
   1254e:	6866      	ldr	r6, [r4, #4]
	gpio_pin_set(data->reset_gpio, config->reset_pin, 1);
   12550:	2201      	movs	r2, #1
   12552:	f896 1020 	ldrb.w	r1, [r6, #32]
   12556:	f7ff fe50 	bl	121fa <gpio_pin_set>
   1255a:	2100      	movs	r1, #0
   1255c:	2021      	movs	r0, #33	; 0x21
   1255e:	f7fe fbf1 	bl	10d44 <z_impl_k_sleep>
	gpio_pin_set(data->reset_gpio, config->reset_pin, 0);
   12562:	2200      	movs	r2, #0
   12564:	f896 1020 	ldrb.w	r1, [r6, #32]
   12568:	6828      	ldr	r0, [r5, #0]
   1256a:	f7ff fe46 	bl	121fa <gpio_pin_set>
   1256e:	2100      	movs	r1, #0
   12570:	20a4      	movs	r0, #164	; 0xa4
   12572:	f7fe fbe7 	bl	10d44 <z_impl_k_sleep>
   12576:	e7af      	b.n	124d8 <ili9xxx_init+0x76>
		orientation = DISPLAY_ORIENTATION_ROTATED_90;
   12578:	2101      	movs	r1, #1
   1257a:	e7c1      	b.n	12500 <ili9xxx_init+0x9e>
		r = ili9xxx_transmit(dev, ILI9XXX_DINVON, NULL, 0U);
   1257c:	2300      	movs	r3, #0
   1257e:	2121      	movs	r1, #33	; 0x21
   12580:	461a      	mov	r2, r3
   12582:	4620      	mov	r0, r4
   12584:	f7ff fe70 	bl	12268 <ili9xxx_transmit>
		if (r < 0) {
   12588:	2800      	cmp	r0, #0
   1258a:	dac1      	bge.n	12510 <ili9xxx_init+0xae>
   1258c:	e774      	b.n	12478 <ili9xxx_init+0x16>

0001258e <ili9340_regs_init>:

#include <logging/log.h>
LOG_MODULE_REGISTER(display_ili9340, CONFIG_DISPLAY_LOG_LEVEL);

int ili9340_regs_init(const struct device *dev)
{
   1258e:	b538      	push	{r3, r4, r5, lr}
	const struct ili9xxx_config *config = dev->config;
	const struct ili9340_regs *regs = config->regs;
   12590:	6843      	ldr	r3, [r0, #4]

	int r;

	LOG_HEXDUMP_DBG(regs->gamset, ILI9340_GAMSET_LEN, "GAMSET");
	r = ili9xxx_transmit(dev, ILI9340_GAMSET, regs->gamset,
   12592:	2126      	movs	r1, #38	; 0x26
	const struct ili9340_regs *regs = config->regs;
   12594:	6add      	ldr	r5, [r3, #44]	; 0x2c
	r = ili9xxx_transmit(dev, ILI9340_GAMSET, regs->gamset,
   12596:	2301      	movs	r3, #1
   12598:	462a      	mov	r2, r5
{
   1259a:	4604      	mov	r4, r0
	r = ili9xxx_transmit(dev, ILI9340_GAMSET, regs->gamset,
   1259c:	f7ff fe64 	bl	12268 <ili9xxx_transmit>
			     ILI9340_GAMSET_LEN);
	if (r < 0) {
   125a0:	2800      	cmp	r0, #0
   125a2:	db44      	blt.n	1262e <ili9340_regs_init+0xa0>
		return r;
	}

	LOG_HEXDUMP_DBG(regs->frmctr1, ILI9340_FRMCTR1_LEN, "FRMCTR1");
	r = ili9xxx_transmit(dev, ILI9340_FRMCTR1, regs->frmctr1,
   125a4:	2302      	movs	r3, #2
   125a6:	21b1      	movs	r1, #177	; 0xb1
   125a8:	4620      	mov	r0, r4
   125aa:	1c6a      	adds	r2, r5, #1
   125ac:	f7ff fe5c 	bl	12268 <ili9xxx_transmit>
			     ILI9340_FRMCTR1_LEN);
	if (r < 0) {
   125b0:	2800      	cmp	r0, #0
   125b2:	db3c      	blt.n	1262e <ili9340_regs_init+0xa0>
		return r;
	}

	LOG_HEXDUMP_DBG(regs->disctrl, ILI9340_DISCTRL_LEN, "DISCTRL");
	r = ili9xxx_transmit(dev, ILI9340_DISCTRL, regs->disctrl,
   125b4:	2303      	movs	r3, #3
   125b6:	21b6      	movs	r1, #182	; 0xb6
   125b8:	4620      	mov	r0, r4
   125ba:	18ea      	adds	r2, r5, r3
   125bc:	f7ff fe54 	bl	12268 <ili9xxx_transmit>
			     ILI9340_DISCTRL_LEN);
	if (r < 0) {
   125c0:	2800      	cmp	r0, #0
   125c2:	db34      	blt.n	1262e <ili9340_regs_init+0xa0>
		return r;
	}

	LOG_HEXDUMP_DBG(regs->pwctrl1, ILI9340_PWCTRL1_LEN, "PWCTRL1");
	r = ili9xxx_transmit(dev, ILI9340_PWCTRL1, regs->pwctrl1,
   125c4:	2302      	movs	r3, #2
   125c6:	21c0      	movs	r1, #192	; 0xc0
   125c8:	4620      	mov	r0, r4
   125ca:	1daa      	adds	r2, r5, #6
   125cc:	f7ff fe4c 	bl	12268 <ili9xxx_transmit>
			     ILI9340_PWCTRL1_LEN);
	if (r < 0) {
   125d0:	2800      	cmp	r0, #0
   125d2:	db2c      	blt.n	1262e <ili9340_regs_init+0xa0>
		return r;
	}

	LOG_HEXDUMP_DBG(regs->pwctrl2, ILI9340_PWCTRL2_LEN, "PWCTRL2");
	r = ili9xxx_transmit(dev, ILI9340_PWCTRL2, regs->pwctrl2,
   125d4:	2301      	movs	r3, #1
   125d6:	21c1      	movs	r1, #193	; 0xc1
   125d8:	4620      	mov	r0, r4
   125da:	f105 0208 	add.w	r2, r5, #8
   125de:	f7ff fe43 	bl	12268 <ili9xxx_transmit>
			     ILI9340_PWCTRL2_LEN);
	if (r < 0) {
   125e2:	2800      	cmp	r0, #0
   125e4:	db23      	blt.n	1262e <ili9340_regs_init+0xa0>
		return r;
	}

	LOG_HEXDUMP_DBG(regs->vmctrl1, ILI9340_VMCTRL1_LEN, "VMCTRL1");
	r = ili9xxx_transmit(dev, ILI9340_VMCTRL1, regs->vmctrl1,
   125e6:	2302      	movs	r3, #2
   125e8:	21c5      	movs	r1, #197	; 0xc5
   125ea:	4620      	mov	r0, r4
   125ec:	f105 0209 	add.w	r2, r5, #9
   125f0:	f7ff fe3a 	bl	12268 <ili9xxx_transmit>
			     ILI9340_VMCTRL1_LEN);
	if (r < 0) {
   125f4:	2800      	cmp	r0, #0
   125f6:	db1a      	blt.n	1262e <ili9340_regs_init+0xa0>
		return r;
	}

	LOG_HEXDUMP_DBG(regs->vmctrl2, ILI9340_VMCTRL2_LEN, "VMCTRL2");
	r = ili9xxx_transmit(dev, ILI9340_VMCTRL2, regs->vmctrl2,
   125f8:	2301      	movs	r3, #1
   125fa:	21c7      	movs	r1, #199	; 0xc7
   125fc:	4620      	mov	r0, r4
   125fe:	f105 020b 	add.w	r2, r5, #11
   12602:	f7ff fe31 	bl	12268 <ili9xxx_transmit>
			     ILI9340_VMCTRL2_LEN);
	if (r < 0) {
   12606:	2800      	cmp	r0, #0
   12608:	db11      	blt.n	1262e <ili9340_regs_init+0xa0>
		return r;
	}

	LOG_HEXDUMP_DBG(regs->pgamctrl, ILI9340_PGAMCTRL_LEN, "PGAMCTRL");
	r = ili9xxx_transmit(dev, ILI9340_PGAMCTRL, regs->pgamctrl,
   1260a:	230f      	movs	r3, #15
   1260c:	21e0      	movs	r1, #224	; 0xe0
   1260e:	4620      	mov	r0, r4
   12610:	f105 020c 	add.w	r2, r5, #12
   12614:	f7ff fe28 	bl	12268 <ili9xxx_transmit>
			     ILI9340_PGAMCTRL_LEN);
	if (r < 0) {
   12618:	2800      	cmp	r0, #0
   1261a:	db08      	blt.n	1262e <ili9340_regs_init+0xa0>
		return r;
	}

	LOG_HEXDUMP_DBG(regs->ngamctrl, ILI9340_NGAMCTRL_LEN, "NGAMCTRL");
	r = ili9xxx_transmit(dev, ILI9340_NGAMCTRL, regs->ngamctrl,
   1261c:	230f      	movs	r3, #15
   1261e:	21e1      	movs	r1, #225	; 0xe1
   12620:	4620      	mov	r0, r4
   12622:	f105 021b 	add.w	r2, r5, #27
   12626:	f7ff fe1f 	bl	12268 <ili9xxx_transmit>
			     ILI9340_NGAMCTRL_LEN);
	if (r < 0) {
   1262a:	ea00 70e0 	and.w	r0, r0, r0, asr #31
		return r;
	}

	return 0;
}
   1262e:	bd38      	pop	{r3, r4, r5, pc}

00012630 <bt_rpmsg_send>:
{
   12630:	b510      	push	{r4, lr}
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
   12632:	7d01      	ldrb	r1, [r0, #20]
   12634:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
   12636:	2902      	cmp	r1, #2
   12638:	d003      	beq.n	12642 <bt_rpmsg_send+0x12>
   1263a:	2904      	cmp	r1, #4
   1263c:	d00d      	beq.n	1265a <bt_rpmsg_send+0x2a>
   1263e:	b939      	cbnz	r1, 12650 <bt_rpmsg_send+0x20>
   12640:	2101      	movs	r1, #1
	net_buf_simple_push_u8(&buf->b, val);
   12642:	f104 0008 	add.w	r0, r4, #8
   12646:	f002 fbe9 	bl	14e1c <net_buf_simple_push_u8>
	err = bt_rpmsg_platform_send(buf);
   1264a:	4620      	mov	r0, r4
   1264c:	f7ef fc98 	bl	1f80 <bt_rpmsg_platform_send>
	net_buf_unref(buf);
   12650:	4620      	mov	r0, r4
   12652:	f7f4 f97d 	bl	6950 <net_buf_unref>
}
   12656:	2000      	movs	r0, #0
   12658:	bd10      	pop	{r4, pc}
		pkt_indicator = RPMSG_ISO;
   1265a:	2105      	movs	r1, #5
   1265c:	e7f1      	b.n	12642 <bt_rpmsg_send+0x12>

0001265e <bt_rpmsg_open>:
{
   1265e:	b508      	push	{r3, lr}
	while (!bt_rpmsg_platform_endpoint_is_bound()) {
   12660:	f7ef fc96 	bl	1f90 <bt_rpmsg_platform_endpoint_is_bound>
   12664:	b108      	cbz	r0, 1266a <bt_rpmsg_open+0xc>
}
   12666:	2000      	movs	r0, #0
   12668:	bd08      	pop	{r3, pc}
   1266a:	2100      	movs	r1, #0
   1266c:	2021      	movs	r0, #33	; 0x21
   1266e:	f7fe fb69 	bl	10d44 <z_impl_k_sleep>
   12672:	e7f5      	b.n	12660 <bt_rpmsg_open+0x2>

00012674 <bt_rpmsg_rx>:
{
   12674:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12676:	4606      	mov	r6, r0
	pkt_indicator = *data++;
   12678:	7800      	ldrb	r0, [r0, #0]
{
   1267a:	460d      	mov	r5, r1
	switch (pkt_indicator) {
   1267c:	2804      	cmp	r0, #4
	remaining -= sizeof(pkt_indicator);
   1267e:	f101 33ff 	add.w	r3, r1, #4294967295
	switch (pkt_indicator) {
   12682:	d021      	beq.n	126c8 <bt_rpmsg_rx+0x54>
   12684:	2805      	cmp	r0, #5
   12686:	d04f      	beq.n	12728 <bt_rpmsg_rx+0xb4>
   12688:	2802      	cmp	r0, #2
   1268a:	d11b      	bne.n	126c4 <bt_rpmsg_rx+0x50>
	if (remaining < sizeof(hdr)) {
   1268c:	2b03      	cmp	r3, #3
   1268e:	d919      	bls.n	126c4 <bt_rpmsg_rx+0x50>
	buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_NO_WAIT);
   12690:	2200      	movs	r2, #0
   12692:	2300      	movs	r3, #0
   12694:	2003      	movs	r0, #3
	buf = bt_buf_get_rx(BT_BUF_ISO_IN, K_NO_WAIT);
   12696:	f7f0 fdc7 	bl	3228 <bt_buf_get_rx>
	if (buf) {
   1269a:	4604      	mov	r4, r0
   1269c:	b190      	cbz	r0, 126c4 <bt_rpmsg_rx+0x50>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   1269e:	2204      	movs	r2, #4
   126a0:	f8d6 3001 	ldr.w	r3, [r6, #1]
   126a4:	f100 0708 	add.w	r7, r0, #8
   126a8:	4638      	mov	r0, r7
   126aa:	eb0d 0102 	add.w	r1, sp, r2
   126ae:	9301      	str	r3, [sp, #4]
   126b0:	f002 fb9a 	bl	14de8 <net_buf_simple_add_mem>
	if (remaining != sys_le16_to_cpu(hdr.len)) {
   126b4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
		remaining -= sizeof(hdr);
   126b8:	3d05      	subs	r5, #5
	if (remaining != sys_le16_to_cpu(hdr.len)) {
   126ba:	429d      	cmp	r5, r3
   126bc:	d039      	beq.n	12732 <bt_rpmsg_rx+0xbe>
		net_buf_unref(buf);
   126be:	4620      	mov	r0, r4
   126c0:	f7f4 f946 	bl	6950 <net_buf_unref>
}
   126c4:	b003      	add	sp, #12
   126c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (remaining < sizeof(hdr)) {
   126c8:	2b01      	cmp	r3, #1
   126ca:	d9fb      	bls.n	126c4 <bt_rpmsg_rx+0x50>
	switch (evt_type) {
   126cc:	7873      	ldrb	r3, [r6, #1]
   126ce:	2b3e      	cmp	r3, #62	; 0x3e
   126d0:	d126      	bne.n	12720 <bt_rpmsg_rx+0xac>
		uint8_t subevt_type = evt_data[sizeof(struct bt_hci_evt_hdr)];
   126d2:	78f1      	ldrb	r1, [r6, #3]
		switch (subevt_type) {
   126d4:	2902      	cmp	r1, #2
   126d6:	d025      	beq.n	12724 <bt_rpmsg_rx+0xb0>
   126d8:	f1a1 030d 	sub.w	r3, r1, #13
   126dc:	4259      	negs	r1, r3
   126de:	4159      	adcs	r1, r3
	memcpy((void *)&hdr, data, sizeof(hdr));
   126e0:	f8b6 0001 	ldrh.w	r0, [r6, #1]
	remaining -= sizeof(hdr);
   126e4:	3d03      	subs	r5, #3
	if (remaining != hdr.len) {
   126e6:	ebb5 2f10 	cmp.w	r5, r0, lsr #8
   126ea:	f8ad 0004 	strh.w	r0, [sp, #4]
   126ee:	d1e9      	bne.n	126c4 <bt_rpmsg_rx+0x50>
	buf = bt_buf_get_evt(hdr.evt, discardable, K_NO_WAIT);
   126f0:	2200      	movs	r2, #0
   126f2:	2300      	movs	r3, #0
   126f4:	b2c0      	uxtb	r0, r0
   126f6:	f7f0 fdd3 	bl	32a0 <bt_buf_get_evt>
	if (!buf) {
   126fa:	4604      	mov	r4, r0
   126fc:	2800      	cmp	r0, #0
   126fe:	d0e1      	beq.n	126c4 <bt_rpmsg_rx+0x50>
   12700:	f100 0708 	add.w	r7, r0, #8
   12704:	2202      	movs	r2, #2
   12706:	a901      	add	r1, sp, #4
   12708:	4638      	mov	r0, r7
   1270a:	f002 fb6d 	bl	14de8 <net_buf_simple_add_mem>
   1270e:	462a      	mov	r2, r5
   12710:	1cf1      	adds	r1, r6, #3
   12712:	4638      	mov	r0, r7
   12714:	f002 fb68 	bl	14de8 <net_buf_simple_add_mem>
		bt_recv(buf);
   12718:	4620      	mov	r0, r4
   1271a:	f7f1 fbbb 	bl	3e94 <bt_recv>
		BT_HEXDUMP_DBG(buf->data, buf->len, "RX buf payload:");
   1271e:	e7d1      	b.n	126c4 <bt_rpmsg_rx+0x50>
		return false;
   12720:	2100      	movs	r1, #0
   12722:	e7dd      	b.n	126e0 <bt_rpmsg_rx+0x6c>
			return true;
   12724:	2101      	movs	r1, #1
   12726:	e7db      	b.n	126e0 <bt_rpmsg_rx+0x6c>
	if (remaining < sizeof(hdr)) {
   12728:	2b03      	cmp	r3, #3
   1272a:	d9cb      	bls.n	126c4 <bt_rpmsg_rx+0x50>
	buf = bt_buf_get_rx(BT_BUF_ISO_IN, K_NO_WAIT);
   1272c:	2200      	movs	r2, #0
   1272e:	2300      	movs	r3, #0
   12730:	e7b1      	b.n	12696 <bt_rpmsg_rx+0x22>
   12732:	462a      	mov	r2, r5
   12734:	1d71      	adds	r1, r6, #5
   12736:	e7ec      	b.n	12712 <bt_rpmsg_rx+0x9e>

00012738 <endpoint_cb>:
{
   12738:	b508      	push	{r3, lr}
   1273a:	4608      	mov	r0, r1
	bt_rpmsg_rx(data, len);
   1273c:	4611      	mov	r1, r2
   1273e:	f7ff ff99 	bl	12674 <bt_rpmsg_rx>
}
   12742:	2000      	movs	r0, #0
   12744:	bd08      	pop	{r3, pc}

00012746 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
   12746:	4770      	bx	lr

00012748 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   12748:	4770      	bx	lr

0001274a <sys_clock_disable>:
   1274a:	4770      	bx	lr

0001274c <abort_function>:
	sys_reboot(SYS_REBOOT_WARM);
   1274c:	2000      	movs	r0, #0
   1274e:	f7ef ba15 	b.w	1b7c <sys_reboot>

00012752 <_copy>:

#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
   12752:	b538      	push	{r3, r4, r5, lr}
   12754:	460d      	mov	r5, r1
	if (from_len <= to_len) {
   12756:	42ab      	cmp	r3, r5
{
   12758:	4611      	mov	r1, r2
   1275a:	461c      	mov	r4, r3
	if (from_len <= to_len) {
   1275c:	d804      	bhi.n	12768 <_copy+0x16>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1275e:	461a      	mov	r2, r3
   12760:	f00b f8ff 	bl	1d962 <memcpy>
		(void)memcpy(to, from, from_len);
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   12764:	4620      	mov	r0, r4
   12766:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   12768:	2400      	movs	r4, #0
   1276a:	e7fb      	b.n	12764 <_copy+0x12>

0001276c <_set>:
__ssp_bos_icheck3(memset, void *, int)
   1276c:	f00b b906 	b.w	1d97c <memset>

00012770 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   12770:	09c3      	lsrs	r3, r0, #7
   12772:	005a      	lsls	r2, r3, #1
   12774:	4413      	add	r3, r2
   12776:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   1277a:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   1277e:	b2c0      	uxtb	r0, r0
   12780:	4770      	bx	lr

00012782 <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   12782:	78cb      	ldrb	r3, [r1, #3]
   12784:	7802      	ldrb	r2, [r0, #0]
   12786:	4053      	eors	r3, r2
   12788:	7003      	strb	r3, [r0, #0]
   1278a:	884b      	ldrh	r3, [r1, #2]
   1278c:	7842      	ldrb	r2, [r0, #1]
   1278e:	4053      	eors	r3, r2
   12790:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   12792:	680a      	ldr	r2, [r1, #0]
   12794:	7883      	ldrb	r3, [r0, #2]
   12796:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   1279a:	7083      	strb	r3, [r0, #2]
   1279c:	680a      	ldr	r2, [r1, #0]
   1279e:	78c3      	ldrb	r3, [r0, #3]
   127a0:	4053      	eors	r3, r2
   127a2:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   127a4:	79cb      	ldrb	r3, [r1, #7]
   127a6:	7902      	ldrb	r2, [r0, #4]
   127a8:	4053      	eors	r3, r2
   127aa:	7103      	strb	r3, [r0, #4]
   127ac:	88cb      	ldrh	r3, [r1, #6]
   127ae:	7942      	ldrb	r2, [r0, #5]
   127b0:	4053      	eors	r3, r2
   127b2:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   127b4:	684a      	ldr	r2, [r1, #4]
   127b6:	7983      	ldrb	r3, [r0, #6]
   127b8:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   127bc:	7183      	strb	r3, [r0, #6]
   127be:	684a      	ldr	r2, [r1, #4]
   127c0:	79c3      	ldrb	r3, [r0, #7]
   127c2:	4053      	eors	r3, r2
   127c4:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   127c6:	7acb      	ldrb	r3, [r1, #11]
   127c8:	7a02      	ldrb	r2, [r0, #8]
   127ca:	4053      	eors	r3, r2
   127cc:	7203      	strb	r3, [r0, #8]
   127ce:	7a42      	ldrb	r2, [r0, #9]
   127d0:	894b      	ldrh	r3, [r1, #10]
   127d2:	4053      	eors	r3, r2
   127d4:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   127d6:	688a      	ldr	r2, [r1, #8]
   127d8:	7a83      	ldrb	r3, [r0, #10]
   127da:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   127de:	7283      	strb	r3, [r0, #10]
   127e0:	688a      	ldr	r2, [r1, #8]
   127e2:	7ac3      	ldrb	r3, [r0, #11]
   127e4:	4053      	eors	r3, r2
   127e6:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   127e8:	7bcb      	ldrb	r3, [r1, #15]
   127ea:	7b02      	ldrb	r2, [r0, #12]
   127ec:	4053      	eors	r3, r2
   127ee:	7303      	strb	r3, [r0, #12]
   127f0:	89cb      	ldrh	r3, [r1, #14]
   127f2:	7b42      	ldrb	r2, [r0, #13]
   127f4:	4053      	eors	r3, r2
   127f6:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   127f8:	68ca      	ldr	r2, [r1, #12]
   127fa:	7b83      	ldrb	r3, [r0, #14]
   127fc:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   12800:	7383      	strb	r3, [r0, #14]
   12802:	68ca      	ldr	r2, [r1, #12]
   12804:	7bc3      	ldrb	r3, [r0, #15]
   12806:	4053      	eors	r3, r2
   12808:	73c3      	strb	r3, [r0, #15]
}
   1280a:	4770      	bx	lr

0001280c <shift_rows>:
{
   1280c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   1280e:	7802      	ldrb	r2, [r0, #0]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   12810:	7ac3      	ldrb	r3, [r0, #11]
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   12812:	f88d 2000 	strb.w	r2, [sp]
   12816:	7942      	ldrb	r2, [r0, #5]
   12818:	f88d 2001 	strb.w	r2, [sp, #1]
   1281c:	7a82      	ldrb	r2, [r0, #10]
   1281e:	f88d 2002 	strb.w	r2, [sp, #2]
   12822:	7bc2      	ldrb	r2, [r0, #15]
   12824:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   12828:	7902      	ldrb	r2, [r0, #4]
   1282a:	f88d 2004 	strb.w	r2, [sp, #4]
   1282e:	7a42      	ldrb	r2, [r0, #9]
   12830:	f88d 2005 	strb.w	r2, [sp, #5]
   12834:	7b82      	ldrb	r2, [r0, #14]
   12836:	f88d 2006 	strb.w	r2, [sp, #6]
   1283a:	78c2      	ldrb	r2, [r0, #3]
   1283c:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   12840:	7a02      	ldrb	r2, [r0, #8]
   12842:	f88d 2008 	strb.w	r2, [sp, #8]
   12846:	7b42      	ldrb	r2, [r0, #13]
   12848:	f88d 2009 	strb.w	r2, [sp, #9]
   1284c:	7882      	ldrb	r2, [r0, #2]
   1284e:	f88d 200a 	strb.w	r2, [sp, #10]
   12852:	79c2      	ldrb	r2, [r0, #7]
   12854:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   12858:	7b02      	ldrb	r2, [r0, #12]
   1285a:	f88d 200c 	strb.w	r2, [sp, #12]
   1285e:	7842      	ldrb	r2, [r0, #1]
   12860:	f88d 200d 	strb.w	r2, [sp, #13]
   12864:	7982      	ldrb	r2, [r0, #6]
   12866:	f88d 200e 	strb.w	r2, [sp, #14]
   1286a:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   1286e:	2310      	movs	r3, #16
   12870:	466a      	mov	r2, sp
   12872:	4619      	mov	r1, r3
   12874:	f7ff ff6d 	bl	12752 <_copy>
}
   12878:	b005      	add	sp, #20
   1287a:	f85d fb04 	ldr.w	pc, [sp], #4

0001287e <mult_row_column>:
{
   1287e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12880:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   12882:	7808      	ldrb	r0, [r1, #0]
{
   12884:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   12886:	f7ff ff73 	bl	12770 <_double_byte>
   1288a:	4605      	mov	r5, r0
   1288c:	7860      	ldrb	r0, [r4, #1]
   1288e:	f7ff ff6f 	bl	12770 <_double_byte>
   12892:	78a2      	ldrb	r2, [r4, #2]
   12894:	7863      	ldrb	r3, [r4, #1]
   12896:	4053      	eors	r3, r2
   12898:	78e2      	ldrb	r2, [r4, #3]
   1289a:	4053      	eors	r3, r2
   1289c:	405d      	eors	r5, r3
   1289e:	4045      	eors	r5, r0
   128a0:	7035      	strb	r5, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   128a2:	7860      	ldrb	r0, [r4, #1]
   128a4:	7827      	ldrb	r7, [r4, #0]
   128a6:	f7ff ff63 	bl	12770 <_double_byte>
   128aa:	4605      	mov	r5, r0
   128ac:	78a0      	ldrb	r0, [r4, #2]
   128ae:	f7ff ff5f 	bl	12770 <_double_byte>
   128b2:	78a3      	ldrb	r3, [r4, #2]
   128b4:	405f      	eors	r7, r3
   128b6:	78e3      	ldrb	r3, [r4, #3]
   128b8:	405f      	eors	r7, r3
   128ba:	407d      	eors	r5, r7
   128bc:	4045      	eors	r5, r0
   128be:	7075      	strb	r5, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   128c0:	78a0      	ldrb	r0, [r4, #2]
   128c2:	7865      	ldrb	r5, [r4, #1]
   128c4:	7827      	ldrb	r7, [r4, #0]
   128c6:	f7ff ff53 	bl	12770 <_double_byte>
   128ca:	406f      	eors	r7, r5
   128cc:	4605      	mov	r5, r0
   128ce:	78e0      	ldrb	r0, [r4, #3]
   128d0:	f7ff ff4e 	bl	12770 <_double_byte>
   128d4:	78e3      	ldrb	r3, [r4, #3]
   128d6:	405f      	eors	r7, r3
   128d8:	407d      	eors	r5, r7
   128da:	4045      	eors	r5, r0
   128dc:	70b5      	strb	r5, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   128de:	7820      	ldrb	r0, [r4, #0]
   128e0:	f7ff ff46 	bl	12770 <_double_byte>
   128e4:	7863      	ldrb	r3, [r4, #1]
   128e6:	7825      	ldrb	r5, [r4, #0]
   128e8:	405d      	eors	r5, r3
   128ea:	78a3      	ldrb	r3, [r4, #2]
   128ec:	405d      	eors	r5, r3
   128ee:	4045      	eors	r5, r0
   128f0:	78e0      	ldrb	r0, [r4, #3]
   128f2:	f7ff ff3d 	bl	12770 <_double_byte>
   128f6:	b2ed      	uxtb	r5, r5
   128f8:	4045      	eors	r5, r0
   128fa:	70f5      	strb	r5, [r6, #3]
}
   128fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000128fe <gf_double>:

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   128fe:	460a      	mov	r2, r1
{
   12900:	b510      	push	{r4, lr}
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   12902:	f912 3b10 	ldrsb.w	r3, [r2], #16

	out += (TC_AES_BLOCK_SIZE - 1);
   12906:	300f      	adds	r0, #15
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   12908:	2b00      	cmp	r3, #0
   1290a:	bfb4      	ite	lt
   1290c:	2387      	movlt	r3, #135	; 0x87
   1290e:	2300      	movge	r3, #0
	for (;;) {
		*out-- = (*x << 1) ^ carry;
   12910:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   12914:	ea83 0344 	eor.w	r3, r3, r4, lsl #1
		if (x == in) {
   12918:	4291      	cmp	r1, r2
		*out-- = (*x << 1) ^ carry;
   1291a:	f800 3901 	strb.w	r3, [r0], #-1
		if (x == in) {
   1291e:	d002      	beq.n	12926 <gf_double+0x28>
			break;
		}
		carry = *x-- >> 7;
   12920:	7813      	ldrb	r3, [r2, #0]
   12922:	09db      	lsrs	r3, r3, #7
		*out-- = (*x << 1) ^ carry;
   12924:	e7f4      	b.n	12910 <gf_double+0x12>
	}
}
   12926:	bd10      	pop	{r4, pc}

00012928 <tc_cmac_erase>:

	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
   12928:	b508      	push	{r3, lr}
	if (s == (TCCmacState_t) 0) {
   1292a:	b120      	cbz	r0, 12936 <tc_cmac_erase+0xe>
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   1292c:	2258      	movs	r2, #88	; 0x58
   1292e:	2100      	movs	r1, #0
   12930:	f7ff ff1c 	bl	1276c <_set>
   12934:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   12936:	bd08      	pop	{r3, pc}

00012938 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
   12938:	b510      	push	{r4, lr}
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   1293a:	4604      	mov	r4, r0
   1293c:	b188      	cbz	r0, 12962 <tc_cmac_init+0x2a>
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   1293e:	2210      	movs	r2, #16
   12940:	2100      	movs	r1, #0
   12942:	f7ff ff13 	bl	1276c <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   12946:	2210      	movs	r2, #16
   12948:	f104 0030 	add.w	r0, r4, #48	; 0x30
   1294c:	2100      	movs	r1, #0
   1294e:	f7ff ff0d 	bl	1276c <_set>
	s->leftover_offset = 0;
   12952:	2300      	movs	r3, #0

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   12954:	2200      	movs	r2, #0
	s->leftover_offset = 0;
   12956:	6463      	str	r3, [r4, #68]	; 0x44
	s->countdown = MAX_CALLS;
   12958:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   1295c:	2001      	movs	r0, #1
   1295e:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50

	return TC_CRYPTO_SUCCESS;
}
   12962:	bd10      	pop	{r4, pc}

00012964 <tc_cmac_setup>:
{
   12964:	b570      	push	{r4, r5, r6, lr}
   12966:	460d      	mov	r5, r1
   12968:	4616      	mov	r6, r2
	if (s == (TCCmacState_t) 0 ||
   1296a:	4604      	mov	r4, r0
   1296c:	b310      	cbz	r0, 129b4 <tc_cmac_setup+0x50>
   1296e:	b311      	cbz	r1, 129b6 <tc_cmac_setup+0x52>
	_set(s, 0, sizeof(*s));
   12970:	2258      	movs	r2, #88	; 0x58
   12972:	2100      	movs	r1, #0
   12974:	f7ff fefa 	bl	1276c <_set>
	tc_aes128_set_encrypt_key(s->sched, key);
   12978:	4629      	mov	r1, r5
   1297a:	4630      	mov	r0, r6
	s->sched = sched;
   1297c:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   1297e:	f7ef fd21 	bl	23c4 <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   12982:	2210      	movs	r2, #16
   12984:	2100      	movs	r1, #0
   12986:	4620      	mov	r0, r4
   12988:	f7ff fef0 	bl	1276c <_set>
	gf_double (s->K1, s->iv);
   1298c:	f104 0510 	add.w	r5, r4, #16
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   12990:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   12992:	4621      	mov	r1, r4
   12994:	4620      	mov	r0, r4
   12996:	f7ef fd69 	bl	246c <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   1299a:	4621      	mov	r1, r4
   1299c:	4628      	mov	r0, r5
   1299e:	f7ff ffae 	bl	128fe <gf_double>
	gf_double (s->K2, s->K1);
   129a2:	4629      	mov	r1, r5
   129a4:	f104 0020 	add.w	r0, r4, #32
   129a8:	f7ff ffa9 	bl	128fe <gf_double>
	tc_cmac_init(s);
   129ac:	4620      	mov	r0, r4
   129ae:	f7ff ffc3 	bl	12938 <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   129b2:	2001      	movs	r0, #1
}
   129b4:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   129b6:	4608      	mov	r0, r1
   129b8:	e7fc      	b.n	129b4 <tc_cmac_setup+0x50>

000129ba <tc_cmac_update>:

int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
   129ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   129be:	460d      	mov	r5, r1
   129c0:	4616      	mov	r6, r2
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   129c2:	4604      	mov	r4, r0
   129c4:	2800      	cmp	r0, #0
   129c6:	d062      	beq.n	12a8e <tc_cmac_update+0xd4>
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   129c8:	b912      	cbnz	r2, 129d0 <tc_cmac_update+0x16>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
   129ca:	2001      	movs	r0, #1
}
   129cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (data == (const uint8_t *) 0) {
   129d0:	2900      	cmp	r1, #0
   129d2:	d05c      	beq.n	12a8e <tc_cmac_update+0xd4>
	if (s->countdown == 0) {
   129d4:	e9d0 0114 	ldrd	r0, r1, [r0, #80]	; 0x50
   129d8:	ea50 0301 	orrs.w	r3, r0, r1
   129dc:	d057      	beq.n	12a8e <tc_cmac_update+0xd4>
	s->countdown--;
   129de:	f110 32ff 	adds.w	r2, r0, #4294967295
	if (s->leftover_offset > 0) {
   129e2:	f8d4 8044 	ldr.w	r8, [r4, #68]	; 0x44
	s->countdown--;
   129e6:	f141 33ff 	adc.w	r3, r1, #4294967295
   129ea:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
	if (s->leftover_offset > 0) {
   129ee:	f1b8 0f00 	cmp.w	r8, #0
   129f2:	d02a      	beq.n	12a4a <tc_cmac_update+0x90>
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   129f4:	f1c8 0710 	rsb	r7, r8, #16
		if (data_length < remaining_space) {
   129f8:	f108 0030 	add.w	r0, r8, #48	; 0x30
   129fc:	42be      	cmp	r6, r7
   129fe:	4420      	add	r0, r4
   12a00:	d208      	bcs.n	12a14 <tc_cmac_update+0x5a>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   12a02:	462a      	mov	r2, r5
   12a04:	4633      	mov	r3, r6
   12a06:	4631      	mov	r1, r6
   12a08:	f7ff fea3 	bl	12752 <_copy>
			s->leftover_offset += data_length;
   12a0c:	6c62      	ldr	r2, [r4, #68]	; 0x44
   12a0e:	4432      	add	r2, r6
   12a10:	6462      	str	r2, [r4, #68]	; 0x44
			return TC_CRYPTO_SUCCESS;
   12a12:	e7da      	b.n	129ca <tc_cmac_update+0x10>
		_copy(&s->leftover[s->leftover_offset],
   12a14:	463b      	mov	r3, r7
   12a16:	462a      	mov	r2, r5
   12a18:	4639      	mov	r1, r7
   12a1a:	f7ff fe9a 	bl	12752 <_copy>
		s->leftover_offset = 0;
   12a1e:	2300      	movs	r3, #0
   12a20:	3e10      	subs	r6, #16
   12a22:	6463      	str	r3, [r4, #68]	; 0x44
		data_length -= remaining_space;
   12a24:	4446      	add	r6, r8
		data += remaining_space;
   12a26:	443d      	add	r5, r7
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   12a28:	1e63      	subs	r3, r4, #1
   12a2a:	f104 010f 	add.w	r1, r4, #15
			s->iv[i] ^= s->leftover[i];
   12a2e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   12a32:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   12a36:	428b      	cmp	r3, r1
			s->iv[i] ^= s->leftover[i];
   12a38:	ea82 0200 	eor.w	r2, r2, r0
   12a3c:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   12a3e:	d1f6      	bne.n	12a2e <tc_cmac_update+0x74>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   12a40:	4621      	mov	r1, r4
   12a42:	4620      	mov	r0, r4
   12a44:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   12a46:	f7ef fd11 	bl	246c <tc_aes_encrypt>
   12a4a:	f104 070f 	add.w	r7, r4, #15
	while (data_length > TC_AES_BLOCK_SIZE) {
   12a4e:	2e10      	cmp	r6, #16
   12a50:	d80a      	bhi.n	12a68 <tc_cmac_update+0xae>
	if (data_length > 0) {
   12a52:	2e00      	cmp	r6, #0
   12a54:	d0b9      	beq.n	129ca <tc_cmac_update+0x10>
		_copy(s->leftover, data_length, data, data_length);
   12a56:	4633      	mov	r3, r6
   12a58:	462a      	mov	r2, r5
   12a5a:	4631      	mov	r1, r6
   12a5c:	f104 0030 	add.w	r0, r4, #48	; 0x30
   12a60:	f7ff fe77 	bl	12752 <_copy>
		s->leftover_offset = data_length;
   12a64:	6466      	str	r6, [r4, #68]	; 0x44
   12a66:	e7b0      	b.n	129ca <tc_cmac_update+0x10>
   12a68:	1e63      	subs	r3, r4, #1
   12a6a:	1e69      	subs	r1, r5, #1
			s->iv[i] ^= data[i];
   12a6c:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   12a70:	f811 0f01 	ldrb.w	r0, [r1, #1]!
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   12a74:	42bb      	cmp	r3, r7
			s->iv[i] ^= data[i];
   12a76:	ea82 0200 	eor.w	r2, r2, r0
   12a7a:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   12a7c:	d1f6      	bne.n	12a6c <tc_cmac_update+0xb2>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   12a7e:	4621      	mov	r1, r4
   12a80:	4620      	mov	r0, r4
   12a82:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   12a84:	f7ef fcf2 	bl	246c <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   12a88:	3510      	adds	r5, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   12a8a:	3e10      	subs	r6, #16
   12a8c:	e7df      	b.n	12a4e <tc_cmac_update+0x94>
		return TC_CRYPTO_FAIL;
   12a8e:	2000      	movs	r0, #0
   12a90:	e79c      	b.n	129cc <tc_cmac_update+0x12>

00012a92 <tc_cmac_final>:

int tc_cmac_final(uint8_t *tag, TCCmacState_t s)
{
   12a92:	b570      	push	{r4, r5, r6, lr}
   12a94:	460c      	mov	r4, r1
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   12a96:	4605      	mov	r5, r0
   12a98:	b1f0      	cbz	r0, 12ad8 <tc_cmac_final+0x46>
   12a9a:	b371      	cbz	r1, 12afa <tc_cmac_final+0x68>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   12a9c:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   12a9e:	2a10      	cmp	r2, #16
   12aa0:	d11b      	bne.n	12ada <tc_cmac_final+0x48>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   12aa2:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   12aa4:	1e63      	subs	r3, r4, #1
   12aa6:	3901      	subs	r1, #1
   12aa8:	f104 000f 	add.w	r0, r4, #15
		s->iv[i] ^= s->leftover[i] ^ k[i];
   12aac:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   12ab0:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   12ab4:	4298      	cmp	r0, r3
		s->iv[i] ^= s->leftover[i] ^ k[i];
   12ab6:	ea82 0206 	eor.w	r2, r2, r6
   12aba:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   12abe:	ea82 0206 	eor.w	r2, r2, r6
   12ac2:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   12ac4:	d1f2      	bne.n	12aac <tc_cmac_final+0x1a>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   12ac6:	4621      	mov	r1, r4
   12ac8:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   12aca:	4628      	mov	r0, r5
   12acc:	f7ef fcce 	bl	246c <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   12ad0:	4620      	mov	r0, r4
   12ad2:	f7ff ff29 	bl	12928 <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   12ad6:	2001      	movs	r0, #1
}
   12ad8:	bd70      	pop	{r4, r5, r6, pc}
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   12ada:	f102 0030 	add.w	r0, r2, #48	; 0x30
   12ade:	2100      	movs	r1, #0
   12ae0:	f1c2 0210 	rsb	r2, r2, #16
   12ae4:	4420      	add	r0, r4
   12ae6:	f7ff fe41 	bl	1276c <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   12aea:	2280      	movs	r2, #128	; 0x80
   12aec:	6c63      	ldr	r3, [r4, #68]	; 0x44
		k = (uint8_t *) s->K2;
   12aee:	f104 0120 	add.w	r1, r4, #32
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   12af2:	4423      	add	r3, r4
   12af4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   12af8:	e7d4      	b.n	12aa4 <tc_cmac_final+0x12>
		return TC_CRYPTO_FAIL;
   12afa:	4608      	mov	r0, r1
   12afc:	e7ec      	b.n	12ad8 <tc_cmac_final+0x46>

00012afe <tc_sha256_update>:
{
   12afe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12b00:	460c      	mov	r4, r1
	if (s == (TCSha256State_t) 0 ||
   12b02:	b110      	cbz	r0, 12b0a <tc_sha256_update+0xc>
   12b04:	b1f9      	cbz	r1, 12b46 <tc_sha256_update+0x48>
	} else if (datalen == 0) {
   12b06:	b90a      	cbnz	r2, 12b0c <tc_sha256_update+0xe>
		return TC_CRYPTO_SUCCESS;
   12b08:	2001      	movs	r0, #1
}
   12b0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			s->leftover_offset = 0;
   12b0c:	2600      	movs	r6, #0
   12b0e:	188d      	adds	r5, r1, r2
			compress(s->iv, s->leftover);
   12b10:	f100 0728 	add.w	r7, r0, #40	; 0x28
	while (datalen-- > 0) {
   12b14:	42a5      	cmp	r5, r4
   12b16:	d0f7      	beq.n	12b08 <tc_sha256_update+0xa>
		s->leftover[s->leftover_offset++] = *(data++);
   12b18:	6e83      	ldr	r3, [r0, #104]	; 0x68
   12b1a:	1c5a      	adds	r2, r3, #1
   12b1c:	6682      	str	r2, [r0, #104]	; 0x68
   12b1e:	f814 1b01 	ldrb.w	r1, [r4], #1
   12b22:	4403      	add	r3, r0
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
   12b24:	2a3f      	cmp	r2, #63	; 0x3f
		s->leftover[s->leftover_offset++] = *(data++);
   12b26:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
   12b2a:	d9f3      	bls.n	12b14 <tc_sha256_update+0x16>
			compress(s->iv, s->leftover);
   12b2c:	4639      	mov	r1, r7
   12b2e:	f7ef fd07 	bl	2540 <compress>
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
   12b32:	e9d0 3208 	ldrd	r3, r2, [r0, #32]
   12b36:	f513 7300 	adds.w	r3, r3, #512	; 0x200
   12b3a:	f142 0200 	adc.w	r2, r2, #0
   12b3e:	e9c0 3208 	strd	r3, r2, [r0, #32]
			s->leftover_offset = 0;
   12b42:	6686      	str	r6, [r0, #104]	; 0x68
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
   12b44:	e7e6      	b.n	12b14 <tc_sha256_update+0x16>
		return TC_CRYPTO_FAIL;
   12b46:	4608      	mov	r0, r1
   12b48:	e7df      	b.n	12b0a <tc_sha256_update+0xc>

00012b4a <tc_sha256_final>:
{
   12b4a:	b570      	push	{r4, r5, r6, lr}
   12b4c:	460c      	mov	r4, r1
	if (digest == (uint8_t *) 0 ||
   12b4e:	4605      	mov	r5, r0
   12b50:	2800      	cmp	r0, #0
   12b52:	d054      	beq.n	12bfe <tc_sha256_final+0xb4>
   12b54:	2900      	cmp	r1, #0
   12b56:	d053      	beq.n	12c00 <tc_sha256_final+0xb6>
	s->bits_hashed += (s->leftover_offset << 3);
   12b58:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
   12b5c:	6e89      	ldr	r1, [r1, #104]	; 0x68
   12b5e:	f104 0628 	add.w	r6, r4, #40	; 0x28
   12b62:	00c8      	lsls	r0, r1, #3
   12b64:	1812      	adds	r2, r2, r0
   12b66:	f143 0300 	adc.w	r3, r3, #0
   12b6a:	e9c4 2308 	strd	r2, r3, [r4, #32]
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
   12b6e:	2380      	movs	r3, #128	; 0x80
   12b70:	1c48      	adds	r0, r1, #1
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
   12b72:	2838      	cmp	r0, #56	; 0x38
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
   12b74:	4421      	add	r1, r4
   12b76:	66a0      	str	r0, [r4, #104]	; 0x68
   12b78:	f881 3028 	strb.w	r3, [r1, #40]	; 0x28
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
   12b7c:	d90b      	bls.n	12b96 <tc_sha256_final+0x4c>
		_set(s->leftover + s->leftover_offset, 0x00,
   12b7e:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   12b82:	2100      	movs	r1, #0
   12b84:	4430      	add	r0, r6
   12b86:	f7ff fdf1 	bl	1276c <_set>
		compress(s->iv, s->leftover);
   12b8a:	4631      	mov	r1, r6
   12b8c:	4620      	mov	r0, r4
   12b8e:	f7ef fcd7 	bl	2540 <compress>
		s->leftover_offset = 0;
   12b92:	2300      	movs	r3, #0
   12b94:	66a3      	str	r3, [r4, #104]	; 0x68
	_set(s->leftover + s->leftover_offset, 0x00,
   12b96:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   12b98:	2100      	movs	r1, #0
   12b9a:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   12b9e:	4430      	add	r0, r6
   12ba0:	f7ff fde4 	bl	1276c <_set>
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
   12ba4:	6a23      	ldr	r3, [r4, #32]
	compress(s->iv, s->leftover);
   12ba6:	4631      	mov	r1, r6
   12ba8:	ba1a      	rev	r2, r3
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
   12baa:	6a63      	ldr	r3, [r4, #36]	; 0x24
	s->leftover[sizeof(s->leftover) - 4] = (uint8_t)(s->bits_hashed >> 24);
   12bac:	6662      	str	r2, [r4, #100]	; 0x64
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
   12bae:	0a1a      	lsrs	r2, r3, #8
	s->leftover[sizeof(s->leftover) - 5] = (uint8_t)(s->bits_hashed >> 32);
   12bb0:	f884 3063 	strb.w	r3, [r4, #99]	; 0x63
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
   12bb4:	f884 2062 	strb.w	r2, [r4, #98]	; 0x62
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
   12bb8:	0c1a      	lsrs	r2, r3, #16
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
   12bba:	0e1b      	lsrs	r3, r3, #24
	compress(s->iv, s->leftover);
   12bbc:	4620      	mov	r0, r4
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
   12bbe:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
   12bc2:	f884 2061 	strb.w	r2, [r4, #97]	; 0x61
	compress(s->iv, s->leftover);
   12bc6:	f7ef fcbb 	bl	2540 <compress>
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
   12bca:	1f26      	subs	r6, r4, #4
   12bcc:	1d2b      	adds	r3, r5, #4
   12bce:	f105 0024 	add.w	r0, r5, #36	; 0x24
		unsigned int t = *((unsigned int *) &s->iv[i]);
   12bd2:	f856 2f04 	ldr.w	r2, [r6, #4]!
		*digest++ = (uint8_t)(t >> 24);
   12bd6:	3304      	adds	r3, #4
   12bd8:	0e11      	lsrs	r1, r2, #24
   12bda:	f803 1c08 	strb.w	r1, [r3, #-8]
		*digest++ = (uint8_t)(t >> 16);
   12bde:	0c11      	lsrs	r1, r2, #16
   12be0:	f803 1c07 	strb.w	r1, [r3, #-7]
		*digest++ = (uint8_t)(t >> 8);
   12be4:	0a11      	lsrs	r1, r2, #8
   12be6:	f803 1c06 	strb.w	r1, [r3, #-6]
		*digest++ = (uint8_t)(t);
   12bea:	f803 2c05 	strb.w	r2, [r3, #-5]
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
   12bee:	4283      	cmp	r3, r0
   12bf0:	d1ef      	bne.n	12bd2 <tc_sha256_final+0x88>
	_set(s, 0, sizeof(*s));
   12bf2:	4620      	mov	r0, r4
   12bf4:	2270      	movs	r2, #112	; 0x70
   12bf6:	2100      	movs	r1, #0
   12bf8:	f7ff fdb8 	bl	1276c <_set>
	return TC_CRYPTO_SUCCESS;
   12bfc:	2001      	movs	r0, #1
}
   12bfe:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   12c00:	4608      	mov	r0, r1
   12c02:	e7fc      	b.n	12bfe <tc_sha256_final+0xb4>

00012c04 <rekey>:
#include <tinycrypt/hmac.h>
#include <tinycrypt/constants.h>
#include <tinycrypt/utils.h>

static void rekey(uint8_t *key, const uint8_t *new_key, unsigned int key_size)
{
   12c04:	b530      	push	{r4, r5, lr}
   12c06:	1e43      	subs	r3, r0, #1
   12c08:	188d      	adds	r5, r1, r2
	const uint8_t inner_pad = (uint8_t) 0x36;
	const uint8_t outer_pad = (uint8_t) 0x5c;
	unsigned int i;

	for (i = 0; i < key_size; ++i) {
   12c0a:	42a9      	cmp	r1, r5
   12c0c:	d106      	bne.n	12c1c <rekey+0x18>
		key[i] = inner_pad ^ new_key[i];
		key[i + TC_SHA256_BLOCK_SIZE] = outer_pad ^ new_key[i];
	}
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
		key[i] = inner_pad; key[i + TC_SHA256_BLOCK_SIZE] = outer_pad;
   12c0e:	2136      	movs	r1, #54	; 0x36
   12c10:	245c      	movs	r4, #92	; 0x5c
   12c12:	4402      	add	r2, r0
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
   12c14:	1a13      	subs	r3, r2, r0
   12c16:	2b3f      	cmp	r3, #63	; 0x3f
   12c18:	d90c      	bls.n	12c34 <rekey+0x30>
	}
}
   12c1a:	bd30      	pop	{r4, r5, pc}
		key[i] = inner_pad ^ new_key[i];
   12c1c:	780c      	ldrb	r4, [r1, #0]
   12c1e:	f084 0436 	eor.w	r4, r4, #54	; 0x36
   12c22:	f803 4f01 	strb.w	r4, [r3, #1]!
		key[i + TC_SHA256_BLOCK_SIZE] = outer_pad ^ new_key[i];
   12c26:	f811 4b01 	ldrb.w	r4, [r1], #1
   12c2a:	f084 045c 	eor.w	r4, r4, #92	; 0x5c
   12c2e:	f883 4040 	strb.w	r4, [r3, #64]	; 0x40
	for (i = 0; i < key_size; ++i) {
   12c32:	e7ea      	b.n	12c0a <rekey+0x6>
		key[i] = inner_pad; key[i + TC_SHA256_BLOCK_SIZE] = outer_pad;
   12c34:	f802 1b01 	strb.w	r1, [r2], #1
   12c38:	f882 403f 	strb.w	r4, [r2, #63]	; 0x3f
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
   12c3c:	e7ea      	b.n	12c14 <rekey+0x10>

00012c3e <tc_hmac_set_key>:

int tc_hmac_set_key(TCHmacState_t ctx, const uint8_t *key,
		    unsigned int key_size)
{
   12c3e:	b5f0      	push	{r4, r5, r6, r7, lr}
   12c40:	460e      	mov	r6, r1
   12c42:	4614      	mov	r4, r2
	/* Input sanity check */
	if (ctx == (TCHmacState_t) 0 ||
   12c44:	4605      	mov	r5, r0
{
   12c46:	b0cd      	sub	sp, #308	; 0x134
	if (ctx == (TCHmacState_t) 0 ||
   12c48:	b1b8      	cbz	r0, 12c7a <tc_hmac_set_key+0x3c>
   12c4a:	b341      	cbz	r1, 12c9e <tc_hmac_set_key+0x60>
	    key == (const uint8_t *) 0 ||
   12c4c:	b34a      	cbz	r2, 12ca2 <tc_hmac_set_key+0x64>
	}

	const uint8_t dummy_key[TC_SHA256_BLOCK_SIZE];
	struct tc_hmac_state_struct dummy_state;

	if (key_size <= TC_SHA256_BLOCK_SIZE) {
   12c4e:	2a40      	cmp	r2, #64	; 0x40
   12c50:	f100 0770 	add.w	r7, r0, #112	; 0x70
   12c54:	d813      	bhi.n	12c7e <tc_hmac_set_key+0x40>
		 * certain timing attacks. Without these dummy calls,
		 * adversaries would be able to learn whether the key_size is
		 * greater than TC_SHA256_BLOCK_SIZE by measuring the time
		 * consumed in this process.
		 */
		(void)tc_sha256_init(&dummy_state.hash_state);
   12c56:	a810      	add	r0, sp, #64	; 0x40
   12c58:	f7ef fd58 	bl	270c <tc_sha256_init>
		(void)tc_sha256_update(&dummy_state.hash_state,
   12c5c:	4622      	mov	r2, r4
   12c5e:	4669      	mov	r1, sp
   12c60:	a810      	add	r0, sp, #64	; 0x40
   12c62:	f7ff ff4c 	bl	12afe <tc_sha256_update>
				       dummy_key,
				       key_size);
		(void)tc_sha256_final(&dummy_state.key[TC_SHA256_DIGEST_SIZE],
   12c66:	a910      	add	r1, sp, #64	; 0x40
   12c68:	a834      	add	r0, sp, #208	; 0xd0
   12c6a:	f7ff ff6e 	bl	12b4a <tc_sha256_final>
				      &dummy_state.hash_state);

		/* Actual code for when key_size <= TC_SHA256_BLOCK_SIZE: */
		rekey(ctx->key, key, key_size);
   12c6e:	4622      	mov	r2, r4
   12c70:	4631      	mov	r1, r6
	} else {
		(void)tc_sha256_init(&ctx->hash_state);
		(void)tc_sha256_update(&ctx->hash_state, key, key_size);
		(void)tc_sha256_final(&ctx->key[TC_SHA256_DIGEST_SIZE],
				      &ctx->hash_state);
		rekey(ctx->key,
   12c72:	4638      	mov	r0, r7
   12c74:	f7ff ffc6 	bl	12c04 <rekey>
		      &ctx->key[TC_SHA256_DIGEST_SIZE],
		      TC_SHA256_DIGEST_SIZE);
	}

	return TC_CRYPTO_SUCCESS;
   12c78:	2001      	movs	r0, #1
}
   12c7a:	b04d      	add	sp, #308	; 0x134
   12c7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		(void)tc_sha256_init(&ctx->hash_state);
   12c7e:	f7ef fd45 	bl	270c <tc_sha256_init>
		(void)tc_sha256_update(&ctx->hash_state, key, key_size);
   12c82:	4622      	mov	r2, r4
   12c84:	4631      	mov	r1, r6
		(void)tc_sha256_final(&ctx->key[TC_SHA256_DIGEST_SIZE],
   12c86:	f105 0490 	add.w	r4, r5, #144	; 0x90
		(void)tc_sha256_update(&ctx->hash_state, key, key_size);
   12c8a:	4628      	mov	r0, r5
   12c8c:	f7ff ff37 	bl	12afe <tc_sha256_update>
		(void)tc_sha256_final(&ctx->key[TC_SHA256_DIGEST_SIZE],
   12c90:	4629      	mov	r1, r5
   12c92:	4620      	mov	r0, r4
   12c94:	f7ff ff59 	bl	12b4a <tc_sha256_final>
		rekey(ctx->key,
   12c98:	2220      	movs	r2, #32
   12c9a:	4621      	mov	r1, r4
   12c9c:	e7e9      	b.n	12c72 <tc_hmac_set_key+0x34>
		return TC_CRYPTO_FAIL;
   12c9e:	4608      	mov	r0, r1
   12ca0:	e7eb      	b.n	12c7a <tc_hmac_set_key+0x3c>
   12ca2:	4610      	mov	r0, r2
   12ca4:	e7e9      	b.n	12c7a <tc_hmac_set_key+0x3c>

00012ca6 <tc_hmac_init>:

int tc_hmac_init(TCHmacState_t ctx)
{
   12ca6:	b510      	push	{r4, lr}

	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
   12ca8:	4604      	mov	r4, r0
   12caa:	b140      	cbz	r0, 12cbe <tc_hmac_init+0x18>
		return TC_CRYPTO_FAIL;
	}

  (void) tc_sha256_init(&ctx->hash_state);
   12cac:	f7ef fd2e 	bl	270c <tc_sha256_init>
  (void) tc_sha256_update(&ctx->hash_state, ctx->key, TC_SHA256_BLOCK_SIZE);
   12cb0:	2240      	movs	r2, #64	; 0x40
   12cb2:	4620      	mov	r0, r4
   12cb4:	f104 0170 	add.w	r1, r4, #112	; 0x70
   12cb8:	f7ff ff21 	bl	12afe <tc_sha256_update>

	return TC_CRYPTO_SUCCESS;
   12cbc:	2001      	movs	r0, #1
}
   12cbe:	bd10      	pop	{r4, pc}

00012cc0 <tc_hmac_update>:

int tc_hmac_update(TCHmacState_t ctx,
		   const void *data,
		   unsigned int data_length)
{
   12cc0:	b508      	push	{r3, lr}

	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
   12cc2:	b110      	cbz	r0, 12cca <tc_hmac_update+0xa>
		return TC_CRYPTO_FAIL;
	}

	(void)tc_sha256_update(&ctx->hash_state, data, data_length);
   12cc4:	f7ff ff1b 	bl	12afe <tc_sha256_update>

	return TC_CRYPTO_SUCCESS;
   12cc8:	2001      	movs	r0, #1
}
   12cca:	bd08      	pop	{r3, pc}

00012ccc <tc_hmac_final>:

int tc_hmac_final(uint8_t *tag, unsigned int taglen, TCHmacState_t ctx)
{
   12ccc:	b570      	push	{r4, r5, r6, lr}
   12cce:	460e      	mov	r6, r1
   12cd0:	4614      	mov	r4, r2

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   12cd2:	4605      	mov	r5, r0
   12cd4:	b1f0      	cbz	r0, 12d14 <tc_hmac_final+0x48>
   12cd6:	2920      	cmp	r1, #32
   12cd8:	d11c      	bne.n	12d14 <tc_hmac_final+0x48>
	    taglen != TC_SHA256_DIGEST_SIZE ||
   12cda:	b1ea      	cbz	r2, 12d18 <tc_hmac_final+0x4c>
	    ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	(void) tc_sha256_final(tag, &ctx->hash_state);
   12cdc:	4611      	mov	r1, r2
   12cde:	f7ff ff34 	bl	12b4a <tc_sha256_final>

	(void)tc_sha256_init(&ctx->hash_state);
   12ce2:	4620      	mov	r0, r4
   12ce4:	f7ef fd12 	bl	270c <tc_sha256_init>
	(void)tc_sha256_update(&ctx->hash_state,
   12ce8:	2240      	movs	r2, #64	; 0x40
   12cea:	f104 01b0 	add.w	r1, r4, #176	; 0xb0
   12cee:	4620      	mov	r0, r4
   12cf0:	f7ff ff05 	bl	12afe <tc_sha256_update>
			       &ctx->key[TC_SHA256_BLOCK_SIZE],
				TC_SHA256_BLOCK_SIZE);
	(void)tc_sha256_update(&ctx->hash_state, tag, TC_SHA256_DIGEST_SIZE);
   12cf4:	4632      	mov	r2, r6
   12cf6:	4629      	mov	r1, r5
   12cf8:	4620      	mov	r0, r4
   12cfa:	f7ff ff00 	bl	12afe <tc_sha256_update>
	(void)tc_sha256_final(tag, &ctx->hash_state);
   12cfe:	4621      	mov	r1, r4
   12d00:	4628      	mov	r0, r5
   12d02:	f7ff ff22 	bl	12b4a <tc_sha256_final>

	/* destroy the current state */
	_set(ctx, 0, sizeof(*ctx));
   12d06:	4620      	mov	r0, r4
   12d08:	22f0      	movs	r2, #240	; 0xf0
   12d0a:	2100      	movs	r1, #0
   12d0c:	f7ff fd2e 	bl	1276c <_set>

	return TC_CRYPTO_SUCCESS;
   12d10:	2001      	movs	r0, #1
}
   12d12:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   12d14:	2000      	movs	r0, #0
   12d16:	e7fc      	b.n	12d12 <tc_hmac_final+0x46>
   12d18:	4610      	mov	r0, r2
   12d1a:	e7fa      	b.n	12d12 <tc_hmac_final+0x46>

00012d1c <update>:

/*
 * Assumes: prng != NULL
 */
static void update(TCHmacPrng_t prng, const uint8_t *data, unsigned int datalen, const uint8_t *additional_data, unsigned int additional_datalen)
{
   12d1c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12d20:	4604      	mov	r4, r0
	const uint8_t separator0 = 0x00;
	const uint8_t separator1 = 0x01;
   12d22:	f04f 0b01 	mov.w	fp, #1
{
   12d26:	461f      	mov	r7, r3
	const uint8_t separator0 = 0x00;
   12d28:	2300      	movs	r3, #0
{
   12d2a:	4688      	mov	r8, r1

	/* configure the new prng key into the prng's instance of hmac */
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   12d2c:	f100 06f0 	add.w	r6, r0, #240	; 0xf0
   12d30:	4631      	mov	r1, r6
{
   12d32:	4691      	mov	r9, r2
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   12d34:	2220      	movs	r2, #32
	const uint8_t separator0 = 0x00;
   12d36:	f88d 3006 	strb.w	r3, [sp, #6]
{
   12d3a:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
	const uint8_t separator1 = 0x01;
   12d3e:	f88d b007 	strb.w	fp, [sp, #7]

	/* use current state, e and separator 0 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   12d42:	f504 7588 	add.w	r5, r4, #272	; 0x110
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   12d46:	f7ff ff7a 	bl	12c3e <tc_hmac_set_key>
	(void)tc_hmac_init(&prng->h);
   12d4a:	4620      	mov	r0, r4
   12d4c:	f7ff ffab 	bl	12ca6 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   12d50:	2220      	movs	r2, #32
   12d52:	4629      	mov	r1, r5
   12d54:	4620      	mov	r0, r4
   12d56:	f7ff ffb3 	bl	12cc0 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, &separator0, sizeof(separator0));
   12d5a:	465a      	mov	r2, fp
   12d5c:	4620      	mov	r0, r4
   12d5e:	f10d 0106 	add.w	r1, sp, #6
   12d62:	f7ff ffad 	bl	12cc0 <tc_hmac_update>

	if (data && datalen)
   12d66:	f1b8 0f00 	cmp.w	r8, #0
   12d6a:	d007      	beq.n	12d7c <update+0x60>
   12d6c:	f1b9 0f00 	cmp.w	r9, #0
   12d70:	d004      	beq.n	12d7c <update+0x60>
		(void)tc_hmac_update(&prng->h, data, datalen);
   12d72:	464a      	mov	r2, r9
   12d74:	4641      	mov	r1, r8
   12d76:	4620      	mov	r0, r4
   12d78:	f7ff ffa2 	bl	12cc0 <tc_hmac_update>
	if (additional_data && additional_datalen)
   12d7c:	b13f      	cbz	r7, 12d8e <update+0x72>
   12d7e:	f1ba 0f00 	cmp.w	sl, #0
   12d82:	d004      	beq.n	12d8e <update+0x72>
		(void)tc_hmac_update(&prng->h, additional_data, additional_datalen);
   12d84:	4652      	mov	r2, sl
   12d86:	4639      	mov	r1, r7
   12d88:	4620      	mov	r0, r4
   12d8a:	f7ff ff99 	bl	12cc0 <tc_hmac_update>

	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
   12d8e:	4622      	mov	r2, r4
   12d90:	2120      	movs	r1, #32
   12d92:	4630      	mov	r0, r6
   12d94:	f7ff ff9a 	bl	12ccc <tc_hmac_final>

	/* configure the new prng key into the prng's instance of hmac */
	(void)tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   12d98:	2220      	movs	r2, #32
   12d9a:	4631      	mov	r1, r6
   12d9c:	4620      	mov	r0, r4
   12d9e:	f7ff ff4e 	bl	12c3e <tc_hmac_set_key>

	/* use the new key to compute a new state variable v */
	(void)tc_hmac_init(&prng->h);
   12da2:	4620      	mov	r0, r4
   12da4:	f7ff ff7f 	bl	12ca6 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   12da8:	2220      	movs	r2, #32
   12daa:	4629      	mov	r1, r5
   12dac:	4620      	mov	r0, r4
   12dae:	f7ff ff87 	bl	12cc0 <tc_hmac_update>
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
   12db2:	4622      	mov	r2, r4
   12db4:	2120      	movs	r1, #32
   12db6:	4628      	mov	r0, r5
   12db8:	f7ff ff88 	bl	12ccc <tc_hmac_final>

	if (data == 0 || datalen == 0)
   12dbc:	f1b8 0f00 	cmp.w	r8, #0
   12dc0:	d03a      	beq.n	12e38 <update+0x11c>
   12dc2:	f1b9 0f00 	cmp.w	r9, #0
   12dc6:	d037      	beq.n	12e38 <update+0x11c>
		return;

	/* configure the new prng key into the prng's instance of hmac */
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   12dc8:	2220      	movs	r2, #32
   12dca:	4631      	mov	r1, r6
   12dcc:	4620      	mov	r0, r4
   12dce:	f7ff ff36 	bl	12c3e <tc_hmac_set_key>

	/* use current state, e and separator 1 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
   12dd2:	4620      	mov	r0, r4
   12dd4:	f7ff ff67 	bl	12ca6 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   12dd8:	2220      	movs	r2, #32
   12dda:	4629      	mov	r1, r5
   12ddc:	4620      	mov	r0, r4
   12dde:	f7ff ff6f 	bl	12cc0 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, &separator1, sizeof(separator1));
   12de2:	2201      	movs	r2, #1
   12de4:	f10d 0107 	add.w	r1, sp, #7
   12de8:	4620      	mov	r0, r4
   12dea:	f7ff ff69 	bl	12cc0 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, data, datalen);
   12dee:	464a      	mov	r2, r9
   12df0:	4641      	mov	r1, r8
   12df2:	4620      	mov	r0, r4
   12df4:	f7ff ff64 	bl	12cc0 <tc_hmac_update>
	if (additional_data && additional_datalen)
   12df8:	b13f      	cbz	r7, 12e0a <update+0xee>
   12dfa:	f1ba 0f00 	cmp.w	sl, #0
   12dfe:	d004      	beq.n	12e0a <update+0xee>
		(void)tc_hmac_update(&prng->h, additional_data, additional_datalen);
   12e00:	4652      	mov	r2, sl
   12e02:	4639      	mov	r1, r7
   12e04:	4620      	mov	r0, r4
   12e06:	f7ff ff5b 	bl	12cc0 <tc_hmac_update>
	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
   12e0a:	4622      	mov	r2, r4
   12e0c:	2120      	movs	r1, #32
   12e0e:	4630      	mov	r0, r6
   12e10:	f7ff ff5c 	bl	12ccc <tc_hmac_final>

	/* configure the new prng key into the prng's instance of hmac */
	(void)tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   12e14:	2220      	movs	r2, #32
   12e16:	4631      	mov	r1, r6
   12e18:	4620      	mov	r0, r4
   12e1a:	f7ff ff10 	bl	12c3e <tc_hmac_set_key>

	/* use the new key to compute a new state variable v */
	(void)tc_hmac_init(&prng->h);
   12e1e:	4620      	mov	r0, r4
   12e20:	f7ff ff41 	bl	12ca6 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   12e24:	2220      	movs	r2, #32
   12e26:	4629      	mov	r1, r5
   12e28:	4620      	mov	r0, r4
   12e2a:	f7ff ff49 	bl	12cc0 <tc_hmac_update>
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
   12e2e:	4622      	mov	r2, r4
   12e30:	2120      	movs	r1, #32
   12e32:	4628      	mov	r0, r5
   12e34:	f7ff ff4a 	bl	12ccc <tc_hmac_final>
}
   12e38:	b003      	add	sp, #12
   12e3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00012e3e <tc_hmac_prng_init>:

int tc_hmac_prng_init(TCHmacPrng_t prng,
		      const uint8_t *personalization,
		      unsigned int plen)
{
   12e3e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12e40:	460c      	mov	r4, r1
   12e42:	4617      	mov	r7, r2

	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
   12e44:	4605      	mov	r5, r0
   12e46:	b1b0      	cbz	r0, 12e76 <tc_hmac_prng_init+0x38>
	    personalization == (uint8_t *) 0 ||
   12e48:	b1b9      	cbz	r1, 12e7a <tc_hmac_prng_init+0x3c>

	/* put the generator into a known state: */
	_set(prng->key, 0x00, sizeof(prng->key));
	_set(prng->v, 0x01, sizeof(prng->v));

	update(prng, personalization, plen, 0, 0);
   12e4a:	2600      	movs	r6, #0
	_set(prng->key, 0x00, sizeof(prng->key));
   12e4c:	2220      	movs	r2, #32
   12e4e:	2100      	movs	r1, #0
   12e50:	30f0      	adds	r0, #240	; 0xf0
   12e52:	f7ff fc8b 	bl	1276c <_set>
	_set(prng->v, 0x01, sizeof(prng->v));
   12e56:	2220      	movs	r2, #32
   12e58:	2101      	movs	r1, #1
   12e5a:	f505 7088 	add.w	r0, r5, #272	; 0x110
   12e5e:	f7ff fc85 	bl	1276c <_set>
	update(prng, personalization, plen, 0, 0);
   12e62:	4628      	mov	r0, r5
   12e64:	4633      	mov	r3, r6
   12e66:	463a      	mov	r2, r7
   12e68:	4621      	mov	r1, r4
   12e6a:	9600      	str	r6, [sp, #0]
   12e6c:	f7ff ff56 	bl	12d1c <update>

	/* force a reseed before allowing tc_hmac_prng_generate to succeed: */
	prng->countdown = 0;

	return TC_CRYPTO_SUCCESS;
   12e70:	2001      	movs	r0, #1
	prng->countdown = 0;
   12e72:	f8c5 6130 	str.w	r6, [r5, #304]	; 0x130
}
   12e76:	b003      	add	sp, #12
   12e78:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
   12e7a:	4608      	mov	r0, r1
   12e7c:	e7fb      	b.n	12e76 <tc_hmac_prng_init+0x38>

00012e7e <tc_hmac_prng_reseed>:
int tc_hmac_prng_reseed(TCHmacPrng_t prng,
			const uint8_t *seed,
			unsigned int seedlen,
			const uint8_t *additional_input,
			unsigned int additionallen)
{
   12e7e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12e80:	9c08      	ldr	r4, [sp, #32]

	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
   12e82:	4605      	mov	r5, r0
   12e84:	b180      	cbz	r0, 12ea8 <tc_hmac_prng_reseed+0x2a>
   12e86:	b179      	cbz	r1, 12ea8 <tc_hmac_prng_reseed+0x2a>
	    seed == (const uint8_t *) 0 ||
	    seedlen < MIN_SLEN ||
   12e88:	2a1f      	cmp	r2, #31
   12e8a:	d90d      	bls.n	12ea8 <tc_hmac_prng_reseed+0x2a>
	    seedlen > MAX_SLEN) {
		return TC_CRYPTO_FAIL;
	}

	if (additional_input != (const uint8_t *) 0) {
   12e8c:	b153      	cbz	r3, 12ea4 <tc_hmac_prng_reseed+0x26>
		/*
		 * Abort if additional_input is provided but has inappropriate
		 * length
		 */
		if (additionallen == 0 ||
   12e8e:	b16c      	cbz	r4, 12eac <tc_hmac_prng_reseed+0x2e>
		    additionallen > MAX_ALEN) {
			return TC_CRYPTO_FAIL;
		} else {
			/* call update for the seed and additional_input */
			update(prng, seed, seedlen, additional_input, additionallen);
   12e90:	9400      	str	r4, [sp, #0]
		}
	} else {
		/* call update only for the seed */
		update(prng, seed, seedlen, 0, 0);
   12e92:	f7ff ff43 	bl	12d1c <update>
	}

	/* ... and enable hmac_prng_generate */
	prng->countdown = MAX_GENS;
   12e96:	f04f 33ff 	mov.w	r3, #4294967295

	return TC_CRYPTO_SUCCESS;
   12e9a:	2001      	movs	r0, #1
	prng->countdown = MAX_GENS;
   12e9c:	f8c5 3130 	str.w	r3, [r5, #304]	; 0x130
}
   12ea0:	b003      	add	sp, #12
   12ea2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		update(prng, seed, seedlen, 0, 0);
   12ea4:	9300      	str	r3, [sp, #0]
   12ea6:	e7f4      	b.n	12e92 <tc_hmac_prng_reseed+0x14>
		return TC_CRYPTO_FAIL;
   12ea8:	2000      	movs	r0, #0
   12eaa:	e7f9      	b.n	12ea0 <tc_hmac_prng_reseed+0x22>
   12eac:	4620      	mov	r0, r4
   12eae:	e7f7      	b.n	12ea0 <tc_hmac_prng_reseed+0x22>

00012eb0 <tc_hmac_prng_generate>:

int tc_hmac_prng_generate(uint8_t *out, unsigned int outlen, TCHmacPrng_t prng)
{
   12eb0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   12eb4:	460d      	mov	r5, r1
   12eb6:	4614      	mov	r4, r2
	unsigned int bufferlen;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
   12eb8:	4680      	mov	r8, r0
   12eba:	b3d8      	cbz	r0, 12f34 <tc_hmac_prng_generate+0x84>
   12ebc:	b3d2      	cbz	r2, 12f34 <tc_hmac_prng_generate+0x84>
	    prng == (TCHmacPrng_t) 0 ||
   12ebe:	1e4b      	subs	r3, r1, #1
   12ec0:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
   12ec4:	d236      	bcs.n	12f34 <tc_hmac_prng_generate+0x84>
	    outlen == 0 ||
	    outlen > MAX_OUT) {
		return TC_CRYPTO_FAIL;
	} else if (prng->countdown == 0) {
   12ec6:	f8d2 3130 	ldr.w	r3, [r2, #304]	; 0x130
   12eca:	b3ab      	cbz	r3, 12f38 <tc_hmac_prng_generate+0x88>
		return TC_HMAC_PRNG_RESEED_REQ;
	}

	prng->countdown--;
   12ecc:	3b01      	subs	r3, #1
   12ece:	f8c2 3130 	str.w	r3, [r2, #304]	; 0x130

	while (outlen != 0) {
		/* configure the new prng key into the prng's instance of hmac */
		tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   12ed2:	f102 09f0 	add.w	r9, r2, #240	; 0xf0

		/* operate HMAC in OFB mode to create "random" outputs */
		(void)tc_hmac_init(&prng->h);
		(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   12ed6:	f502 7788 	add.w	r7, r2, #272	; 0x110
		tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   12eda:	2220      	movs	r2, #32
   12edc:	4649      	mov	r1, r9
   12ede:	4620      	mov	r0, r4
   12ee0:	f7ff fead 	bl	12c3e <tc_hmac_set_key>
		(void)tc_hmac_init(&prng->h);
   12ee4:	4620      	mov	r0, r4
   12ee6:	f7ff fede 	bl	12ca6 <tc_hmac_init>
		(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   12eea:	2220      	movs	r2, #32
   12eec:	4639      	mov	r1, r7
   12eee:	4620      	mov	r0, r4
   12ef0:	f7ff fee6 	bl	12cc0 <tc_hmac_update>
		(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
   12ef4:	4622      	mov	r2, r4
   12ef6:	2120      	movs	r1, #32
   12ef8:	4638      	mov	r0, r7
   12efa:	f7ff fee7 	bl	12ccc <tc_hmac_final>

		bufferlen = (TC_SHA256_DIGEST_SIZE > outlen) ?
   12efe:	2d20      	cmp	r5, #32
   12f00:	462e      	mov	r6, r5
   12f02:	bf28      	it	cs
   12f04:	2620      	movcs	r6, #32
			outlen : TC_SHA256_DIGEST_SIZE;
		(void)_copy(out, bufferlen, prng->v, bufferlen);
   12f06:	4640      	mov	r0, r8
   12f08:	4633      	mov	r3, r6
   12f0a:	463a      	mov	r2, r7
   12f0c:	4631      	mov	r1, r6
   12f0e:	f7ff fc20 	bl	12752 <_copy>

		out += bufferlen;
		outlen = (outlen > TC_SHA256_DIGEST_SIZE) ?
			(outlen - TC_SHA256_DIGEST_SIZE) : 0;
   12f12:	2d20      	cmp	r5, #32
   12f14:	bf38      	it	cc
   12f16:	2520      	movcc	r5, #32
	while (outlen != 0) {
   12f18:	3d20      	subs	r5, #32
		out += bufferlen;
   12f1a:	44b0      	add	r8, r6
	while (outlen != 0) {
   12f1c:	d1dd      	bne.n	12eda <tc_hmac_prng_generate+0x2a>
	}

	/* block future PRNG compromises from revealing past state */
	update(prng, 0, 0, 0, 0);
   12f1e:	4620      	mov	r0, r4
   12f20:	462b      	mov	r3, r5
   12f22:	462a      	mov	r2, r5
   12f24:	4629      	mov	r1, r5
   12f26:	9500      	str	r5, [sp, #0]
   12f28:	f7ff fef8 	bl	12d1c <update>

	return TC_CRYPTO_SUCCESS;
   12f2c:	2001      	movs	r0, #1
}
   12f2e:	b003      	add	sp, #12
   12f30:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return TC_CRYPTO_FAIL;
   12f34:	2000      	movs	r0, #0
   12f36:	e7fa      	b.n	12f2e <tc_hmac_prng_generate+0x7e>
		return TC_HMAC_PRNG_RESEED_REQ;
   12f38:	f04f 30ff 	mov.w	r0, #4294967295
   12f3c:	e7f7      	b.n	12f2e <tc_hmac_prng_generate+0x7e>

00012f3e <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   12f3e:	2100      	movs	r1, #0
   12f40:	2001      	movs	r0, #1
   12f42:	f000 b804 	b.w	12f4e <z_arm_fatal_error>

00012f46 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   12f46:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
   12f48:	f383 880b 	msr	PSPLIM, r3
}
   12f4c:	4770      	bx	lr

00012f4e <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   12f4e:	f009 bfe7 	b.w	1cf20 <z_fatal_error>

00012f52 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   12f52:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
   12f54:	6800      	ldr	r0, [r0, #0]
   12f56:	f009 bfe3 	b.w	1cf20 <z_fatal_error>

00012f5a <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   12f5a:	b508      	push	{r3, lr}
	handler();
   12f5c:	f7ef fd04 	bl	2968 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   12f60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   12f64:	f7ef bd46 	b.w	29f4 <z_arm_exc_exit>

00012f68 <mpu_configure_region>:
{
   12f68:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	p_attr->rbar = attr->rbar &
   12f6a:	890a      	ldrh	r2, [r1, #8]
   12f6c:	7a8e      	ldrb	r6, [r1, #10]
	region_conf.base = new_region->start;
   12f6e:	680b      	ldr	r3, [r1, #0]
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   12f70:	684d      	ldr	r5, [r1, #4]
   12f72:	f002 021f 	and.w	r2, r2, #31
   12f76:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
	region_conf.base = new_region->start;
   12f7a:	9300      	str	r3, [sp, #0]
   12f7c:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   12f80:	f023 031f 	bic.w	r3, r3, #31
   12f84:	1e6a      	subs	r2, r5, #1
   12f86:	4413      	add	r3, r2
   12f88:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
   12f8c:	2807      	cmp	r0, #7
   12f8e:	9303      	str	r3, [sp, #12]
   12f90:	d804      	bhi.n	12f9c <mpu_configure_region+0x34>
	region_init(index, region_conf);
   12f92:	4669      	mov	r1, sp
   12f94:	f7ef fe74 	bl	2c80 <region_init>
}
   12f98:	b004      	add	sp, #16
   12f9a:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   12f9c:	f06f 0015 	mvn.w	r0, #21
	return region_allocate_and_init(index,
   12fa0:	e7fa      	b.n	12f98 <mpu_configure_region+0x30>

00012fa2 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   12fa2:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   12fa6:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   12faa:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   12fac:	bf08      	it	eq
   12fae:	f06f 0015 	mvneq.w	r0, #21
   12fb2:	4770      	bx	lr

00012fb4 <_stdout_hook_default>:
}
   12fb4:	f04f 30ff 	mov.w	r0, #4294967295
   12fb8:	4770      	bx	lr

00012fba <display_get_capabilities>:
   12fba:	6883      	ldr	r3, [r0, #8]
   12fbc:	69db      	ldr	r3, [r3, #28]
   12fbe:	4718      	bx	r3

00012fc0 <lvgl_flush_cb_mono>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_mono(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
   12fc0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12fc4:	4690      	mov	r8, r2
   12fc6:	460c      	mov	r4, r1
	uint16_t w = area->x2 - area->x1 + 1;
   12fc8:	888d      	ldrh	r5, [r1, #4]
   12fca:	880b      	ldrh	r3, [r1, #0]
	uint16_t h = area->y2 - area->y1 + 1;
   12fcc:	88ce      	ldrh	r6, [r1, #6]
	uint16_t w = area->x2 - area->x1 + 1;
   12fce:	3501      	adds	r5, #1
   12fd0:	1aed      	subs	r5, r5, r3
	uint16_t h = area->y2 - area->y1 + 1;
   12fd2:	884b      	ldrh	r3, [r1, #2]
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
   12fd4:	f8d0 902c 	ldr.w	r9, [r0, #44]	; 0x2c
	uint16_t h = area->y2 - area->y1 + 1;
   12fd8:	3601      	adds	r6, #1
{
   12fda:	b08b      	sub	sp, #44	; 0x2c
	uint16_t h = area->y2 - area->y1 + 1;
   12fdc:	1af6      	subs	r6, r6, r3
	uint16_t w = area->x2 - area->x1 + 1;
   12fde:	b2ad      	uxth	r5, r5
	uint16_t h = area->y2 - area->y1 + 1;
   12fe0:	b2b6      	uxth	r6, r6
	struct display_capabilities cap;
	struct display_buffer_descriptor desc;

	display_get_capabilities(display_dev, &cap);
   12fe2:	a906      	add	r1, sp, #24
{
   12fe4:	4607      	mov	r7, r0
	display_get_capabilities(display_dev, &cap);
   12fe6:	4648      	mov	r0, r9
   12fe8:	f7ff ffe7 	bl	12fba <display_get_capabilities>

	desc.buf_size = (w * h)/8U;
   12fec:	fb06 f305 	mul.w	r3, r6, r5
   12ff0:	08db      	lsrs	r3, r3, #3
   12ff2:	9303      	str	r3, [sp, #12]
	return api->write(dev, x, y, desc, buf);
   12ff4:	f8d9 3008 	ldr.w	r3, [r9, #8]
   12ff8:	f8cd 8000 	str.w	r8, [sp]
	desc.width = w;
   12ffc:	f8ad 5010 	strh.w	r5, [sp, #16]
	desc.pitch = w;
   13000:	f8ad 5014 	strh.w	r5, [sp, #20]
   13004:	4648      	mov	r0, r9
   13006:	689d      	ldr	r5, [r3, #8]
   13008:	8862      	ldrh	r2, [r4, #2]
   1300a:	ab03      	add	r3, sp, #12
   1300c:	8821      	ldrh	r1, [r4, #0]
	desc.height = h;
   1300e:	f8ad 6012 	strh.w	r6, [sp, #18]
   13012:	47a8      	blx	r5
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);
	if (cap.screen_info & SCREEN_INFO_DOUBLE_BUFFER) {
   13014:	9b08      	ldr	r3, [sp, #32]
   13016:	071b      	lsls	r3, r3, #28
   13018:	d509      	bpl.n	1302e <lvgl_flush_cb_mono+0x6e>
   1301a:	f8d9 3008 	ldr.w	r3, [r9, #8]
   1301e:	f8cd 8000 	str.w	r8, [sp]
   13022:	689d      	ldr	r5, [r3, #8]
   13024:	4648      	mov	r0, r9
   13026:	8862      	ldrh	r2, [r4, #2]
   13028:	8821      	ldrh	r1, [r4, #0]
   1302a:	ab03      	add	r3, sp, #12
   1302c:	47a8      	blx	r5
		display_write(display_dev, area->x1, area->y1, &desc,
				(void *) color_p);
	}

	lv_disp_flush_ready(disp_drv);
   1302e:	4638      	mov	r0, r7
   13030:	f007 fd43 	bl	1aaba <lv_disp_flush_ready>
}
   13034:	b00b      	add	sp, #44	; 0x2c
   13036:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0001303a <lvgl_set_px_cb_mono>:


void lvgl_set_px_cb_mono(struct _disp_drv_t *disp_drv,
		uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
   1303a:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	uint8_t *buf_xy;
	uint8_t bit;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
   1303e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
{
   13040:	460f      	mov	r7, r1
	display_get_capabilities(display_dev, &cap);
   13042:	4669      	mov	r1, sp
{
   13044:	4690      	mov	r8, r2
   13046:	461c      	mov	r4, r3
   13048:	f9bd 6028 	ldrsh.w	r6, [sp, #40]	; 0x28
   1304c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
	display_get_capabilities(display_dev, &cap);
   1304e:	f7ff ffb4 	bl	12fba <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
   13052:	9802      	ldr	r0, [sp, #8]
   13054:	f010 0f01 	tst.w	r0, #1
   13058:	f000 0002 	and.w	r0, r0, #2
   1305c:	d020      	beq.n	130a0 <lvgl_set_px_cb_mono+0x66>
		buf_xy = buf + x + y/8 * buf_w;
   1305e:	4633      	mov	r3, r6
   13060:	2e00      	cmp	r6, #0
   13062:	bfb8      	it	lt
   13064:	1df3      	addlt	r3, r6, #7
   13066:	10d9      	asrs	r1, r3, #3
   13068:	fb11 4408 	smlabb	r4, r1, r8, r4
   1306c:	4273      	negs	r3, r6
   1306e:	eb07 0104 	add.w	r1, r7, r4

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
   13072:	f006 0407 	and.w	r4, r6, #7
   13076:	f003 0307 	and.w	r3, r3, #7
   1307a:	bf58      	it	pl
   1307c:	425c      	negpl	r4, r3
			bit = y%8;
		}
	} else {
		buf_xy = buf + x/8 + y * buf_w/8;

		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
   1307e:	b108      	cbz	r0, 13084 <lvgl_set_px_cb_mono+0x4a>
			bit = 7 - x%8;
   13080:	f1c4 0407 	rsb	r4, r4, #7
		} else {
			bit = x%8;
   13084:	2201      	movs	r2, #1
   13086:	b2e4      	uxtb	r4, r4
		}
	}

	if (cap.current_pixel_format == PIXEL_FORMAT_MONO10) {
   13088:	fa02 f404 	lsl.w	r4, r2, r4
   1308c:	f89d 200c 	ldrb.w	r2, [sp, #12]
   13090:	780b      	ldrb	r3, [r1, #0]
   13092:	2a04      	cmp	r2, #4
   13094:	b2e4      	uxtb	r4, r4
   13096:	d114      	bne.n	130c2 <lvgl_set_px_cb_mono+0x88>
		if (color.full == 0) {
   13098:	b9ad      	cbnz	r5, 130c6 <lvgl_set_px_cb_mono+0x8c>
		}
	} else {
		if (color.full == 0) {
			*buf_xy |= BIT(bit);
		} else {
			*buf_xy &= ~BIT(bit);
   1309a:	ea23 0304 	bic.w	r3, r3, r4
   1309e:	e013      	b.n	130c8 <lvgl_set_px_cb_mono+0x8e>
		buf_xy = buf + x/8 + y * buf_w/8;
   130a0:	4643      	mov	r3, r8
   130a2:	4621      	mov	r1, r4
   130a4:	435e      	muls	r6, r3
   130a6:	bf48      	it	mi
   130a8:	3607      	addmi	r6, #7
   130aa:	2c00      	cmp	r4, #0
   130ac:	bfb8      	it	lt
   130ae:	1de1      	addlt	r1, r4, #7
   130b0:	10f6      	asrs	r6, r6, #3
   130b2:	eb06 06e1 	add.w	r6, r6, r1, asr #3
   130b6:	4263      	negs	r3, r4
   130b8:	eb07 0106 	add.w	r1, r7, r6
		if (cap.screen_info & SCREEN_INFO_MONO_MSB_FIRST) {
   130bc:	f004 0407 	and.w	r4, r4, #7
   130c0:	e7d9      	b.n	13076 <lvgl_set_px_cb_mono+0x3c>
		if (color.full == 0) {
   130c2:	2d00      	cmp	r5, #0
   130c4:	d1e9      	bne.n	1309a <lvgl_set_px_cb_mono+0x60>
			*buf_xy |= BIT(bit);
   130c6:	4323      	orrs	r3, r4
			*buf_xy &= ~BIT(bit);
   130c8:	700b      	strb	r3, [r1, #0]
		}
	}
}
   130ca:	b004      	add	sp, #16
   130cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000130d0 <lvgl_rounder_cb_mono>:

void lvgl_rounder_cb_mono(struct _disp_drv_t *disp_drv,
		lv_area_t *area)
{
   130d0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   130d2:	460c      	mov	r4, r1
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	struct display_capabilities cap;

	display_get_capabilities(display_dev, &cap);
   130d4:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   130d6:	4669      	mov	r1, sp
   130d8:	f7ff ff6f 	bl	12fba <display_get_capabilities>

	if (cap.screen_info & SCREEN_INFO_MONO_VTILED) {
   130dc:	9b02      	ldr	r3, [sp, #8]
   130de:	07db      	lsls	r3, r3, #31
   130e0:	d509      	bpl.n	130f6 <lvgl_rounder_cb_mono+0x26>
		area->y1 &= ~0x7;
   130e2:	8863      	ldrh	r3, [r4, #2]
   130e4:	f023 0307 	bic.w	r3, r3, #7
   130e8:	8063      	strh	r3, [r4, #2]
		area->y2 |= 0x7;
   130ea:	88e3      	ldrh	r3, [r4, #6]
   130ec:	f043 0307 	orr.w	r3, r3, #7
   130f0:	80e3      	strh	r3, [r4, #6]
	} else {
		area->x1 &= ~0x7;
		area->x2 |= 0x7;
	}
}
   130f2:	b004      	add	sp, #16
   130f4:	bd10      	pop	{r4, pc}
		area->x1 &= ~0x7;
   130f6:	8823      	ldrh	r3, [r4, #0]
   130f8:	f023 0307 	bic.w	r3, r3, #7
   130fc:	8023      	strh	r3, [r4, #0]
		area->x2 |= 0x7;
   130fe:	88a3      	ldrh	r3, [r4, #4]
   13100:	f043 0307 	orr.w	r3, r3, #7
   13104:	80a3      	strh	r3, [r4, #4]
}
   13106:	e7f4      	b.n	130f2 <lvgl_rounder_cb_mono+0x22>

00013108 <lvgl_flush_cb_16bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_16bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
   13108:	b5f0      	push	{r4, r5, r6, r7, lr}
   1310a:	4605      	mov	r5, r0
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	uint16_t w = area->x2 - area->x1 + 1;
   1310c:	888b      	ldrh	r3, [r1, #4]
	uint16_t h = area->y2 - area->y1 + 1;
   1310e:	88cc      	ldrh	r4, [r1, #6]
	uint16_t w = area->x2 - area->x1 + 1;
   13110:	f9b1 6000 	ldrsh.w	r6, [r1]
	uint16_t h = area->y2 - area->y1 + 1;
   13114:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	uint16_t w = area->x2 - area->x1 + 1;
   13118:	3301      	adds	r3, #1
	uint16_t h = area->y2 - area->y1 + 1;
   1311a:	3401      	adds	r4, #1
	uint16_t w = area->x2 - area->x1 + 1;
   1311c:	1b9b      	subs	r3, r3, r6
	uint16_t h = area->y2 - area->y1 + 1;
   1311e:	1be4      	subs	r4, r4, r7
	uint16_t w = area->x2 - area->x1 + 1;
   13120:	b29b      	uxth	r3, r3
	uint16_t h = area->y2 - area->y1 + 1;
   13122:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 2U * h;
   13124:	fb04 f103 	mul.w	r1, r4, r3
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
   13128:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
{
   1312a:	b087      	sub	sp, #28
	desc.width = w;
   1312c:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
   13130:	f8ad 3014 	strh.w	r3, [sp, #20]
   13134:	6883      	ldr	r3, [r0, #8]
	desc.buf_size = w * 2U * h;
   13136:	0049      	lsls	r1, r1, #1
   13138:	9200      	str	r2, [sp, #0]
   1313a:	9103      	str	r1, [sp, #12]
	desc.height = h;
   1313c:	f8ad 4012 	strh.w	r4, [sp, #18]
   13140:	b2ba      	uxth	r2, r7
   13142:	689c      	ldr	r4, [r3, #8]
   13144:	b2b1      	uxth	r1, r6
   13146:	ab03      	add	r3, sp, #12
   13148:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
   1314a:	4628      	mov	r0, r5
   1314c:	f007 fcb5 	bl	1aaba <lv_disp_flush_ready>
}
   13150:	b007      	add	sp, #28
   13152:	bdf0      	pop	{r4, r5, r6, r7, pc}

00013154 <lvgl_set_px_cb_16bit>:

#ifndef CONFIG_LVGL_COLOR_DEPTH_16
void lvgl_set_px_cb_16bit(struct _disp_drv_t *disp_drv,
		uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
   13154:	b530      	push	{r4, r5, lr}
   13156:	9c04      	ldr	r4, [sp, #16]
    LV_COLOR_SET_B16(ret, LV_COLOR_GET_B(color) >> 3);  /* 8 - 5  = 3*/
   13158:	f3c4 2585 	ubfx	r5, r4, #10, #6
   1315c:	f3c4 00c4 	ubfx	r0, r4, #3, #5
   13160:	ea40 1045 	orr.w	r0, r0, r5, lsl #5
   13164:	f3c4 44c4 	ubfx	r4, r4, #19, #5
    return ret.full;
   13168:	ea40 20c4 	orr.w	r0, r0, r4, lsl #11
	uint16_t *buf_xy = (uint16_t *)(buf + x * 2U + y * 2U * buf_w);
   1316c:	f9bd 400c 	ldrsh.w	r4, [sp, #12]
   13170:	fb04 3202 	mla	r2, r4, r2, r3
	*buf_xy = lv_color_to16(color);
   13174:	f821 0012 	strh.w	r0, [r1, r2, lsl #1]
}
   13178:	bd30      	pop	{r4, r5, pc}

0001317a <lvgl_flush_cb_24bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_24bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
   1317a:	b5f0      	push	{r4, r5, r6, r7, lr}
   1317c:	4605      	mov	r5, r0
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	uint16_t w = area->x2 - area->x1 + 1;
   1317e:	888b      	ldrh	r3, [r1, #4]
	uint16_t h = area->y2 - area->y1 + 1;
   13180:	88cc      	ldrh	r4, [r1, #6]
	uint16_t w = area->x2 - area->x1 + 1;
   13182:	f9b1 6000 	ldrsh.w	r6, [r1]
	uint16_t h = area->y2 - area->y1 + 1;
   13186:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	uint16_t w = area->x2 - area->x1 + 1;
   1318a:	3301      	adds	r3, #1
	uint16_t h = area->y2 - area->y1 + 1;
   1318c:	3401      	adds	r4, #1
	uint16_t w = area->x2 - area->x1 + 1;
   1318e:	1b9b      	subs	r3, r3, r6
	uint16_t h = area->y2 - area->y1 + 1;
   13190:	1be4      	subs	r4, r4, r7
	uint16_t w = area->x2 - area->x1 + 1;
   13192:	b29b      	uxth	r3, r3
	uint16_t h = area->y2 - area->y1 + 1;
   13194:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 3U * h;
   13196:	fb04 f103 	mul.w	r1, r4, r3
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
   1319a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
{
   1319c:	b087      	sub	sp, #28
	desc.width = w;
   1319e:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
   131a2:	f8ad 3014 	strh.w	r3, [sp, #20]
   131a6:	6883      	ldr	r3, [r0, #8]
	desc.buf_size = w * 3U * h;
   131a8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   131ac:	9200      	str	r2, [sp, #0]
   131ae:	9103      	str	r1, [sp, #12]
	desc.height = h;
   131b0:	f8ad 4012 	strh.w	r4, [sp, #18]
   131b4:	b2ba      	uxth	r2, r7
   131b6:	689c      	ldr	r4, [r3, #8]
   131b8:	b2b1      	uxth	r1, r6
   131ba:	ab03      	add	r3, sp, #12
   131bc:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
   131be:	4628      	mov	r0, r5
   131c0:	f007 fc7b 	bl	1aaba <lv_disp_flush_ready>
}
   131c4:	b007      	add	sp, #28
   131c6:	bdf0      	pop	{r4, r5, r6, r7, pc}

000131c8 <lvgl_set_px_cb_24bit>:

void lvgl_set_px_cb_24bit(struct _disp_drv_t *disp_drv,
		uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y,
		lv_color_t color, lv_opa_t opa)
{
   131c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
   131cc:	f9bd 4018 	ldrsh.w	r4, [sp, #24]
{
   131d0:	f89d e020 	ldrb.w	lr, [sp, #32]
	uint8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
   131d4:	fb04 3302 	mla	r3, r4, r2, r3
	lv_color32_t converted_color;

#ifdef CONFIG_LVGL_COLOR_DEPTH_32
	if (opa != LV_OPA_COVER) {
   131d8:	f1be 0fff 	cmp.w	lr, #255	; 0xff
	uint8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
   131dc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
{
   131e0:	9807      	ldr	r0, [sp, #28]
	uint8_t *buf_xy = buf + x * 3U + y * 3U * buf_w;
   131e2:	eb01 0c03 	add.w	ip, r1, r3
	if (opa != LV_OPA_COVER) {
   131e6:	d027      	beq.n	13238 <lvgl_set_px_cb_24bit+0x70>
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   131e8:	f248 0781 	movw	r7, #32897	; 0x8081
   131ec:	5ccc      	ldrb	r4, [r1, r3]
   131ee:	f1ce 05ff 	rsb	r5, lr, #255	; 0xff
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   131f2:	f89c 6001 	ldrb.w	r6, [ip, #1]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   131f6:	436c      	muls	r4, r5
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   131f8:	436e      	muls	r6, r5
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   131fa:	f3c0 4207 	ubfx	r2, r0, #16, #8
   131fe:	fb02 420e 	mla	r2, r2, lr, r4
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   13202:	f3c0 2407 	ubfx	r4, r0, #8, #8
   13206:	fb04 640e 	mla	r4, r4, lr, r6
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1320a:	f89c 6002 	ldrb.w	r6, [ip, #2]
   1320e:	fa5f f880 	uxtb.w	r8, r0
   13212:	436e      	muls	r6, r5
   13214:	fb08 650e 	mla	r5, r8, lr, r6
   13218:	437d      	muls	r5, r7
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1321a:	437c      	muls	r4, r7
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   1321c:	437a      	muls	r2, r7
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1321e:	0ded      	lsrs	r5, r5, #23
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   13220:	f3c4 54c7 	ubfx	r4, r4, #23, #8
   13224:	f365 0007 	bfi	r0, r5, #0, #8
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   13228:	f3c2 52c7 	ubfx	r2, r2, #23, #8
    return ret;
   1322c:	f364 200f 	bfi	r0, r4, #8, #8
   13230:	f362 4017 	bfi	r0, r2, #16, #8
   13234:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
		color = lv_color_mix(color, mix_color, opa);
	}
#endif

	converted_color.full = lv_color_to32(color);
	*buf_xy = converted_color.ch.red;
   13238:	f3c0 4207 	ubfx	r2, r0, #16, #8
   1323c:	54ca      	strb	r2, [r1, r3]
	*(buf_xy + 1) = converted_color.ch.green;
   1323e:	f3c0 2307 	ubfx	r3, r0, #8, #8
   13242:	f88c 3001 	strb.w	r3, [ip, #1]
	*(buf_xy + 2) = converted_color.ch.blue;
   13246:	f88c 0002 	strb.w	r0, [ip, #2]
}
   1324a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001324e <lvgl_flush_cb_32bit>:
#include <lvgl.h>
#include "lvgl_display.h"

void lvgl_flush_cb_32bit(struct _disp_drv_t *disp_drv,
		const lv_area_t *area, lv_color_t *color_p)
{
   1324e:	b5f0      	push	{r4, r5, r6, r7, lr}
   13250:	4605      	mov	r5, r0
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
	uint16_t w = area->x2 - area->x1 + 1;
   13252:	888b      	ldrh	r3, [r1, #4]
	uint16_t h = area->y2 - area->y1 + 1;
   13254:	88cc      	ldrh	r4, [r1, #6]
	uint16_t w = area->x2 - area->x1 + 1;
   13256:	f9b1 6000 	ldrsh.w	r6, [r1]
	uint16_t h = area->y2 - area->y1 + 1;
   1325a:	f9b1 7002 	ldrsh.w	r7, [r1, #2]
	uint16_t w = area->x2 - area->x1 + 1;
   1325e:	3301      	adds	r3, #1
	uint16_t h = area->y2 - area->y1 + 1;
   13260:	3401      	adds	r4, #1
	uint16_t w = area->x2 - area->x1 + 1;
   13262:	1b9b      	subs	r3, r3, r6
	uint16_t h = area->y2 - area->y1 + 1;
   13264:	1be4      	subs	r4, r4, r7
	uint16_t w = area->x2 - area->x1 + 1;
   13266:	b29b      	uxth	r3, r3
	uint16_t h = area->y2 - area->y1 + 1;
   13268:	b2a4      	uxth	r4, r4
	struct display_buffer_descriptor desc;

	desc.buf_size = w * 4U * h;
   1326a:	fb04 f103 	mul.w	r1, r4, r3
	const struct device *display_dev = (const struct device *)disp_drv->user_data;
   1326e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
{
   13270:	b087      	sub	sp, #28
	desc.width = w;
   13272:	f8ad 3010 	strh.w	r3, [sp, #16]
	desc.pitch = w;
   13276:	f8ad 3014 	strh.w	r3, [sp, #20]
   1327a:	6883      	ldr	r3, [r0, #8]
	desc.buf_size = w * 4U * h;
   1327c:	0089      	lsls	r1, r1, #2
   1327e:	9200      	str	r2, [sp, #0]
   13280:	9103      	str	r1, [sp, #12]
	desc.height = h;
   13282:	f8ad 4012 	strh.w	r4, [sp, #18]
   13286:	b2ba      	uxth	r2, r7
   13288:	689c      	ldr	r4, [r3, #8]
   1328a:	b2b1      	uxth	r1, r6
   1328c:	ab03      	add	r3, sp, #12
   1328e:	47a0      	blx	r4
	display_write(display_dev, area->x1, area->y1, &desc, (void *) color_p);

	lv_disp_flush_ready(disp_drv);
   13290:	4628      	mov	r0, r5
   13292:	f007 fc12 	bl	1aaba <lv_disp_flush_ready>
}
   13296:	b007      	add	sp, #28
   13298:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001329a <bt_uuid_cmp>:

	return memcmp(uuid1.val, uuid2.val, 16);
}

int bt_uuid_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
   1329a:	b510      	push	{r4, lr}
   1329c:	460c      	mov	r4, r1
	/* Convert to 128 bit if types don't match */
	if (u1->type != u2->type) {
   1329e:	7801      	ldrb	r1, [r0, #0]
   132a0:	7822      	ldrb	r2, [r4, #0]
{
   132a2:	b08a      	sub	sp, #40	; 0x28
	if (u1->type != u2->type) {
   132a4:	428a      	cmp	r2, r1
   132a6:	d00e      	beq.n	132c6 <bt_uuid_cmp+0x2c>
	uuid_to_uuid128(u1, &uuid1);
   132a8:	4669      	mov	r1, sp
   132aa:	f7ef ff79 	bl	31a0 <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   132ae:	4620      	mov	r0, r4
   132b0:	a905      	add	r1, sp, #20
   132b2:	f7ef ff75 	bl	31a0 <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
   132b6:	2210      	movs	r2, #16
   132b8:	f10d 0115 	add.w	r1, sp, #21
   132bc:	f10d 0001 	add.w	r0, sp, #1
	case BT_UUID_TYPE_16:
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
	case BT_UUID_TYPE_32:
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
	case BT_UUID_TYPE_128:
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   132c0:	f00a fb41 	bl	1d946 <memcmp>
   132c4:	e007      	b.n	132d6 <bt_uuid_cmp+0x3c>
	switch (u1->type) {
   132c6:	2a01      	cmp	r2, #1
   132c8:	d007      	beq.n	132da <bt_uuid_cmp+0x40>
   132ca:	2a02      	cmp	r2, #2
   132cc:	d008      	beq.n	132e0 <bt_uuid_cmp+0x46>
   132ce:	b95a      	cbnz	r2, 132e8 <bt_uuid_cmp+0x4e>
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   132d0:	8840      	ldrh	r0, [r0, #2]
   132d2:	8863      	ldrh	r3, [r4, #2]
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   132d4:	1ac0      	subs	r0, r0, r3
	}

	return -EINVAL;
}
   132d6:	b00a      	add	sp, #40	; 0x28
   132d8:	bd10      	pop	{r4, pc}
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   132da:	6840      	ldr	r0, [r0, #4]
   132dc:	6863      	ldr	r3, [r4, #4]
   132de:	e7f9      	b.n	132d4 <bt_uuid_cmp+0x3a>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   132e0:	2210      	movs	r2, #16
   132e2:	1c61      	adds	r1, r4, #1
   132e4:	3001      	adds	r0, #1
   132e6:	e7eb      	b.n	132c0 <bt_uuid_cmp+0x26>
	switch (u1->type) {
   132e8:	f06f 0015 	mvn.w	r0, #21
   132ec:	e7f3      	b.n	132d6 <bt_uuid_cmp+0x3c>

000132ee <bt_uuid_create>:

bool bt_uuid_create(struct bt_uuid *uuid, const uint8_t *data, uint8_t data_len)
{
	/* Copy UUID from packet data/internal variable to internal bt_uuid */
	switch (data_len) {
   132ee:	2a04      	cmp	r2, #4
{
   132f0:	b530      	push	{r4, r5, lr}
	switch (data_len) {
   132f2:	d00d      	beq.n	13310 <bt_uuid_create+0x22>
   132f4:	2a10      	cmp	r2, #16
   132f6:	d019      	beq.n	1332c <bt_uuid_create+0x3e>
   132f8:	2a02      	cmp	r2, #2
   132fa:	f04f 0300 	mov.w	r3, #0
   132fe:	d121      	bne.n	13344 <bt_uuid_create+0x56>
	case 2:
		uuid->type = BT_UUID_TYPE_16;
   13300:	7003      	strb	r3, [r0, #0]
	return ((uint16_t)src[1] << 8) | src[0];
   13302:	784a      	ldrb	r2, [r1, #1]
   13304:	780b      	ldrb	r3, [r1, #0]
   13306:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   1330a:	8043      	strh	r3, [r0, #2]
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
		break;
	default:
		return false;
	}
	return true;
   1330c:	2001      	movs	r0, #1
}
   1330e:	bd30      	pop	{r4, r5, pc}
		uuid->type = BT_UUID_TYPE_32;
   13310:	2301      	movs	r3, #1
   13312:	7003      	strb	r3, [r0, #0]
   13314:	788a      	ldrb	r2, [r1, #2]
   13316:	78cc      	ldrb	r4, [r1, #3]
   13318:	784d      	ldrb	r5, [r1, #1]
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   1331a:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
	return ((uint16_t)src[1] << 8) | src[0];
   1331e:	780a      	ldrb	r2, [r1, #0]
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   13320:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
   13324:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   13328:	6042      	str	r2, [r0, #4]
		break;
   1332a:	e7ef      	b.n	1330c <bt_uuid_create+0x1e>
		uuid->type = BT_UUID_TYPE_128;
   1332c:	2302      	movs	r3, #2
   1332e:	f800 3b01 	strb.w	r3, [r0], #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   13332:	f101 0310 	add.w	r3, r1, #16
   13336:	f851 2b04 	ldr.w	r2, [r1], #4
   1333a:	4299      	cmp	r1, r3
   1333c:	f840 2b04 	str.w	r2, [r0], #4
   13340:	d1f9      	bne.n	13336 <bt_uuid_create+0x48>
   13342:	e7e3      	b.n	1330c <bt_uuid_create+0x1e>
	switch (data_len) {
   13344:	4618      	mov	r0, r3
   13346:	e7e2      	b.n	1330e <bt_uuid_create+0x20>

00013348 <bt_addr_le_create_static>:
#include <bluetooth/addr.h>
#include <bluetooth/crypto.h>

static inline int create_random_addr(bt_addr_le_t *addr)
{
	addr->type = BT_ADDR_LE_RANDOM;
   13348:	2301      	movs	r3, #1

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
   1334a:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
   1334c:	2106      	movs	r1, #6
{
   1334e:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   13350:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   13354:	f7f1 fb94 	bl	4a80 <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
   13358:	b918      	cbnz	r0, 13362 <bt_addr_le_create_static+0x1a>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
   1335a:	79a3      	ldrb	r3, [r4, #6]
   1335c:	f063 033f 	orn	r3, r3, #63	; 0x3f
   13360:	71a3      	strb	r3, [r4, #6]

	return 0;
}
   13362:	bd10      	pop	{r4, pc}

00013364 <bt_hci_evt_get_flags>:
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
	switch (evt) {
   13364:	280f      	cmp	r0, #15
   13366:	d806      	bhi.n	13376 <bt_hci_evt_get_flags+0x12>
   13368:	280d      	cmp	r0, #13
   1336a:	d80b      	bhi.n	13384 <bt_hci_evt_get_flags+0x20>
   1336c:	2805      	cmp	r0, #5
	case BT_HCI_EVT_DISCONN_COMPLETE:
		return BT_HCI_EVT_FLAG_RECV | BT_HCI_EVT_FLAG_RECV_PRIO;
   1336e:	bf14      	ite	ne
   13370:	2002      	movne	r0, #2
   13372:	2003      	moveq	r0, #3
   13374:	4770      	bx	lr
	switch (evt) {
   13376:	2813      	cmp	r0, #19
   13378:	d004      	beq.n	13384 <bt_hci_evt_get_flags+0x20>
   1337a:	281a      	cmp	r0, #26
   1337c:	bf14      	ite	ne
   1337e:	2002      	movne	r0, #2
   13380:	2001      	moveq	r0, #1
   13382:	4770      	bx	lr
   13384:	2001      	movs	r0, #1
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
	}
}
   13386:	4770      	bx	lr

00013388 <handle_event>:
{
   13388:	b410      	push	{r4}
   1338a:	4604      	mov	r4, r0
   1338c:	4608      	mov	r0, r1
   1338e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
		if (handler->event != event) {
   13392:	7811      	ldrb	r1, [r2, #0]
   13394:	42a1      	cmp	r1, r4
   13396:	d004      	beq.n	133a2 <handle_event+0x1a>
	for (i = 0; i < num_handlers; i++) {
   13398:	3208      	adds	r2, #8
   1339a:	429a      	cmp	r2, r3
   1339c:	d1f9      	bne.n	13392 <handle_event+0xa>
}
   1339e:	bc10      	pop	{r4}
   133a0:	4770      	bx	lr
		if (buf->len < handler->min_len) {
   133a2:	8981      	ldrh	r1, [r0, #12]
   133a4:	7853      	ldrb	r3, [r2, #1]
   133a6:	4299      	cmp	r1, r3
   133a8:	d3f9      	bcc.n	1339e <handle_event+0x16>
		handler->handler(buf);
   133aa:	6853      	ldr	r3, [r2, #4]
}
   133ac:	bc10      	pop	{r4}
		handler->handler(buf);
   133ae:	4718      	bx	r3

000133b0 <hci_data_buf_overflow>:
}
   133b0:	4770      	bx	lr

000133b2 <get_adv_channel_map>:
{
   133b2:	4603      	mov	r3, r0
		channel_map &= ~0x01;
   133b4:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   133b8:	bf0c      	ite	eq
   133ba:	2007      	moveq	r0, #7
   133bc:	2006      	movne	r0, #6
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
   133be:	03da      	lsls	r2, r3, #15
		channel_map &= ~0x02;
   133c0:	bf48      	it	mi
   133c2:	f000 0005 	andmi.w	r0, r0, #5
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
   133c6:	039b      	lsls	r3, r3, #14
		channel_map &= ~0x04;
   133c8:	bf48      	it	mi
   133ca:	f000 00fb 	andmi.w	r0, r0, #251	; 0xfb
}
   133ce:	4770      	bx	lr

000133d0 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   133d0:	e8d0 0faf 	lda	r0, [r0]
}
   133d4:	4770      	bx	lr

000133d6 <bt_addr_le_cmp>:
   133d6:	2207      	movs	r2, #7
   133d8:	f00a bab5 	b.w	1d946 <memcmp>

000133dc <le_data_len_change>:
{
   133dc:	b508      	push	{r3, lr}
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   133de:	6883      	ldr	r3, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   133e0:	8818      	ldrh	r0, [r3, #0]
   133e2:	f7f1 fd37 	bl	4e54 <bt_conn_lookup_handle>
	if (!conn) {
   133e6:	b118      	cbz	r0, 133f0 <le_data_len_change+0x14>
}
   133e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	bt_conn_unref(conn);
   133ec:	f000 bb4b 	b.w	13a86 <bt_conn_unref>
}
   133f0:	bd08      	pop	{r3, pc}

000133f2 <hci_disconn_complete_prio>:
{
   133f2:	b510      	push	{r4, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
   133f4:	6883      	ldr	r3, [r0, #8]
	if (evt->status) {
   133f6:	781a      	ldrb	r2, [r3, #0]
   133f8:	b96a      	cbnz	r2, 13416 <hci_disconn_complete_prio+0x24>
	conn = bt_conn_lookup_handle(handle);
   133fa:	f8b3 0001 	ldrh.w	r0, [r3, #1]
   133fe:	f7f1 fd29 	bl	4e54 <bt_conn_lookup_handle>
	if (!conn) {
   13402:	4604      	mov	r4, r0
   13404:	b138      	cbz	r0, 13416 <hci_disconn_complete_prio+0x24>
	bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
   13406:	2101      	movs	r1, #1
   13408:	f7f1 fd30 	bl	4e6c <bt_conn_set_state>
	bt_conn_unref(conn);
   1340c:	4620      	mov	r0, r4
}
   1340e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_conn_unref(conn);
   13412:	f000 bb38 	b.w	13a86 <bt_conn_unref>
}
   13416:	bd10      	pop	{r4, pc}

00013418 <hci_disconn_complete>:
{
   13418:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
   1341a:	6886      	ldr	r6, [r0, #8]
	if (evt->status) {
   1341c:	7835      	ldrb	r5, [r6, #0]
   1341e:	b985      	cbnz	r5, 13442 <hci_disconn_complete+0x2a>
	conn = bt_conn_lookup_handle(handle);
   13420:	f8b6 0001 	ldrh.w	r0, [r6, #1]
   13424:	f7f1 fd16 	bl	4e54 <bt_conn_lookup_handle>
	if (!conn) {
   13428:	4604      	mov	r4, r0
   1342a:	b150      	cbz	r0, 13442 <hci_disconn_complete+0x2a>
	conn->err = evt->reason;
   1342c:	78f3      	ldrb	r3, [r6, #3]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   1342e:	4629      	mov	r1, r5
	conn->err = evt->reason;
   13430:	7243      	strb	r3, [r0, #9]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   13432:	f7f1 fd1b 	bl	4e6c <bt_conn_set_state>
		bt_conn_unref(conn);
   13436:	4620      	mov	r0, r4
	conn->handle = 0U;
   13438:	8025      	strh	r5, [r4, #0]
}
   1343a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
   1343e:	f000 bb22 	b.w	13a86 <bt_conn_unref>
}
   13442:	bd70      	pop	{r4, r5, r6, pc}

00013444 <atomic_or>:
{
   13444:	4603      	mov	r3, r0
}
   13446:	e8d3 0fef 	ldaex	r0, [r3]
   1344a:	ea40 0201 	orr.w	r2, r0, r1
   1344e:	e8c3 2fec 	stlex	ip, r2, [r3]
   13452:	f1bc 0f00 	cmp.w	ip, #0
   13456:	d1f6      	bne.n	13446 <atomic_or+0x2>
   13458:	4770      	bx	lr

0001345a <atomic_and>:
{
   1345a:	4603      	mov	r3, r0
}
   1345c:	e8d3 0fef 	ldaex	r0, [r3]
   13460:	ea00 0201 	and.w	r2, r0, r1
   13464:	e8c3 2fec 	stlex	ip, r2, [r3]
   13468:	f1bc 0f00 	cmp.w	ip, #0
   1346c:	d1f6      	bne.n	1345c <atomic_and+0x2>
   1346e:	4770      	bx	lr

00013470 <atomic_set_bit_to>:
 * @param val true for 1, false for 0.
 *
 * @return N/A
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
   13470:	460b      	mov	r3, r1
   13472:	b410      	push	{r4}
	atomic_val_t mask = ATOMIC_MASK(bit);
   13474:	f001 041f 	and.w	r4, r1, #31
   13478:	2101      	movs	r1, #1
   1347a:	095b      	lsrs	r3, r3, #5
   1347c:	40a1      	lsls	r1, r4

	if (val) {
   1347e:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   13482:	b112      	cbz	r2, 1348a <atomic_set_bit_to+0x1a>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
	}
}
   13484:	bc10      	pop	{r4}
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   13486:	f7ff bfdd 	b.w	13444 <atomic_or>
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1348a:	43c9      	mvns	r1, r1
}
   1348c:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1348e:	f7ff bfe4 	b.w	1345a <atomic_and>

00013492 <hci_hardware_error>:
	return net_buf_simple_pull_mem(&buf->b, len);
   13492:	2101      	movs	r1, #1
   13494:	3008      	adds	r0, #8
   13496:	f001 bcd2 	b.w	14e3e <net_buf_simple_pull_mem>

0001349a <le_conn_update_complete>:
{
   1349a:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
   1349c:	6885      	ldr	r5, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   1349e:	f8b5 0001 	ldrh.w	r0, [r5, #1]
   134a2:	f7f1 fcd7 	bl	4e54 <bt_conn_lookup_handle>
	if (!conn) {
   134a6:	4604      	mov	r4, r0
   134a8:	b1c0      	cbz	r0, 134dc <le_conn_update_complete+0x42>
	if (!evt->status) {
   134aa:	782b      	ldrb	r3, [r5, #0]
   134ac:	b9c3      	cbnz	r3, 134e0 <le_conn_update_complete+0x46>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
   134ae:	792a      	ldrb	r2, [r5, #4]
   134b0:	78eb      	ldrb	r3, [r5, #3]
   134b2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   134b6:	f8a0 309e 	strh.w	r3, [r0, #158]	; 0x9e
		conn->le.latency = sys_le16_to_cpu(evt->latency);
   134ba:	79aa      	ldrb	r2, [r5, #6]
   134bc:	796b      	ldrb	r3, [r5, #5]
   134be:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   134c2:	f8a0 30a4 	strh.w	r3, [r0, #164]	; 0xa4
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
   134c6:	79eb      	ldrb	r3, [r5, #7]
   134c8:	7a2a      	ldrb	r2, [r5, #8]
   134ca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   134ce:	f8a0 30a6 	strh.w	r3, [r0, #166]	; 0xa6
		notify_le_param_updated(conn);
   134d2:	f7f1 fb9b 	bl	4c0c <notify_le_param_updated>
	bt_conn_unref(conn);
   134d6:	4620      	mov	r0, r4
   134d8:	f000 fad5 	bl	13a86 <bt_conn_unref>
}
   134dc:	b003      	add	sp, #12
   134de:	bd30      	pop	{r4, r5, pc}
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
   134e0:	2b1a      	cmp	r3, #26
   134e2:	d1f8      	bne.n	134d6 <le_conn_update_complete+0x3c>
   134e4:	78c3      	ldrb	r3, [r0, #3]
   134e6:	2b01      	cmp	r3, #1
   134e8:	d1f5      	bne.n	134d6 <le_conn_update_complete+0x3c>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   134ea:	f44f 6180 	mov.w	r1, #1024	; 0x400
   134ee:	3004      	adds	r0, #4
   134f0:	f7ff ffa8 	bl	13444 <atomic_or>
		   conn->role == BT_HCI_ROLE_SLAVE &&
   134f4:	0543      	lsls	r3, r0, #21
   134f6:	d4ee      	bmi.n	134d6 <le_conn_update_complete+0x3c>
		param.interval_min = conn->le.interval_min;
   134f8:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
		bt_l2cap_update_conn_param(conn, &param);
   134fc:	4669      	mov	r1, sp
		param.interval_min = conn->le.interval_min;
   134fe:	9300      	str	r3, [sp, #0]
		param.latency = conn->le.pending_latency;
   13500:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
		bt_l2cap_update_conn_param(conn, &param);
   13504:	4620      	mov	r0, r4
		param.latency = conn->le.pending_latency;
   13506:	9301      	str	r3, [sp, #4]
		bt_l2cap_update_conn_param(conn, &param);
   13508:	f7f1 ff5a 	bl	53c0 <bt_l2cap_update_conn_param>
   1350c:	e7e3      	b.n	134d6 <le_conn_update_complete+0x3c>

0001350e <bt_addr_copy>:
   1350e:	680b      	ldr	r3, [r1, #0]
   13510:	6003      	str	r3, [r0, #0]
   13512:	888b      	ldrh	r3, [r1, #4]
   13514:	8083      	strh	r3, [r0, #4]
 *  @param src Bluetooth device address source buffer.
 */
static inline void bt_addr_copy(bt_addr_t *dst, const bt_addr_t *src)
{
	memcpy(dst, src, sizeof(*dst));
}
   13516:	4770      	bx	lr

00013518 <bt_addr_le_copy>:
   13518:	680b      	ldr	r3, [r1, #0]
   1351a:	6003      	str	r3, [r0, #0]
   1351c:	888b      	ldrh	r3, [r1, #4]
   1351e:	8083      	strh	r3, [r0, #4]
   13520:	798b      	ldrb	r3, [r1, #6]
   13522:	7183      	strb	r3, [r0, #6]
 *  @param src Bluetooth LE device address source buffer.
 */
static inline void bt_addr_le_copy(bt_addr_le_t *dst, const bt_addr_le_t *src)
{
	memcpy(dst, src, sizeof(*dst));
}
   13524:	4770      	bx	lr

00013526 <hci_vendor_event>:
   13526:	4770      	bx	lr

00013528 <hci_le_read_max_data_len>:
{
   13528:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1352a:	4606      	mov	r6, r0
   1352c:	460d      	mov	r5, r1
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
   1352e:	f242 002f 	movw	r0, #8239	; 0x202f
   13532:	2100      	movs	r1, #0
   13534:	aa01      	add	r2, sp, #4
   13536:	f7f0 f975 	bl	3824 <bt_hci_cmd_send_sync>
	if (err) {
   1353a:	4604      	mov	r4, r0
   1353c:	b948      	cbnz	r0, 13552 <hci_le_read_max_data_len+0x2a>
	rp = (void *)rsp->data;
   1353e:	9801      	ldr	r0, [sp, #4]
   13540:	6883      	ldr	r3, [r0, #8]
	*tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
   13542:	f8b3 2001 	ldrh.w	r2, [r3, #1]
   13546:	8032      	strh	r2, [r6, #0]
	*tx_time = sys_le16_to_cpu(rp->max_tx_time);
   13548:	f8b3 3003 	ldrh.w	r3, [r3, #3]
   1354c:	802b      	strh	r3, [r5, #0]
	net_buf_unref(rsp);
   1354e:	f7f3 f9ff 	bl	6950 <net_buf_unref>
}
   13552:	4620      	mov	r0, r4
   13554:	b002      	add	sp, #8
   13556:	bd70      	pop	{r4, r5, r6, pc}

00013558 <hci_set_ad>:
{
   13558:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1355c:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   1355e:	2120      	movs	r1, #32
{
   13560:	4682      	mov	sl, r0
   13562:	4615      	mov	r5, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   13564:	f7f0 f926 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
   13568:	4606      	mov	r6, r0
   1356a:	2800      	cmp	r0, #0
   1356c:	d04a      	beq.n	13604 <hci_set_ad+0xac>
	return net_buf_simple_add(&buf->b, len);
   1356e:	2120      	movs	r1, #32
   13570:	3008      	adds	r0, #8
   13572:	f001 fc33 	bl	14ddc <net_buf_simple_add>
__ssp_bos_icheck3(memset, void *, int)
   13576:	2220      	movs	r2, #32
   13578:	4681      	mov	r9, r0
   1357a:	2100      	movs	r1, #0
   1357c:	f00a f9fe 	bl	1d97c <memset>
	err = set_data_add(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
   13580:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
	uint8_t set_data_len = 0;
   13584:	2500      	movs	r5, #0
	err = set_data_add(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
   13586:	f109 0b01 	add.w	fp, r9, #1
	for (size_t i = 0; i < ad_len; i++) {
   1358a:	9300      	str	r3, [sp, #0]
		for (size_t j = 0; j < ad[i].len; j++) {
   1358c:	2300      	movs	r3, #0
   1358e:	f8d4 8000 	ldr.w	r8, [r4]
   13592:	6862      	ldr	r2, [r4, #4]
   13594:	4293      	cmp	r3, r2
   13596:	d30d      	bcc.n	135b4 <hci_set_ad+0x5c>
	for (size_t i = 0; i < ad_len; i++) {
   13598:	9b00      	ldr	r3, [sp, #0]
   1359a:	3408      	adds	r4, #8
   1359c:	42a3      	cmp	r3, r4
   1359e:	d1f5      	bne.n	1358c <hci_set_ad+0x34>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   135a0:	2200      	movs	r2, #0
   135a2:	4631      	mov	r1, r6
   135a4:	4650      	mov	r0, sl
	*data_len = set_data_len;
   135a6:	f889 5000 	strb.w	r5, [r9]
}
   135aa:	b003      	add	sp, #12
   135ac:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   135b0:	f7f0 b938 	b.w	3824 <bt_hci_cmd_send_sync>
			size_t len = data[j].data_len;
   135b4:	f898 2001 	ldrb.w	r2, [r8, #1]
			uint8_t type = data[j].type;
   135b8:	1ca8      	adds	r0, r5, #2
			if ((set_data_len + len + 2) > set_data_len_max) {
   135ba:	1881      	adds	r1, r0, r2
   135bc:	291f      	cmp	r1, #31
			uint8_t type = data[j].type;
   135be:	f898 c000 	ldrb.w	ip, [r8]
			if ((set_data_len + len + 2) > set_data_len_max) {
   135c2:	d908      	bls.n	135d6 <hci_set_ad+0x7e>
				if (!(type == BT_DATA_NAME_COMPLETE &&
   135c4:	f1bc 0f09 	cmp.w	ip, #9
				ssize_t shortened_len = set_data_len_max -
   135c8:	f1c5 021d 	rsb	r2, r5, #29
				if (!(type == BT_DATA_NAME_COMPLETE &&
   135cc:	d11f      	bne.n	1360e <hci_set_ad+0xb6>
   135ce:	2a00      	cmp	r2, #0
   135d0:	dd1d      	ble.n	1360e <hci_set_ad+0xb6>
				type = BT_DATA_NAME_SHORTENED;
   135d2:	f04f 0c08 	mov.w	ip, #8
			set_data[set_data_len++] = len + 1;
   135d6:	b2d7      	uxtb	r7, r2
   135d8:	1c79      	adds	r1, r7, #1
   135da:	f80b 1005 	strb.w	r1, [fp, r5]
   135de:	1c69      	adds	r1, r5, #1
			set_data[set_data_len++] = type;
   135e0:	b2c9      	uxtb	r1, r1
   135e2:	f80b c001 	strb.w	ip, [fp, r1]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   135e6:	f8d8 1004 	ldr.w	r1, [r8, #4]
   135ea:	fa5b f080 	uxtab	r0, fp, r0
   135ee:	9301      	str	r3, [sp, #4]
			set_data_len += len;
   135f0:	3702      	adds	r7, #2
   135f2:	f00a f9b6 	bl	1d962 <memcpy>
		for (size_t j = 0; j < ad[i].len; j++) {
   135f6:	9b01      	ldr	r3, [sp, #4]
			set_data_len += len;
   135f8:	443d      	add	r5, r7
   135fa:	b2ed      	uxtb	r5, r5
		for (size_t j = 0; j < ad[i].len; j++) {
   135fc:	3301      	adds	r3, #1
   135fe:	f108 0808 	add.w	r8, r8, #8
   13602:	e7c6      	b.n	13592 <hci_set_ad+0x3a>
		return -ENOBUFS;
   13604:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   13608:	b003      	add	sp, #12
   1360a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		net_buf_unref(buf);
   1360e:	4630      	mov	r0, r6
   13610:	f7f3 f99e 	bl	6950 <net_buf_unref>
		return err;
   13614:	f06f 0015 	mvn.w	r0, #21
   13618:	e7f6      	b.n	13608 <hci_set_ad+0xb0>

0001361a <bt_hci_disconnect>:
{
   1361a:	b570      	push	{r4, r5, r6, lr}
   1361c:	4606      	mov	r6, r0
   1361e:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   13620:	f240 4006 	movw	r0, #1030	; 0x406
   13624:	2103      	movs	r1, #3
   13626:	f7f0 f8c5 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
   1362a:	4604      	mov	r4, r0
   1362c:	b168      	cbz	r0, 1364a <bt_hci_disconnect+0x30>
   1362e:	2103      	movs	r1, #3
   13630:	3008      	adds	r0, #8
   13632:	f001 fbd3 	bl	14ddc <net_buf_simple_add>
	disconn->reason = reason;
   13636:	7085      	strb	r5, [r0, #2]
	disconn->handle = sys_cpu_to_le16(handle);
   13638:	8006      	strh	r6, [r0, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
   1363a:	4621      	mov	r1, r4
}
   1363c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
   13640:	2200      	movs	r2, #0
   13642:	f240 4006 	movw	r0, #1030	; 0x406
   13646:	f7f0 b8ed 	b.w	3824 <bt_hci_cmd_send_sync>
}
   1364a:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1364e:	bd70      	pop	{r4, r5, r6, pc}

00013650 <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
   13650:	8802      	ldrh	r2, [r0, #0]
   13652:	8843      	ldrh	r3, [r0, #2]
{
   13654:	b510      	push	{r4, lr}
	if (param->interval_min > param->interval_max ||
   13656:	429a      	cmp	r2, r3
   13658:	d818      	bhi.n	1368c <bt_le_conn_params_valid+0x3c>
   1365a:	2a05      	cmp	r2, #5
   1365c:	d916      	bls.n	1368c <bt_le_conn_params_valid+0x3c>
	    param->interval_min < 6 || param->interval_max > 3200) {
   1365e:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   13662:	d813      	bhi.n	1368c <bt_le_conn_params_valid+0x3c>
	if (param->latency > 499) {
   13664:	8884      	ldrh	r4, [r0, #4]
   13666:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
   1366a:	d20f      	bcs.n	1368c <bt_le_conn_params_valid+0x3c>
	if (param->timeout < 10 || param->timeout > 3200 ||
   1366c:	88c1      	ldrh	r1, [r0, #6]
   1366e:	f640 4076 	movw	r0, #3190	; 0xc76
   13672:	f1a1 020a 	sub.w	r2, r1, #10
   13676:	b292      	uxth	r2, r2
   13678:	4282      	cmp	r2, r0
   1367a:	d807      	bhi.n	1368c <bt_le_conn_params_valid+0x3c>
	     ((1U + param->latency) * param->interval_max))) {
   1367c:	fb04 3303 	mla	r3, r4, r3, r3
	if (param->timeout < 10 || param->timeout > 3200 ||
   13680:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
   13684:	bf34      	ite	cc
   13686:	2001      	movcc	r0, #1
   13688:	2000      	movcs	r0, #0
}
   1368a:	bd10      	pop	{r4, pc}
		return false;
   1368c:	2000      	movs	r0, #0
   1368e:	e7fc      	b.n	1368a <bt_le_conn_params_valid+0x3a>

00013690 <bt_le_set_data_len>:
{
   13690:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13692:	4607      	mov	r7, r0
   13694:	460e      	mov	r6, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
   13696:	f242 0022 	movw	r0, #8226	; 0x2022
   1369a:	2106      	movs	r1, #6
{
   1369c:	4615      	mov	r5, r2
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
   1369e:	f7f0 f889 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
   136a2:	4604      	mov	r4, r0
   136a4:	b170      	cbz	r0, 136c4 <bt_le_set_data_len+0x34>
   136a6:	2106      	movs	r1, #6
   136a8:	3008      	adds	r0, #8
   136aa:	f001 fb97 	bl	14ddc <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   136ae:	883b      	ldrh	r3, [r7, #0]
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
   136b0:	4621      	mov	r1, r4
	cp->handle = sys_cpu_to_le16(conn->handle);
   136b2:	8003      	strh	r3, [r0, #0]
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
   136b4:	8046      	strh	r6, [r0, #2]
	cp->tx_time = sys_cpu_to_le16(tx_time);
   136b6:	8085      	strh	r5, [r0, #4]
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
   136b8:	f242 0022 	movw	r0, #8226	; 0x2022
}
   136bc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
   136c0:	f7f0 ba44 	b.w	3b4c <bt_hci_cmd_send>
}
   136c4:	f06f 0068 	mvn.w	r0, #104	; 0x68
   136c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000136ca <bt_le_set_phy>:
{
   136ca:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   136ce:	4680      	mov	r8, r0
   136d0:	460f      	mov	r7, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
   136d2:	f242 0032 	movw	r0, #8242	; 0x2032
   136d6:	2107      	movs	r1, #7
{
   136d8:	4616      	mov	r6, r2
   136da:	461d      	mov	r5, r3
   136dc:	f89d 9020 	ldrb.w	r9, [sp, #32]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
   136e0:	f7f0 f868 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
   136e4:	4604      	mov	r4, r0
   136e6:	b190      	cbz	r0, 1370e <bt_le_set_phy+0x44>
   136e8:	2107      	movs	r1, #7
   136ea:	3008      	adds	r0, #8
   136ec:	f001 fb76 	bl	14ddc <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   136f0:	f8b8 3000 	ldrh.w	r3, [r8]
	cp->all_phys = all_phys;
   136f4:	7087      	strb	r7, [r0, #2]
	cp->tx_phys = pref_tx_phy;
   136f6:	70c6      	strb	r6, [r0, #3]
	cp->rx_phys = pref_rx_phy;
   136f8:	7105      	strb	r5, [r0, #4]
	cp->handle = sys_cpu_to_le16(conn->handle);
   136fa:	8003      	strh	r3, [r0, #0]
	cp->phy_opts = phy_opts;
   136fc:	f8a0 9005 	strh.w	r9, [r0, #5]
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_PHY, buf);
   13700:	4621      	mov	r1, r4
}
   13702:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return bt_hci_cmd_send(BT_HCI_OP_LE_SET_PHY, buf);
   13706:	f242 0032 	movw	r0, #8242	; 0x2032
   1370a:	f7f0 ba1f 	b.w	3b4c <bt_hci_cmd_send>
}
   1370e:	f06f 0068 	mvn.w	r0, #104	; 0x68
   13712:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00013716 <le_phy_update_complete>:
{
   13716:	b538      	push	{r3, r4, r5, lr}
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   13718:	6883      	ldr	r3, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   1371a:	f8b3 0001 	ldrh.w	r0, [r3, #1]
   1371e:	f7f1 fb99 	bl	4e54 <bt_conn_lookup_handle>
	if (!conn) {
   13722:	4604      	mov	r4, r0
   13724:	b1a0      	cbz	r0, 13750 <le_phy_update_complete+0x3a>
	    atomic_test_and_clear_bit(conn->flags, BT_CONN_AUTO_PHY_UPDATE)) {
   13726:	1d05      	adds	r5, r0, #4
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   13728:	f06f 0180 	mvn.w	r1, #128	; 0x80
   1372c:	4628      	mov	r0, r5
   1372e:	f7ff fe94 	bl	1345a <atomic_and>
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
   13732:	0603      	lsls	r3, r0, #24
   13734:	d507      	bpl.n	13746 <le_phy_update_complete+0x30>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   13736:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   1373a:	4628      	mov	r0, r5
   1373c:	f7ff fe82 	bl	13444 <atomic_or>
		conn_auto_initiate(conn);
   13740:	4620      	mov	r0, r4
   13742:	f7f0 fa67 	bl	3c14 <conn_auto_initiate>
	bt_conn_unref(conn);
   13746:	4620      	mov	r0, r4
}
   13748:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
   1374c:	f000 b99b 	b.w	13a86 <bt_conn_unref>
}
   13750:	bd38      	pop	{r3, r4, r5, pc}

00013752 <le_remote_feat_complete>:
{
   13752:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
   13754:	6885      	ldr	r5, [r0, #8]
	conn = bt_conn_lookup_handle(handle);
   13756:	f8b5 0001 	ldrh.w	r0, [r5, #1]
   1375a:	f7f1 fb7b 	bl	4e54 <bt_conn_lookup_handle>
	if (!conn) {
   1375e:	4604      	mov	r4, r0
   13760:	b1a8      	cbz	r0, 1378e <le_remote_feat_complete+0x3c>
	if (!evt->status) {
   13762:	782b      	ldrb	r3, [r5, #0]
   13764:	b933      	cbnz	r3, 13774 <le_remote_feat_complete+0x22>
   13766:	f855 3f03 	ldr.w	r3, [r5, #3]!
   1376a:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
   1376e:	686b      	ldr	r3, [r5, #4]
   13770:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
   13774:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   13778:	1d20      	adds	r0, r4, #4
   1377a:	f7ff fe63 	bl	13444 <atomic_or>
	conn_auto_initiate(conn);
   1377e:	4620      	mov	r0, r4
   13780:	f7f0 fa48 	bl	3c14 <conn_auto_initiate>
	bt_conn_unref(conn);
   13784:	4620      	mov	r0, r4
}
   13786:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
   1378a:	f000 b97c 	b.w	13a86 <bt_conn_unref>
}
   1378e:	bd38      	pop	{r3, r4, r5, pc}

00013790 <le_conn_param_neg_reply>:
{
   13790:	b570      	push	{r4, r5, r6, lr}
   13792:	4606      	mov	r6, r0
   13794:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
   13796:	f242 0021 	movw	r0, #8225	; 0x2021
   1379a:	2103      	movs	r1, #3
   1379c:	f7f0 f80a 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
   137a0:	4604      	mov	r4, r0
   137a2:	b160      	cbz	r0, 137be <le_conn_param_neg_reply+0x2e>
   137a4:	2103      	movs	r1, #3
   137a6:	3008      	adds	r0, #8
   137a8:	f001 fb18 	bl	14ddc <net_buf_simple_add>
	cp->reason = sys_cpu_to_le16(reason);
   137ac:	7085      	strb	r5, [r0, #2]
	cp->handle = sys_cpu_to_le16(handle);
   137ae:	8006      	strh	r6, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
   137b0:	4621      	mov	r1, r4
}
   137b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
   137b6:	f242 0021 	movw	r0, #8225	; 0x2021
   137ba:	f7f0 b9c7 	b.w	3b4c <bt_hci_cmd_send>
}
   137be:	bd70      	pop	{r4, r5, r6, pc}

000137c0 <le_conn_param_req>:
{
   137c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
   137c2:	6883      	ldr	r3, [r0, #8]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
   137c4:	78d9      	ldrb	r1, [r3, #3]
   137c6:	789a      	ldrb	r2, [r3, #2]
	handle = sys_le16_to_cpu(evt->handle);
   137c8:	881f      	ldrh	r7, [r3, #0]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
   137ca:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   137ce:	f8ad 2000 	strh.w	r2, [sp]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
   137d2:	7959      	ldrb	r1, [r3, #5]
   137d4:	791a      	ldrb	r2, [r3, #4]
	handle = sys_le16_to_cpu(evt->handle);
   137d6:	b2bc      	uxth	r4, r7
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
   137d8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   137dc:	f8ad 2002 	strh.w	r2, [sp, #2]
	param.latency = sys_le16_to_cpu(evt->latency);
   137e0:	799a      	ldrb	r2, [r3, #6]
   137e2:	79d9      	ldrb	r1, [r3, #7]
	conn = bt_conn_lookup_handle(handle);
   137e4:	4620      	mov	r0, r4
	param.latency = sys_le16_to_cpu(evt->latency);
   137e6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   137ea:	f8ad 2004 	strh.w	r2, [sp, #4]
	param.timeout = sys_le16_to_cpu(evt->timeout);
   137ee:	7a1a      	ldrb	r2, [r3, #8]
   137f0:	7a5b      	ldrb	r3, [r3, #9]
   137f2:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
   137f6:	f8ad 3006 	strh.w	r3, [sp, #6]
	conn = bt_conn_lookup_handle(handle);
   137fa:	f7f1 fb2b 	bl	4e54 <bt_conn_lookup_handle>
	if (!conn) {
   137fe:	4606      	mov	r6, r0
   13800:	b928      	cbnz	r0, 1380e <le_conn_param_req+0x4e>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
   13802:	2102      	movs	r1, #2
   13804:	4620      	mov	r0, r4
   13806:	f7ff ffc3 	bl	13790 <le_conn_param_neg_reply>
}
   1380a:	b003      	add	sp, #12
   1380c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!le_param_req(conn, &param)) {
   1380e:	4669      	mov	r1, sp
   13810:	f7f1 fa2c 	bl	4c6c <le_param_req>
   13814:	b938      	cbnz	r0, 13826 <le_conn_param_req+0x66>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
   13816:	211e      	movs	r1, #30
   13818:	4620      	mov	r0, r4
   1381a:	f7ff ffb9 	bl	13790 <le_conn_param_neg_reply>
	bt_conn_unref(conn);
   1381e:	4630      	mov	r0, r6
   13820:	f000 f931 	bl	13a86 <bt_conn_unref>
   13824:	e7f1      	b.n	1380a <le_conn_param_req+0x4a>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
   13826:	210e      	movs	r1, #14
   13828:	f242 0020 	movw	r0, #8224	; 0x2020
   1382c:	f7ef ffc2 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
   13830:	4605      	mov	r5, r0
   13832:	2800      	cmp	r0, #0
   13834:	d0f3      	beq.n	1381e <le_conn_param_req+0x5e>
   13836:	210e      	movs	r1, #14
   13838:	3008      	adds	r0, #8
   1383a:	f001 facf 	bl	14ddc <net_buf_simple_add>
   1383e:	4604      	mov	r4, r0
__ssp_bos_icheck3(memset, void *, int)
   13840:	220e      	movs	r2, #14
   13842:	2100      	movs	r1, #0
   13844:	f00a f89a 	bl	1d97c <memset>
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
   13848:	f8bd 3000 	ldrh.w	r3, [sp]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
   1384c:	4629      	mov	r1, r5
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
   1384e:	8063      	strh	r3, [r4, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
   13850:	f8bd 3002 	ldrh.w	r3, [sp, #2]
	cp->handle = sys_cpu_to_le16(handle);
   13854:	8027      	strh	r7, [r4, #0]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
   13856:	80a3      	strh	r3, [r4, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
   13858:	f8bd 3004 	ldrh.w	r3, [sp, #4]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
   1385c:	f242 0020 	movw	r0, #8224	; 0x2020
	cp->latency = sys_cpu_to_le16(param->latency);
   13860:	80e3      	strh	r3, [r4, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
   13862:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   13866:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
   13868:	f7f0 f970 	bl	3b4c <bt_hci_cmd_send>
   1386c:	e7d7      	b.n	1381e <le_conn_param_req+0x5e>

0001386e <bt_addr_le_is_bonded>:
}
   1386e:	2000      	movs	r0, #0
   13870:	4770      	bx	lr

00013872 <le_enh_conn_complete>:
	enh_conn_complete((void *)buf->data);
   13872:	6880      	ldr	r0, [r0, #8]
   13874:	f7f1 b80c 	b.w	4890 <enh_conn_complete>

00013878 <le_legacy_conn_complete>:
{
   13878:	b500      	push	{lr}
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
   1387a:	6881      	ldr	r1, [r0, #8]
{
   1387c:	b08b      	sub	sp, #44	; 0x2c
	enh.status         = evt->status;
   1387e:	780b      	ldrb	r3, [r1, #0]
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   13880:	a803      	add	r0, sp, #12
	enh.status         = evt->status;
   13882:	f88d 3008 	strb.w	r3, [sp, #8]
	enh.handle         = evt->handle;
   13886:	f8b1 3001 	ldrh.w	r3, [r1, #1]
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   1388a:	3104      	adds	r1, #4
	enh.handle         = evt->handle;
   1388c:	f8ad 3009 	strh.w	r3, [sp, #9]
	enh.role           = evt->role;
   13890:	f811 3c01 	ldrb.w	r3, [r1, #-1]
   13894:	f88d 300b 	strb.w	r3, [sp, #11]
	enh.interval       = evt->interval;
   13898:	f8b1 3007 	ldrh.w	r3, [r1, #7]
   1389c:	f8ad 301f 	strh.w	r3, [sp, #31]
	enh.latency        = evt->latency;
   138a0:	f8b1 3009 	ldrh.w	r3, [r1, #9]
   138a4:	f8ad 3021 	strh.w	r3, [sp, #33]	; 0x21
	enh.supv_timeout   = evt->supv_timeout;
   138a8:	f8b1 300b 	ldrh.w	r3, [r1, #11]
   138ac:	f8ad 3023 	strh.w	r3, [sp, #35]	; 0x23
	enh.clock_accuracy = evt->clock_accuracy;
   138b0:	7b4b      	ldrb	r3, [r1, #13]
   138b2:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   138b6:	f7ff fe2f 	bl	13518 <bt_addr_le_copy>
		bt_addr_copy(&enh.local_rpa, BT_ADDR_ANY);
   138ba:	2200      	movs	r2, #0
   138bc:	4669      	mov	r1, sp
   138be:	f10d 0013 	add.w	r0, sp, #19
   138c2:	9200      	str	r2, [sp, #0]
   138c4:	f8ad 2004 	strh.w	r2, [sp, #4]
   138c8:	f7ff fe21 	bl	1350e <bt_addr_copy>
	bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
   138cc:	4669      	mov	r1, sp
   138ce:	f10d 0019 	add.w	r0, sp, #25
   138d2:	9200      	str	r2, [sp, #0]
   138d4:	f8ad 2004 	strh.w	r2, [sp, #4]
   138d8:	f7ff fe19 	bl	1350e <bt_addr_copy>
	enh_conn_complete(&enh);
   138dc:	a802      	add	r0, sp, #8
   138de:	f7f0 ffd7 	bl	4890 <enh_conn_complete>
}
   138e2:	b00b      	add	sp, #44	; 0x2c
   138e4:	f85d fb04 	ldr.w	pc, [sp], #4

000138e8 <tx_notify>:
{
   138e8:	b570      	push	{r4, r5, r6, lr}
   138ea:	4604      	mov	r4, r0
	__asm__ volatile(
   138ec:	f04f 0220 	mov.w	r2, #32
   138f0:	f3ef 8311 	mrs	r3, BASEPRI
   138f4:	f382 8811 	msr	BASEPRI, r2
   138f8:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   138fc:	6a20      	ldr	r0, [r4, #32]
		if (sys_slist_is_empty(&conn->tx_complete)) {
   138fe:	b920      	cbnz	r0, 1390a <tx_notify+0x22>
	__asm__ volatile(
   13900:	f383 8811 	msr	BASEPRI, r3
   13904:	f3bf 8f6f 	isb	sy
}
   13908:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1390a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1390c:	6802      	ldr	r2, [r0, #0]
   1390e:	4288      	cmp	r0, r1
	list->tail = node;
   13910:	bf08      	it	eq
   13912:	6262      	streq	r2, [r4, #36]	; 0x24
	list->head = node;
   13914:	6222      	str	r2, [r4, #32]
   13916:	f383 8811 	msr	BASEPRI, r3
   1391a:	f3bf 8f6f 	isb	sy
		user_data = tx->user_data;
   1391e:	e9d0 5601 	ldrd	r5, r6, [r0, #4]
		tx_free(tx);
   13922:	f7f1 f8c5 	bl	4ab0 <tx_free>
		cb(conn, user_data);
   13926:	4631      	mov	r1, r6
   13928:	4620      	mov	r0, r4
   1392a:	47a8      	blx	r5
	while (1) {
   1392c:	e7de      	b.n	138ec <tx_notify+0x4>

0001392e <tx_complete_work>:
	tx_notify(conn);
   1392e:	3828      	subs	r0, #40	; 0x28
   13930:	f7ff bfda 	b.w	138e8 <tx_notify>

00013934 <bt_conn_new>:
{
   13934:	b538      	push	{r3, r4, r5, lr}
	for (i = 0; i < size; i++) {
   13936:	2200      	movs	r2, #0
   13938:	4603      	mov	r3, r0
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1393a:	2401      	movs	r4, #1
   1393c:	428a      	cmp	r2, r1
   1393e:	d102      	bne.n	13946 <bt_conn_new+0x12>
		return NULL;
   13940:	2300      	movs	r3, #0
}
   13942:	4618      	mov	r0, r3
   13944:	bd38      	pop	{r3, r4, r5, pc}
   13946:	f103 00b8 	add.w	r0, r3, #184	; 0xb8
   1394a:	e8d0 5fef 	ldaex	r5, [r0]
   1394e:	2d00      	cmp	r5, #0
   13950:	d104      	bne.n	1395c <bt_conn_new+0x28>
   13952:	e8c0 4fec 	stlex	ip, r4, [r0]
   13956:	f1bc 0f00 	cmp.w	ip, #0
   1395a:	d1f6      	bne.n	1394a <bt_conn_new+0x16>
   1395c:	f103 00c0 	add.w	r0, r3, #192	; 0xc0
		if (atomic_cas(&conns[i].ref, 0, 1)) {
   13960:	d002      	beq.n	13968 <bt_conn_new+0x34>
	for (i = 0; i < size; i++) {
   13962:	4603      	mov	r3, r0
   13964:	3201      	adds	r2, #1
   13966:	e7e9      	b.n	1393c <bt_conn_new+0x8>
	if (!conn) {
   13968:	2b00      	cmp	r3, #0
   1396a:	d0ea      	beq.n	13942 <bt_conn_new+0xe>
   1396c:	4618      	mov	r0, r3
   1396e:	22b8      	movs	r2, #184	; 0xb8
   13970:	2100      	movs	r1, #0
   13972:	f00a f803 	bl	1d97c <memset>
   13976:	4603      	mov	r3, r0
   13978:	e7e3      	b.n	13942 <bt_conn_new+0xe>

0001397a <bt_conn_get_security>:
}
   1397a:	2001      	movs	r0, #1
   1397c:	4770      	bx	lr

0001397e <bt_conn_reset_rx_state>:
{
   1397e:	b510      	push	{r4, lr}
   13980:	4604      	mov	r4, r0
	if (!conn->rx) {
   13982:	6900      	ldr	r0, [r0, #16]
   13984:	b118      	cbz	r0, 1398e <bt_conn_reset_rx_state+0x10>
	net_buf_unref(conn->rx);
   13986:	f7f2 ffe3 	bl	6950 <net_buf_unref>
	conn->rx = NULL;
   1398a:	2300      	movs	r3, #0
   1398c:	6123      	str	r3, [r4, #16]
}
   1398e:	bd10      	pop	{r4, pc}

00013990 <bt_conn_recv>:
{
   13990:	b570      	push	{r4, r5, r6, lr}
   13992:	4616      	mov	r6, r2
   13994:	4604      	mov	r4, r0
   13996:	460d      	mov	r5, r1
	tx_notify(conn);
   13998:	f7ff ffa6 	bl	138e8 <tx_notify>
	switch (flags) {
   1399c:	2e01      	cmp	r6, #1
   1399e:	d01a      	beq.n	139d6 <bt_conn_recv+0x46>
   139a0:	2e02      	cmp	r6, #2
   139a2:	d11a      	bne.n	139da <bt_conn_recv+0x4a>
		if (conn->rx) {
   139a4:	6923      	ldr	r3, [r4, #16]
   139a6:	b113      	cbz	r3, 139ae <bt_conn_recv+0x1e>
			bt_conn_reset_rx_state(conn);
   139a8:	4620      	mov	r0, r4
   139aa:	f7ff ffe8 	bl	1397e <bt_conn_reset_rx_state>
		conn->rx = buf;
   139ae:	6125      	str	r5, [r4, #16]
	if (conn->rx->len < sizeof(uint16_t)) {
   139b0:	6921      	ldr	r1, [r4, #16]
   139b2:	898a      	ldrh	r2, [r1, #12]
   139b4:	2a01      	cmp	r2, #1
   139b6:	d931      	bls.n	13a1c <bt_conn_recv+0x8c>
	acl_total_len = sys_get_le16(conn->rx->data) + sizeof(struct bt_l2cap_hdr);
   139b8:	6888      	ldr	r0, [r1, #8]
	return ((uint16_t)src[1] << 8) | src[0];
   139ba:	7845      	ldrb	r5, [r0, #1]
   139bc:	7803      	ldrb	r3, [r0, #0]
   139be:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
   139c2:	3304      	adds	r3, #4
   139c4:	b29b      	uxth	r3, r3
	if (conn->rx->len < acl_total_len) {
   139c6:	429a      	cmp	r2, r3
   139c8:	d328      	bcc.n	13a1c <bt_conn_recv+0x8c>
	if (conn->rx->len > acl_total_len) {
   139ca:	d920      	bls.n	13a0e <bt_conn_recv+0x7e>
		bt_conn_reset_rx_state(conn);
   139cc:	4620      	mov	r0, r4
}
   139ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		bt_conn_reset_rx_state(conn);
   139d2:	f7ff bfd4 	b.w	1397e <bt_conn_reset_rx_state>
		if (!conn->rx) {
   139d6:	6920      	ldr	r0, [r4, #16]
   139d8:	b918      	cbnz	r0, 139e2 <bt_conn_recv+0x52>
		bt_conn_reset_rx_state(conn);
   139da:	4620      	mov	r0, r4
   139dc:	f7ff ffcf 	bl	1397e <bt_conn_reset_rx_state>
   139e0:	e001      	b.n	139e6 <bt_conn_recv+0x56>
		if (!buf->len) {
   139e2:	89ae      	ldrh	r6, [r5, #12]
   139e4:	b926      	cbnz	r6, 139f0 <bt_conn_recv+0x60>
		net_buf_unref(buf);
   139e6:	4628      	mov	r0, r5
}
   139e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		net_buf_unref(buf);
   139ec:	f7f2 bfb0 	b.w	6950 <net_buf_unref>
	return net_buf_simple_tailroom(&buf->b);
   139f0:	3008      	adds	r0, #8
   139f2:	f001 fa38 	bl	14e66 <net_buf_simple_tailroom>
		if (buf->len > net_buf_tailroom(conn->rx)) {
   139f6:	4286      	cmp	r6, r0
   139f8:	d8ef      	bhi.n	139da <bt_conn_recv+0x4a>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   139fa:	6920      	ldr	r0, [r4, #16]
   139fc:	89aa      	ldrh	r2, [r5, #12]
   139fe:	68a9      	ldr	r1, [r5, #8]
   13a00:	3008      	adds	r0, #8
   13a02:	f001 f9f1 	bl	14de8 <net_buf_simple_add_mem>
		net_buf_unref(buf);
   13a06:	4628      	mov	r0, r5
   13a08:	f7f2 ffa2 	bl	6950 <net_buf_unref>
		break;
   13a0c:	e7d0      	b.n	139b0 <bt_conn_recv+0x20>
	conn->rx = NULL;
   13a0e:	2300      	movs	r3, #0
	bt_l2cap_recv(conn, buf);
   13a10:	4620      	mov	r0, r4
	conn->rx = NULL;
   13a12:	6123      	str	r3, [r4, #16]
}
   13a14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_l2cap_recv(conn, buf);
   13a18:	f000 b96f 	b.w	13cfa <bt_l2cap_recv>
}
   13a1c:	bd70      	pop	{r4, r5, r6, pc}

00013a1e <bt_conn_is_peer_addr_le>:
{
   13a1e:	b538      	push	{r3, r4, r5, lr}
	if (id != conn->id) {
   13a20:	7a03      	ldrb	r3, [r0, #8]
{
   13a22:	4604      	mov	r4, r0
	if (id != conn->id) {
   13a24:	428b      	cmp	r3, r1
{
   13a26:	4615      	mov	r5, r2
	if (id != conn->id) {
   13a28:	d115      	bne.n	13a56 <bt_conn_is_peer_addr_le+0x38>
	return memcmp(a, b, sizeof(*a));
   13a2a:	f100 0188 	add.w	r1, r0, #136	; 0x88
   13a2e:	2207      	movs	r2, #7
   13a30:	4628      	mov	r0, r5
   13a32:	f009 ff88 	bl	1d946 <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   13a36:	b180      	cbz	r0, 13a5a <bt_conn_is_peer_addr_le+0x3c>
	if (conn->role == BT_HCI_ROLE_MASTER) {
   13a38:	78e3      	ldrb	r3, [r4, #3]
   13a3a:	2207      	movs	r2, #7
   13a3c:	b943      	cbnz	r3, 13a50 <bt_conn_is_peer_addr_le+0x32>
   13a3e:	f104 0196 	add.w	r1, r4, #150	; 0x96
   13a42:	4628      	mov	r0, r5
   13a44:	f009 ff7f 	bl	1d946 <memcmp>
	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
   13a48:	fab0 f080 	clz	r0, r0
   13a4c:	0940      	lsrs	r0, r0, #5
}
   13a4e:	bd38      	pop	{r3, r4, r5, pc}
   13a50:	f104 018f 	add.w	r1, r4, #143	; 0x8f
   13a54:	e7f5      	b.n	13a42 <bt_conn_is_peer_addr_le+0x24>
		return false;
   13a56:	2000      	movs	r0, #0
   13a58:	e7f9      	b.n	13a4e <bt_conn_is_peer_addr_le+0x30>
		return true;
   13a5a:	2001      	movs	r0, #1
   13a5c:	e7f7      	b.n	13a4e <bt_conn_is_peer_addr_le+0x30>

00013a5e <bt_conn_ref>:
{
   13a5e:	b510      	push	{r4, lr}
		old = atomic_get(&conn->ref);
   13a60:	f100 02b8 	add.w	r2, r0, #184	; 0xb8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   13a64:	e8d2 3faf 	lda	r3, [r2]
		if (!old) {
   13a68:	b15b      	cbz	r3, 13a82 <bt_conn_ref+0x24>
	} while (!atomic_cas(&conn->ref, old, old + 1));
   13a6a:	1c59      	adds	r1, r3, #1
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   13a6c:	e8d2 4fef 	ldaex	r4, [r2]
   13a70:	429c      	cmp	r4, r3
   13a72:	d104      	bne.n	13a7e <bt_conn_ref+0x20>
   13a74:	e8c2 1fec 	stlex	ip, r1, [r2]
   13a78:	f1bc 0f00 	cmp.w	ip, #0
   13a7c:	d1f6      	bne.n	13a6c <bt_conn_ref+0xe>
   13a7e:	d1f1      	bne.n	13a64 <bt_conn_ref+0x6>
}
   13a80:	bd10      	pop	{r4, pc}
			return NULL;
   13a82:	4618      	mov	r0, r3
   13a84:	e7fc      	b.n	13a80 <bt_conn_ref+0x22>

00013a86 <bt_conn_unref>:
	atomic_val_t old = atomic_dec(&conn->ref);
   13a86:	30b8      	adds	r0, #184	; 0xb8
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   13a88:	e8d0 3fef 	ldaex	r3, [r0]
   13a8c:	3b01      	subs	r3, #1
   13a8e:	e8c0 3fe2 	stlex	r2, r3, [r0]
   13a92:	2a00      	cmp	r2, #0
   13a94:	d1f8      	bne.n	13a88 <bt_conn_unref+0x2>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   13a96:	e8d0 3faf 	lda	r3, [r0]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   13a9a:	b90b      	cbnz	r3, 13aa0 <bt_conn_unref+0x1a>
		bt_le_adv_resume();
   13a9c:	f7f0 bec2 	b.w	4824 <bt_le_adv_resume>
}
   13aa0:	4770      	bx	lr

00013aa2 <conn_lookup_handle>:
{
   13aa2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13aa6:	4607      	mov	r7, r0
   13aa8:	460e      	mov	r6, r1
   13aaa:	4690      	mov	r8, r2
	for (i = 0; i < size; i++) {
   13aac:	2400      	movs	r4, #0
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   13aae:	f04f 09c0 	mov.w	r9, #192	; 0xc0
	for (i = 0; i < size; i++) {
   13ab2:	42b4      	cmp	r4, r6
   13ab4:	d103      	bne.n	13abe <conn_lookup_handle+0x1c>
	return NULL;
   13ab6:	2300      	movs	r3, #0
}
   13ab8:	4618      	mov	r0, r3
   13aba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   13abe:	fb09 7004 	mla	r0, r9, r4, r7
   13ac2:	f7ff ffcc 	bl	13a5e <bt_conn_ref>
   13ac6:	4603      	mov	r3, r0
		if (!conn) {
   13ac8:	b158      	cbz	r0, 13ae2 <conn_lookup_handle+0x40>
		if (!bt_conn_is_handle_valid(conn)) {
   13aca:	7a85      	ldrb	r5, [r0, #10]
   13acc:	2d01      	cmp	r5, #1
   13ace:	d002      	beq.n	13ad6 <conn_lookup_handle+0x34>
   13ad0:	3d07      	subs	r5, #7
   13ad2:	2d01      	cmp	r5, #1
   13ad4:	d803      	bhi.n	13ade <conn_lookup_handle+0x3c>
		if (conn->handle != handle) {
   13ad6:	881a      	ldrh	r2, [r3, #0]
   13ad8:	4542      	cmp	r2, r8
   13ada:	d0ed      	beq.n	13ab8 <conn_lookup_handle+0x16>
			bt_conn_unref(conn);
   13adc:	4618      	mov	r0, r3
   13ade:	f7ff ffd2 	bl	13a86 <bt_conn_unref>
	for (i = 0; i < size; i++) {
   13ae2:	3401      	adds	r4, #1
   13ae4:	e7e5      	b.n	13ab2 <conn_lookup_handle+0x10>

00013ae6 <bt_conn_exists_le>:
{
   13ae6:	b508      	push	{r3, lr}
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, peer);
   13ae8:	f7f1 fa6a 	bl	4fc0 <bt_conn_lookup_addr_le>
	if (conn) {
   13aec:	b110      	cbz	r0, 13af4 <bt_conn_exists_le+0xe>
		bt_conn_unref(conn);
   13aee:	f7ff ffca 	bl	13a86 <bt_conn_unref>
		return true;
   13af2:	2001      	movs	r0, #1
}
   13af4:	bd08      	pop	{r3, pc}

00013af6 <bt_conn_le_conn_update>:
{
   13af6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13af8:	4607      	mov	r7, r0
   13afa:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   13afc:	f242 0013 	movw	r0, #8211	; 0x2013
   13b00:	210e      	movs	r1, #14
   13b02:	f7ef fe57 	bl	37b4 <bt_hci_cmd_create>
	if (!buf) {
   13b06:	4606      	mov	r6, r0
   13b08:	b1d0      	cbz	r0, 13b40 <bt_conn_le_conn_update+0x4a>
	return net_buf_simple_add(&buf->b, len);
   13b0a:	210e      	movs	r1, #14
   13b0c:	3008      	adds	r0, #8
   13b0e:	f001 f965 	bl	14ddc <net_buf_simple_add>
   13b12:	4604      	mov	r4, r0
   13b14:	220e      	movs	r2, #14
   13b16:	2100      	movs	r1, #0
   13b18:	f009 ff30 	bl	1d97c <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   13b1c:	883b      	ldrh	r3, [r7, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   13b1e:	4631      	mov	r1, r6
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   13b20:	8023      	strh	r3, [r4, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   13b22:	882b      	ldrh	r3, [r5, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   13b24:	2200      	movs	r2, #0
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   13b26:	8063      	strh	r3, [r4, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   13b28:	886b      	ldrh	r3, [r5, #2]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   13b2a:	f242 0013 	movw	r0, #8211	; 0x2013
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   13b2e:	80a3      	strh	r3, [r4, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   13b30:	88ab      	ldrh	r3, [r5, #4]
   13b32:	80e3      	strh	r3, [r4, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   13b34:	88eb      	ldrh	r3, [r5, #6]
   13b36:	8123      	strh	r3, [r4, #8]
}
   13b38:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   13b3c:	f7ef be72 	b.w	3824 <bt_hci_cmd_send_sync>
}
   13b40:	f06f 0068 	mvn.w	r0, #104	; 0x68
   13b44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00013b46 <l2cap_connected>:
}
   13b46:	4770      	bx	lr

00013b48 <l2cap_create_le_sig_pdu.isra.0>:
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
   13b48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13b4a:	4607      	mov	r7, r0
   13b4c:	460e      	mov	r6, r1
   13b4e:	4615      	mov	r5, r2
	return bt_conn_create_pdu_timeout(pool,
   13b50:	2300      	movs	r3, #0
   13b52:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   13b56:	2104      	movs	r1, #4
   13b58:	2000      	movs	r0, #0
   13b5a:	f7f1 fae7 	bl	512c <bt_conn_create_pdu_timeout>
	if (!buf) {
   13b5e:	4604      	mov	r4, r0
   13b60:	b130      	cbz	r0, 13b70 <l2cap_create_le_sig_pdu.isra.0+0x28>
   13b62:	2104      	movs	r1, #4
   13b64:	3008      	adds	r0, #8
   13b66:	f001 f939 	bl	14ddc <net_buf_simple_add>
	hdr->code = code;
   13b6a:	7007      	strb	r7, [r0, #0]
	hdr->ident = ident;
   13b6c:	7046      	strb	r6, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
   13b6e:	8045      	strh	r5, [r0, #2]
}
   13b70:	4620      	mov	r0, r4
   13b72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00013b74 <l2cap_disconnected>:
   13b74:	4770      	bx	lr

00013b76 <bt_l2cap_chan_remove>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   13b76:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
{
   13b78:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   13b7a:	b17b      	cbz	r3, 13b9c <bt_l2cap_chan_remove+0x26>
   13b7c:	2200      	movs	r2, #0
   13b7e:	3b08      	subs	r3, #8
   13b80:	b163      	cbz	r3, 13b9c <bt_l2cap_chan_remove+0x26>
		if (chan == ch) {
   13b82:	428b      	cmp	r3, r1
   13b84:	f103 0408 	add.w	r4, r3, #8
   13b88:	d10f      	bne.n	13baa <bt_l2cap_chan_remove+0x34>
Z_GENLIST_REMOVE(slist, snode)
   13b8a:	688b      	ldr	r3, [r1, #8]
   13b8c:	b93a      	cbnz	r2, 13b9e <bt_l2cap_chan_remove+0x28>
   13b8e:	6d02      	ldr	r2, [r0, #80]	; 0x50
	list->head = node;
   13b90:	64c3      	str	r3, [r0, #76]	; 0x4c
Z_GENLIST_REMOVE(slist, snode)
   13b92:	4294      	cmp	r4, r2
   13b94:	d100      	bne.n	13b98 <bt_l2cap_chan_remove+0x22>
	list->tail = node;
   13b96:	6503      	str	r3, [r0, #80]	; 0x50
	parent->next = child;
   13b98:	2300      	movs	r3, #0
   13b9a:	608b      	str	r3, [r1, #8]
}
   13b9c:	bd10      	pop	{r4, pc}
   13b9e:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   13ba0:	6d03      	ldr	r3, [r0, #80]	; 0x50
   13ba2:	429c      	cmp	r4, r3
	list->tail = node;
   13ba4:	bf08      	it	eq
   13ba6:	6502      	streq	r2, [r0, #80]	; 0x50
}
   13ba8:	e7f6      	b.n	13b98 <bt_l2cap_chan_remove+0x22>
Z_GENLIST_PEEK_NEXT(slist, snode)
   13baa:	2c00      	cmp	r4, #0
   13bac:	d0f6      	beq.n	13b9c <bt_l2cap_chan_remove+0x26>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   13bae:	689b      	ldr	r3, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   13bb0:	2b00      	cmp	r3, #0
   13bb2:	d0f3      	beq.n	13b9c <bt_l2cap_chan_remove+0x26>
   13bb4:	4622      	mov	r2, r4
   13bb6:	3b08      	subs	r3, #8
   13bb8:	e7e2      	b.n	13b80 <bt_l2cap_chan_remove+0xa>

00013bba <bt_l2cap_chan_del>:
{
   13bba:	b570      	push	{r4, r5, r6, lr}
	if (!chan->conn) {
   13bbc:	e9d0 3500 	ldrd	r3, r5, [r0]
{
   13bc0:	4604      	mov	r4, r0
	if (!chan->conn) {
   13bc2:	b123      	cbz	r3, 13bce <bt_l2cap_chan_del+0x14>
	if (ops->disconnected) {
   13bc4:	686b      	ldr	r3, [r5, #4]
   13bc6:	b103      	cbz	r3, 13bca <bt_l2cap_chan_del+0x10>
		ops->disconnected(chan);
   13bc8:	4798      	blx	r3
	chan->conn = NULL;
   13bca:	2300      	movs	r3, #0
   13bcc:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   13bce:	68e3      	ldr	r3, [r4, #12]
   13bd0:	b10b      	cbz	r3, 13bd6 <bt_l2cap_chan_del+0x1c>
		chan->destroy(chan);
   13bd2:	4620      	mov	r0, r4
   13bd4:	4798      	blx	r3
	if (ops->released) {
   13bd6:	69eb      	ldr	r3, [r5, #28]
   13bd8:	b11b      	cbz	r3, 13be2 <bt_l2cap_chan_del+0x28>
		ops->released(chan);
   13bda:	4620      	mov	r0, r4
}
   13bdc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		ops->released(chan);
   13be0:	4718      	bx	r3
}
   13be2:	bd70      	pop	{r4, r5, r6, pc}

00013be4 <l2cap_rtx_timeout>:
	bt_l2cap_chan_remove(conn, &chan->chan);
   13be4:	f1a0 0110 	sub.w	r1, r0, #16
{
   13be8:	b508      	push	{r3, lr}
	bt_l2cap_chan_remove(conn, &chan->chan);
   13bea:	f850 0c10 	ldr.w	r0, [r0, #-16]
   13bee:	f7ff ffc2 	bl	13b76 <bt_l2cap_chan_remove>
}
   13bf2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	bt_l2cap_chan_del(&chan->chan);
   13bf6:	4608      	mov	r0, r1
   13bf8:	f7ff bfdf 	b.w	13bba <bt_l2cap_chan_del>

00013bfc <bt_l2cap_disconnected>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   13bfc:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
{
   13bfe:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   13c00:	b18b      	cbz	r3, 13c26 <bt_l2cap_disconnected+0x2a>
   13c02:	f1b3 0008 	subs.w	r0, r3, #8
   13c06:	d00e      	beq.n	13c26 <bt_l2cap_disconnected+0x2a>
   13c08:	681c      	ldr	r4, [r3, #0]
   13c0a:	b104      	cbz	r4, 13c0e <bt_l2cap_disconnected+0x12>
   13c0c:	3c08      	subs	r4, #8
		bt_l2cap_chan_del(chan);
   13c0e:	f7ff ffd4 	bl	13bba <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   13c12:	b144      	cbz	r4, 13c26 <bt_l2cap_disconnected+0x2a>
Z_GENLIST_PEEK_NEXT(slist, snode)
   13c14:	f114 0308 	adds.w	r3, r4, #8
   13c18:	d002      	beq.n	13c20 <bt_l2cap_disconnected+0x24>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   13c1a:	68a3      	ldr	r3, [r4, #8]
   13c1c:	b103      	cbz	r3, 13c20 <bt_l2cap_disconnected+0x24>
   13c1e:	3b08      	subs	r3, #8
{
   13c20:	4620      	mov	r0, r4
   13c22:	461c      	mov	r4, r3
   13c24:	e7f3      	b.n	13c0e <bt_l2cap_disconnected+0x12>
}
   13c26:	bd10      	pop	{r4, pc}

00013c28 <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
   13c28:	3104      	adds	r1, #4
   13c2a:	f7f1 ba7f 	b.w	512c <bt_conn_create_pdu_timeout>

00013c2e <bt_l2cap_send_cb>:
{
   13c2e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13c32:	4614      	mov	r4, r2
   13c34:	4605      	mov	r5, r0
   13c36:	460f      	mov	r7, r1
	return net_buf_simple_push(&buf->b, len);
   13c38:	f102 0008 	add.w	r0, r2, #8
   13c3c:	2104      	movs	r1, #4
   13c3e:	461e      	mov	r6, r3
   13c40:	f8dd 8018 	ldr.w	r8, [sp, #24]
   13c44:	f001 f8e2 	bl	14e0c <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   13c48:	89a2      	ldrh	r2, [r4, #12]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   13c4a:	4643      	mov	r3, r8
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   13c4c:	3a04      	subs	r2, #4
   13c4e:	8002      	strh	r2, [r0, #0]
	hdr->cid = sys_cpu_to_le16(cid);
   13c50:	8047      	strh	r7, [r0, #2]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   13c52:	4632      	mov	r2, r6
   13c54:	4621      	mov	r1, r4
   13c56:	4628      	mov	r0, r5
}
   13c58:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_conn_send_cb(conn, buf, cb, user_data);
   13c5c:	f7f1 b850 	b.w	4d00 <bt_conn_send_cb>

00013c60 <l2cap_recv>:
	if (buf->len < sizeof(*hdr)) {
   13c60:	898b      	ldrh	r3, [r1, #12]
{
   13c62:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (buf->len < sizeof(*hdr)) {
   13c64:	2b03      	cmp	r3, #3
{
   13c66:	4605      	mov	r5, r0
   13c68:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
   13c6a:	d923      	bls.n	13cb4 <l2cap_recv+0x54>
	return net_buf_simple_pull_mem(&buf->b, len);
   13c6c:	2104      	movs	r1, #4
   13c6e:	f104 0008 	add.w	r0, r4, #8
   13c72:	f001 f8e4 	bl	14e3e <net_buf_simple_pull_mem>
	if (buf->len != len) {
   13c76:	89a3      	ldrh	r3, [r4, #12]
   13c78:	8842      	ldrh	r2, [r0, #2]
   13c7a:	429a      	cmp	r2, r3
   13c7c:	d11a      	bne.n	13cb4 <l2cap_recv+0x54>
	if (!hdr->ident) {
   13c7e:	7841      	ldrb	r1, [r0, #1]
   13c80:	b1c1      	cbz	r1, 13cb4 <l2cap_recv+0x54>
	switch (hdr->code) {
   13c82:	7803      	ldrb	r3, [r0, #0]
   13c84:	2b01      	cmp	r3, #1
   13c86:	d015      	beq.n	13cb4 <l2cap_recv+0x54>
   13c88:	2b13      	cmp	r3, #19
   13c8a:	d013      	beq.n	13cb4 <l2cap_recv+0x54>
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   13c8c:	2202      	movs	r2, #2
   13c8e:	2001      	movs	r0, #1
		l2cap_send_reject(chan->conn, hdr->ident,
   13c90:	682d      	ldr	r5, [r5, #0]
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   13c92:	f7ff ff59 	bl	13b48 <l2cap_create_le_sig_pdu.isra.0>
	if (!buf) {
   13c96:	4604      	mov	r4, r0
   13c98:	b160      	cbz	r0, 13cb4 <l2cap_recv+0x54>
	return net_buf_simple_add(&buf->b, len);
   13c9a:	2102      	movs	r1, #2
   13c9c:	3008      	adds	r0, #8
   13c9e:	f001 f89d 	bl	14ddc <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
   13ca2:	2300      	movs	r3, #0
   13ca4:	4622      	mov	r2, r4
   13ca6:	7003      	strb	r3, [r0, #0]
   13ca8:	7043      	strb	r3, [r0, #1]
   13caa:	2105      	movs	r1, #5
   13cac:	4628      	mov	r0, r5
   13cae:	9300      	str	r3, [sp, #0]
   13cb0:	f7ff ffbd 	bl	13c2e <bt_l2cap_send_cb>
}
   13cb4:	2000      	movs	r0, #0
   13cb6:	b003      	add	sp, #12
   13cb8:	bd30      	pop	{r4, r5, pc}

00013cba <bt_l2cap_le_lookup_tx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   13cba:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
   13cbc:	b160      	cbz	r0, 13cd8 <bt_l2cap_le_lookup_tx_cid+0x1e>
   13cbe:	3808      	subs	r0, #8
   13cc0:	b900      	cbnz	r0, 13cc4 <bt_l2cap_le_lookup_tx_cid+0xa>
   13cc2:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
   13cc4:	f8b0 3054 	ldrh.w	r3, [r0, #84]	; 0x54
   13cc8:	428b      	cmp	r3, r1
   13cca:	d005      	beq.n	13cd8 <bt_l2cap_le_lookup_tx_cid+0x1e>
Z_GENLIST_PEEK_NEXT(slist, snode)
   13ccc:	f110 0308 	adds.w	r3, r0, #8
   13cd0:	d001      	beq.n	13cd6 <bt_l2cap_le_lookup_tx_cid+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   13cd2:	6880      	ldr	r0, [r0, #8]
   13cd4:	e7f2      	b.n	13cbc <bt_l2cap_le_lookup_tx_cid+0x2>
	return NULL;
   13cd6:	4618      	mov	r0, r3
}
   13cd8:	4770      	bx	lr

00013cda <bt_l2cap_le_lookup_rx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   13cda:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
   13cdc:	b160      	cbz	r0, 13cf8 <bt_l2cap_le_lookup_rx_cid+0x1e>
   13cde:	3808      	subs	r0, #8
   13ce0:	b900      	cbnz	r0, 13ce4 <bt_l2cap_le_lookup_rx_cid+0xa>
   13ce2:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   13ce4:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
   13ce8:	428b      	cmp	r3, r1
   13cea:	d005      	beq.n	13cf8 <bt_l2cap_le_lookup_rx_cid+0x1e>
Z_GENLIST_PEEK_NEXT(slist, snode)
   13cec:	f110 0308 	adds.w	r3, r0, #8
   13cf0:	d001      	beq.n	13cf6 <bt_l2cap_le_lookup_rx_cid+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   13cf2:	6880      	ldr	r0, [r0, #8]
   13cf4:	e7f2      	b.n	13cdc <bt_l2cap_le_lookup_rx_cid+0x2>
	return NULL;
   13cf6:	4618      	mov	r0, r3
}
   13cf8:	4770      	bx	lr

00013cfa <bt_l2cap_recv>:
{
   13cfa:	b538      	push	{r3, r4, r5, lr}
	if (buf->len < sizeof(*hdr)) {
   13cfc:	898b      	ldrh	r3, [r1, #12]
{
   13cfe:	4605      	mov	r5, r0
	if (buf->len < sizeof(*hdr)) {
   13d00:	2b03      	cmp	r3, #3
{
   13d02:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
   13d04:	d804      	bhi.n	13d10 <bt_l2cap_recv+0x16>
	net_buf_unref(buf);
   13d06:	4620      	mov	r0, r4
}
   13d08:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	net_buf_unref(buf);
   13d0c:	f7f2 be20 	b.w	6950 <net_buf_unref>
	return net_buf_simple_pull_mem(&buf->b, len);
   13d10:	2104      	movs	r1, #4
   13d12:	f104 0008 	add.w	r0, r4, #8
   13d16:	f001 f892 	bl	14e3e <net_buf_simple_pull_mem>
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
   13d1a:	8841      	ldrh	r1, [r0, #2]
   13d1c:	4628      	mov	r0, r5
   13d1e:	f7ff ffdc 	bl	13cda <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   13d22:	2800      	cmp	r0, #0
   13d24:	d0ef      	beq.n	13d06 <bt_l2cap_recv+0xc>
	chan->ops->recv(chan, buf);
   13d26:	6843      	ldr	r3, [r0, #4]
   13d28:	4621      	mov	r1, r4
   13d2a:	691b      	ldr	r3, [r3, #16]
   13d2c:	4798      	blx	r3
   13d2e:	e7ea      	b.n	13d06 <bt_l2cap_recv+0xc>

00013d30 <bt_l2cap_init>:
void bt_l2cap_init(void)
{
	if (IS_ENABLED(CONFIG_BT_BREDR)) {
		bt_l2cap_br_init();
	}
}
   13d30:	4770      	bx	lr

00013d32 <sys_slist_get>:
Z_GENLIST_GET(slist, snode)
   13d32:	4603      	mov	r3, r0
Z_GENLIST_IS_EMPTY(slist)
   13d34:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_GET(slist, snode)
   13d36:	b128      	cbz	r0, 13d44 <sys_slist_get+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   13d38:	6859      	ldr	r1, [r3, #4]
   13d3a:	6802      	ldr	r2, [r0, #0]
   13d3c:	4288      	cmp	r0, r1
	list->head = node;
   13d3e:	601a      	str	r2, [r3, #0]
	list->tail = node;
   13d40:	bf08      	it	eq
   13d42:	605a      	streq	r2, [r3, #4]
Z_GENLIST_GET(slist, snode)
   13d44:	4770      	bx	lr

00013d46 <sys_slist_find_and_remove>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   13d46:	2200      	movs	r2, #0
   13d48:	4603      	mov	r3, r0
   13d4a:	6800      	ldr	r0, [r0, #0]
   13d4c:	b900      	cbnz	r0, 13d50 <sys_slist_find_and_remove+0xa>
   13d4e:	4770      	bx	lr
   13d50:	4288      	cmp	r0, r1
   13d52:	d110      	bne.n	13d76 <sys_slist_find_and_remove+0x30>
Z_GENLIST_REMOVE(slist, snode)
   13d54:	6808      	ldr	r0, [r1, #0]
   13d56:	b942      	cbnz	r2, 13d6a <sys_slist_find_and_remove+0x24>
   13d58:	685a      	ldr	r2, [r3, #4]
	list->head = node;
   13d5a:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   13d5c:	4291      	cmp	r1, r2
   13d5e:	d100      	bne.n	13d62 <sys_slist_find_and_remove+0x1c>
	list->tail = node;
   13d60:	6058      	str	r0, [r3, #4]
	parent->next = child;
   13d62:	2300      	movs	r3, #0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   13d64:	2001      	movs	r0, #1
	parent->next = child;
   13d66:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   13d68:	4770      	bx	lr
	parent->next = child;
   13d6a:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   13d6c:	6858      	ldr	r0, [r3, #4]
   13d6e:	4281      	cmp	r1, r0
	list->tail = node;
   13d70:	bf08      	it	eq
   13d72:	605a      	streq	r2, [r3, #4]
}
   13d74:	e7f5      	b.n	13d62 <sys_slist_find_and_remove+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   13d76:	4602      	mov	r2, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   13d78:	6800      	ldr	r0, [r0, #0]
   13d7a:	e7e7      	b.n	13d4c <sys_slist_find_and_remove+0x6>

00013d7c <net_buf_frags_len>:
 * @param buf Buffer to start off with.
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
   13d7c:	4603      	mov	r3, r0
	size_t bytes = 0;
   13d7e:	2000      	movs	r0, #0

	while (buf) {
   13d80:	b903      	cbnz	r3, 13d84 <net_buf_frags_len+0x8>
		bytes += buf->len;
		buf = buf->frags;
	}

	return bytes;
}
   13d82:	4770      	bx	lr
		bytes += buf->len;
   13d84:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
   13d86:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   13d88:	4410      	add	r0, r2
		buf = buf->frags;
   13d8a:	e7f9      	b.n	13d80 <net_buf_frags_len+0x4>

00013d8c <att_sent>:
	if (chan->ops->sent) {
   13d8c:	684b      	ldr	r3, [r1, #4]
{
   13d8e:	4608      	mov	r0, r1
	if (chan->ops->sent) {
   13d90:	695b      	ldr	r3, [r3, #20]
   13d92:	b103      	cbz	r3, 13d96 <att_sent+0xa>
		chan->ops->sent(chan);
   13d94:	4718      	bx	r3
}
   13d96:	4770      	bx	lr

00013d98 <attr_read_type_cb>:
{
   13d98:	b510      	push	{r4, lr}
	if (!data->rsp->len) {
   13d9a:	68d4      	ldr	r4, [r2, #12]
   13d9c:	3102      	adds	r1, #2
   13d9e:	7823      	ldrb	r3, [r4, #0]
   13da0:	b913      	cbnz	r3, 13da8 <attr_read_type_cb+0x10>
		data->rsp->len = read + sizeof(*data->item);
   13da2:	7021      	strb	r1, [r4, #0]
	return true;
   13da4:	2001      	movs	r0, #1
   13da6:	e006      	b.n	13db6 <attr_read_type_cb+0x1e>
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   13da8:	428b      	cmp	r3, r1
   13daa:	d0fb      	beq.n	13da4 <attr_read_type_cb+0xc>
		frag->len -= sizeof(*data->item);
   13dac:	8983      	ldrh	r3, [r0, #12]
   13dae:	3b02      	subs	r3, #2
   13db0:	8183      	strh	r3, [r0, #12]
		data->item = NULL;
   13db2:	2000      	movs	r0, #0
   13db4:	6110      	str	r0, [r2, #16]
}
   13db6:	bd10      	pop	{r4, pc}

00013db8 <att_prepare_write_req>:
}
   13db8:	2006      	movs	r0, #6
   13dba:	4770      	bx	lr

00013dbc <att_op_get_type>:
	switch (op) {
   13dbc:	281e      	cmp	r0, #30
   13dbe:	d816      	bhi.n	13dee <att_op_get_type+0x32>
   13dc0:	b308      	cbz	r0, 13e06 <att_op_get_type+0x4a>
   13dc2:	1e43      	subs	r3, r0, #1
   13dc4:	2b1d      	cmp	r3, #29
   13dc6:	d81e      	bhi.n	13e06 <att_op_get_type+0x4a>
   13dc8:	e8df f003 	tbb	[pc, r3]
   13dcc:	23172317 	.word	0x23172317
   13dd0:	23172317 	.word	0x23172317
   13dd4:	23172317 	.word	0x23172317
   13dd8:	23172317 	.word	0x23172317
   13ddc:	1d172317 	.word	0x1d172317
   13de0:	2317231d 	.word	0x2317231d
   13de4:	1d191d17 	.word	0x1d191d17
   13de8:	0f1b      	.short	0x0f1b
   13dea:	2004      	movs	r0, #4
   13dec:	4770      	bx	lr
   13dee:	f000 037f 	and.w	r3, r0, #127	; 0x7f
   13df2:	2b52      	cmp	r3, #82	; 0x52
   13df4:	d107      	bne.n	13e06 <att_op_get_type+0x4a>
		return ATT_COMMAND;
   13df6:	2000      	movs	r0, #0
}
   13df8:	4770      	bx	lr
		return ATT_RESPONSE;
   13dfa:	2002      	movs	r0, #2
   13dfc:	4770      	bx	lr
		return ATT_NOTIFICATION;
   13dfe:	2003      	movs	r0, #3
   13e00:	4770      	bx	lr
		return ATT_INDICATION;
   13e02:	2005      	movs	r0, #5
   13e04:	4770      	bx	lr
		return ATT_COMMAND;
   13e06:	f010 0f40 	tst.w	r0, #64	; 0x40
   13e0a:	bf0c      	ite	eq
   13e0c:	2006      	moveq	r0, #6
   13e0e:	2000      	movne	r0, #0
   13e10:	4770      	bx	lr
		return ATT_REQUEST;
   13e12:	2001      	movs	r0, #1
   13e14:	4770      	bx	lr

00013e16 <bt_gatt_foreach_attr>:
{
   13e16:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   13e18:	e9cd 2301 	strd	r2, r3, [sp, #4]
   13e1c:	2300      	movs	r3, #0
   13e1e:	461a      	mov	r2, r3
   13e20:	9300      	str	r3, [sp, #0]
   13e22:	f7f2 fa77 	bl	6314 <bt_gatt_foreach_attr_type>
}
   13e26:	b005      	add	sp, #20
   13e28:	f85d fb04 	ldr.w	pc, [sp], #4

00013e2c <att_chan_read>:
{
   13e2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13e30:	4680      	mov	r8, r0
   13e32:	b085      	sub	sp, #20
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   13e34:	4610      	mov	r0, r2
{
   13e36:	4699      	mov	r9, r3
   13e38:	468b      	mov	fp, r1
   13e3a:	4616      	mov	r6, r2
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   13e3c:	f7ff ff9e 	bl	13d7c <net_buf_frags_len>
   13e40:	f8b8 305e 	ldrh.w	r3, [r8, #94]	; 0x5e
   13e44:	4283      	cmp	r3, r0
   13e46:	d97a      	bls.n	13f3e <att_chan_read+0x112>
	struct bt_conn *conn = chan->chan.chan.conn;
   13e48:	f8d8 3008 	ldr.w	r3, [r8, #8]
	frag = net_buf_frag_last(buf);
   13e4c:	4630      	mov	r0, r6
	struct bt_conn *conn = chan->chan.chan.conn;
   13e4e:	9303      	str	r3, [sp, #12]
	frag = net_buf_frag_last(buf);
   13e50:	f000 ffa2 	bl	14d98 <net_buf_frag_last>
	size_t len, total = 0;
   13e54:	f04f 0a00 	mov.w	sl, #0
	frag = net_buf_frag_last(buf);
   13e58:	4605      	mov	r5, r0
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   13e5a:	4630      	mov	r0, r6
   13e5c:	f7ff ff8e 	bl	13d7c <net_buf_frags_len>
   13e60:	f8b8 405e 	ldrh.w	r4, [r8, #94]	; 0x5e
	return net_buf_simple_tailroom(&buf->b);
   13e64:	f105 0708 	add.w	r7, r5, #8
   13e68:	1a24      	subs	r4, r4, r0
   13e6a:	4638      	mov	r0, r7
   13e6c:	f000 fffb 	bl	14e66 <net_buf_simple_tailroom>
   13e70:	4284      	cmp	r4, r0
   13e72:	d211      	bcs.n	13e98 <att_chan_read+0x6c>
   13e74:	4630      	mov	r0, r6
   13e76:	f7ff ff81 	bl	13d7c <net_buf_frags_len>
   13e7a:	f8b8 405e 	ldrh.w	r4, [r8, #94]	; 0x5e
   13e7e:	1a24      	subs	r4, r4, r0
		if (!len) {
   13e80:	bb34      	cbnz	r4, 13ed0 <att_chan_read+0xa4>
			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id),
   13e82:	79b0      	ldrb	r0, [r6, #6]
   13e84:	f7f2 fca8 	bl	67d8 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   13e88:	2200      	movs	r2, #0
   13e8a:	2300      	movs	r3, #0
   13e8c:	f000 ff50 	bl	14d30 <net_buf_alloc_fixed>
			if (!frag) {
   13e90:	4605      	mov	r5, r0
   13e92:	b930      	cbnz	r0, 13ea2 <att_chan_read+0x76>
	return total;
   13e94:	4657      	mov	r7, sl
   13e96:	e02c      	b.n	13ef2 <att_chan_read+0xc6>
	return net_buf_simple_tailroom(&buf->b);
   13e98:	4638      	mov	r0, r7
   13e9a:	f000 ffe4 	bl	14e66 <net_buf_simple_tailroom>
   13e9e:	4604      	mov	r4, r0
   13ea0:	e7ee      	b.n	13e80 <att_chan_read+0x54>
			net_buf_frag_add(buf, frag);
   13ea2:	4601      	mov	r1, r0
   13ea4:	4630      	mov	r0, r6
   13ea6:	f000 ff88 	bl	14dba <net_buf_frag_add>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   13eaa:	4630      	mov	r0, r6
   13eac:	f7ff ff66 	bl	13d7c <net_buf_frags_len>
   13eb0:	f8b8 405e 	ldrh.w	r4, [r8, #94]	; 0x5e
   13eb4:	f105 0708 	add.w	r7, r5, #8
   13eb8:	1a24      	subs	r4, r4, r0
   13eba:	4638      	mov	r0, r7
   13ebc:	f000 ffd3 	bl	14e66 <net_buf_simple_tailroom>
   13ec0:	4284      	cmp	r4, r0
   13ec2:	d21a      	bcs.n	13efa <att_chan_read+0xce>
   13ec4:	4630      	mov	r0, r6
   13ec6:	f7ff ff59 	bl	13d7c <net_buf_frags_len>
   13eca:	f8b8 405e 	ldrh.w	r4, [r8, #94]	; 0x5e
   13ece:	1a24      	subs	r4, r4, r0
		read = attr->read(conn, attr, frag->data + frag->len, len,
   13ed0:	68a9      	ldr	r1, [r5, #8]
   13ed2:	89aa      	ldrh	r2, [r5, #12]
   13ed4:	f8db 7004 	ldr.w	r7, [fp, #4]
   13ed8:	440a      	add	r2, r1
   13eda:	9803      	ldr	r0, [sp, #12]
   13edc:	4659      	mov	r1, fp
   13ede:	f8cd 9000 	str.w	r9, [sp]
   13ee2:	b2a3      	uxth	r3, r4
   13ee4:	47b8      	blx	r7
		if (read < 0) {
   13ee6:	1e07      	subs	r7, r0, #0
   13ee8:	da0c      	bge.n	13f04 <att_chan_read+0xd8>
				return total;
   13eea:	f1ba 0f00 	cmp.w	sl, #0
   13eee:	bf18      	it	ne
   13ef0:	4657      	movne	r7, sl
}
   13ef2:	4638      	mov	r0, r7
   13ef4:	b005      	add	sp, #20
   13ef6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13efa:	4638      	mov	r0, r7
   13efc:	f000 ffb3 	bl	14e66 <net_buf_simple_tailroom>
   13f00:	4604      	mov	r4, r0
   13f02:	e7e5      	b.n	13ed0 <att_chan_read+0xa4>
		if (cb && !cb(frag, read, user_data)) {
   13f04:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   13f06:	b993      	cbnz	r3, 13f2e <att_chan_read+0x102>
	return net_buf_simple_add(&buf->b, len);
   13f08:	4639      	mov	r1, r7
   13f0a:	f105 0008 	add.w	r0, r5, #8
   13f0e:	f000 ff65 	bl	14ddc <net_buf_simple_add>
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   13f12:	4630      	mov	r0, r6
   13f14:	f7ff ff32 	bl	13d7c <net_buf_frags_len>
   13f18:	f8b8 305e 	ldrh.w	r3, [r8, #94]	; 0x5e
		offset += read;
   13f1c:	44b9      	add	r9, r7
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   13f1e:	4283      	cmp	r3, r0
		total += read;
   13f20:	44ba      	add	sl, r7
		offset += read;
   13f22:	fa1f f989 	uxth.w	r9, r9
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   13f26:	d9b5      	bls.n	13e94 <att_chan_read+0x68>
   13f28:	42a7      	cmp	r7, r4
   13f2a:	d096      	beq.n	13e5a <att_chan_read+0x2e>
   13f2c:	e7b2      	b.n	13e94 <att_chan_read+0x68>
		if (cb && !cb(frag, read, user_data)) {
   13f2e:	4639      	mov	r1, r7
   13f30:	4628      	mov	r0, r5
   13f32:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   13f34:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   13f36:	4798      	blx	r3
   13f38:	2800      	cmp	r0, #0
   13f3a:	d1e5      	bne.n	13f08 <att_chan_read+0xdc>
   13f3c:	e7aa      	b.n	13e94 <att_chan_read+0x68>
		return 0;
   13f3e:	2700      	movs	r7, #0
   13f40:	e7d7      	b.n	13ef2 <att_chan_read+0xc6>

00013f42 <find_type_cb>:
{
   13f42:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   13f46:	f642 0301 	movw	r3, #10241	; 0x2801
   13f4a:	2500      	movs	r5, #0
{
   13f4c:	b091      	sub	sp, #68	; 0x44
	struct bt_att_chan *chan = data->chan;
   13f4e:	f8d2 9000 	ldr.w	r9, [r2]
{
   13f52:	4607      	mov	r7, r0
   13f54:	460e      	mov	r6, r1
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   13f56:	6800      	ldr	r0, [r0, #0]
   13f58:	a90b      	add	r1, sp, #44	; 0x2c
	struct bt_conn *conn = chan->chan.chan.conn;
   13f5a:	f8d9 8008 	ldr.w	r8, [r9, #8]
{
   13f5e:	4614      	mov	r4, r2
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   13f60:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
   13f64:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
   13f68:	f7ff f997 	bl	1329a <bt_uuid_cmp>
   13f6c:	2800      	cmp	r0, #0
   13f6e:	d079      	beq.n	14064 <find_type_cb+0x122>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
   13f70:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   13f74:	6838      	ldr	r0, [r7, #0]
   13f76:	a90b      	add	r1, sp, #44	; 0x2c
   13f78:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
   13f7c:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
   13f80:	f7ff f98b 	bl	1329a <bt_uuid_cmp>
   13f84:	b138      	cbz	r0, 13f96 <find_type_cb+0x54>
		if (data->group &&
   13f86:	68a3      	ldr	r3, [r4, #8]
   13f88:	b11b      	cbz	r3, 13f92 <find_type_cb+0x50>
   13f8a:	885a      	ldrh	r2, [r3, #2]
   13f8c:	42b2      	cmp	r2, r6
   13f8e:	d200      	bcs.n	13f92 <find_type_cb+0x50>
			data->group->end_handle = sys_cpu_to_le16(handle);
   13f90:	805e      	strh	r6, [r3, #2]
	return BT_GATT_ITER_CONTINUE;
   13f92:	2001      	movs	r0, #1
   13f94:	e009      	b.n	13faa <find_type_cb+0x68>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
   13f96:	6861      	ldr	r1, [r4, #4]
   13f98:	4608      	mov	r0, r1
   13f9a:	f7ff feef 	bl	13d7c <net_buf_frags_len>
   13f9e:	f8b9 305e 	ldrh.w	r3, [r9, #94]	; 0x5e
   13fa2:	1a1b      	subs	r3, r3, r0
   13fa4:	2b03      	cmp	r3, #3
   13fa6:	d803      	bhi.n	13fb0 <find_type_cb+0x6e>
		return BT_GATT_ITER_STOP;
   13fa8:	2000      	movs	r0, #0
}
   13faa:	b011      	add	sp, #68	; 0x44
   13fac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	frag = net_buf_frag_last(data->buf);
   13fb0:	4608      	mov	r0, r1
   13fb2:	f000 fef1 	bl	14d98 <net_buf_frag_last>
   13fb6:	4605      	mov	r5, r0
	len = MIN(chan->chan.tx.mtu - net_buf_frags_len(data->buf),
   13fb8:	6860      	ldr	r0, [r4, #4]
   13fba:	f7ff fedf 	bl	13d7c <net_buf_frags_len>
   13fbe:	f8b9 a05e 	ldrh.w	sl, [r9, #94]	; 0x5e
	return net_buf_simple_tailroom(&buf->b);
   13fc2:	f105 0b08 	add.w	fp, r5, #8
   13fc6:	ebaa 0a00 	sub.w	sl, sl, r0
   13fca:	4658      	mov	r0, fp
   13fcc:	f000 ff4b 	bl	14e66 <net_buf_simple_tailroom>
   13fd0:	4550      	cmp	r0, sl
   13fd2:	d93f      	bls.n	14054 <find_type_cb+0x112>
   13fd4:	6860      	ldr	r0, [r4, #4]
   13fd6:	f7ff fed1 	bl	13d7c <net_buf_frags_len>
   13fda:	f8b9 305e 	ldrh.w	r3, [r9, #94]	; 0x5e
   13fde:	1a18      	subs	r0, r3, r0
	if (!len) {
   13fe0:	b970      	cbnz	r0, 14000 <find_type_cb+0xbe>
		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id),
   13fe2:	6863      	ldr	r3, [r4, #4]
   13fe4:	7998      	ldrb	r0, [r3, #6]
   13fe6:	f7f2 fbf7 	bl	67d8 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   13fea:	2200      	movs	r2, #0
   13fec:	2300      	movs	r3, #0
   13fee:	f000 fe9f 	bl	14d30 <net_buf_alloc_fixed>
		if (!frag) {
   13ff2:	4605      	mov	r5, r0
   13ff4:	2800      	cmp	r0, #0
   13ff6:	d0d7      	beq.n	13fa8 <find_type_cb+0x66>
		net_buf_frag_add(data->buf, frag);
   13ff8:	4601      	mov	r1, r0
   13ffa:	6860      	ldr	r0, [r4, #4]
   13ffc:	f000 fedd 	bl	14dba <net_buf_frag_add>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
   14000:	2300      	movs	r3, #0
   14002:	9300      	str	r3, [sp, #0]
   14004:	4639      	mov	r1, r7
   14006:	f8d7 9004 	ldr.w	r9, [r7, #4]
   1400a:	2310      	movs	r3, #16
   1400c:	4640      	mov	r0, r8
   1400e:	aa02      	add	r2, sp, #8
   14010:	47c8      	blx	r9
	if (read < 0) {
   14012:	1e07      	subs	r7, r0, #0
   14014:	db26      	blt.n	14064 <find_type_cb+0x122>
	if (read != data->value_len) {
   14016:	7c22      	ldrb	r2, [r4, #16]
   14018:	68e0      	ldr	r0, [r4, #12]
   1401a:	42ba      	cmp	r2, r7
   1401c:	d01e      	beq.n	1405c <find_type_cb+0x11a>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
   1401e:	4601      	mov	r1, r0
   14020:	a80b      	add	r0, sp, #44	; 0x2c
   14022:	f7ff f964 	bl	132ee <bt_uuid_create>
   14026:	b1e8      	cbz	r0, 14064 <find_type_cb+0x122>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
   14028:	b2fa      	uxtb	r2, r7
   1402a:	a902      	add	r1, sp, #8
   1402c:	a806      	add	r0, sp, #24
   1402e:	f7ff f95e 	bl	132ee <bt_uuid_create>
   14032:	b1b8      	cbz	r0, 14064 <find_type_cb+0x122>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
   14034:	a906      	add	r1, sp, #24
   14036:	a80b      	add	r0, sp, #44	; 0x2c
   14038:	f7ff f92f 	bl	1329a <bt_uuid_cmp>
	} else if (memcmp(data->value, uuid, read)) {
   1403c:	b990      	cbnz	r0, 14064 <find_type_cb+0x122>
	data->err = 0x00;
   1403e:	2300      	movs	r3, #0
	return net_buf_simple_add(&buf->b, len);
   14040:	2104      	movs	r1, #4
   14042:	7463      	strb	r3, [r4, #17]
   14044:	f105 0008 	add.w	r0, r5, #8
   14048:	f000 fec8 	bl	14ddc <net_buf_simple_add>
	data->group = net_buf_add(frag, sizeof(*data->group));
   1404c:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(handle);
   1404e:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
   14050:	8046      	strh	r6, [r0, #2]
	return BT_GATT_ITER_CONTINUE;
   14052:	e79e      	b.n	13f92 <find_type_cb+0x50>
	return net_buf_simple_tailroom(&buf->b);
   14054:	4658      	mov	r0, fp
   14056:	f000 ff06 	bl	14e66 <net_buf_simple_tailroom>
   1405a:	e7c1      	b.n	13fe0 <find_type_cb+0x9e>
	} else if (memcmp(data->value, uuid, read)) {
   1405c:	a902      	add	r1, sp, #8
   1405e:	f009 fc72 	bl	1d946 <memcmp>
   14062:	e7eb      	b.n	1403c <find_type_cb+0xfa>
	data->group = NULL;
   14064:	2300      	movs	r3, #0
   14066:	60a3      	str	r3, [r4, #8]
   14068:	e793      	b.n	13f92 <find_type_cb+0x50>

0001406a <attr_read_group_cb>:
	if (!data->rsp->len) {
   1406a:	68d0      	ldr	r0, [r2, #12]
   1406c:	3104      	adds	r1, #4
   1406e:	7803      	ldrb	r3, [r0, #0]
   14070:	b913      	cbnz	r3, 14078 <attr_read_group_cb+0xe>
		data->rsp->len = read + sizeof(*data->group);
   14072:	7001      	strb	r1, [r0, #0]
	return true;
   14074:	2001      	movs	r0, #1
}
   14076:	4770      	bx	lr
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   14078:	428b      	cmp	r3, r1
   1407a:	d0fb      	beq.n	14074 <attr_read_group_cb+0xa>
		data->group = NULL;
   1407c:	2000      	movs	r0, #0
		data->buf->len -= sizeof(*data->group);
   1407e:	6891      	ldr	r1, [r2, #8]
   14080:	898b      	ldrh	r3, [r1, #12]
   14082:	3b04      	subs	r3, #4
   14084:	818b      	strh	r3, [r1, #12]
		data->group = NULL;
   14086:	6110      	str	r0, [r2, #16]
		return false;
   14088:	4770      	bx	lr

0001408a <process_queue>:
{
   1408a:	b570      	push	{r4, r5, r6, lr}
	buf = net_buf_get(queue, K_NO_WAIT);
   1408c:	2200      	movs	r2, #0
{
   1408e:	4604      	mov	r4, r0
	buf = net_buf_get(queue, K_NO_WAIT);
   14090:	2300      	movs	r3, #0
   14092:	4608      	mov	r0, r1
{
   14094:	460e      	mov	r6, r1
	buf = net_buf_get(queue, K_NO_WAIT);
   14096:	f000 fe50 	bl	14d3a <net_buf_get>
	if (buf) {
   1409a:	4605      	mov	r5, r0
   1409c:	b160      	cbz	r0, 140b8 <process_queue+0x2e>
		err = chan_send(chan, buf, NULL);
   1409e:	4601      	mov	r1, r0
   140a0:	2200      	movs	r2, #0
   140a2:	4620      	mov	r0, r4
   140a4:	f7f1 fa88 	bl	55b8 <chan_send>
		if (err) {
   140a8:	4604      	mov	r4, r0
   140aa:	b118      	cbz	r0, 140b4 <process_queue+0x2a>
			k_queue_prepend(&queue->_queue, buf);
   140ac:	4629      	mov	r1, r5
   140ae:	4630      	mov	r0, r6
   140b0:	f009 f869 	bl	1d186 <k_queue_prepend>
}
   140b4:	4620      	mov	r0, r4
   140b6:	bd70      	pop	{r4, r5, r6, pc}
	return -ENOENT;
   140b8:	f06f 0401 	mvn.w	r4, #1
   140bc:	e7fa      	b.n	140b4 <process_queue+0x2a>

000140be <find_info_cb>:
{
   140be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!data->rsp) {
   140c0:	6893      	ldr	r3, [r2, #8]
{
   140c2:	4605      	mov	r5, r0
   140c4:	460f      	mov	r7, r1
   140c6:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   140c8:	6816      	ldr	r6, [r2, #0]
	if (!data->rsp) {
   140ca:	b963      	cbnz	r3, 140e6 <find_info_cb+0x28>
	return net_buf_simple_add(&buf->b, len);
   140cc:	6850      	ldr	r0, [r2, #4]
   140ce:	2101      	movs	r1, #1
   140d0:	3008      	adds	r0, #8
   140d2:	f000 fe83 	bl	14ddc <net_buf_simple_add>
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   140d6:	682b      	ldr	r3, [r5, #0]
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   140d8:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   140da:	781b      	ldrb	r3, [r3, #0]
   140dc:	2b00      	cmp	r3, #0
   140de:	bf0c      	ite	eq
   140e0:	2301      	moveq	r3, #1
   140e2:	2302      	movne	r3, #2
   140e4:	7003      	strb	r3, [r0, #0]
	switch (data->rsp->format) {
   140e6:	68a3      	ldr	r3, [r4, #8]
   140e8:	781b      	ldrb	r3, [r3, #0]
   140ea:	2b01      	cmp	r3, #1
   140ec:	d003      	beq.n	140f6 <find_info_cb+0x38>
   140ee:	2b02      	cmp	r3, #2
   140f0:	d019      	beq.n	14126 <find_info_cb+0x68>
			return BT_GATT_ITER_STOP;
   140f2:	2000      	movs	r0, #0
   140f4:	e016      	b.n	14124 <find_info_cb+0x66>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   140f6:	682b      	ldr	r3, [r5, #0]
   140f8:	781b      	ldrb	r3, [r3, #0]
   140fa:	2b00      	cmp	r3, #0
   140fc:	d1f9      	bne.n	140f2 <find_info_cb+0x34>
   140fe:	6860      	ldr	r0, [r4, #4]
   14100:	2104      	movs	r1, #4
   14102:	3008      	adds	r0, #8
   14104:	f000 fe6a 	bl	14ddc <net_buf_simple_add>
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   14108:	682b      	ldr	r3, [r5, #0]
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   1410a:	60e0      	str	r0, [r4, #12]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   1410c:	885b      	ldrh	r3, [r3, #2]
		data->info16->handle = sys_cpu_to_le16(handle);
   1410e:	8007      	strh	r7, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   14110:	8043      	strh	r3, [r0, #2]
		if (chan->chan.tx.mtu - data->buf->len >
   14112:	6863      	ldr	r3, [r4, #4]
   14114:	f8b6 005e 	ldrh.w	r0, [r6, #94]	; 0x5e
   14118:	899b      	ldrh	r3, [r3, #12]
   1411a:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   1411c:	2804      	cmp	r0, #4
   1411e:	bf94      	ite	ls
   14120:	2000      	movls	r0, #0
   14122:	2001      	movhi	r0, #1
}
   14124:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   14126:	682b      	ldr	r3, [r5, #0]
   14128:	781b      	ldrb	r3, [r3, #0]
   1412a:	2b02      	cmp	r3, #2
   1412c:	d1e1      	bne.n	140f2 <find_info_cb+0x34>
   1412e:	6860      	ldr	r0, [r4, #4]
   14130:	2112      	movs	r1, #18
   14132:	3008      	adds	r0, #8
   14134:	f000 fe52 	bl	14ddc <net_buf_simple_add>
   14138:	4603      	mov	r3, r0
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1413a:	682a      	ldr	r2, [r5, #0]
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   1413c:	60e0      	str	r0, [r4, #12]
   1413e:	1c51      	adds	r1, r2, #1
		data->info128->handle = sys_cpu_to_le16(handle);
   14140:	f823 7b02 	strh.w	r7, [r3], #2
   14144:	3211      	adds	r2, #17
   14146:	f851 0b04 	ldr.w	r0, [r1], #4
   1414a:	4291      	cmp	r1, r2
   1414c:	f843 0b04 	str.w	r0, [r3], #4
   14150:	d1f9      	bne.n	14146 <find_info_cb+0x88>
		if (chan->chan.tx.mtu - data->buf->len >
   14152:	6863      	ldr	r3, [r4, #4]
   14154:	f8b6 005e 	ldrh.w	r0, [r6, #94]	; 0x5e
   14158:	899b      	ldrh	r3, [r3, #12]
   1415a:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   1415c:	2812      	cmp	r0, #18
   1415e:	e7de      	b.n	1411e <find_info_cb+0x60>

00014160 <att_exec_write_req>:
   14160:	2006      	movs	r0, #6
   14162:	4770      	bx	lr

00014164 <chan_rsp_sent>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   14164:	30c0      	adds	r0, #192	; 0xc0
   14166:	e8d0 3fef 	ldaex	r3, [r0]
   1416a:	f023 0301 	bic.w	r3, r3, #1
   1416e:	e8c0 3fe2 	stlex	r2, r3, [r0]
   14172:	2a00      	cmp	r2, #0
   14174:	d1f7      	bne.n	14166 <chan_rsp_sent+0x2>
}
   14176:	4770      	bx	lr

00014178 <chan_cfm_sent>:
   14178:	30c0      	adds	r0, #192	; 0xc0
   1417a:	e8d0 3fef 	ldaex	r3, [r0]
   1417e:	f023 0302 	bic.w	r3, r3, #2
   14182:	e8c0 3fe2 	stlex	r2, r3, [r0]
   14186:	2a00      	cmp	r2, #0
   14188:	d1f7      	bne.n	1417a <chan_cfm_sent+0x2>
}
   1418a:	4770      	bx	lr

0001418c <att_get>:
{
   1418c:	b508      	push	{r3, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   1418e:	7a83      	ldrb	r3, [r0, #10]
   14190:	2b07      	cmp	r3, #7
   14192:	d001      	beq.n	14198 <att_get+0xc>
		return NULL;
   14194:	2000      	movs	r0, #0
}
   14196:	bd08      	pop	{r3, pc}
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   14198:	2104      	movs	r1, #4
   1419a:	f7ff fd9e 	bl	13cda <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   1419e:	2800      	cmp	r0, #0
   141a0:	d0f8      	beq.n	14194 <att_get+0x8>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   141a2:	f100 03b8 	add.w	r3, r0, #184	; 0xb8
   141a6:	e8d3 3faf 	lda	r3, [r3]
	if (atomic_test_bit(att_chan->flags, ATT_DISCONNECTED)) {
   141aa:	075b      	lsls	r3, r3, #29
   141ac:	d4f2      	bmi.n	14194 <att_get+0x8>
	return att_chan->att;
   141ae:	f850 0c08 	ldr.w	r0, [r0, #-8]
   141b2:	e7f0      	b.n	14196 <att_get+0xa>

000141b4 <chan_req_send>:
{
   141b4:	b570      	push	{r4, r5, r6, lr}
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   141b6:	690e      	ldr	r6, [r1, #16]
{
   141b8:	4605      	mov	r5, r0
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   141ba:	4630      	mov	r0, r6
{
   141bc:	460c      	mov	r4, r1
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   141be:	f7ff fddd 	bl	13d7c <net_buf_frags_len>
   141c2:	f8b5 305e 	ldrh.w	r3, [r5, #94]	; 0x5e
   141c6:	4283      	cmp	r3, r0
   141c8:	d317      	bcc.n	141fa <chan_req_send+0x46>
	chan->req = req;
   141ca:	f8c5 10c4 	str.w	r1, [r5, #196]	; 0xc4
	state->offset = net_buf_simple_headroom(buf);
   141ce:	f106 0008 	add.w	r0, r6, #8
   141d2:	f000 fe44 	bl	14e5e <net_buf_simple_headroom>
	state->len = buf->len;
   141d6:	89b3      	ldrh	r3, [r6, #12]
	state->offset = net_buf_simple_headroom(buf);
   141d8:	81a0      	strh	r0, [r4, #12]
	state->len = buf->len;
   141da:	81e3      	strh	r3, [r4, #14]
	err = chan_send(chan, net_buf_ref(req->buf), NULL);
   141dc:	6920      	ldr	r0, [r4, #16]
   141de:	f000 fdd7 	bl	14d90 <net_buf_ref>
   141e2:	2200      	movs	r2, #0
   141e4:	4601      	mov	r1, r0
   141e6:	4628      	mov	r0, r5
   141e8:	f7f1 f9e6 	bl	55b8 <chan_send>
	if (err) {
   141ec:	4605      	mov	r5, r0
   141ee:	b110      	cbz	r0, 141f6 <chan_req_send+0x42>
		net_buf_unref(req->buf);
   141f0:	6920      	ldr	r0, [r4, #16]
   141f2:	f7f2 fbad 	bl	6950 <net_buf_unref>
}
   141f6:	4628      	mov	r0, r5
   141f8:	bd70      	pop	{r4, r5, r6, pc}
		return -EMSGSIZE;
   141fa:	f06f 0579 	mvn.w	r5, #121	; 0x79
   141fe:	e7fa      	b.n	141f6 <chan_req_send+0x42>

00014200 <bt_att_chan_req_send>:
{
   14200:	b570      	push	{r4, r5, r6, lr}
   14202:	4604      	mov	r4, r0
   14204:	460d      	mov	r5, r1
	if (k_sem_take(&chan->tx_sem, K_NO_WAIT) < 0) {
   14206:	f500 7688 	add.w	r6, r0, #272	; 0x110
	return z_impl_k_sem_take(sem, timeout);
   1420a:	2200      	movs	r2, #0
   1420c:	2300      	movs	r3, #0
   1420e:	4630      	mov	r0, r6
   14210:	f7fc fde6 	bl	10de0 <z_impl_k_sem_take>
   14214:	2800      	cmp	r0, #0
   14216:	db0a      	blt.n	1422e <bt_att_chan_req_send+0x2e>
	err = chan_req_send(chan, req);
   14218:	4620      	mov	r0, r4
   1421a:	4629      	mov	r1, r5
   1421c:	f7ff ffca 	bl	141b4 <chan_req_send>
	if (err < 0) {
   14220:	1e04      	subs	r4, r0, #0
   14222:	da02      	bge.n	1422a <bt_att_chan_req_send+0x2a>
	z_impl_k_sem_give(sem);
   14224:	4630      	mov	r0, r6
   14226:	f7fc fdb5 	bl	10d94 <z_impl_k_sem_give>
}
   1422a:	4620      	mov	r0, r4
   1422c:	bd70      	pop	{r4, r5, r6, pc}
		return -EAGAIN;
   1422e:	f06f 040a 	mvn.w	r4, #10
   14232:	e7fa      	b.n	1422a <bt_att_chan_req_send+0x2a>

00014234 <bt_att_status>:
{
   14234:	b538      	push	{r3, r4, r5, lr}
   14236:	4605      	mov	r5, r0
   14238:	e8d1 3faf 	lda	r3, [r1]
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
   1423c:	07db      	lsls	r3, r3, #31
   1423e:	d519      	bpl.n	14274 <bt_att_status+0x40>
	if (!chan->att) {
   14240:	f850 0c08 	ldr.w	r0, [r0, #-8]
   14244:	b1b0      	cbz	r0, 14274 <bt_att_status+0x40>
	if (chan->req) {
   14246:	f8d5 30bc 	ldr.w	r3, [r5, #188]	; 0xbc
   1424a:	b99b      	cbnz	r3, 14274 <bt_att_status+0x40>
	node = sys_slist_get(&chan->att->reqs);
   1424c:	3004      	adds	r0, #4
   1424e:	f7ff fd70 	bl	13d32 <sys_slist_get>
	if (!node) {
   14252:	4604      	mov	r4, r0
   14254:	b170      	cbz	r0, 14274 <bt_att_status+0x40>
	if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
   14256:	4601      	mov	r1, r0
   14258:	f1a5 0008 	sub.w	r0, r5, #8
   1425c:	f7ff ffd0 	bl	14200 <bt_att_chan_req_send>
   14260:	2800      	cmp	r0, #0
   14262:	da07      	bge.n	14274 <bt_att_status+0x40>
	sys_slist_prepend(&chan->att->reqs, node);
   14264:	f855 3c08 	ldr.w	r3, [r5, #-8]
Z_GENLIST_PREPEND(slist, snode)
   14268:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   1426a:	6022      	str	r2, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   1426c:	689a      	ldr	r2, [r3, #8]
	list->head = node;
   1426e:	605c      	str	r4, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   14270:	b902      	cbnz	r2, 14274 <bt_att_status+0x40>
	list->tail = node;
   14272:	609c      	str	r4, [r3, #8]
}
   14274:	bd38      	pop	{r3, r4, r5, pc}

00014276 <write_cb>:
{
   14276:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   14278:	4614      	mov	r4, r2
	data->err = bt_gatt_check_perm(data->conn, attr,
   1427a:	4601      	mov	r1, r0
{
   1427c:	4606      	mov	r6, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
   1427e:	222a      	movs	r2, #42	; 0x2a
   14280:	6820      	ldr	r0, [r4, #0]
   14282:	f000 fce3 	bl	14c4c <bt_gatt_check_perm>
   14286:	4605      	mov	r5, r0
   14288:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   1428a:	bb00      	cbnz	r0, 142ce <write_cb+0x58>
	if (!data->req) {
   1428c:	7a23      	ldrb	r3, [r4, #8]
	write = attr->write(data->conn, attr, data->value, data->len,
   1428e:	4631      	mov	r1, r6
	if (!data->req) {
   14290:	2b00      	cmp	r3, #0
		flags |= BT_GATT_WRITE_FLAG_CMD;
   14292:	bf14      	ite	ne
   14294:	2300      	movne	r3, #0
   14296:	2302      	moveq	r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
   14298:	9301      	str	r3, [sp, #4]
   1429a:	8a63      	ldrh	r3, [r4, #18]
   1429c:	68b7      	ldr	r7, [r6, #8]
   1429e:	9300      	str	r3, [sp, #0]
   142a0:	68e2      	ldr	r2, [r4, #12]
   142a2:	8a23      	ldrh	r3, [r4, #16]
   142a4:	6820      	ldr	r0, [r4, #0]
   142a6:	47b8      	blx	r7
	if (write < 0 || write != data->len) {
   142a8:	1e03      	subs	r3, r0, #0
   142aa:	db05      	blt.n	142b8 <write_cb+0x42>
   142ac:	8a22      	ldrh	r2, [r4, #16]
   142ae:	4293      	cmp	r3, r2
   142b0:	d10b      	bne.n	142ca <write_cb+0x54>
	data->err = 0U;
   142b2:	7525      	strb	r5, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   142b4:	2501      	movs	r5, #1
   142b6:	e005      	b.n	142c4 <write_cb+0x4e>
	if (err < 0 && err >= -0xff) {
   142b8:	f113 0fff 	cmn.w	r3, #255	; 0xff
   142bc:	d305      	bcc.n	142ca <write_cb+0x54>
		return -err;
   142be:	425b      	negs	r3, r3
   142c0:	b2db      	uxtb	r3, r3
		data->err = err_to_att(write);
   142c2:	7523      	strb	r3, [r4, #20]
}
   142c4:	4628      	mov	r0, r5
   142c6:	b003      	add	sp, #12
   142c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return BT_ATT_ERR_UNLIKELY;
   142ca:	230e      	movs	r3, #14
   142cc:	e7f9      	b.n	142c2 <write_cb+0x4c>
		return BT_GATT_ITER_STOP;
   142ce:	2500      	movs	r5, #0
   142d0:	e7f8      	b.n	142c4 <write_cb+0x4e>

000142d2 <bt_att_sent>:
{
   142d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (chan->sent) {
   142d4:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
{
   142d8:	4604      	mov	r4, r0
	struct bt_att *att = chan->att;
   142da:	f850 5c08 	ldr.w	r5, [r0, #-8]
	struct bt_att_chan *chan = ATT_CHAN(ch);
   142de:	f1a0 0708 	sub.w	r7, r0, #8
	if (chan->sent) {
   142e2:	b10b      	cbz	r3, 142e8 <bt_att_sent+0x16>
		chan->sent(chan);
   142e4:	4638      	mov	r0, r7
   142e6:	4798      	blx	r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   142e8:	f104 03b8 	add.w	r3, r4, #184	; 0xb8
   142ec:	e8d3 2fef 	ldaex	r2, [r3]
   142f0:	f022 0210 	bic.w	r2, r2, #16
   142f4:	e8c3 2fe1 	stlex	r1, r2, [r3]
   142f8:	2900      	cmp	r1, #0
   142fa:	d1f7      	bne.n	142ec <bt_att_sent+0x1a>
	if (!att) {
   142fc:	b335      	cbz	r5, 1434c <bt_att_sent+0x7a>
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
   142fe:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
   14302:	b98b      	cbnz	r3, 14328 <bt_att_sent+0x56>
   14304:	686b      	ldr	r3, [r5, #4]
   14306:	b17b      	cbz	r3, 14328 <bt_att_sent+0x56>
		sys_snode_t *node = sys_slist_get(&att->reqs);
   14308:	1d28      	adds	r0, r5, #4
   1430a:	f7ff fd12 	bl	13d32 <sys_slist_get>
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   1430e:	4601      	mov	r1, r0
		sys_snode_t *node = sys_slist_get(&att->reqs);
   14310:	4606      	mov	r6, r0
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   14312:	4638      	mov	r0, r7
   14314:	f7ff ff4e 	bl	141b4 <chan_req_send>
   14318:	2800      	cmp	r0, #0
   1431a:	da17      	bge.n	1434c <bt_att_sent+0x7a>
Z_GENLIST_PREPEND(slist, snode)
   1431c:	686b      	ldr	r3, [r5, #4]
	parent->next = child;
   1431e:	6033      	str	r3, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
   14320:	68ab      	ldr	r3, [r5, #8]
	list->head = node;
   14322:	606e      	str	r6, [r5, #4]
Z_GENLIST_PREPEND(slist, snode)
   14324:	b903      	cbnz	r3, 14328 <bt_att_sent+0x56>
	list->tail = node;
   14326:	60ae      	str	r6, [r5, #8]
	err = process_queue(chan, &chan->tx_queue);
   14328:	4638      	mov	r0, r7
   1432a:	f104 01c0 	add.w	r1, r4, #192	; 0xc0
   1432e:	f7ff feac 	bl	1408a <process_queue>
	if (!err) {
   14332:	b158      	cbz	r0, 1434c <bt_att_sent+0x7a>
	err = process_queue(chan, &att->tx_queue);
   14334:	4638      	mov	r0, r7
   14336:	f105 010c 	add.w	r1, r5, #12
   1433a:	f7ff fea6 	bl	1408a <process_queue>
	if (!err) {
   1433e:	b128      	cbz	r0, 1434c <bt_att_sent+0x7a>
   14340:	f504 7084 	add.w	r0, r4, #264	; 0x108
}
   14344:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   14348:	f7fc bd24 	b.w	10d94 <z_impl_k_sem_give>
   1434c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001434e <read_cb>:
{
   1434e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   14352:	4606      	mov	r6, r0
	data->err = 0x00;
   14354:	2700      	movs	r7, #0
	struct bt_att_chan *chan = data->chan;
   14356:	f8d2 8000 	ldr.w	r8, [r2]
{
   1435a:	4615      	mov	r5, r2
	struct bt_conn *conn = chan->chan.chan.conn;
   1435c:	f8d8 0008 	ldr.w	r0, [r8, #8]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   14360:	4631      	mov	r1, r6
	data->err = 0x00;
   14362:	7317      	strb	r7, [r2, #12]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   14364:	2215      	movs	r2, #21
   14366:	f000 fc71 	bl	14c4c <bt_gatt_check_perm>
   1436a:	4604      	mov	r4, r0
   1436c:	7328      	strb	r0, [r5, #12]
	if (data->err) {
   1436e:	b9a0      	cbnz	r0, 1439a <read_cb+0x4c>
	ret = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   14370:	e9cd 0000 	strd	r0, r0, [sp]
   14374:	88ab      	ldrh	r3, [r5, #4]
   14376:	4631      	mov	r1, r6
   14378:	4640      	mov	r0, r8
   1437a:	68aa      	ldr	r2, [r5, #8]
   1437c:	f7ff fd56 	bl	13e2c <att_chan_read>
	if (ret < 0) {
   14380:	1e03      	subs	r3, r0, #0
   14382:	da0c      	bge.n	1439e <read_cb+0x50>
	if (err < 0 && err >= -0xff) {
   14384:	f113 0fff 	cmn.w	r3, #255	; 0xff
	return BT_ATT_ERR_UNLIKELY;
   14388:	bf32      	itee	cc
   1438a:	230e      	movcc	r3, #14
		return -err;
   1438c:	425b      	negcs	r3, r3
   1438e:	b2db      	uxtbcs	r3, r3
		data->err = err_to_att(ret);
   14390:	732b      	strb	r3, [r5, #12]
}
   14392:	4620      	mov	r0, r4
   14394:	b002      	add	sp, #8
   14396:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ITER_STOP;
   1439a:	463c      	mov	r4, r7
   1439c:	e7f9      	b.n	14392 <read_cb+0x44>
	return BT_GATT_ITER_CONTINUE;
   1439e:	2401      	movs	r4, #1
   143a0:	e7f7      	b.n	14392 <read_cb+0x44>

000143a2 <bt_att_chan_create_pdu>:
{
   143a2:	b538      	push	{r3, r4, r5, lr}
	if (len + sizeof(op) > chan->chan.tx.mtu) {
   143a4:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
   143a8:	3201      	adds	r2, #1
   143aa:	429a      	cmp	r2, r3
{
   143ac:	460d      	mov	r5, r1
	if (len + sizeof(op) > chan->chan.tx.mtu) {
   143ae:	d81b      	bhi.n	143e8 <bt_att_chan_create_pdu+0x46>
	switch (att_op_get_type(op)) {
   143b0:	4608      	mov	r0, r1
   143b2:	f7ff fd03 	bl	13dbc <att_op_get_type>
   143b6:	2802      	cmp	r0, #2
   143b8:	d001      	beq.n	143be <bt_att_chan_create_pdu+0x1c>
   143ba:	2804      	cmp	r0, #4
   143bc:	d10f      	bne.n	143de <bt_att_chan_create_pdu+0x3c>
		buf = bt_l2cap_create_pdu_timeout(NULL, 0, BT_ATT_TIMEOUT);
   143be:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
   143c2:	2300      	movs	r3, #0
		buf = bt_l2cap_create_pdu(NULL, 0);
   143c4:	2100      	movs	r1, #0
   143c6:	4608      	mov	r0, r1
   143c8:	f7ff fc2e 	bl	13c28 <bt_l2cap_create_pdu_timeout>
   143cc:	4604      	mov	r4, r0
	if (!buf) {
   143ce:	b120      	cbz	r0, 143da <bt_att_chan_create_pdu+0x38>
	return net_buf_simple_add(&buf->b, len);
   143d0:	2101      	movs	r1, #1
   143d2:	3008      	adds	r0, #8
   143d4:	f000 fd02 	bl	14ddc <net_buf_simple_add>
	hdr->code = op;
   143d8:	7005      	strb	r5, [r0, #0]
}
   143da:	4620      	mov	r0, r4
   143dc:	bd38      	pop	{r3, r4, r5, pc}
		buf = bt_l2cap_create_pdu(NULL, 0);
   143de:	f04f 32ff 	mov.w	r2, #4294967295
   143e2:	f04f 33ff 	mov.w	r3, #4294967295
   143e6:	e7ed      	b.n	143c4 <bt_att_chan_create_pdu+0x22>
		return NULL;
   143e8:	2400      	movs	r4, #0
   143ea:	e7f6      	b.n	143da <bt_att_chan_create_pdu+0x38>

000143ec <send_err_rsp.part.0>:
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
   143ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   143f0:	4688      	mov	r8, r1
   143f2:	4617      	mov	r7, r2
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   143f4:	2101      	movs	r1, #1
   143f6:	2204      	movs	r2, #4
static void send_err_rsp(struct bt_att_chan *chan, uint8_t req, uint16_t handle,
   143f8:	4605      	mov	r5, r0
   143fa:	461e      	mov	r6, r3
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   143fc:	f7ff ffd1 	bl	143a2 <bt_att_chan_create_pdu>
	if (!buf) {
   14400:	4604      	mov	r4, r0
   14402:	b170      	cbz	r0, 14422 <send_err_rsp.part.0+0x36>
   14404:	2104      	movs	r1, #4
   14406:	3008      	adds	r0, #8
   14408:	f000 fce8 	bl	14ddc <net_buf_simple_add>
	rsp->request = req;
   1440c:	f880 8000 	strb.w	r8, [r0]
	rsp->error = err;
   14410:	70c6      	strb	r6, [r0, #3]
	rsp->handle = sys_cpu_to_le16(handle);
   14412:	f8a0 7001 	strh.w	r7, [r0, #1]
	bt_att_chan_send_rsp(chan, buf, chan_rsp_sent);
   14416:	4621      	mov	r1, r4
   14418:	4628      	mov	r0, r5
}
   1441a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_att_chan_send_rsp(chan, buf, chan_rsp_sent);
   1441e:	f7f1 b98b 	b.w	5738 <bt_att_chan_send_rsp.constprop.0>
}
   14422:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00014426 <bt_att_create_pdu>:
{
   14426:	b570      	push	{r4, r5, r6, lr}
   14428:	460e      	mov	r6, r1
   1442a:	4615      	mov	r5, r2
	att = att_get(conn);
   1442c:	f7ff feae 	bl	1418c <att_get>
	if (!att) {
   14430:	b170      	cbz	r0, 14450 <bt_att_create_pdu+0x2a>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14432:	6a43      	ldr	r3, [r0, #36]	; 0x24
   14434:	b163      	cbz	r3, 14450 <bt_att_create_pdu+0x2a>
   14436:	f5b3 7096 	subs.w	r0, r3, #300	; 0x12c
   1443a:	d009      	beq.n	14450 <bt_att_create_pdu+0x2a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1443c:	681b      	ldr	r3, [r3, #0]
   1443e:	b10b      	cbz	r3, 14444 <bt_att_create_pdu+0x1e>
   14440:	f5a3 7396 	sub.w	r3, r3, #300	; 0x12c
		if (len + sizeof(op) > chan->chan.tx.mtu) {
   14444:	1c6a      	adds	r2, r5, #1
   14446:	f8b0 105e 	ldrh.w	r1, [r0, #94]	; 0x5e
   1444a:	428a      	cmp	r2, r1
   1444c:	d902      	bls.n	14454 <bt_att_create_pdu+0x2e>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   1444e:	b93b      	cbnz	r3, 14460 <bt_att_create_pdu+0x3a>
}
   14450:	2000      	movs	r0, #0
   14452:	bd70      	pop	{r4, r5, r6, pc}
		return bt_att_chan_create_pdu(chan, op, len);
   14454:	462a      	mov	r2, r5
   14456:	4631      	mov	r1, r6
}
   14458:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return bt_att_chan_create_pdu(chan, op, len);
   1445c:	f7ff bfa1 	b.w	143a2 <bt_att_chan_create_pdu>
Z_GENLIST_PEEK_NEXT(slist, snode)
   14460:	f513 7496 	adds.w	r4, r3, #300	; 0x12c
   14464:	d004      	beq.n	14470 <bt_att_create_pdu+0x4a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   14466:	f8d3 412c 	ldr.w	r4, [r3, #300]	; 0x12c
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   1446a:	b10c      	cbz	r4, 14470 <bt_att_create_pdu+0x4a>
   1446c:	f5a4 7496 	sub.w	r4, r4, #300	; 0x12c
{
   14470:	4618      	mov	r0, r3
   14472:	4623      	mov	r3, r4
   14474:	e7e7      	b.n	14446 <bt_att_create_pdu+0x20>

00014476 <att_read_blob_req>:
{
   14476:	b507      	push	{r0, r1, r2, lr}
	req = (void *)buf->data;
   14478:	688a      	ldr	r2, [r1, #8]
	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ,
   1447a:	210c      	movs	r1, #12
   1447c:	8813      	ldrh	r3, [r2, #0]
   1447e:	8852      	ldrh	r2, [r2, #2]
   14480:	9200      	str	r2, [sp, #0]
   14482:	220d      	movs	r2, #13
   14484:	f7f1 fb5c 	bl	5b40 <att_read_rsp>
}
   14488:	b003      	add	sp, #12
   1448a:	f85d fb04 	ldr.w	pc, [sp], #4

0001448e <att_read_req>:
{
   1448e:	b507      	push	{r0, r1, r2, lr}
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   14490:	2200      	movs	r2, #0
	handle = sys_le16_to_cpu(req->handle);
   14492:	688b      	ldr	r3, [r1, #8]
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   14494:	210a      	movs	r1, #10
   14496:	881b      	ldrh	r3, [r3, #0]
   14498:	9200      	str	r2, [sp, #0]
   1449a:	220b      	movs	r2, #11
   1449c:	f7f1 fb50 	bl	5b40 <att_read_rsp>
}
   144a0:	b003      	add	sp, #12
   144a2:	f85d fb04 	ldr.w	pc, [sp], #4

000144a6 <att_mtu_req>:
{
   144a6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_conn *conn = chan->att->conn;
   144a8:	4603      	mov	r3, r0
   144aa:	f853 2bc0 	ldr.w	r2, [r3], #192
{
   144ae:	4605      	mov	r5, r0
	struct bt_conn *conn = chan->att->conn;
   144b0:	6810      	ldr	r0, [r2, #0]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   144b2:	e8d3 3faf 	lda	r3, [r3]
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   144b6:	f3c3 04c0 	ubfx	r4, r3, #3, #1
   144ba:	071b      	lsls	r3, r3, #28
   144bc:	d41a      	bmi.n	144f4 <att_mtu_req+0x4e>
	mtu_client = sys_le16_to_cpu(req->mtu);
   144be:	688b      	ldr	r3, [r1, #8]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
   144c0:	881b      	ldrh	r3, [r3, #0]
   144c2:	2b16      	cmp	r3, #22
   144c4:	d918      	bls.n	144f8 <att_mtu_req+0x52>
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
   144c6:	2202      	movs	r2, #2
   144c8:	2103      	movs	r1, #3
   144ca:	f7ff ffac 	bl	14426 <bt_att_create_pdu>
	if (!pdu) {
   144ce:	4606      	mov	r6, r0
   144d0:	b1a0      	cbz	r0, 144fc <att_mtu_req+0x56>
   144d2:	2102      	movs	r1, #2
   144d4:	3008      	adds	r0, #8
   144d6:	f000 fc81 	bl	14ddc <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
   144da:	2717      	movs	r7, #23
   144dc:	7044      	strb	r4, [r0, #1]
   144de:	7007      	strb	r7, [r0, #0]
	bt_att_chan_send_rsp(chan, pdu, chan_rsp_sent);
   144e0:	4631      	mov	r1, r6
   144e2:	4628      	mov	r0, r5
   144e4:	f7f1 f928 	bl	5738 <bt_att_chan_send_rsp.constprop.0>
	return 0;
   144e8:	4620      	mov	r0, r4
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
   144ea:	f8a5 7052 	strh.w	r7, [r5, #82]	; 0x52
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   144ee:	f8a5 705e 	strh.w	r7, [r5, #94]	; 0x5e
}
   144f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_ATT_ERR_NOT_SUPPORTED;
   144f4:	2006      	movs	r0, #6
   144f6:	e7fc      	b.n	144f2 <att_mtu_req+0x4c>
		return BT_ATT_ERR_INVALID_PDU;
   144f8:	2004      	movs	r0, #4
   144fa:	e7fa      	b.n	144f2 <att_mtu_req+0x4c>
		return BT_ATT_ERR_UNLIKELY;
   144fc:	200e      	movs	r0, #14
   144fe:	e7f8      	b.n	144f2 <att_mtu_req+0x4c>

00014500 <bt_att_init>:
	bt_gatt_init();
   14500:	f7f1 be86 	b.w	6210 <bt_gatt_init>

00014504 <att_req_destroy>:
{
   14504:	b510      	push	{r4, lr}
   14506:	4604      	mov	r4, r0
	if (req->buf) {
   14508:	6900      	ldr	r0, [r0, #16]
   1450a:	b108      	cbz	r0, 14510 <att_req_destroy+0xc>
		net_buf_unref(req->buf);
   1450c:	f7f2 fa20 	bl	6950 <net_buf_unref>
	if (req->destroy) {
   14510:	68a3      	ldr	r3, [r4, #8]
   14512:	b10b      	cbz	r3, 14518 <att_req_destroy+0x14>
		req->destroy(req);
   14514:	4620      	mov	r0, r4
   14516:	4798      	blx	r3
	bt_att_req_free(req);
   14518:	4620      	mov	r0, r4
}
   1451a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_att_req_free(req);
   1451e:	f7f1 bc6f 	b.w	5e00 <bt_att_req_free>

00014522 <att_confirm>:
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   14522:	898a      	ldrh	r2, [r1, #12]
   14524:	2300      	movs	r3, #0
   14526:	6889      	ldr	r1, [r1, #8]
   14528:	f7f1 bc76 	b.w	5e18 <att_handle_rsp>

0001452c <att_chan_detach>:
{
   1452c:	b538      	push	{r3, r4, r5, lr}
   1452e:	4604      	mov	r4, r0
	sys_slist_find_and_remove(&chan->att->chans, &chan->node);
   14530:	6800      	ldr	r0, [r0, #0]
   14532:	f504 7196 	add.w	r1, r4, #300	; 0x12c
   14536:	3024      	adds	r0, #36	; 0x24
   14538:	f7ff fc05 	bl	13d46 <sys_slist_find_and_remove>
		k_sem_give(&chan->tx_sem);
   1453c:	f504 7588 	add.w	r5, r4, #272	; 0x110
   14540:	4628      	mov	r0, r5
   14542:	f7fc fc27 	bl	10d94 <z_impl_k_sem_give>
   14546:	4628      	mov	r0, r5
   14548:	f7fc fc24 	bl	10d94 <z_impl_k_sem_give>
   1454c:	4628      	mov	r0, r5
   1454e:	f7fc fc21 	bl	10d94 <z_impl_k_sem_give>
	while ((buf = net_buf_get(&chan->tx_queue, K_NO_WAIT))) {
   14552:	f104 05c8 	add.w	r5, r4, #200	; 0xc8
   14556:	2200      	movs	r2, #0
   14558:	2300      	movs	r3, #0
   1455a:	4628      	mov	r0, r5
   1455c:	f000 fbed 	bl	14d3a <net_buf_get>
   14560:	4602      	mov	r2, r0
   14562:	b950      	cbnz	r0, 1457a <att_chan_detach+0x4e>
	if (chan->req) {
   14564:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
   14568:	b123      	cbz	r3, 14574 <att_chan_detach+0x48>
		att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_UNLIKELY);
   1456a:	4601      	mov	r1, r0
   1456c:	230e      	movs	r3, #14
   1456e:	4620      	mov	r0, r4
   14570:	f7f1 fc52 	bl	5e18 <att_handle_rsp>
	chan->att = NULL;
   14574:	2300      	movs	r3, #0
   14576:	6023      	str	r3, [r4, #0]
}
   14578:	bd38      	pop	{r3, r4, r5, pc}
		net_buf_unref(buf);
   1457a:	f7f2 f9e9 	bl	6950 <net_buf_unref>
   1457e:	e7ea      	b.n	14556 <att_chan_detach+0x2a>

00014580 <bt_att_disconnected>:
{
   14580:	b538      	push	{r3, r4, r5, lr}
   14582:	4604      	mov	r4, r0
	struct bt_att *att = att_chan->att;
   14584:	f850 5d08 	ldr.w	r5, [r0, #-8]!
	att_chan_detach(att_chan);
   14588:	f7ff ffd0 	bl	1452c <att_chan_detach>
	if (!sys_slist_is_empty(&att->chans)) {
   1458c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1458e:	b93b      	cbnz	r3, 145a0 <bt_att_disconnected+0x20>
	att_reset(att);
   14590:	4628      	mov	r0, r5
   14592:	f7f1 fca9 	bl	5ee8 <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
   14596:	6820      	ldr	r0, [r4, #0]
}
   14598:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_gatt_disconnected(ch->chan.conn);
   1459c:	f7f2 b8e4 	b.w	6768 <bt_gatt_disconnected>
}
   145a0:	bd38      	pop	{r3, r4, r5, pc}

000145a2 <att_timeout>:
{
   145a2:	b570      	push	{r4, r5, r6, lr}
   145a4:	4604      	mov	r4, r0
	struct bt_att *att = chan->att;
   145a6:	f850 6de0 	ldr.w	r6, [r0, #-224]!
	att_chan_detach(chan);
   145aa:	f7ff ffbf 	bl	1452c <att_chan_detach>
	if (!sys_slist_is_empty(&att->chans)) {
   145ae:	6a75      	ldr	r5, [r6, #36]	; 0x24
   145b0:	b945      	cbnz	r5, 145c4 <att_timeout+0x22>
	att_reset(att);
   145b2:	4630      	mov	r0, r6
   145b4:	f7f1 fc98 	bl	5ee8 <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
   145b8:	f854 0cd8 	ldr.w	r0, [r4, #-216]
   145bc:	f7f2 f8d4 	bl	6768 <bt_gatt_disconnected>
	ch->chan.conn = NULL;
   145c0:	f844 5cd8 	str.w	r5, [r4, #-216]
}
   145c4:	bd70      	pop	{r4, r5, r6, pc}

000145c6 <bt_att_send>:

int bt_att_send(struct bt_conn *conn, struct net_buf *buf, bt_conn_tx_cb_t cb,
		void *user_data)
{
   145c6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   145ca:	4605      	mov	r5, r0
   145cc:	460e      	mov	r6, r1
   145ce:	4614      	mov	r4, r2
   145d0:	4698      	mov	r8, r3
	int ret;

	__ASSERT_NO_MSG(conn);
	__ASSERT_NO_MSG(buf);

	att = att_get(conn);
   145d2:	f7ff fddb 	bl	1418c <att_get>
	if (!att) {
   145d6:	4607      	mov	r7, r0
   145d8:	b938      	cbnz	r0, 145ea <bt_att_send+0x24>
		net_buf_unref(buf);
   145da:	4630      	mov	r0, r6
   145dc:	f7f2 f9b8 	bl	6950 <net_buf_unref>
		return -ENOTCONN;
   145e0:	f06f 007f 	mvn.w	r0, #127	; 0x7f
		BT_DBG("Queueing buffer %p", buf);
		net_buf_put(&att->tx_queue, buf);
	}

	return 0;
}
   145e4:	b002      	add	sp, #8
   145e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (cb) {
   145ea:	b144      	cbz	r4, 145fe <bt_att_send+0x38>
		return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, cb,
   145ec:	4623      	mov	r3, r4
   145ee:	4632      	mov	r2, r6
   145f0:	2104      	movs	r1, #4
   145f2:	4628      	mov	r0, r5
   145f4:	f8cd 8000 	str.w	r8, [sp]
   145f8:	f7ff fb19 	bl	13c2e <bt_l2cap_send_cb>
   145fc:	e7f2      	b.n	145e4 <bt_att_send+0x1e>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   145fe:	6a44      	ldr	r4, [r0, #36]	; 0x24
   14600:	b184      	cbz	r4, 14624 <bt_att_send+0x5e>
   14602:	f5b4 7596 	subs.w	r5, r4, #300	; 0x12c
   14606:	d00f      	beq.n	14628 <bt_att_send+0x62>
   14608:	6824      	ldr	r4, [r4, #0]
   1460a:	b10c      	cbz	r4, 14610 <bt_att_send+0x4a>
   1460c:	f5a4 7496 	sub.w	r4, r4, #300	; 0x12c
   14610:	2000      	movs	r0, #0
   14612:	b95d      	cbnz	r5, 1462c <bt_att_send+0x66>
	if (ret < 0) {
   14614:	b1c8      	cbz	r0, 1464a <bt_att_send+0x84>
		net_buf_put(&att->tx_queue, buf);
   14616:	f107 000c 	add.w	r0, r7, #12
   1461a:	4631      	mov	r1, r6
   1461c:	f000 fbab 	bl	14d76 <net_buf_put>
	return 0;
   14620:	4628      	mov	r0, r5
   14622:	e7df      	b.n	145e4 <bt_att_send+0x1e>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14624:	4625      	mov	r5, r4
   14626:	e7f3      	b.n	14610 <bt_att_send+0x4a>
   14628:	462c      	mov	r4, r5
   1462a:	e7f1      	b.n	14610 <bt_att_send+0x4a>
	return z_impl_k_sem_take(sem, timeout);
   1462c:	2200      	movs	r2, #0
   1462e:	2300      	movs	r3, #0
   14630:	f505 7088 	add.w	r0, r5, #272	; 0x110
   14634:	f7fc fbd4 	bl	10de0 <z_impl_k_sem_take>
		if (k_sem_take(&chan->tx_sem, K_NO_WAIT) < 0) {
   14638:	2800      	cmp	r0, #0
   1463a:	db08      	blt.n	1464e <bt_att_send+0x88>
	return chan_send(chan, buf, cb);
   1463c:	2200      	movs	r2, #0
   1463e:	4631      	mov	r1, r6
   14640:	4628      	mov	r0, r5
   14642:	f7f0 ffb9 	bl	55b8 <chan_send>
		if (ret >= 0) {
   14646:	2800      	cmp	r0, #0
   14648:	db03      	blt.n	14652 <bt_att_send+0x8c>
	return 0;
   1464a:	2000      	movs	r0, #0
   1464c:	e7ca      	b.n	145e4 <bt_att_send+0x1e>
			return -EAGAIN;
   1464e:	f06f 000a 	mvn.w	r0, #10
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14652:	b154      	cbz	r4, 1466a <bt_att_send+0xa4>
Z_GENLIST_PEEK_NEXT(slist, snode)
   14654:	f514 7296 	adds.w	r2, r4, #300	; 0x12c
   14658:	d004      	beq.n	14664 <bt_att_send+0x9e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1465a:	f8d4 212c 	ldr.w	r2, [r4, #300]	; 0x12c
   1465e:	b10a      	cbz	r2, 14664 <bt_att_send+0x9e>
   14660:	f5a2 7296 	sub.w	r2, r2, #300	; 0x12c
   14664:	4625      	mov	r5, r4
   14666:	4614      	mov	r4, r2
   14668:	e7d3      	b.n	14612 <bt_att_send+0x4c>
   1466a:	4622      	mov	r2, r4
   1466c:	e7fa      	b.n	14664 <bt_att_send+0x9e>

0001466e <bt_att_req_send>:

int bt_att_req_send(struct bt_conn *conn, struct bt_att_req *req)
{
   1466e:	b570      	push	{r4, r5, r6, lr}
   14670:	460c      	mov	r4, r1
	BT_DBG("conn %p req %p", conn, req);

	__ASSERT_NO_MSG(conn);
	__ASSERT_NO_MSG(req);

	att = att_get(conn);
   14672:	f7ff fd8b 	bl	1418c <att_get>
	if (!att) {
   14676:	4605      	mov	r5, r0
   14678:	b930      	cbnz	r0, 14688 <bt_att_req_send+0x1a>
		net_buf_unref(req->buf);
   1467a:	6920      	ldr	r0, [r4, #16]
   1467c:	f7f2 f968 	bl	6950 <net_buf_unref>
		req->buf = NULL;
		return -ENOTCONN;
   14680:	f06f 007f 	mvn.w	r0, #127	; 0x7f
		req->buf = NULL;
   14684:	6125      	str	r5, [r4, #16]
	sys_slist_append(&att->reqs, &req->node);

	BT_DBG("req %p queued", req);

	return 0;
}
   14686:	bd70      	pop	{r4, r5, r6, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   14688:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1468a:	b153      	cbz	r3, 146a2 <bt_att_req_send+0x34>
   1468c:	f5b3 7096 	subs.w	r0, r3, #300	; 0x12c
   14690:	d007      	beq.n	146a2 <bt_att_req_send+0x34>
   14692:	681e      	ldr	r6, [r3, #0]
   14694:	b10e      	cbz	r6, 1469a <bt_att_req_send+0x2c>
   14696:	f5a6 7696 	sub.w	r6, r6, #300	; 0x12c
		if (!chan->req) {
   1469a:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
   1469e:	b143      	cbz	r3, 146b2 <bt_att_req_send+0x44>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   146a0:	b96e      	cbnz	r6, 146be <bt_att_req_send+0x50>
	parent->next = child;
   146a2:	2000      	movs	r0, #0
   146a4:	6020      	str	r0, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
   146a6:	68ab      	ldr	r3, [r5, #8]
   146a8:	b9a3      	cbnz	r3, 146d4 <bt_att_req_send+0x66>
	return 0;
   146aa:	4618      	mov	r0, r3
	list->head = node;
   146ac:	e9c5 4401 	strd	r4, r4, [r5, #4]
}
   146b0:	e7e9      	b.n	14686 <bt_att_req_send+0x18>
			ret = bt_att_chan_req_send(chan, req);
   146b2:	4621      	mov	r1, r4
   146b4:	f7ff fda4 	bl	14200 <bt_att_chan_req_send>
			if (ret >= 0) {
   146b8:	2800      	cmp	r0, #0
   146ba:	dbf1      	blt.n	146a0 <bt_att_req_send+0x32>
   146bc:	e7e3      	b.n	14686 <bt_att_req_send+0x18>
Z_GENLIST_PEEK_NEXT(slist, snode)
   146be:	f516 7396 	adds.w	r3, r6, #300	; 0x12c
   146c2:	d004      	beq.n	146ce <bt_att_req_send+0x60>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   146c4:	f8d6 312c 	ldr.w	r3, [r6, #300]	; 0x12c
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   146c8:	b10b      	cbz	r3, 146ce <bt_att_req_send+0x60>
   146ca:	f5a3 7396 	sub.w	r3, r3, #300	; 0x12c
{
   146ce:	4630      	mov	r0, r6
   146d0:	461e      	mov	r6, r3
   146d2:	e7e2      	b.n	1469a <bt_att_req_send+0x2c>
	parent->next = child;
   146d4:	601c      	str	r4, [r3, #0]
	list->tail = node;
   146d6:	60ac      	str	r4, [r5, #8]
}
   146d8:	e7d5      	b.n	14686 <bt_att_req_send+0x18>

000146da <gatt_ccc_changed>:
{
   146da:	460b      	mov	r3, r1
		if (ccc->cfg[i].value > value) {
   146dc:	8909      	ldrh	r1, [r1, #8]
	if (value != ccc->value) {
   146de:	895a      	ldrh	r2, [r3, #10]
   146e0:	428a      	cmp	r2, r1
   146e2:	d003      	beq.n	146ec <gatt_ccc_changed+0x12>
		ccc->value = value;
   146e4:	8159      	strh	r1, [r3, #10]
		if (ccc->cfg_changed) {
   146e6:	68db      	ldr	r3, [r3, #12]
   146e8:	b103      	cbz	r3, 146ec <gatt_ccc_changed+0x12>
			ccc->cfg_changed(attr, value);
   146ea:	4718      	bx	r3
}
   146ec:	4770      	bx	lr

000146ee <gatt_indicate_rsp>:
{
   146ee:	b510      	push	{r4, lr}
   146f0:	9c02      	ldr	r4, [sp, #8]
   146f2:	460a      	mov	r2, r1
	params->_ref--;
   146f4:	7da3      	ldrb	r3, [r4, #22]
	params->func(conn, params, err);
   146f6:	4621      	mov	r1, r4
	params->_ref--;
   146f8:	3b01      	subs	r3, #1
   146fa:	75a3      	strb	r3, [r4, #22]
	params->func(conn, params, err);
   146fc:	68a3      	ldr	r3, [r4, #8]
   146fe:	4798      	blx	r3
	if (params->destroy && (params->_ref == 0)) {
   14700:	68e3      	ldr	r3, [r4, #12]
   14702:	b12b      	cbz	r3, 14710 <gatt_indicate_rsp+0x22>
   14704:	7da2      	ldrb	r2, [r4, #22]
   14706:	b91a      	cbnz	r2, 14710 <gatt_indicate_rsp+0x22>
		params->destroy(params);
   14708:	4620      	mov	r0, r4
}
   1470a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		params->destroy(params);
   1470e:	4718      	bx	r3
}
   14710:	bd10      	pop	{r4, pc}

00014712 <match_uuid>:
	data->attr = attr;
   14712:	6010      	str	r0, [r2, #0]
	data->handle = handle;
   14714:	8091      	strh	r1, [r2, #4]
}
   14716:	2000      	movs	r0, #0
   14718:	4770      	bx	lr

0001471a <gen_hash_m>:
{
   1471a:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (attr->uuid->type != BT_UUID_TYPE_16)
   1471c:	6807      	ldr	r7, [r0, #0]
{
   1471e:	4606      	mov	r6, r0
	if (attr->uuid->type != BT_UUID_TYPE_16)
   14720:	783d      	ldrb	r5, [r7, #0]
{
   14722:	4614      	mov	r4, r2
   14724:	b089      	sub	sp, #36	; 0x24
	if (attr->uuid->type != BT_UUID_TYPE_16)
   14726:	b10d      	cbz	r5, 1472c <gen_hash_m+0x12>
	switch (u16->val) {
   14728:	2501      	movs	r5, #1
   1472a:	e014      	b.n	14756 <gen_hash_m+0x3c>
   1472c:	887b      	ldrh	r3, [r7, #2]
   1472e:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   14732:	d004      	beq.n	1473e <gen_hash_m+0x24>
   14734:	d812      	bhi.n	1475c <gen_hash_m+0x42>
   14736:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
   1473a:	2b03      	cmp	r3, #3
   1473c:	d8f4      	bhi.n	14728 <gen_hash_m+0xe>
		value = sys_cpu_to_le16(handle);
   1473e:	f8ad 100e 	strh.w	r1, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   14742:	2202      	movs	r2, #2
   14744:	4620      	mov	r0, r4
   14746:	f10d 010e 	add.w	r1, sp, #14
   1474a:	f7fe f936 	bl	129ba <tc_cmac_update>
   1474e:	b9e0      	cbnz	r0, 1478a <gen_hash_m+0x70>
			state->err = -EINVAL;
   14750:	f06f 0315 	mvn.w	r3, #21
   14754:	65a3      	str	r3, [r4, #88]	; 0x58
}
   14756:	4628      	mov	r0, r5
   14758:	b009      	add	sp, #36	; 0x24
   1475a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (u16->val) {
   1475c:	f503 4356 	add.w	r3, r3, #54784	; 0xd600
   14760:	33ff      	adds	r3, #255	; 0xff
   14762:	b29b      	uxth	r3, r3
   14764:	2b04      	cmp	r3, #4
   14766:	d8df      	bhi.n	14728 <gen_hash_m+0xe>
		value = sys_cpu_to_le16(handle);
   14768:	f8ad 100e 	strh.w	r1, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1476c:	2202      	movs	r2, #2
   1476e:	4620      	mov	r0, r4
   14770:	f10d 010e 	add.w	r1, sp, #14
   14774:	f7fe f921 	bl	129ba <tc_cmac_update>
   14778:	2800      	cmp	r0, #0
   1477a:	d0e9      	beq.n	14750 <gen_hash_m+0x36>
		value = sys_cpu_to_le16(u16->val);
   1477c:	887b      	ldrh	r3, [r7, #2]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1477e:	2202      	movs	r2, #2
		value = sys_cpu_to_le16(u16->val);
   14780:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   14784:	f10d 010e 	add.w	r1, sp, #14
   14788:	e017      	b.n	147ba <gen_hash_m+0xa0>
		value = sys_cpu_to_le16(u16->val);
   1478a:	887b      	ldrh	r3, [r7, #2]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1478c:	2202      	movs	r2, #2
   1478e:	4620      	mov	r0, r4
   14790:	f10d 010e 	add.w	r1, sp, #14
		value = sys_cpu_to_le16(u16->val);
   14794:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   14798:	f7fe f90f 	bl	129ba <tc_cmac_update>
   1479c:	2800      	cmp	r0, #0
   1479e:	d0d7      	beq.n	14750 <gen_hash_m+0x36>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   147a0:	2000      	movs	r0, #0
   147a2:	2310      	movs	r3, #16
   147a4:	4631      	mov	r1, r6
   147a6:	eb0d 0203 	add.w	r2, sp, r3
   147aa:	6877      	ldr	r7, [r6, #4]
   147ac:	9000      	str	r0, [sp, #0]
   147ae:	47b8      	blx	r7
		if (len < 0) {
   147b0:	1e02      	subs	r2, r0, #0
   147b2:	da01      	bge.n	147b8 <gen_hash_m+0x9e>
			state->err = len;
   147b4:	65a2      	str	r2, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   147b6:	e7ce      	b.n	14756 <gen_hash_m+0x3c>
		if (tc_cmac_update(&state->state, data, len) ==
   147b8:	a904      	add	r1, sp, #16
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   147ba:	4620      	mov	r0, r4
   147bc:	f7fe f8fd 	bl	129ba <tc_cmac_update>
   147c0:	2800      	cmp	r0, #0
   147c2:	d1b1      	bne.n	14728 <gen_hash_m+0xe>
   147c4:	e7c4      	b.n	14750 <gen_hash_m+0x36>

000147c6 <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   147c6:	2301      	movs	r3, #1
   147c8:	408b      	lsls	r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   147ca:	e8d0 2fef 	ldaex	r2, [r0]
   147ce:	431a      	orrs	r2, r3
   147d0:	e8c0 2fe1 	stlex	r1, r2, [r0]
   147d4:	2900      	cmp	r1, #0
   147d6:	d1f8      	bne.n	147ca <atomic_set_bit+0x4>
}
   147d8:	4770      	bx	lr

000147da <bt_addr_le_copy>:
   147da:	680b      	ldr	r3, [r1, #0]
   147dc:	6003      	str	r3, [r0, #0]
   147de:	888b      	ldrh	r3, [r1, #4]
   147e0:	8083      	strh	r3, [r0, #4]
   147e2:	798b      	ldrb	r3, [r1, #6]
   147e4:	7183      	strb	r3, [r0, #6]
}
   147e6:	4770      	bx	lr

000147e8 <clear_sc_cfg>:
__ssp_bos_icheck3(memset, void *, int)
   147e8:	2300      	movs	r3, #0
   147ea:	6003      	str	r3, [r0, #0]
   147ec:	6043      	str	r3, [r0, #4]
   147ee:	6083      	str	r3, [r0, #8]
}
   147f0:	4770      	bx	lr

000147f2 <bt_gatt_attr_read.constprop.0>:
ssize_t bt_gatt_attr_read(struct bt_conn *conn, const struct bt_gatt_attr *attr,
   147f2:	b538      	push	{r3, r4, r5, lr}
   147f4:	f8bd 5010 	ldrh.w	r5, [sp, #16]
   147f8:	460c      	mov	r4, r1
	if (offset > value_len) {
   147fa:	4295      	cmp	r5, r2
ssize_t bt_gatt_attr_read(struct bt_conn *conn, const struct bt_gatt_attr *attr,
   147fc:	4611      	mov	r1, r2
	if (offset > value_len) {
   147fe:	d30a      	bcc.n	14816 <bt_gatt_attr_read.constprop.0+0x24>
	len = MIN(buf_len, value_len - offset);
   14800:	1aad      	subs	r5, r5, r2
   14802:	42a5      	cmp	r5, r4
   14804:	bfa8      	it	ge
   14806:	4625      	movge	r5, r4
   14808:	b2ad      	uxth	r5, r5
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1480a:	462a      	mov	r2, r5
   1480c:	4419      	add	r1, r3
   1480e:	f009 f8a8 	bl	1d962 <memcpy>
}
   14812:	4628      	mov	r0, r5
   14814:	bd38      	pop	{r3, r4, r5, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   14816:	f06f 0506 	mvn.w	r5, #6
   1481a:	e7fa      	b.n	14812 <bt_gatt_attr_read.constprop.0+0x20>

0001481c <bt_gatt_attr_read_service>:
{
   1481c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   1481e:	460c      	mov	r4, r1
   14820:	4619      	mov	r1, r3
	struct bt_uuid *uuid = attr->user_data;
   14822:	68e3      	ldr	r3, [r4, #12]
{
   14824:	4610      	mov	r0, r2
	if (uuid->type == BT_UUID_TYPE_16) {
   14826:	781c      	ldrb	r4, [r3, #0]
{
   14828:	f8bd 2018 	ldrh.w	r2, [sp, #24]
	if (uuid->type == BT_UUID_TYPE_16) {
   1482c:	b954      	cbnz	r4, 14844 <bt_gatt_attr_read_service+0x28>
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   1482e:	885b      	ldrh	r3, [r3, #2]
   14830:	f8ad 300e 	strh.w	r3, [sp, #14]
		return bt_gatt_attr_read(conn, attr, buf, len, offset,
   14834:	2302      	movs	r3, #2
   14836:	9300      	str	r3, [sp, #0]
   14838:	f10d 030e 	add.w	r3, sp, #14
	return bt_gatt_attr_read(conn, attr, buf, len, offset,
   1483c:	f7ff ffd9 	bl	147f2 <bt_gatt_attr_read.constprop.0>
}
   14840:	b004      	add	sp, #16
   14842:	bd10      	pop	{r4, pc}
	return bt_gatt_attr_read(conn, attr, buf, len, offset,
   14844:	2410      	movs	r4, #16
   14846:	3301      	adds	r3, #1
   14848:	9400      	str	r4, [sp, #0]
   1484a:	e7f7      	b.n	1483c <bt_gatt_attr_read_service+0x20>

0001484c <read_name>:
{
   1484c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14850:	4614      	mov	r4, r2
   14852:	461d      	mov	r5, r3
   14854:	f8bd 7018 	ldrh.w	r7, [sp, #24]
	const char *name = bt_get_name();
   14858:	f7ef fb58 	bl	3f0c <bt_get_name>
   1485c:	4606      	mov	r6, r0
				 strlen(name));
   1485e:	f7eb fe01 	bl	464 <strlen>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   14862:	b280      	uxth	r0, r0
   14864:	9006      	str	r0, [sp, #24]
   14866:	4633      	mov	r3, r6
   14868:	463a      	mov	r2, r7
   1486a:	4629      	mov	r1, r5
   1486c:	4620      	mov	r0, r4
}
   1486e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   14872:	f7ff bfbe 	b.w	147f2 <bt_gatt_attr_read.constprop.0>

00014876 <read_appearance>:
{
   14876:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   14878:	4619      	mov	r1, r3
	uint16_t appearance = sys_cpu_to_le16(gap_appearance);
   1487a:	2300      	movs	r3, #0
   1487c:	f8ad 300e 	strh.w	r3, [sp, #14]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   14880:	2302      	movs	r3, #2
{
   14882:	4610      	mov	r0, r2
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   14884:	9300      	str	r3, [sp, #0]
   14886:	f8bd 2018 	ldrh.w	r2, [sp, #24]
   1488a:	f10d 030e 	add.w	r3, sp, #14
   1488e:	f7ff ffb0 	bl	147f2 <bt_gatt_attr_read.constprop.0>
}
   14892:	b005      	add	sp, #20
   14894:	f85d fb04 	ldr.w	pc, [sp], #4

00014898 <clear_cf_cfg>:
{
   14898:	b513      	push	{r0, r1, r4, lr}
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   1489a:	2400      	movs	r4, #0
{
   1489c:	4602      	mov	r2, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   1489e:	4669      	mov	r1, sp
   148a0:	3001      	adds	r0, #1
   148a2:	9400      	str	r4, [sp, #0]
   148a4:	f8cd 4003 	str.w	r4, [sp, #3]
   148a8:	f7ff ff97 	bl	147da <bt_addr_le_copy>
__ssp_bos_icheck3(memset, void *, int)
   148ac:	7214      	strb	r4, [r2, #8]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   148ae:	320c      	adds	r2, #12
   148b0:	e8d2 3fef 	ldaex	r3, [r2]
   148b4:	e8c2 4fe1 	stlex	r1, r4, [r2]
   148b8:	2900      	cmp	r1, #0
   148ba:	d1f9      	bne.n	148b0 <clear_cf_cfg+0x18>
}
   148bc:	b002      	add	sp, #8
   148be:	bd10      	pop	{r4, pc}

000148c0 <sc_save>:
{
   148c0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   148c4:	4680      	mov	r8, r0
   148c6:	460f      	mov	r7, r1
   148c8:	4616      	mov	r6, r2
   148ca:	461d      	mov	r5, r3
	cfg = find_sc_cfg(id, peer);
   148cc:	f7f1 fb52 	bl	5f74 <find_sc_cfg>
	if (!cfg) {
   148d0:	4604      	mov	r4, r0
   148d2:	b960      	cbnz	r0, 148ee <sc_save+0x2e>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   148d4:	4669      	mov	r1, sp
   148d6:	9000      	str	r0, [sp, #0]
   148d8:	f8cd 0003 	str.w	r0, [sp, #3]
   148dc:	f7f1 fb4a 	bl	5f74 <find_sc_cfg>
		if (!cfg) {
   148e0:	4604      	mov	r4, r0
   148e2:	b178      	cbz	r0, 14904 <sc_save+0x44>
		bt_addr_le_copy(&cfg->peer, peer);
   148e4:	4639      	mov	r1, r7
		cfg->id = id;
   148e6:	f800 8b01 	strb.w	r8, [r0], #1
		bt_addr_le_copy(&cfg->peer, peer);
   148ea:	f7ff ff76 	bl	147da <bt_addr_le_copy>
	if (!(cfg->data.start || cfg->data.end)) {
   148ee:	8922      	ldrh	r2, [r4, #8]
   148f0:	8963      	ldrh	r3, [r4, #10]
   148f2:	b91a      	cbnz	r2, 148fc <sc_save+0x3c>
   148f4:	b923      	cbnz	r3, 14900 <sc_save+0x40>
		cfg->data.start = start;
   148f6:	8126      	strh	r6, [r4, #8]
		*end = new_end;
   148f8:	8165      	strh	r5, [r4, #10]
   148fa:	e003      	b.n	14904 <sc_save+0x44>
	if (new_start >= *start && new_end <= *end) {
   148fc:	4296      	cmp	r6, r2
   148fe:	d304      	bcc.n	1490a <sc_save+0x4a>
   14900:	429d      	cmp	r5, r3
   14902:	d8f9      	bhi.n	148f8 <sc_save+0x38>
}
   14904:	b002      	add	sp, #8
   14906:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*start = new_start;
   1490a:	8126      	strh	r6, [r4, #8]
	if (*end < new_end) {
   1490c:	e7f8      	b.n	14900 <sc_save+0x40>

0001490e <sc_clear>:
{
   1490e:	b538      	push	{r3, r4, r5, lr}
   14910:	4604      	mov	r4, r0
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   14912:	f100 0588 	add.w	r5, r0, #136	; 0x88
   14916:	4629      	mov	r1, r5
   14918:	7a00      	ldrb	r0, [r0, #8]
   1491a:	f7fe ffa8 	bl	1386e <bt_addr_le_is_bonded>
	cfg = find_sc_cfg(id, (bt_addr_le_t *)addr);
   1491e:	4629      	mov	r1, r5
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
   14920:	7a20      	ldrb	r0, [r4, #8]
   14922:	f7f1 fb27 	bl	5f74 <find_sc_cfg>
		if (cfg) {
   14926:	b118      	cbz	r0, 14930 <sc_clear+0x22>
}
   14928:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			clear_sc_cfg(cfg);
   1492c:	f7ff bf5c 	b.w	147e8 <clear_sc_cfg>
}
   14930:	bd38      	pop	{r3, r4, r5, pc}

00014932 <sc_ccc_cfg_write>:
	if (value == BT_GATT_CCC_INDICATE) {
   14932:	2a02      	cmp	r2, #2
{
   14934:	b510      	push	{r4, lr}
	if (value == BT_GATT_CCC_INDICATE) {
   14936:	d108      	bne.n	1494a <sc_ccc_cfg_write+0x18>
		sc_save(conn->id, &conn->le.dst, 0, 0);
   14938:	2300      	movs	r3, #0
   1493a:	f100 0188 	add.w	r1, r0, #136	; 0x88
   1493e:	461a      	mov	r2, r3
   14940:	7a00      	ldrb	r0, [r0, #8]
   14942:	f7ff ffbd 	bl	148c0 <sc_save>
}
   14946:	2002      	movs	r0, #2
   14948:	bd10      	pop	{r4, pc}
		sc_clear(conn);
   1494a:	f7ff ffe0 	bl	1490e <sc_clear>
   1494e:	e7fa      	b.n	14946 <sc_ccc_cfg_write+0x14>

00014950 <cf_write>:
{
   14950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14954:	461f      	mov	r7, r3
   14956:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   1495a:	4680      	mov	r8, r0
	if (offset > sizeof(cfg->data)) {
   1495c:	2b01      	cmp	r3, #1
{
   1495e:	4616      	mov	r6, r2
	if (offset > sizeof(cfg->data)) {
   14960:	d83a      	bhi.n	149d8 <cf_write+0x88>
	if (offset + len > sizeof(cfg->data)) {
   14962:	443b      	add	r3, r7
   14964:	2b01      	cmp	r3, #1
   14966:	463d      	mov	r5, r7
   14968:	dc39      	bgt.n	149de <cf_write+0x8e>
	cfg = find_cf_cfg(conn);
   1496a:	f7f1 fb13 	bl	5f94 <find_cf_cfg>
	if (!cfg) {
   1496e:	4604      	mov	r4, r0
   14970:	b918      	cbnz	r0, 1497a <cf_write+0x2a>
		cfg = find_cf_cfg(NULL);
   14972:	f7f1 fb0f 	bl	5f94 <find_cf_cfg>
	if (!cfg) {
   14976:	4604      	mov	r4, r0
   14978:	b3a0      	cbz	r0, 149e4 <cf_write+0x94>
static bool cf_set_value(struct gatt_cf_cfg *cfg, const uint8_t *value, uint16_t len)
   1497a:	4632      	mov	r2, r6
   1497c:	eb07 0c06 	add.w	ip, r7, r6
	for (i = 0U; i < len && i <= last_byte; i++) {
   14980:	4562      	cmp	r2, ip
   14982:	d116      	bne.n	149b2 <cf_write+0x62>
	for (i = 0U; i < len && i < last_byte; i++) {
   14984:	b12f      	cbz	r7, 14992 <cf_write+0x42>
		cfg->data[i] |= value[i] & (BIT(last_bit + 1) - 1);
   14986:	7833      	ldrb	r3, [r6, #0]
   14988:	7a22      	ldrb	r2, [r4, #8]
   1498a:	f003 0307 	and.w	r3, r3, #7
   1498e:	4313      	orrs	r3, r2
   14990:	7223      	strb	r3, [r4, #8]
	bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   14992:	f108 0188 	add.w	r1, r8, #136	; 0x88
   14996:	1c60      	adds	r0, r4, #1
   14998:	f7ff ff1f 	bl	147da <bt_addr_le_copy>
	cfg->id = conn->id;
   1499c:	4620      	mov	r0, r4
   1499e:	f898 3008 	ldrb.w	r3, [r8, #8]
	atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   149a2:	2100      	movs	r1, #0
	cfg->id = conn->id;
   149a4:	f800 3b0c 	strb.w	r3, [r0], #12
	atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   149a8:	f7ff ff0d 	bl	147c6 <atomic_set_bit>
}
   149ac:	4628      	mov	r0, r5
   149ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		uint8_t chg_bits = value[i] ^ cfg->data[i];
   149b2:	2300      	movs	r3, #0
   149b4:	f812 1b01 	ldrb.w	r1, [r2], #1
   149b8:	7a20      	ldrb	r0, [r4, #8]
   149ba:	4041      	eors	r1, r0
			if ((BIT(bit) & chg_bits) &&
   149bc:	fa21 fe03 	lsr.w	lr, r1, r3
   149c0:	f01e 0f01 	tst.w	lr, #1
   149c4:	d004      	beq.n	149d0 <cf_write+0x80>
   149c6:	fa20 fe03 	lsr.w	lr, r0, r3
   149ca:	f01e 0f01 	tst.w	lr, #1
   149ce:	d10c      	bne.n	149ea <cf_write+0x9a>
		for (bit = 0U; bit <= last_bit; bit++) {
   149d0:	3301      	adds	r3, #1
   149d2:	2b03      	cmp	r3, #3
   149d4:	d1f2      	bne.n	149bc <cf_write+0x6c>
   149d6:	e7d3      	b.n	14980 <cf_write+0x30>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   149d8:	f06f 0506 	mvn.w	r5, #6
   149dc:	e7e6      	b.n	149ac <cf_write+0x5c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   149de:	f06f 050c 	mvn.w	r5, #12
   149e2:	e7e3      	b.n	149ac <cf_write+0x5c>
		return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
   149e4:	f06f 0510 	mvn.w	r5, #16
   149e8:	e7e0      	b.n	149ac <cf_write+0x5c>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
   149ea:	f06f 0512 	mvn.w	r5, #18
   149ee:	e7dd      	b.n	149ac <cf_write+0x5c>

000149f0 <sc_restore_rsp>:
{
   149f0:	b508      	push	{r3, lr}
	cfg = find_cf_cfg(conn);
   149f2:	f7f1 facf 	bl	5f94 <find_cf_cfg>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
   149f6:	b140      	cbz	r0, 14a0a <sc_restore_rsp+0x1a>
   149f8:	7a03      	ldrb	r3, [r0, #8]
   149fa:	07db      	lsls	r3, r3, #31
   149fc:	d505      	bpl.n	14a0a <sc_restore_rsp+0x1a>
}
   149fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   14a02:	2100      	movs	r1, #0
   14a04:	300c      	adds	r0, #12
   14a06:	f7ff bede 	b.w	147c6 <atomic_set_bit>
}
   14a0a:	bd08      	pop	{r3, pc}

00014a0c <cf_read>:
{
   14a0c:	b530      	push	{r4, r5, lr}
   14a0e:	461d      	mov	r5, r3
	uint8_t data[1] = {};
   14a10:	2300      	movs	r3, #0
{
   14a12:	b085      	sub	sp, #20
   14a14:	4614      	mov	r4, r2
	uint8_t data[1] = {};
   14a16:	f88d 300c 	strb.w	r3, [sp, #12]
	cfg = find_cf_cfg(conn);
   14a1a:	f7f1 fabb 	bl	5f94 <find_cf_cfg>
	if (cfg) {
   14a1e:	b110      	cbz	r0, 14a26 <cf_read+0x1a>
		memcpy(data, cfg->data, sizeof(data));
   14a20:	7a03      	ldrb	r3, [r0, #8]
   14a22:	f88d 300c 	strb.w	r3, [sp, #12]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   14a26:	2301      	movs	r3, #1
   14a28:	4629      	mov	r1, r5
   14a2a:	9300      	str	r3, [sp, #0]
   14a2c:	4620      	mov	r0, r4
   14a2e:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   14a32:	ab03      	add	r3, sp, #12
   14a34:	f7ff fedd 	bl	147f2 <bt_gatt_attr_read.constprop.0>
}
   14a38:	b005      	add	sp, #20
   14a3a:	bd30      	pop	{r4, r5, pc}

00014a3c <find_ccc_cfg>:
{
   14a3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   14a3e:	460c      	mov	r4, r1
   14a40:	1c4d      	adds	r5, r1, #1
		if (conn) {
   14a42:	b148      	cbz	r0, 14a58 <find_ccc_cfg+0x1c>
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
   14a44:	462a      	mov	r2, r5
   14a46:	7809      	ldrb	r1, [r1, #0]
   14a48:	f7fe ffe9 	bl	13a1e <bt_conn_is_peer_addr_le>
   14a4c:	2800      	cmp	r0, #0
	return NULL;
   14a4e:	bf08      	it	eq
   14a50:	2400      	moveq	r4, #0
}
   14a52:	4620      	mov	r0, r4
   14a54:	b003      	add	sp, #12
   14a56:	bd30      	pop	{r4, r5, pc}
		} else if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   14a58:	9000      	str	r0, [sp, #0]
	return memcmp(a, b, sizeof(*a));
   14a5a:	2207      	movs	r2, #7
   14a5c:	f8cd 0003 	str.w	r0, [sp, #3]
   14a60:	4669      	mov	r1, sp
   14a62:	4628      	mov	r0, r5
   14a64:	f008 ff6f 	bl	1d946 <memcmp>
   14a68:	2800      	cmp	r0, #0
	return NULL;
   14a6a:	bf18      	it	ne
   14a6c:	2400      	movne	r4, #0
   14a6e:	e7f0      	b.n	14a52 <find_ccc_cfg+0x16>

00014a70 <bt_gatt_attr_write_ccc>:
{
   14a70:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   14a74:	461f      	mov	r7, r3
   14a76:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   14a7a:	4606      	mov	r6, r0
   14a7c:	4688      	mov	r8, r1
	struct _bt_gatt_ccc *ccc = attr->user_data;
   14a7e:	f8d1 900c 	ldr.w	r9, [r1, #12]
	if (offset) {
   14a82:	2b00      	cmp	r3, #0
   14a84:	d144      	bne.n	14b10 <bt_gatt_attr_write_ccc+0xa0>
	if (!len || len > sizeof(uint16_t)) {
   14a86:	1e7b      	subs	r3, r7, #1
   14a88:	2b01      	cmp	r3, #1
   14a8a:	d844      	bhi.n	14b16 <bt_gatt_attr_write_ccc+0xa6>
	if (len < sizeof(uint16_t)) {
   14a8c:	2f01      	cmp	r7, #1
		value = *(uint8_t *)buf;
   14a8e:	7815      	ldrb	r5, [r2, #0]
   14a90:	bf18      	it	ne
   14a92:	7852      	ldrbne	r2, [r2, #1]
	cfg = find_ccc_cfg(conn, ccc);
   14a94:	4649      	mov	r1, r9
		value = *(uint8_t *)buf;
   14a96:	bf0c      	ite	eq
   14a98:	b2ad      	uxtheq	r5, r5
   14a9a:	ea45 2502 	orrne.w	r5, r5, r2, lsl #8
	cfg = find_ccc_cfg(conn, ccc);
   14a9e:	f7ff ffcd 	bl	14a3c <find_ccc_cfg>
	if (!cfg) {
   14aa2:	4604      	mov	r4, r0
   14aa4:	b980      	cbnz	r0, 14ac8 <bt_gatt_attr_write_ccc+0x58>
		if (!value) {
   14aa6:	b91d      	cbnz	r5, 14ab0 <bt_gatt_attr_write_ccc+0x40>
			return len;
   14aa8:	4638      	mov	r0, r7
}
   14aaa:	b003      	add	sp, #12
   14aac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		cfg = find_ccc_cfg(NULL, ccc);
   14ab0:	4649      	mov	r1, r9
   14ab2:	f7ff ffc3 	bl	14a3c <find_ccc_cfg>
		if (!cfg) {
   14ab6:	4604      	mov	r4, r0
   14ab8:	b380      	cbz	r0, 14b1c <bt_gatt_attr_write_ccc+0xac>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   14aba:	f106 0188 	add.w	r1, r6, #136	; 0x88
   14abe:	3001      	adds	r0, #1
   14ac0:	f7ff fe8b 	bl	147da <bt_addr_le_copy>
		cfg->id = conn->id;
   14ac4:	7a33      	ldrb	r3, [r6, #8]
   14ac6:	7023      	strb	r3, [r4, #0]
	if (ccc->cfg_write) {
   14ac8:	f8d9 3010 	ldr.w	r3, [r9, #16]
   14acc:	b9a3      	cbnz	r3, 14af8 <bt_gatt_attr_write_ccc+0x88>
	if (cfg->value != ccc->value) {
   14ace:	f8b9 300a 	ldrh.w	r3, [r9, #10]
	cfg->value = value;
   14ad2:	8125      	strh	r5, [r4, #8]
	if (cfg->value != ccc->value) {
   14ad4:	42ab      	cmp	r3, r5
   14ad6:	d003      	beq.n	14ae0 <bt_gatt_attr_write_ccc+0x70>
		gatt_ccc_changed(attr, ccc);
   14ad8:	4649      	mov	r1, r9
   14ada:	4640      	mov	r0, r8
   14adc:	f7ff fdfd 	bl	146da <gatt_ccc_changed>
	if (!value) {
   14ae0:	2d00      	cmp	r5, #0
   14ae2:	d1e1      	bne.n	14aa8 <bt_gatt_attr_write_ccc+0x38>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   14ae4:	4669      	mov	r1, sp
   14ae6:	1c60      	adds	r0, r4, #1
   14ae8:	9500      	str	r5, [sp, #0]
   14aea:	f8cd 5003 	str.w	r5, [sp, #3]
   14aee:	f7ff fe74 	bl	147da <bt_addr_le_copy>
	cfg->id = 0U;
   14af2:	7025      	strb	r5, [r4, #0]
	cfg->value = 0U;
   14af4:	8125      	strh	r5, [r4, #8]
}
   14af6:	e7d7      	b.n	14aa8 <bt_gatt_attr_write_ccc+0x38>
		ssize_t write = ccc->cfg_write(conn, attr, value);
   14af8:	462a      	mov	r2, r5
   14afa:	4641      	mov	r1, r8
   14afc:	4630      	mov	r0, r6
   14afe:	4798      	blx	r3
		if (write < 0) {
   14b00:	2800      	cmp	r0, #0
   14b02:	dbd2      	blt.n	14aaa <bt_gatt_attr_write_ccc+0x3a>
		if (write != sizeof(value) && write != 1) {
   14b04:	3801      	subs	r0, #1
   14b06:	2801      	cmp	r0, #1
   14b08:	d9e1      	bls.n	14ace <bt_gatt_attr_write_ccc+0x5e>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
   14b0a:	f06f 000d 	mvn.w	r0, #13
   14b0e:	e7cc      	b.n	14aaa <bt_gatt_attr_write_ccc+0x3a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   14b10:	f06f 0006 	mvn.w	r0, #6
   14b14:	e7c9      	b.n	14aaa <bt_gatt_attr_write_ccc+0x3a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   14b16:	f06f 000c 	mvn.w	r0, #12
   14b1a:	e7c6      	b.n	14aaa <bt_gatt_attr_write_ccc+0x3a>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
   14b1c:	f06f 0010 	mvn.w	r0, #16
   14b20:	e7c3      	b.n	14aaa <bt_gatt_attr_write_ccc+0x3a>

00014b22 <bt_gatt_attr_read_ccc>:
{
   14b22:	b530      	push	{r4, r5, lr}
	cfg = find_ccc_cfg(conn, ccc);
   14b24:	68c9      	ldr	r1, [r1, #12]
{
   14b26:	b085      	sub	sp, #20
   14b28:	4614      	mov	r4, r2
   14b2a:	461d      	mov	r5, r3
	cfg = find_ccc_cfg(conn, ccc);
   14b2c:	f7ff ff86 	bl	14a3c <find_ccc_cfg>
	if (cfg) {
   14b30:	b100      	cbz	r0, 14b34 <bt_gatt_attr_read_ccc+0x12>
		value = sys_cpu_to_le16(cfg->value);
   14b32:	8900      	ldrh	r0, [r0, #8]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   14b34:	2302      	movs	r3, #2
   14b36:	f8ad 000e 	strh.w	r0, [sp, #14]
   14b3a:	9300      	str	r3, [sp, #0]
   14b3c:	4629      	mov	r1, r5
   14b3e:	4620      	mov	r0, r4
   14b40:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   14b44:	f10d 030e 	add.w	r3, sp, #14
   14b48:	f7ff fe53 	bl	147f2 <bt_gatt_attr_read.constprop.0>
}
   14b4c:	b005      	add	sp, #20
   14b4e:	bd30      	pop	{r4, r5, pc}

00014b50 <gatt_notify>:
{
   14b50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14b54:	4614      	mov	r4, r2
				sizeof(*nfy) + params->len);
   14b56:	8992      	ldrh	r2, [r2, #12]
{
   14b58:	4688      	mov	r8, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
   14b5a:	3202      	adds	r2, #2
   14b5c:	211b      	movs	r1, #27
{
   14b5e:	4607      	mov	r7, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
   14b60:	f7ff fc61 	bl	14426 <bt_att_create_pdu>
	if (!buf) {
   14b64:	4605      	mov	r5, r0
   14b66:	b1c8      	cbz	r0, 14b9c <gatt_notify+0x4c>
   14b68:	f100 0908 	add.w	r9, r0, #8
   14b6c:	2102      	movs	r1, #2
   14b6e:	4648      	mov	r0, r9
   14b70:	f000 f934 	bl	14ddc <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
   14b74:	4606      	mov	r6, r0
   14b76:	89a1      	ldrh	r1, [r4, #12]
   14b78:	f826 8b02 	strh.w	r8, [r6], #2
   14b7c:	4648      	mov	r0, r9
   14b7e:	f000 f92d 	bl	14ddc <net_buf_simple_add>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   14b82:	89a2      	ldrh	r2, [r4, #12]
   14b84:	68a1      	ldr	r1, [r4, #8]
   14b86:	4630      	mov	r0, r6
   14b88:	f008 feeb 	bl	1d962 <memcpy>
	return bt_att_send(conn, buf, params->func, params->user_data);
   14b8c:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   14b90:	4629      	mov	r1, r5
   14b92:	4638      	mov	r0, r7
}
   14b94:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_att_send(conn, buf, params->func, params->user_data);
   14b98:	f7ff bd15 	b.w	145c6 <bt_att_send>
}
   14b9c:	f06f 000b 	mvn.w	r0, #11
   14ba0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00014ba4 <bt_gatt_attr_value_handle>:
{
   14ba4:	b513      	push	{r0, r1, r4, lr}
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   14ba6:	4604      	mov	r4, r0
   14ba8:	b910      	cbnz	r0, 14bb0 <bt_gatt_attr_value_handle+0xc>
	uint16_t handle = 0;
   14baa:	2000      	movs	r0, #0
}
   14bac:	b002      	add	sp, #8
   14bae:	bd10      	pop	{r4, pc}
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   14bb0:	2300      	movs	r3, #0
   14bb2:	f88d 3004 	strb.w	r3, [sp, #4]
   14bb6:	f642 0303 	movw	r3, #10243	; 0x2803
   14bba:	6800      	ldr	r0, [r0, #0]
   14bbc:	a901      	add	r1, sp, #4
   14bbe:	f8ad 3006 	strh.w	r3, [sp, #6]
   14bc2:	f7fe fb6a 	bl	1329a <bt_uuid_cmp>
   14bc6:	2800      	cmp	r0, #0
   14bc8:	d1ef      	bne.n	14baa <bt_gatt_attr_value_handle+0x6>
		handle = chrc->value_handle;
   14bca:	68e3      	ldr	r3, [r4, #12]
   14bcc:	8898      	ldrh	r0, [r3, #4]
		if (handle == 0) {
   14bce:	2800      	cmp	r0, #0
   14bd0:	d1ec      	bne.n	14bac <bt_gatt_attr_value_handle+0x8>
			handle = bt_gatt_attr_get_handle(attr) + 1U;
   14bd2:	4620      	mov	r0, r4
   14bd4:	f7f1 fb6e 	bl	62b4 <bt_gatt_attr_get_handle>
   14bd8:	3001      	adds	r0, #1
   14bda:	b280      	uxth	r0, r0
	return handle;
   14bdc:	e7e6      	b.n	14bac <bt_gatt_attr_value_handle+0x8>

00014bde <bt_gatt_attr_read_chrc>:
{
   14bde:	b570      	push	{r4, r5, r6, lr}
	struct bt_gatt_chrc *chrc = attr->user_data;
   14be0:	68ce      	ldr	r6, [r1, #12]
{
   14be2:	461d      	mov	r5, r3
	pdu.properties = chrc->properties;
   14be4:	79b3      	ldrb	r3, [r6, #6]
{
   14be6:	b088      	sub	sp, #32
   14be8:	4608      	mov	r0, r1
	pdu.properties = chrc->properties;
   14bea:	f88d 300c 	strb.w	r3, [sp, #12]
{
   14bee:	4614      	mov	r4, r2
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   14bf0:	f7ff ffd8 	bl	14ba4 <bt_gatt_attr_value_handle>
   14bf4:	f8ad 000d 	strh.w	r0, [sp, #13]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   14bf8:	6830      	ldr	r0, [r6, #0]
   14bfa:	7803      	ldrb	r3, [r0, #0]
   14bfc:	b96b      	cbnz	r3, 14c1a <bt_gatt_attr_read_chrc+0x3c>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   14bfe:	8843      	ldrh	r3, [r0, #2]
   14c00:	f8ad 300f 	strh.w	r3, [sp, #15]
		value_len += 2U;
   14c04:	2305      	movs	r3, #5
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   14c06:	9300      	str	r3, [sp, #0]
   14c08:	4629      	mov	r1, r5
   14c0a:	4620      	mov	r0, r4
   14c0c:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   14c10:	ab03      	add	r3, sp, #12
   14c12:	f7ff fdee 	bl	147f2 <bt_gatt_attr_read.constprop.0>
}
   14c16:	b008      	add	sp, #32
   14c18:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   14c1a:	1c43      	adds	r3, r0, #1
   14c1c:	f10d 020f 	add.w	r2, sp, #15
   14c20:	3011      	adds	r0, #17
   14c22:	f853 1b04 	ldr.w	r1, [r3], #4
   14c26:	4283      	cmp	r3, r0
   14c28:	f842 1b04 	str.w	r1, [r2], #4
   14c2c:	d1f9      	bne.n	14c22 <bt_gatt_attr_read_chrc+0x44>
		value_len += 16U;
   14c2e:	2313      	movs	r3, #19
   14c30:	e7e9      	b.n	14c06 <bt_gatt_attr_read_chrc+0x28>

00014c32 <bt_gatt_foreach_attr>:
{
   14c32:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   14c34:	e9cd 2301 	strd	r2, r3, [sp, #4]
   14c38:	2300      	movs	r3, #0
   14c3a:	461a      	mov	r2, r3
   14c3c:	9300      	str	r3, [sp, #0]
   14c3e:	f7f1 fb69 	bl	6314 <bt_gatt_foreach_attr_type>
}
   14c42:	b005      	add	sp, #20
   14c44:	f85d fb04 	ldr.w	pc, [sp], #4

00014c48 <db_hash_process>:
	db_hash_gen(true);
   14c48:	f7f1 bbbe 	b.w	63c8 <db_hash_gen.isra.0>

00014c4c <bt_gatt_check_perm>:
	if ((mask & BT_GATT_PERM_READ) &&
   14c4c:	07d3      	lsls	r3, r2, #31
{
   14c4e:	b510      	push	{r4, lr}
   14c50:	7c8c      	ldrb	r4, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
   14c52:	d504      	bpl.n	14c5e <bt_gatt_check_perm+0x12>
   14c54:	f014 0f15 	tst.w	r4, #21
   14c58:	d017      	beq.n	14c8a <bt_gatt_check_perm+0x3e>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   14c5a:	684b      	ldr	r3, [r1, #4]
   14c5c:	b1ab      	cbz	r3, 14c8a <bt_gatt_check_perm+0x3e>
	if ((mask & BT_GATT_PERM_WRITE) &&
   14c5e:	0793      	lsls	r3, r2, #30
   14c60:	d504      	bpl.n	14c6c <bt_gatt_check_perm+0x20>
   14c62:	f014 0f2a 	tst.w	r4, #42	; 0x2a
   14c66:	d012      	beq.n	14c8e <bt_gatt_check_perm+0x42>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   14c68:	688b      	ldr	r3, [r1, #8]
   14c6a:	b183      	cbz	r3, 14c8e <bt_gatt_check_perm+0x42>
	mask &= attr->perm;
   14c6c:	4014      	ands	r4, r2
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   14c6e:	f014 0f30 	tst.w	r4, #48	; 0x30
   14c72:	d104      	bne.n	14c7e <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   14c74:	f014 000c 	ands.w	r0, r4, #12
   14c78:	bf18      	it	ne
   14c7a:	200f      	movne	r0, #15
}
   14c7c:	bd10      	pop	{r4, pc}
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   14c7e:	f7fe fe7c 	bl	1397a <bt_conn_get_security>
   14c82:	2802      	cmp	r0, #2
   14c84:	d8f6      	bhi.n	14c74 <bt_gatt_check_perm+0x28>
			return BT_ATT_ERR_AUTHENTICATION;
   14c86:	2005      	movs	r0, #5
   14c88:	e7f8      	b.n	14c7c <bt_gatt_check_perm+0x30>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   14c8a:	2002      	movs	r0, #2
   14c8c:	e7f6      	b.n	14c7c <bt_gatt_check_perm+0x30>
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   14c8e:	2003      	movs	r0, #3
   14c90:	e7f4      	b.n	14c7c <bt_gatt_check_perm+0x30>

00014c92 <bt_gatt_change_aware>:
{
   14c92:	b510      	push	{r4, lr}
   14c94:	460c      	mov	r4, r1
	cfg = find_cf_cfg(conn);
   14c96:	f7f1 f97d 	bl	5f94 <find_cf_cfg>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   14c9a:	b910      	cbnz	r0, 14ca2 <bt_gatt_change_aware+0x10>
		return true;
   14c9c:	2401      	movs	r4, #1
}
   14c9e:	4620      	mov	r0, r4
   14ca0:	bd10      	pop	{r4, pc}
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   14ca2:	7a03      	ldrb	r3, [r0, #8]
   14ca4:	07da      	lsls	r2, r3, #31
   14ca6:	d5f9      	bpl.n	14c9c <bt_gatt_change_aware+0xa>
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   14ca8:	300c      	adds	r0, #12
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   14caa:	e8d0 1faf 	lda	r1, [r0]
   14cae:	f011 0101 	ands.w	r1, r1, #1
   14cb2:	d1f3      	bne.n	14c9c <bt_gatt_change_aware+0xa>
	if (!req) {
   14cb4:	2c00      	cmp	r4, #0
   14cb6:	d0f2      	beq.n	14c9e <bt_gatt_change_aware+0xc>
   14cb8:	e8d0 3faf 	lda	r3, [r0]
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   14cbc:	f3c3 0440 	ubfx	r4, r3, #1, #1
	if (atomic_test_bit(cfg->flags, CF_OUT_OF_SYNC)) {
   14cc0:	079b      	lsls	r3, r3, #30
   14cc2:	d50a      	bpl.n	14cda <bt_gatt_change_aware+0x48>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   14cc4:	e8d0 3fef 	ldaex	r3, [r0]
   14cc8:	f023 0302 	bic.w	r3, r3, #2
   14ccc:	e8c0 3fe2 	stlex	r2, r3, [r0]
   14cd0:	2a00      	cmp	r2, #0
   14cd2:	d1f7      	bne.n	14cc4 <bt_gatt_change_aware+0x32>
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   14cd4:	f7ff fd77 	bl	147c6 <atomic_set_bit>
	return false;
   14cd8:	e7e1      	b.n	14c9e <bt_gatt_change_aware+0xc>
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   14cda:	2101      	movs	r1, #1
   14cdc:	e7fa      	b.n	14cd4 <bt_gatt_change_aware+0x42>

00014cde <bt_smp_recv>:
{
   14cde:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	buf = bt_l2cap_create_pdu(NULL, 0);
   14ce0:	2100      	movs	r1, #0
   14ce2:	f04f 32ff 	mov.w	r2, #4294967295
   14ce6:	f04f 33ff 	mov.w	r3, #4294967295
	struct bt_conn *conn = chan->conn;
   14cea:	6807      	ldr	r7, [r0, #0]
	buf = bt_l2cap_create_pdu(NULL, 0);
   14cec:	4608      	mov	r0, r1
   14cee:	f7fe ff9b 	bl	13c28 <bt_l2cap_create_pdu_timeout>
   14cf2:	f100 0608 	add.w	r6, r0, #8
   14cf6:	4604      	mov	r4, r0
   14cf8:	2101      	movs	r1, #1
   14cfa:	4630      	mov	r0, r6
   14cfc:	f000 f86e 	bl	14ddc <net_buf_simple_add>
	hdr->code = BT_SMP_CMD_PAIRING_FAIL;
   14d00:	2505      	movs	r5, #5
   14d02:	2101      	movs	r1, #1
   14d04:	7005      	strb	r5, [r0, #0]
   14d06:	4630      	mov	r0, r6
   14d08:	f000 f868 	bl	14ddc <net_buf_simple_add>
	rsp->reason = BT_SMP_ERR_PAIRING_NOTSUPP;
   14d0c:	7005      	strb	r5, [r0, #0]
   14d0e:	2500      	movs	r5, #0
   14d10:	4622      	mov	r2, r4
   14d12:	462b      	mov	r3, r5
   14d14:	2106      	movs	r1, #6
   14d16:	4638      	mov	r0, r7
   14d18:	9500      	str	r5, [sp, #0]
   14d1a:	f7fe ff88 	bl	13c2e <bt_l2cap_send_cb>
}
   14d1e:	4628      	mov	r0, r5
   14d20:	b003      	add	sp, #12
   14d22:	bdf0      	pop	{r4, r5, r6, r7, pc}

00014d24 <bt_smp_sign>:
   14d24:	f06f 0085 	mvn.w	r0, #133	; 0x85
   14d28:	4770      	bx	lr

00014d2a <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_fixed_chan, BT_L2CAP_CID_SMP, bt_smp_accept, NULL);

int bt_smp_init(void)
{
	return 0;
}
   14d2a:	2000      	movs	r0, #0
   14d2c:	4770      	bx	lr

00014d2e <fixed_data_unref>:
}
   14d2e:	4770      	bx	lr

00014d30 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   14d30:	6a01      	ldr	r1, [r0, #32]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   14d32:	6849      	ldr	r1, [r1, #4]
   14d34:	6809      	ldr	r1, [r1, #0]
   14d36:	f7f1 bd7f 	b.w	6838 <net_buf_alloc_len>

00014d3a <net_buf_get>:
{
   14d3a:	b570      	push	{r4, r5, r6, lr}
   14d3c:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
   14d3e:	f7fb fc57 	bl	105f0 <z_impl_k_queue_get>
	if (!buf) {
   14d42:	4605      	mov	r5, r0
   14d44:	b128      	cbz	r0, 14d52 <net_buf_get+0x18>
   14d46:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   14d48:	7963      	ldrb	r3, [r4, #5]
   14d4a:	f013 0301 	ands.w	r3, r3, #1
   14d4e:	d102      	bne.n	14d56 <net_buf_get+0x1c>
	frag->frags = NULL;
   14d50:	6023      	str	r3, [r4, #0]
}
   14d52:	4628      	mov	r0, r5
   14d54:	bd70      	pop	{r4, r5, r6, pc}
   14d56:	2300      	movs	r3, #0
   14d58:	2200      	movs	r2, #0
   14d5a:	4630      	mov	r0, r6
   14d5c:	f7fb fc48 	bl	105f0 <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
   14d60:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   14d62:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
   14d64:	f023 0301 	bic.w	r3, r3, #1
   14d68:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   14d6a:	4604      	mov	r4, r0
   14d6c:	e7ec      	b.n	14d48 <net_buf_get+0xe>

00014d6e <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
   14d6e:	6883      	ldr	r3, [r0, #8]
   14d70:	440b      	add	r3, r1
   14d72:	6003      	str	r3, [r0, #0]
}
   14d74:	4770      	bx	lr

00014d76 <net_buf_put>:
	for (tail = buf; tail->frags; tail = tail->frags) {
   14d76:	460a      	mov	r2, r1
{
   14d78:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
   14d7a:	6814      	ldr	r4, [r2, #0]
   14d7c:	b914      	cbnz	r4, 14d84 <net_buf_put+0xe>
}
   14d7e:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
   14d80:	f008 ba0b 	b.w	1d19a <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   14d84:	7953      	ldrb	r3, [r2, #5]
   14d86:	f043 0301 	orr.w	r3, r3, #1
   14d8a:	7153      	strb	r3, [r2, #5]
   14d8c:	4622      	mov	r2, r4
   14d8e:	e7f4      	b.n	14d7a <net_buf_put+0x4>

00014d90 <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   14d90:	7902      	ldrb	r2, [r0, #4]
   14d92:	3201      	adds	r2, #1
   14d94:	7102      	strb	r2, [r0, #4]
	return buf;
}
   14d96:	4770      	bx	lr

00014d98 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
   14d98:	4603      	mov	r3, r0
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
   14d9a:	4618      	mov	r0, r3
   14d9c:	681b      	ldr	r3, [r3, #0]
   14d9e:	2b00      	cmp	r3, #0
   14da0:	d1fb      	bne.n	14d9a <net_buf_frag_last+0x2>
		buf = buf->frags;
	}

	return buf;
}
   14da2:	4770      	bx	lr

00014da4 <net_buf_frag_insert>:
void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
   14da4:	6802      	ldr	r2, [r0, #0]
{
   14da6:	b510      	push	{r4, lr}
	if (parent->frags) {
   14da8:	b12a      	cbz	r2, 14db6 <net_buf_frag_insert+0x12>
   14daa:	460b      	mov	r3, r1
	while (buf->frags) {
   14dac:	461c      	mov	r4, r3
   14dae:	681b      	ldr	r3, [r3, #0]
   14db0:	2b00      	cmp	r3, #0
   14db2:	d1fb      	bne.n	14dac <net_buf_frag_insert+0x8>
		net_buf_frag_last(frag)->frags = parent->frags;
   14db4:	6022      	str	r2, [r4, #0]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
   14db6:	6001      	str	r1, [r0, #0]
}
   14db8:	bd10      	pop	{r4, pc}

00014dba <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
   14dba:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(frag);

	if (!head) {
   14dbc:	4604      	mov	r4, r0
   14dbe:	b920      	cbnz	r0, 14dca <net_buf_frag_add+0x10>
		return net_buf_ref(frag);
   14dc0:	4608      	mov	r0, r1
	buf->ref++;
   14dc2:	790b      	ldrb	r3, [r1, #4]
   14dc4:	3301      	adds	r3, #1
   14dc6:	710b      	strb	r3, [r1, #4]
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);

	return head;
}
   14dc8:	bd10      	pop	{r4, pc}
   14dca:	4603      	mov	r3, r0
	while (buf->frags) {
   14dcc:	4618      	mov	r0, r3
   14dce:	681b      	ldr	r3, [r3, #0]
   14dd0:	2b00      	cmp	r3, #0
   14dd2:	d1fb      	bne.n	14dcc <net_buf_frag_add+0x12>
	net_buf_frag_insert(net_buf_frag_last(head), frag);
   14dd4:	f7ff ffe6 	bl	14da4 <net_buf_frag_insert>
   14dd8:	4620      	mov	r0, r4
   14dda:	e7f5      	b.n	14dc8 <net_buf_frag_add+0xe>

00014ddc <net_buf_simple_add>:
	return buf->data + buf->len;
   14ddc:	8883      	ldrh	r3, [r0, #4]
   14dde:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   14de0:	4419      	add	r1, r3
   14de2:	8081      	strh	r1, [r0, #4]
	return tail;
}
   14de4:	18d0      	adds	r0, r2, r3
   14de6:	4770      	bx	lr

00014de8 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   14de8:	b510      	push	{r4, lr}
   14dea:	6803      	ldr	r3, [r0, #0]
   14dec:	8884      	ldrh	r4, [r0, #4]
   14dee:	4423      	add	r3, r4
	buf->len += len;
   14df0:	4414      	add	r4, r2
   14df2:	8084      	strh	r4, [r0, #4]
   14df4:	4618      	mov	r0, r3
   14df6:	f008 fdb4 	bl	1d962 <memcpy>
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
}
   14dfa:	bd10      	pop	{r4, pc}

00014dfc <net_buf_simple_add_u8>:

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
   14dfc:	b510      	push	{r4, lr}
   14dfe:	8883      	ldrh	r3, [r0, #4]
   14e00:	6802      	ldr	r2, [r0, #0]
	buf->len += len;
   14e02:	1c5c      	adds	r4, r3, #1
   14e04:	8084      	strh	r4, [r0, #4]
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
   14e06:	54d1      	strb	r1, [r2, r3]

	return u8;
}
   14e08:	18d0      	adds	r0, r2, r3
   14e0a:	bd10      	pop	{r4, pc}

00014e0c <net_buf_simple_push>:

	return sys_be64_to_cpu(val);
}

void *net_buf_simple_push(struct net_buf_simple *buf, size_t len)
{
   14e0c:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
   14e0e:	6800      	ldr	r0, [r0, #0]
	buf->len += len;
   14e10:	889a      	ldrh	r2, [r3, #4]
	buf->data -= len;
   14e12:	1a40      	subs	r0, r0, r1
	buf->len += len;
   14e14:	4411      	add	r1, r2
	buf->data -= len;
   14e16:	6018      	str	r0, [r3, #0]
	buf->len += len;
   14e18:	8099      	strh	r1, [r3, #4]
	return buf->data;
}
   14e1a:	4770      	bx	lr

00014e1c <net_buf_simple_push_u8>:
	buf->data -= len;
   14e1c:	6802      	ldr	r2, [r0, #0]
   14e1e:	1e53      	subs	r3, r2, #1
   14e20:	6003      	str	r3, [r0, #0]
	buf->len += len;
   14e22:	8883      	ldrh	r3, [r0, #4]
   14e24:	3301      	adds	r3, #1
   14e26:	8083      	strh	r3, [r0, #4]

void net_buf_simple_push_u8(struct net_buf_simple *buf, uint8_t val)
{
	uint8_t *data = net_buf_simple_push(buf, 1);

	*data = val;
   14e28:	f802 1c01 	strb.w	r1, [r2, #-1]
}
   14e2c:	4770      	bx	lr

00014e2e <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
   14e2e:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   14e30:	8882      	ldrh	r2, [r0, #4]
   14e32:	1a52      	subs	r2, r2, r1
   14e34:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
   14e36:	6800      	ldr	r0, [r0, #0]
   14e38:	4408      	add	r0, r1
   14e3a:	6018      	str	r0, [r3, #0]
}
   14e3c:	4770      	bx	lr

00014e3e <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   14e3e:	4603      	mov	r3, r0
	void *data = buf->data;
   14e40:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   14e42:	889a      	ldrh	r2, [r3, #4]
   14e44:	1a52      	subs	r2, r2, r1
	buf->data += len;
   14e46:	4401      	add	r1, r0
	buf->len -= len;
   14e48:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   14e4a:	6019      	str	r1, [r3, #0]

	return data;
}
   14e4c:	4770      	bx	lr

00014e4e <net_buf_simple_pull_le16>:

	return val;
}

uint16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
   14e4e:	b510      	push	{r4, lr}
	uint16_t val;

	val = UNALIGNED_GET((uint16_t *)buf->data);
   14e50:	6803      	ldr	r3, [r0, #0]
	net_buf_simple_pull(buf, sizeof(val));
   14e52:	2102      	movs	r1, #2
	val = UNALIGNED_GET((uint16_t *)buf->data);
   14e54:	881c      	ldrh	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   14e56:	f7ff ffea 	bl	14e2e <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   14e5a:	4620      	mov	r0, r4
   14e5c:	bd10      	pop	{r4, pc}

00014e5e <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   14e5e:	6802      	ldr	r2, [r0, #0]
   14e60:	6880      	ldr	r0, [r0, #8]
}
   14e62:	1a10      	subs	r0, r2, r0
   14e64:	4770      	bx	lr

00014e66 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   14e66:	8883      	ldrh	r3, [r0, #4]
   14e68:	88c2      	ldrh	r2, [r0, #6]
   14e6a:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
   14e6c:	6803      	ldr	r3, [r0, #0]
   14e6e:	6880      	ldr	r0, [r0, #8]
   14e70:	1a18      	subs	r0, r3, r0
}
   14e72:	1a10      	subs	r0, r2, r0
   14e74:	4770      	bx	lr

00014e76 <gpio_fire_callbacks>:
 * @param pins The actual pin mask that triggered the interrupt
 */
static inline void gpio_fire_callbacks(sys_slist_t *list,
					const struct device *port,
					uint32_t pins)
{
   14e76:	b570      	push	{r4, r5, r6, lr}
   14e78:	460e      	mov	r6, r1
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   14e7a:	6801      	ldr	r1, [r0, #0]
{
   14e7c:	4615      	mov	r5, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   14e7e:	b189      	cbz	r1, 14ea4 <gpio_fire_callbacks+0x2e>
	return node->next;
   14e80:	680c      	ldr	r4, [r1, #0]
   14e82:	2c00      	cmp	r4, #0
   14e84:	bf38      	it	cc
   14e86:	2400      	movcc	r4, #0
		if (cb->pin_mask & pins) {
   14e88:	688a      	ldr	r2, [r1, #8]
   14e8a:	402a      	ands	r2, r5
   14e8c:	d002      	beq.n	14e94 <gpio_fire_callbacks+0x1e>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   14e8e:	4630      	mov	r0, r6
   14e90:	684b      	ldr	r3, [r1, #4]
   14e92:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   14e94:	b134      	cbz	r4, 14ea4 <gpio_fire_callbacks+0x2e>
   14e96:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   14e98:	4621      	mov	r1, r4
   14e9a:	2b00      	cmp	r3, #0
   14e9c:	bf38      	it	cc
   14e9e:	2300      	movcc	r3, #0
   14ea0:	461c      	mov	r4, r3
   14ea2:	e7f1      	b.n	14e88 <gpio_fire_callbacks+0x12>
		}
	}
}
   14ea4:	bd70      	pop	{r4, r5, r6, pc}

00014ea6 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14ea6:	6843      	ldr	r3, [r0, #4]
}
   14ea8:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14eaa:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   14eac:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   14eae:	600b      	str	r3, [r1, #0]
}
   14eb0:	4770      	bx	lr

00014eb2 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14eb2:	6843      	ldr	r3, [r0, #4]
   14eb4:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   14eb6:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   14eb8:	4042      	eors	r2, r0
   14eba:	400a      	ands	r2, r1
   14ebc:	4042      	eors	r2, r0
    p_reg->OUT = value;
   14ebe:	605a      	str	r2, [r3, #4]
}
   14ec0:	2000      	movs	r0, #0
   14ec2:	4770      	bx	lr

00014ec4 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14ec4:	6843      	ldr	r3, [r0, #4]
}
   14ec6:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14ec8:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   14eca:	6099      	str	r1, [r3, #8]
}
   14ecc:	4770      	bx	lr

00014ece <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14ece:	6843      	ldr	r3, [r0, #4]
}
   14ed0:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14ed2:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   14ed4:	60d9      	str	r1, [r3, #12]
}
   14ed6:	4770      	bx	lr

00014ed8 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14ed8:	6843      	ldr	r3, [r0, #4]
}
   14eda:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   14edc:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   14ede:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   14ee0:	404b      	eors	r3, r1
    p_reg->OUT = value;
   14ee2:	6053      	str	r3, [r2, #4]
}
   14ee4:	4770      	bx	lr

00014ee6 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   14ee6:	68c3      	ldr	r3, [r0, #12]
{
   14ee8:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   14eea:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   14eec:	b158      	cbz	r0, 14f06 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   14eee:	2400      	movs	r4, #0
   14ef0:	4281      	cmp	r1, r0
   14ef2:	d113      	bne.n	14f1c <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   14ef4:	6808      	ldr	r0, [r1, #0]
   14ef6:	b95c      	cbnz	r4, 14f10 <gpio_nrfx_manage_callback+0x2a>
   14ef8:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   14efa:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   14efc:	42a1      	cmp	r1, r4
   14efe:	d100      	bne.n	14f02 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   14f00:	6098      	str	r0, [r3, #8]
	parent->next = child;
   14f02:	2000      	movs	r0, #0
   14f04:	6008      	str	r0, [r1, #0]
	if (set) {
   14f06:	b972      	cbnz	r2, 14f26 <gpio_nrfx_manage_callback+0x40>
	return 0;
   14f08:	2000      	movs	r0, #0
}
   14f0a:	bd30      	pop	{r4, r5, pc}
   14f0c:	4628      	mov	r0, r5
   14f0e:	e7ef      	b.n	14ef0 <gpio_nrfx_manage_callback+0xa>
   14f10:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   14f12:	6898      	ldr	r0, [r3, #8]
   14f14:	4281      	cmp	r1, r0
	list->tail = node;
   14f16:	bf08      	it	eq
   14f18:	609c      	streq	r4, [r3, #8]
}
   14f1a:	e7f2      	b.n	14f02 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   14f1c:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   14f1e:	4604      	mov	r4, r0
   14f20:	2d00      	cmp	r5, #0
   14f22:	d1f3      	bne.n	14f0c <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   14f24:	b13a      	cbz	r2, 14f36 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   14f26:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   14f28:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   14f2a:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   14f2c:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   14f2e:	2800      	cmp	r0, #0
   14f30:	d1ea      	bne.n	14f08 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   14f32:	6099      	str	r1, [r3, #8]
}
   14f34:	e7e9      	b.n	14f0a <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   14f36:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   14f3a:	e7e6      	b.n	14f0a <gpio_nrfx_manage_callback+0x24>

00014f3c <check_level_trigger_pins>:
{
   14f3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t bit = 1U << pin;
   14f40:	2601      	movs	r6, #1
	uint32_t pin = 0U;
   14f42:	2700      	movs	r7, #0
	struct gpio_nrfx_data *data = get_port_data(port);
   14f44:	68c3      	ldr	r3, [r0, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   14f46:	f8d0 8004 	ldr.w	r8, [r0, #4]
	uint32_t out = data->pin_int_en;
   14f4a:	68dc      	ldr	r4, [r3, #12]
	out &= ~data->trig_edge & ~data->double_edge;
   14f4c:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   14f50:	430a      	orrs	r2, r1
   14f52:	ea24 0402 	bic.w	r4, r4, r2
	uint32_t port_in = nrf_gpio_port_in_read(cfg->port);
   14f56:	f8d8 2004 	ldr.w	r2, [r8, #4]
	uint32_t pin_states = ~(port_in ^ data->int_active_level);
   14f5a:	691b      	ldr	r3, [r3, #16]
    return p_reg->IN;
   14f5c:	6915      	ldr	r5, [r2, #16]
   14f5e:	405d      	eors	r5, r3
	uint32_t out = pin_states & level_pins;
   14f60:	ea24 0505 	bic.w	r5, r4, r5
	while (level_pins) {
   14f64:	b914      	cbnz	r4, 14f6c <check_level_trigger_pins+0x30>
}
   14f66:	4628      	mov	r0, r5
   14f68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   14f6c:	4234      	tst	r4, r6
   14f6e:	d00a      	beq.n	14f86 <check_level_trigger_pins+0x4a>
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   14f70:	f898 3008 	ldrb.w	r3, [r8, #8]
   14f74:	f007 001f 	and.w	r0, r7, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   14f78:	2100      	movs	r1, #0
   14f7a:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   14f7e:	f7f1 fd93 	bl	6aa8 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   14f82:	ea24 0406 	bic.w	r4, r4, r6
		++pin;
   14f86:	3701      	adds	r7, #1
		bit <<= 1;
   14f88:	0076      	lsls	r6, r6, #1
   14f8a:	e7eb      	b.n	14f64 <check_level_trigger_pins+0x28>

00014f8c <cfg_level_pins>:
{
   14f8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t bit = 1U << pin;
   14f90:	2601      	movs	r6, #1
	uint32_t pin = 0U;
   14f92:	2500      	movs	r5, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
   14f94:	68c7      	ldr	r7, [r0, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   14f96:	f8d0 8004 	ldr.w	r8, [r0, #4]
	uint32_t out = data->pin_int_en;
   14f9a:	68fc      	ldr	r4, [r7, #12]
	out &= ~data->trig_edge & ~data->double_edge;
   14f9c:	e9d7 3205 	ldrd	r3, r2, [r7, #20]
   14fa0:	4313      	orrs	r3, r2
   14fa2:	ea24 0403 	bic.w	r4, r4, r3
	while (level_pins) {
   14fa6:	b90c      	cbnz	r4, 14fac <cfg_level_pins+0x20>
}
   14fa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   14fac:	4226      	tst	r6, r4
   14fae:	d010      	beq.n	14fd2 <cfg_level_pins+0x46>
	if ((BIT(pin) & data->int_active_level) != 0U) {
   14fb0:	6939      	ldr	r1, [r7, #16]
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   14fb2:	f898 3008 	ldrb.w	r3, [r8, #8]
	if ((BIT(pin) & data->int_active_level) != 0U) {
   14fb6:	40e9      	lsrs	r1, r5
   14fb8:	f001 0101 	and.w	r1, r1, #1
   14fbc:	f1c1 0103 	rsb	r1, r1, #3
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   14fc0:	f005 001f 	and.w	r0, r5, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   14fc4:	b2c9      	uxtb	r1, r1
   14fc6:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   14fca:	f7f1 fd6d 	bl	6aa8 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   14fce:	ea24 0406 	bic.w	r4, r4, r6
		++pin;
   14fd2:	3501      	adds	r5, #1
		bit <<= 1;
   14fd4:	0076      	lsls	r6, r6, #1
   14fd6:	e7e6      	b.n	14fa6 <cfg_level_pins+0x1a>

00014fd8 <i2c_nrfx_twim_configure>:
	if (I2C_ADDR_10_BITS & dev_config) {
   14fd8:	07ca      	lsls	r2, r1, #31
	nrfx_twim_t const *inst = &(get_dev_config(dev)->twim);
   14fda:	6843      	ldr	r3, [r0, #4]
	if (I2C_ADDR_10_BITS & dev_config) {
   14fdc:	d405      	bmi.n	14fea <i2c_nrfx_twim_configure+0x12>
	switch (I2C_SPEED_GET(dev_config)) {
   14fde:	f3c1 0242 	ubfx	r2, r1, #1, #3
   14fe2:	2a01      	cmp	r2, #1
   14fe4:	d004      	beq.n	14ff0 <i2c_nrfx_twim_configure+0x18>
   14fe6:	2a02      	cmp	r2, #2
   14fe8:	d00b      	beq.n	15002 <i2c_nrfx_twim_configure+0x2a>
		return -EINVAL;
   14fea:	f06f 0015 	mvn.w	r0, #21
}
   14fee:	4770      	bx	lr
    p_reg->FREQUENCY = frequency;
   14ff0:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_100K);
   14ff4:	681b      	ldr	r3, [r3, #0]
   14ff6:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
   14ffa:	68c3      	ldr	r3, [r0, #12]
	return 0;
   14ffc:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
   14ffe:	6359      	str	r1, [r3, #52]	; 0x34
	return 0;
   15000:	4770      	bx	lr
   15002:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_400K);
   15006:	681b      	ldr	r3, [r3, #0]
   15008:	e7f5      	b.n	14ff6 <i2c_nrfx_twim_configure+0x1e>

0001500a <vipm_nrf_max_data_size_get>:
static inline int z_impl_ipm_max_data_size_get(const struct device *ipmdev)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->api;

	return api->max_data_size_get(ipmdev);
   1500a:	6883      	ldr	r3, [r0, #8]
   1500c:	689b      	ldr	r3, [r3, #8]
   1500e:	4718      	bx	r3

00015010 <vipm_nrf_max_id_val_get>:
}
   15010:	2000      	movs	r0, #0
   15012:	4770      	bx	lr

00015014 <vipm_nrf_0_register_callback>:
UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
   15014:	4770      	bx	lr

00015016 <vipm_nrf_0_set_enabled>:
   15016:	f06f 0015 	mvn.w	r0, #21
   1501a:	4770      	bx	lr

0001501c <vipm_nrf_1_send>:
   1501c:	f06f 0015 	mvn.w	r0, #21
   15020:	4770      	bx	lr

00015022 <vipm_nrf_1_set_enabled>:
   15022:	b508      	push	{r3, lr}
   15024:	b139      	cbz	r1, 15036 <vipm_nrf_1_set_enabled+0x14>
   15026:	202a      	movs	r0, #42	; 0x2a
   15028:	f7ed fbb8 	bl	279c <arch_irq_enable>
   1502c:	2001      	movs	r0, #1
   1502e:	f7f2 fdb1 	bl	7b94 <nrfx_ipc_receive_event_enable>
   15032:	2000      	movs	r0, #0
   15034:	bd08      	pop	{r3, pc}
   15036:	2001      	movs	r0, #1
   15038:	f7f2 fdb4 	bl	7ba4 <nrfx_ipc_receive_event_disable>
   1503c:	e7f9      	b.n	15032 <vipm_nrf_1_set_enabled+0x10>

0001503e <gpio_pin_set>:
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1503e:	2301      	movs	r3, #1
   15040:	fa03 f101 	lsl.w	r1, r3, r1
   15044:	68c3      	ldr	r3, [r0, #12]
   15046:	681b      	ldr	r3, [r3, #0]
   15048:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   1504a:	bf18      	it	ne
   1504c:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   15050:	b112      	cbz	r2, 15058 <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   15052:	6883      	ldr	r3, [r0, #8]
   15054:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   15056:	4718      	bx	r3
   15058:	6883      	ldr	r3, [r0, #8]
   1505a:	691b      	ldr	r3, [r3, #16]
   1505c:	e7fb      	b.n	15056 <gpio_pin_set+0x18>

0001505e <_spi_context_cs_control.isra.0>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   1505e:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   15060:	6805      	ldr	r5, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   15062:	4604      	mov	r4, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   15064:	b1fd      	cbz	r5, 150a6 <_spi_context_cs_control.isra.0+0x48>
   15066:	68ab      	ldr	r3, [r5, #8]
   15068:	b1eb      	cbz	r3, 150a6 <_spi_context_cs_control.isra.0+0x48>
   1506a:	6818      	ldr	r0, [r3, #0]
   1506c:	b1d8      	cbz	r0, 150a6 <_spi_context_cs_control.isra.0+0x48>
		if (on) {
   1506e:	b151      	cbz	r1, 15086 <_spi_context_cs_control.isra.0+0x28>
			gpio_pin_set(ctx->config->cs->gpio_dev,
   15070:	7a19      	ldrb	r1, [r3, #8]
   15072:	2201      	movs	r2, #1
   15074:	f7ff ffe3 	bl	1503e <gpio_pin_set>
			k_busy_wait(ctx->config->cs->delay);
   15078:	6823      	ldr	r3, [r4, #0]
   1507a:	689b      	ldr	r3, [r3, #8]
   1507c:	6858      	ldr	r0, [r3, #4]
}
   1507e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   15082:	f008 b9d7 	b.w	1d434 <z_impl_k_busy_wait>
			if (!force_off &&
   15086:	b912      	cbnz	r2, 1508e <_spi_context_cs_control.isra.0+0x30>
   15088:	88aa      	ldrh	r2, [r5, #4]
   1508a:	0492      	lsls	r2, r2, #18
   1508c:	d40b      	bmi.n	150a6 <_spi_context_cs_control.isra.0+0x48>
			k_busy_wait(ctx->config->cs->delay);
   1508e:	6858      	ldr	r0, [r3, #4]
   15090:	f008 f9d0 	bl	1d434 <z_impl_k_busy_wait>
			gpio_pin_set(ctx->config->cs->gpio_dev,
   15094:	6823      	ldr	r3, [r4, #0]
   15096:	2200      	movs	r2, #0
   15098:	689b      	ldr	r3, [r3, #8]
   1509a:	7a19      	ldrb	r1, [r3, #8]
   1509c:	6818      	ldr	r0, [r3, #0]
}
   1509e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set(ctx->config->cs->gpio_dev,
   150a2:	f7ff bfcc 	b.w	1503e <gpio_pin_set>
}
   150a6:	bd38      	pop	{r3, r4, r5, pc}

000150a8 <spi_context_unlock_unconditionally>:
{
   150a8:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   150aa:	2201      	movs	r2, #1
   150ac:	2100      	movs	r1, #0
{
   150ae:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   150b0:	f7ff ffd5 	bl	1505e <_spi_context_cs_control.isra.0>
	if (!k_sem_count_get(&ctx->lock)) {
   150b4:	6923      	ldr	r3, [r4, #16]
   150b6:	b933      	cbnz	r3, 150c6 <spi_context_unlock_unconditionally+0x1e>
		ctx->owner = NULL;
   150b8:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
   150ba:	f104 0008 	add.w	r0, r4, #8
}
   150be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   150c2:	f7fb be67 	b.w	10d94 <z_impl_k_sem_give>
   150c6:	bd10      	pop	{r4, pc}

000150c8 <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   150c8:	68c0      	ldr	r0, [r0, #12]
{
   150ca:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   150cc:	6803      	ldr	r3, [r0, #0]
   150ce:	428b      	cmp	r3, r1
   150d0:	d106      	bne.n	150e0 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   150d2:	f890 4064 	ldrb.w	r4, [r0, #100]	; 0x64
   150d6:	b934      	cbnz	r4, 150e6 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   150d8:	f7ff ffe6 	bl	150a8 <spi_context_unlock_unconditionally>
	return 0;
   150dc:	4620      	mov	r0, r4
}
   150de:	bd10      	pop	{r4, pc}
		return -EINVAL;
   150e0:	f06f 0015 	mvn.w	r0, #21
   150e4:	e7fb      	b.n	150de <spi_nrfx_release+0x16>
		return -EBUSY;
   150e6:	f06f 000f 	mvn.w	r0, #15
   150ea:	e7f8      	b.n	150de <spi_nrfx_release+0x16>

000150ec <event_handler>:
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   150ec:	7803      	ldrb	r3, [r0, #0]
   150ee:	2b00      	cmp	r3, #0
   150f0:	d135      	bne.n	1515e <event_handler+0x72>
	if (!ctx->tx_len) {
   150f2:	6d0a      	ldr	r2, [r1, #80]	; 0x50
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
   150f4:	6e0b      	ldr	r3, [r1, #96]	; 0x60
   150f6:	b182      	cbz	r2, 1511a <event_handler+0x2e>
	if (len > ctx->tx_len) {
   150f8:	4293      	cmp	r3, r2
   150fa:	d80e      	bhi.n	1511a <event_handler+0x2e>
	ctx->tx_len -= len;
   150fc:	1ad2      	subs	r2, r2, r3
   150fe:	650a      	str	r2, [r1, #80]	; 0x50
	if (!ctx->tx_len) {
   15100:	bb0a      	cbnz	r2, 15146 <event_handler+0x5a>
		ctx->tx_count--;
   15102:	6c0a      	ldr	r2, [r1, #64]	; 0x40
   15104:	3a01      	subs	r2, #1
   15106:	640a      	str	r2, [r1, #64]	; 0x40
		if (ctx->tx_count) {
   15108:	b30a      	cbz	r2, 1514e <event_handler+0x62>
			ctx->current_tx++;
   1510a:	6bca      	ldr	r2, [r1, #60]	; 0x3c
   1510c:	f102 0008 	add.w	r0, r2, #8
   15110:	63c8      	str	r0, [r1, #60]	; 0x3c
			ctx->tx_buf = (const uint8_t *)ctx->current_tx->buf;
   15112:	6890      	ldr	r0, [r2, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
   15114:	68d2      	ldr	r2, [r2, #12]
			ctx->tx_buf = (const uint8_t *)ctx->current_tx->buf;
   15116:	64c8      	str	r0, [r1, #76]	; 0x4c
			ctx->tx_len = ctx->current_tx->len / dfs;
   15118:	650a      	str	r2, [r1, #80]	; 0x50
	if (!ctx->rx_len) {
   1511a:	6d8a      	ldr	r2, [r1, #88]	; 0x58
   1511c:	b182      	cbz	r2, 15140 <event_handler+0x54>
	if (len > ctx->rx_len) {
   1511e:	4293      	cmp	r3, r2
   15120:	d80e      	bhi.n	15140 <event_handler+0x54>
	ctx->rx_len -= len;
   15122:	1ad2      	subs	r2, r2, r3
   15124:	658a      	str	r2, [r1, #88]	; 0x58
	if (!ctx->rx_len) {
   15126:	b9a2      	cbnz	r2, 15152 <event_handler+0x66>
		ctx->rx_count--;
   15128:	6c8b      	ldr	r3, [r1, #72]	; 0x48
   1512a:	3b01      	subs	r3, #1
   1512c:	648b      	str	r3, [r1, #72]	; 0x48
		if (ctx->rx_count) {
   1512e:	b1a3      	cbz	r3, 1515a <event_handler+0x6e>
			ctx->current_rx++;
   15130:	6c4b      	ldr	r3, [r1, #68]	; 0x44
   15132:	f103 0208 	add.w	r2, r3, #8
   15136:	644a      	str	r2, [r1, #68]	; 0x44
			ctx->rx_buf = (uint8_t *)ctx->current_rx->buf;
   15138:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
   1513a:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (uint8_t *)ctx->current_rx->buf;
   1513c:	654a      	str	r2, [r1, #84]	; 0x54
			ctx->rx_len = ctx->current_rx->len / dfs;
   1513e:	658b      	str	r3, [r1, #88]	; 0x58
		transfer_next_chunk(dev_data->dev);
   15140:	6dc8      	ldr	r0, [r1, #92]	; 0x5c
   15142:	f7f1 bf59 	b.w	6ff8 <transfer_next_chunk>
	} else if (ctx->tx_buf) {
   15146:	6cca      	ldr	r2, [r1, #76]	; 0x4c
   15148:	2a00      	cmp	r2, #0
   1514a:	d0e6      	beq.n	1511a <event_handler+0x2e>
		ctx->tx_buf += dfs * len;
   1514c:	441a      	add	r2, r3
   1514e:	64ca      	str	r2, [r1, #76]	; 0x4c
   15150:	e7e3      	b.n	1511a <event_handler+0x2e>
	} else if (ctx->rx_buf) {
   15152:	6d4a      	ldr	r2, [r1, #84]	; 0x54
   15154:	2a00      	cmp	r2, #0
   15156:	d0f3      	beq.n	15140 <event_handler+0x54>
		ctx->rx_buf += dfs * len;
   15158:	4413      	add	r3, r2
   1515a:	654b      	str	r3, [r1, #84]	; 0x54
   1515c:	e7f0      	b.n	15140 <event_handler+0x54>
}
   1515e:	4770      	bx	lr

00015160 <ft5336_configure>:
	struct ft5336_data *data = dev->data;
   15160:	68c3      	ldr	r3, [r0, #12]
	if (!callback) {
   15162:	b111      	cbz	r1, 1516a <ft5336_configure+0xa>
	return 0;
   15164:	2000      	movs	r0, #0
	data->callback = callback;
   15166:	6099      	str	r1, [r3, #8]
	return 0;
   15168:	4770      	bx	lr
		return -EINVAL;
   1516a:	f06f 0015 	mvn.w	r0, #21
}
   1516e:	4770      	bx	lr

00015170 <ft5336_disable_callback>:
	k_timer_stop(&data->timer);
   15170:	68c0      	ldr	r0, [r0, #12]
{
   15172:	b508      	push	{r3, lr}
	k_timer_stop(&data->timer);
   15174:	3018      	adds	r0, #24
	z_impl_k_timer_stop(timer);
   15176:	f008 fa4d 	bl	1d614 <z_impl_k_timer_stop>
}
   1517a:	2000      	movs	r0, #0
   1517c:	bd08      	pop	{r3, pc}

0001517e <ft5336_enable_callback>:
{
   1517e:	b507      	push	{r0, r1, r2, lr}
	k_timer_start(&data->timer, K_MSEC(CONFIG_KSCAN_FT5336_PERIOD),
   15180:	68c0      	ldr	r0, [r0, #12]
   15182:	f44f 72a4 	mov.w	r2, #328	; 0x148
   15186:	2300      	movs	r3, #0
   15188:	3018      	adds	r0, #24
	z_impl_k_timer_start(timer, duration, period);
   1518a:	e9cd 2300 	strd	r2, r3, [sp]
   1518e:	f7fc f94b 	bl	11428 <z_impl_k_timer_start>
}
   15192:	2000      	movs	r0, #0
   15194:	b003      	add	sp, #12
   15196:	f85d fb04 	ldr.w	pc, [sp], #4

0001519a <ft5336_work_handler>:
{
   1519a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1519e:	2602      	movs	r6, #2
	ft5336_process(data->dev);
   151a0:	f850 4c0c 	ldr.w	r4, [r0, #-12]
{
   151a4:	b088      	sub	sp, #32
	const struct ft5336_config *config = dev->config;
   151a6:	f8d4 9004 	ldr.w	r9, [r4, #4]
	struct ft5336_data *data = dev->data;
   151aa:	68e5      	ldr	r5, [r4, #12]
				 const void *write_buf, size_t num_write,
				 void *read_buf, size_t num_read)
{
	struct i2c_msg msg[2];

	msg[0].buf = (uint8_t *)write_buf;
   151ac:	eb0d 0206 	add.w	r2, sp, r6
	r = i2c_reg_read_byte(data->i2c, config->i2c_address, REG_TD_STATUS,
   151b0:	6868      	ldr	r0, [r5, #4]
   151b2:	f899 3004 	ldrb.w	r3, [r9, #4]
	msg[0].len = num_write;
   151b6:	2701      	movs	r7, #1
	msg[0].buf = (uint8_t *)write_buf;
   151b8:	9202      	str	r2, [sp, #8]
	msg[0].flags = I2C_MSG_WRITE;
   151ba:	2200      	movs	r2, #0

	msg[1].buf = (uint8_t *)read_buf;
	msg[1].len = num_read;
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
   151bc:	f04f 0807 	mov.w	r8, #7
	msg[0].flags = I2C_MSG_WRITE;
   151c0:	f88d 2010 	strb.w	r2, [sp, #16]
	msg[1].buf = (uint8_t *)read_buf;
   151c4:	eb0d 0207 	add.w	r2, sp, r7
	msg[1].len = num_read;
   151c8:	e9cd 2705 	strd	r2, r7, [sp, #20]
   151cc:	f88d 6002 	strb.w	r6, [sp, #2]
	msg[0].len = num_write;
   151d0:	9703      	str	r7, [sp, #12]
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
   151d2:	f88d 801c 	strb.w	r8, [sp, #28]
	return api->transfer(dev, msgs, num_msgs, addr);
   151d6:	6882      	ldr	r2, [r0, #8]
   151d8:	a902      	add	r1, sp, #8
   151da:	f8d2 a004 	ldr.w	sl, [r2, #4]
   151de:	4632      	mov	r2, r6
   151e0:	47d0      	blx	sl
	if (r < 0) {
   151e2:	2800      	cmp	r0, #0
   151e4:	db37      	blt.n	15256 <ft5336_work_handler+0xbc>
	points = (points >> TOUCH_POINTS_POS) & TOUCH_POINTS_MSK;
   151e6:	f89d 3001 	ldrb.w	r3, [sp, #1]
   151ea:	f003 020f 	and.w	r2, r3, #15
	if (points != 0U && points != 1U) {
   151ee:	f013 010e 	ands.w	r1, r3, #14
	points = (points >> TOUCH_POINTS_POS) & TOUCH_POINTS_MSK;
   151f2:	f88d 2001 	strb.w	r2, [sp, #1]
	if (points != 0U && points != 1U) {
   151f6:	d12e      	bne.n	15256 <ft5336_work_handler+0xbc>
	r = i2c_burst_read(data->i2c, config->i2c_address, REG_P1_XH, coords,
   151f8:	2203      	movs	r2, #3
   151fa:	f88d 2003 	strb.w	r2, [sp, #3]
	msg[0].buf = (uint8_t *)write_buf;
   151fe:	446a      	add	r2, sp
   15200:	6868      	ldr	r0, [r5, #4]
   15202:	f899 3004 	ldrb.w	r3, [r9, #4]
	msg[0].len = num_write;
   15206:	e9cd 2702 	strd	r2, r7, [sp, #8]
	msg[1].buf = (uint8_t *)read_buf;
   1520a:	aa01      	add	r2, sp, #4
   1520c:	9205      	str	r2, [sp, #20]
	msg[1].len = num_read;
   1520e:	2204      	movs	r2, #4
	msg[0].flags = I2C_MSG_WRITE;
   15210:	f88d 1010 	strb.w	r1, [sp, #16]
	msg[1].len = num_read;
   15214:	9206      	str	r2, [sp, #24]
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
   15216:	f88d 801c 	strb.w	r8, [sp, #28]
	return api->transfer(dev, msgs, num_msgs, addr);
   1521a:	6882      	ldr	r2, [r0, #8]
   1521c:	a902      	add	r1, sp, #8
   1521e:	6857      	ldr	r7, [r2, #4]
   15220:	4632      	mov	r2, r6
   15222:	47b8      	blx	r7
	if (r < 0) {
   15224:	2800      	cmp	r0, #0
   15226:	db16      	blt.n	15256 <ft5336_work_handler+0xbc>
	event = (coords[0] >> EVENT_POS) & EVENT_MSK;
   15228:	f89d 1004 	ldrb.w	r1, [sp, #4]
	col = ((coords[2] & POSITION_H_MSK) << 8U) | coords[3];
   1522c:	f89d 2006 	ldrb.w	r2, [sp, #6]
	row = ((coords[0] & POSITION_H_MSK) << 8U) | coords[1];
   15230:	f89d 0005 	ldrb.w	r0, [sp, #5]
	pressed = (event == EVENT_PRESS_DOWN) || (event == EVENT_CONTACT);
   15234:	f3c1 1380 	ubfx	r3, r1, #6, #1
	col = ((coords[2] & POSITION_H_MSK) << 8U) | coords[3];
   15238:	f89d 6007 	ldrb.w	r6, [sp, #7]
   1523c:	0212      	lsls	r2, r2, #8
	row = ((coords[0] & POSITION_H_MSK) << 8U) | coords[1];
   1523e:	0209      	lsls	r1, r1, #8
	col = ((coords[2] & POSITION_H_MSK) << 8U) | coords[3];
   15240:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
	row = ((coords[0] & POSITION_H_MSK) << 8U) | coords[1];
   15244:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
	data->callback(dev, row, col, pressed);
   15248:	4301      	orrs	r1, r0
   1524a:	68ad      	ldr	r5, [r5, #8]
   1524c:	4620      	mov	r0, r4
   1524e:	f083 0301 	eor.w	r3, r3, #1
   15252:	4332      	orrs	r2, r6
   15254:	47a8      	blx	r5
}
   15256:	b008      	add	sp, #32
   15258:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001525c <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   1525c:	6843      	ldr	r3, [r0, #4]
   1525e:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   15260:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   15264:	05d2      	lsls	r2, r2, #23
   15266:	d518      	bpl.n	1529a <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   15268:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   1526c:	b1aa      	cbz	r2, 1529a <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   1526e:	f04f 0120 	mov.w	r1, #32
   15272:	f3ef 8211 	mrs	r2, BASEPRI
   15276:	f381 8811 	msr	BASEPRI, r1
   1527a:	f3bf 8f6f 	isb	sy
   1527e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   15282:	b131      	cbz	r1, 15292 <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   15284:	2100      	movs	r1, #0
   15286:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   1528a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1528e:	2101      	movs	r1, #1
   15290:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   15292:	f382 8811 	msr	BASEPRI, r2
   15296:	f3bf 8f6f 	isb	sy
}
   1529a:	4770      	bx	lr

0001529c <uarte_nrfx_config_get>:
{
   1529c:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   1529e:	68c2      	ldr	r2, [r0, #12]
   152a0:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   152a4:	e883 0003 	stmia.w	r3, {r0, r1}
}
   152a8:	2000      	movs	r0, #0
   152aa:	4770      	bx	lr

000152ac <uarte_nrfx_err_check>:
	return config->uarte_regs;
   152ac:	6843      	ldr	r3, [r0, #4]
   152ae:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   152b0:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   152b4:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   152b8:	4770      	bx	lr

000152ba <is_tx_ready>:
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   152ba:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   152bc:	6813      	ldr	r3, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   152be:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   152c2:	b938      	cbnz	r0, 152d4 <is_tx_ready+0x1a>
   152c4:	7992      	ldrb	r2, [r2, #6]
   152c6:	b932      	cbnz	r2, 152d6 <is_tx_ready+0x1c>
   152c8:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   152cc:	3800      	subs	r0, #0
   152ce:	bf18      	it	ne
   152d0:	2001      	movne	r0, #1
   152d2:	4770      	bx	lr
   152d4:	2001      	movs	r0, #1
}
   152d6:	4770      	bx	lr

000152d8 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   152d8:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   152da:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
   152dc:	681b      	ldr	r3, [r3, #0]
   152de:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   152e2:	b148      	cbz	r0, 152f8 <uarte_nrfx_poll_in+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   152e4:	2000      	movs	r0, #0
	*c = data->rx_data;
   152e6:	7c52      	ldrb	r2, [r2, #17]
   152e8:	700a      	strb	r2, [r1, #0]
   152ea:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   152ee:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   152f2:	2201      	movs	r2, #1
   152f4:	601a      	str	r2, [r3, #0]
	return 0;
   152f6:	4770      	bx	lr
		return -1;
   152f8:	f04f 30ff 	mov.w	r0, #4294967295
}
   152fc:	4770      	bx	lr

000152fe <k_sys_fatal_error_handler>:
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
	sys_arch_reboot(0);
   152fe:	2000      	movs	r0, #0
{
   15300:	b508      	push	{r3, lr}
	sys_arch_reboot(0);
   15302:	f7ed fc61 	bl	2bc8 <sys_arch_reboot>

00015306 <hw_cc3xx_init>:
#include <nrf_cc3xx_platform.h>

#if CONFIG_HW_CC3XX

static int hw_cc3xx_init(const struct device *dev)
{
   15306:	b508      	push	{r3, lr}
	int res;

	__ASSERT_NO_MSG(dev != NULL);

	/* Set the RTOS abort APIs */
	nrf_cc3xx_platform_abort_init();
   15308:	f7ec ff80 	bl	220c <nrf_cc3xx_platform_abort_init>

	/* Set the RTOS mutex APIs */
	nrf_cc3xx_platform_mutex_init();
   1530c:	f7ed f844 	bl	2398 <nrf_cc3xx_platform_mutex_init>
	res = nrf_cc3xx_platform_init();
#else
	res = nrf_cc3xx_platform_init_no_rng();
#endif
	return res;
}
   15310:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	res = nrf_cc3xx_platform_init_no_rng();
   15314:	f7fc b988 	b.w	11628 <nrf_cc3xx_platform_init_no_rng>

00015318 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   15318:	4700      	bx	r0

0001531a <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   1531a:	f008 b88b 	b.w	1d434 <z_impl_k_busy_wait>

0001531e <nrfx_clock_enable>:
{
   1531e:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   15320:	2005      	movs	r0, #5
   15322:	f7ed fa4b 	bl	27bc <arch_irq_is_enabled>
   15326:	b910      	cbnz	r0, 1532e <nrfx_clock_enable+0x10>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   15328:	2005      	movs	r0, #5
   1532a:	f7ed fa37 	bl	279c <arch_irq_enable>
}

#if NRF_CLOCK_HAS_HFCLKSRC
NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLKSRC = (uint32_t)(source);
   1532e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   15332:	2201      	movs	r2, #1
   15334:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
                                   >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
}

NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLK192MSRC = (uint32_t)(source);
   15338:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
}
   1533c:	bd08      	pop	{r3, pc}

0001533e <nrf_gpio_cfg_output>:
{
   1533e:	b507      	push	{r0, r1, r2, lr}
   15340:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   15342:	a801      	add	r0, sp, #4
   15344:	f7f2 fc56 	bl	7bf4 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   15348:	2203      	movs	r2, #3
   1534a:	9b01      	ldr	r3, [sp, #4]
   1534c:	3380      	adds	r3, #128	; 0x80
   1534e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
   15352:	b003      	add	sp, #12
   15354:	f85d fb04 	ldr.w	pc, [sp], #4

00015358 <nrf_gpio_pin_set>:
{
   15358:	b507      	push	{r0, r1, r2, lr}
   1535a:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   1535c:	a801      	add	r0, sp, #4
   1535e:	f7f2 fc49 	bl	7bf4 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   15362:	2301      	movs	r3, #1
   15364:	9a01      	ldr	r2, [sp, #4]
   15366:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
   15368:	6083      	str	r3, [r0, #8]
}
   1536a:	b003      	add	sp, #12
   1536c:	f85d fb04 	ldr.w	pc, [sp], #4

00015370 <nrf_gpio_pin_clear>:
{
   15370:	b507      	push	{r0, r1, r2, lr}
   15372:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   15374:	a801      	add	r0, sp, #4
   15376:	f7f2 fc3d 	bl	7bf4 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   1537a:	2301      	movs	r3, #1
   1537c:	9a01      	ldr	r2, [sp, #4]
   1537e:	4093      	lsls	r3, r2
    p_reg->OUTCLR = clr_mask;
   15380:	60c3      	str	r3, [r0, #12]
}
   15382:	b003      	add	sp, #12
   15384:	f85d fb04 	ldr.w	pc, [sp], #4

00015388 <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   15388:	7b0a      	ldrb	r2, [r1, #12]
{
   1538a:	4603      	mov	r3, r0
   1538c:	2a03      	cmp	r2, #3
   1538e:	d829      	bhi.n	153e4 <xfer_completeness_check+0x5c>
   15390:	e8df f002 	tbb	[pc, r2]
   15394:	02192521 	.word	0x02192521
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   15398:	688a      	ldr	r2, [r1, #8]
   1539a:	0350      	lsls	r0, r2, #13
   1539c:	d504      	bpl.n	153a8 <xfer_completeness_check+0x20>
    return p_reg->TXD.AMOUNT;
   1539e:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
   153a2:	6908      	ldr	r0, [r1, #16]
   153a4:	4290      	cmp	r0, r2
   153a6:	d107      	bne.n	153b8 <xfer_completeness_check+0x30>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   153a8:	688a      	ldr	r2, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   153aa:	0352      	lsls	r2, r2, #13
   153ac:	d41a      	bmi.n	153e4 <xfer_completeness_check+0x5c>
   153ae:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   153b2:	6949      	ldr	r1, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   153b4:	4291      	cmp	r1, r2
   153b6:	d015      	beq.n	153e4 <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   153b8:	2000      	movs	r0, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   153ba:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   153bc:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   153c0:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   153c4:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   153c6:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   153ca:	6908      	ldr	r0, [r1, #16]
   153cc:	4290      	cmp	r0, r2
   153ce:	d1f3      	bne.n	153b8 <xfer_completeness_check+0x30>
    return p_reg->RXD.AMOUNT;
   153d0:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   153d4:	e7ed      	b.n	153b2 <xfer_completeness_check+0x2a>
    return p_reg->TXD.AMOUNT;
   153d6:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   153da:	6909      	ldr	r1, [r1, #16]
   153dc:	e7ea      	b.n	153b4 <xfer_completeness_check+0x2c>
    return p_reg->RXD.AMOUNT;
   153de:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   153e2:	e7fa      	b.n	153da <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   153e4:	2001      	movs	r0, #1
}
   153e6:	4770      	bx	lr

000153e8 <metal_device_open>:
{
   153e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
   153ea:	460c      	mov	r4, r1
   153ec:	4615      	mov	r5, r2
	if (!bus_name || !strlen(bus_name) ||
   153ee:	4606      	mov	r6, r0
   153f0:	b918      	cbnz	r0, 153fa <metal_device_open+0x12>
		return -EINVAL;
   153f2:	f06f 0015 	mvn.w	r0, #21
}
   153f6:	b002      	add	sp, #8
   153f8:	bd70      	pop	{r4, r5, r6, pc}
	if (!bus_name || !strlen(bus_name) ||
   153fa:	f7eb f833 	bl	464 <strlen>
   153fe:	2800      	cmp	r0, #0
   15400:	d0f7      	beq.n	153f2 <metal_device_open+0xa>
   15402:	2c00      	cmp	r4, #0
   15404:	d0f5      	beq.n	153f2 <metal_device_open+0xa>
	    !dev_name || !strlen(dev_name) ||
   15406:	4620      	mov	r0, r4
   15408:	f7eb f82c 	bl	464 <strlen>
   1540c:	2800      	cmp	r0, #0
   1540e:	d0f0      	beq.n	153f2 <metal_device_open+0xa>
   15410:	2d00      	cmp	r5, #0
   15412:	d0ee      	beq.n	153f2 <metal_device_open+0xa>
	error = metal_bus_find(bus_name, &bus);
   15414:	4630      	mov	r0, r6
   15416:	a901      	add	r1, sp, #4
   15418:	f7f3 f848 	bl	84ac <metal_bus_find>
	if (error)
   1541c:	2800      	cmp	r0, #0
   1541e:	d1ea      	bne.n	153f6 <metal_device_open+0xe>
	if (!bus->ops.dev_open)
   15420:	9801      	ldr	r0, [sp, #4]
   15422:	6883      	ldr	r3, [r0, #8]
   15424:	b11b      	cbz	r3, 1542e <metal_device_open+0x46>
	error = (*bus->ops.dev_open)(bus, dev_name, device);
   15426:	462a      	mov	r2, r5
   15428:	4621      	mov	r1, r4
   1542a:	4798      	blx	r3
	if (error)
   1542c:	e7e3      	b.n	153f6 <metal_device_open+0xe>
		return -ENODEV;
   1542e:	f06f 0012 	mvn.w	r0, #18
   15432:	e7e0      	b.n	153f6 <metal_device_open+0xe>

00015434 <metal_io_block_read>:
	metal_sys_io_mem_map(io);
}

int metal_io_block_read(struct metal_io_region *io, unsigned long offset,
	       void *restrict dst, int len)
{
   15434:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
   15436:	6804      	ldr	r4, [r0, #0]
   15438:	6885      	ldr	r5, [r0, #8]
		: NULL);
   1543a:	1c66      	adds	r6, r4, #1
   1543c:	d00f      	beq.n	1545e <metal_io_block_read+0x2a>
	return (io->virt != METAL_BAD_VA && offset < io->size
   1543e:	42a9      	cmp	r1, r5
   15440:	d232      	bcs.n	154a8 <metal_io_block_read+0x74>
		: NULL);
   15442:	440c      	add	r4, r1
	unsigned char *dest = dst;
	int retlen;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
   15444:	185e      	adds	r6, r3, r1
   15446:	42ae      	cmp	r6, r5
		len = io->size - offset;
   15448:	bf88      	it	hi
   1544a:	1a6b      	subhi	r3, r5, r1
	retlen = len;
	if (io->ops.block_read) {
   1544c:	6a05      	ldr	r5, [r0, #32]
   1544e:	b155      	cbz	r5, 15466 <metal_io_block_read+0x32>
		retlen = (*io->ops.block_read)(
   15450:	9300      	str	r3, [sp, #0]
   15452:	2305      	movs	r3, #5
   15454:	47a8      	blx	r5
   15456:	4603      	mov	r3, r0
		for (; len != 0; dest++, ptr++, len--)
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
	}
	return retlen;
}
   15458:	4618      	mov	r0, r3
   1545a:	b002      	add	sp, #8
   1545c:	bd70      	pop	{r4, r5, r6, pc}
	if (offset >= io->size)
   1545e:	42a9      	cmp	r1, r5
   15460:	d222      	bcs.n	154a8 <metal_io_block_read+0x74>
   15462:	2400      	movs	r4, #0
   15464:	e7ee      	b.n	15444 <metal_io_block_read+0x10>
		atomic_thread_fence(memory_order_seq_cst);
   15466:	f3bf 8f5b 	dmb	ish
		while ( len && (
   1546a:	4621      	mov	r1, r4
   1546c:	4618      	mov	r0, r3
   1546e:	2800      	cmp	r0, #0
   15470:	d0f2      	beq.n	15458 <metal_io_block_read+0x24>
			((uintptr_t)dest % sizeof(int)) ||
   15472:	ea42 0401 	orr.w	r4, r2, r1
   15476:	07a4      	lsls	r4, r4, #30
   15478:	d10a      	bne.n	15490 <metal_io_block_read+0x5c>
		for (; len >= (int)sizeof(int); dest += sizeof(int),
   1547a:	2803      	cmp	r0, #3
   1547c:	dc0e      	bgt.n	1549c <metal_io_block_read+0x68>
   1547e:	3901      	subs	r1, #1
   15480:	4410      	add	r0, r2
		for (; len != 0; dest++, ptr++, len--)
   15482:	4282      	cmp	r2, r0
   15484:	d0e8      	beq.n	15458 <metal_io_block_read+0x24>
				*(const unsigned char *)ptr;
   15486:	f811 4f01 	ldrb.w	r4, [r1, #1]!
			*(unsigned char *)dest =
   1548a:	f802 4b01 	strb.w	r4, [r2], #1
		for (; len != 0; dest++, ptr++, len--)
   1548e:	e7f8      	b.n	15482 <metal_io_block_read+0x4e>
				*(const unsigned char *)ptr;
   15490:	f811 4b01 	ldrb.w	r4, [r1], #1
			len--;
   15494:	3801      	subs	r0, #1
			*(unsigned char *)dest =
   15496:	f802 4b01 	strb.w	r4, [r2], #1
			len--;
   1549a:	e7e8      	b.n	1546e <metal_io_block_read+0x3a>
			*(unsigned int *)dest = *(const unsigned int *)ptr;
   1549c:	f851 4b04 	ldr.w	r4, [r1], #4
   154a0:	3804      	subs	r0, #4
   154a2:	f842 4b04 	str.w	r4, [r2], #4
		for (; len >= (int)sizeof(int); dest += sizeof(int),
   154a6:	e7e8      	b.n	1547a <metal_io_block_read+0x46>
		return -ERANGE;
   154a8:	f06f 0321 	mvn.w	r3, #33	; 0x21
   154ac:	e7d4      	b.n	15458 <metal_io_block_read+0x24>

000154ae <metal_io_block_write>:

int metal_io_block_write(struct metal_io_region *io, unsigned long offset,
	       const void *restrict src, int len)
{
   154ae:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
   154b0:	6804      	ldr	r4, [r0, #0]
   154b2:	6885      	ldr	r5, [r0, #8]
		: NULL);
   154b4:	1c66      	adds	r6, r4, #1
   154b6:	d00e      	beq.n	154d6 <metal_io_block_write+0x28>
	return (io->virt != METAL_BAD_VA && offset < io->size
   154b8:	42a9      	cmp	r1, r5
   154ba:	d230      	bcs.n	1551e <metal_io_block_write+0x70>
		: NULL);
   154bc:	440c      	add	r4, r1
	const unsigned char *source = src;
	int retlen;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
   154be:	185e      	adds	r6, r3, r1
   154c0:	42ae      	cmp	r6, r5
		len = io->size - offset;
   154c2:	bf88      	it	hi
   154c4:	1a6b      	subhi	r3, r5, r1
	retlen = len;
	if (io->ops.block_write) {
   154c6:	6a45      	ldr	r5, [r0, #36]	; 0x24
   154c8:	b94d      	cbnz	r5, 154de <metal_io_block_write+0x30>
   154ca:	4619      	mov	r1, r3
		retlen = (*io->ops.block_write)(
			io, offset, src, memory_order_seq_cst, len);
	} else {
		while ( len && (
   154cc:	b991      	cbnz	r1, 154f4 <metal_io_block_write+0x46>
					len -= sizeof(int))
			*(unsigned int *)ptr = *(const unsigned int *)source;
		for (; len != 0; ptr++, source++, len--)
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
		atomic_thread_fence(memory_order_seq_cst);
   154ce:	f3bf 8f5b 	dmb	ish
	retlen = len;
   154d2:	4618      	mov	r0, r3
   154d4:	e006      	b.n	154e4 <metal_io_block_write+0x36>
	if (offset >= io->size)
   154d6:	42a9      	cmp	r1, r5
   154d8:	d221      	bcs.n	1551e <metal_io_block_write+0x70>
   154da:	2400      	movs	r4, #0
   154dc:	e7ef      	b.n	154be <metal_io_block_write+0x10>
		retlen = (*io->ops.block_write)(
   154de:	9300      	str	r3, [sp, #0]
   154e0:	2305      	movs	r3, #5
   154e2:	47a8      	blx	r5
	}
	return retlen;
}
   154e4:	b002      	add	sp, #8
   154e6:	bd70      	pop	{r4, r5, r6, pc}
				*(const unsigned char *)source;
   154e8:	f812 0b01 	ldrb.w	r0, [r2], #1
			len--;
   154ec:	3901      	subs	r1, #1
			*(unsigned char *)ptr =
   154ee:	f804 0b01 	strb.w	r0, [r4], #1
			len--;
   154f2:	e7eb      	b.n	154cc <metal_io_block_write+0x1e>
			((uintptr_t)ptr % sizeof(int)) ||
   154f4:	ea44 0002 	orr.w	r0, r4, r2
   154f8:	0780      	lsls	r0, r0, #30
   154fa:	d1f5      	bne.n	154e8 <metal_io_block_write+0x3a>
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
   154fc:	2903      	cmp	r1, #3
   154fe:	dc08      	bgt.n	15512 <metal_io_block_write+0x64>
   15500:	3a01      	subs	r2, #1
   15502:	4421      	add	r1, r4
		for (; len != 0; ptr++, source++, len--)
   15504:	428c      	cmp	r4, r1
   15506:	d0e2      	beq.n	154ce <metal_io_block_write+0x20>
				*(const unsigned char *)source;
   15508:	f812 0f01 	ldrb.w	r0, [r2, #1]!
			*(unsigned char *)ptr =
   1550c:	f804 0b01 	strb.w	r0, [r4], #1
		for (; len != 0; ptr++, source++, len--)
   15510:	e7f8      	b.n	15504 <metal_io_block_write+0x56>
			*(unsigned int *)ptr = *(const unsigned int *)source;
   15512:	f852 0b04 	ldr.w	r0, [r2], #4
   15516:	3904      	subs	r1, #4
   15518:	f844 0b04 	str.w	r0, [r4], #4
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
   1551c:	e7ee      	b.n	154fc <metal_io_block_write+0x4e>
		return -ERANGE;
   1551e:	f06f 0021 	mvn.w	r0, #33	; 0x21
   15522:	e7df      	b.n	154e4 <metal_io_block_write+0x36>

00015524 <metal_io_block_set>:

int metal_io_block_set(struct metal_io_region *io, unsigned long offset,
	       unsigned char value, int len)
{
   15524:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
   15526:	6804      	ldr	r4, [r0, #0]
   15528:	461d      	mov	r5, r3
		: NULL);
   1552a:	1c66      	adds	r6, r4, #1
   1552c:	6883      	ldr	r3, [r0, #8]
   1552e:	d00e      	beq.n	1554e <metal_io_block_set+0x2a>
	return (io->virt != METAL_BAD_VA && offset < io->size
   15530:	4299      	cmp	r1, r3
   15532:	d22d      	bcs.n	15590 <metal_io_block_set+0x6c>
		: NULL);
   15534:	440c      	add	r4, r1
	unsigned char *ptr = metal_io_virt(io, offset);
	int retlen = len;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
   15536:	186e      	adds	r6, r5, r1
   15538:	429e      	cmp	r6, r3
		len = io->size - offset;
	retlen = len;
	if (io->ops.block_set) {
   1553a:	6a86      	ldr	r6, [r0, #40]	; 0x28
		len = io->size - offset;
   1553c:	bf88      	it	hi
   1553e:	1a5d      	subhi	r5, r3, r1
	if (io->ops.block_set) {
   15540:	b186      	cbz	r6, 15564 <metal_io_block_set+0x40>
		(*io->ops.block_set)(
   15542:	2305      	movs	r3, #5
   15544:	9500      	str	r5, [sp, #0]
   15546:	47b0      	blx	r6
		for (; len != 0; ptr++, len--)
			*(unsigned char *)ptr = (unsigned char) value;
		atomic_thread_fence(memory_order_seq_cst);
	}
	return retlen;
}
   15548:	4628      	mov	r0, r5
   1554a:	b002      	add	sp, #8
   1554c:	bd70      	pop	{r4, r5, r6, pc}
	if (offset >= io->size)
   1554e:	4299      	cmp	r1, r3
   15550:	d21e      	bcs.n	15590 <metal_io_block_set+0x6c>
   15552:	2400      	movs	r4, #0
   15554:	e7ef      	b.n	15536 <metal_io_block_set+0x12>
			*(unsigned char *)ptr = (unsigned char) value;
   15556:	f804 2b01 	strb.w	r2, [r4], #1
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
   1555a:	3b01      	subs	r3, #1
   1555c:	b923      	cbnz	r3, 15568 <metal_io_block_set+0x44>
		atomic_thread_fence(memory_order_seq_cst);
   1555e:	f3bf 8f5b 	dmb	ish
   15562:	e7f1      	b.n	15548 <metal_io_block_set+0x24>
   15564:	462b      	mov	r3, r5
   15566:	e7f9      	b.n	1555c <metal_io_block_set+0x38>
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
   15568:	07a1      	lsls	r1, r4, #30
   1556a:	d1f4      	bne.n	15556 <metal_io_block_set+0x32>
			cint |= ((unsigned int)value << (CHAR_BIT * i));
   1556c:	0611      	lsls	r1, r2, #24
   1556e:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   15572:	4311      	orrs	r1, r2
   15574:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
   15578:	2b03      	cmp	r3, #3
   1557a:	dc05      	bgt.n	15588 <metal_io_block_set+0x64>
   1557c:	4423      	add	r3, r4
		for (; len != 0; ptr++, len--)
   1557e:	429c      	cmp	r4, r3
   15580:	d0ed      	beq.n	1555e <metal_io_block_set+0x3a>
			*(unsigned char *)ptr = (unsigned char) value;
   15582:	f804 2b01 	strb.w	r2, [r4], #1
		for (; len != 0; ptr++, len--)
   15586:	e7fa      	b.n	1557e <metal_io_block_set+0x5a>
			*(unsigned int *)ptr = cint;
   15588:	f844 1b04 	str.w	r1, [r4], #4
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
   1558c:	3b04      	subs	r3, #4
   1558e:	e7f3      	b.n	15578 <metal_io_block_set+0x54>
		return -ERANGE;
   15590:	f06f 0521 	mvn.w	r5, #33	; 0x21
   15594:	e7d8      	b.n	15548 <metal_io_block_set+0x24>

00015596 <metal_generic_dev_sys_open>:

	/* Since Zephyr runs bare-metal there is no mapping that needs to be
	 * done of IO regions
	 */
	return 0;
}
   15596:	2000      	movs	r0, #0
   15598:	4770      	bx	lr

0001559a <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
   1559a:	b508      	push	{r3, lr}
    if(!disp) disp = lv_disp_get_default();
   1559c:	b910      	cbnz	r0, 155a4 <lv_disp_get_scr_act+0xa>
   1559e:	f7f6 ffe3 	bl	c568 <lv_disp_get_default>
    if(!disp) {
   155a2:	b100      	cbz	r0, 155a6 <lv_disp_get_scr_act+0xc>
        LV_LOG_WARN("no display registered to get its active screen");
        return NULL;
    }

    return disp->act_scr;
   155a4:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
   155a6:	bd08      	pop	{r3, pc}

000155a8 <lv_disp_get_scr_prev>:
 * @param disp pointer to display which previous screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the previous screen object or NULL if not used now
 */
lv_obj_t * lv_disp_get_scr_prev(lv_disp_t * disp)
{
   155a8:	b508      	push	{r3, lr}
    if(!disp) disp = lv_disp_get_default();
   155aa:	b910      	cbnz	r0, 155b2 <lv_disp_get_scr_prev+0xa>
   155ac:	f7f6 ffdc 	bl	c568 <lv_disp_get_default>
    if(!disp) {
   155b0:	b100      	cbz	r0, 155b4 <lv_disp_get_scr_prev+0xc>
        LV_LOG_WARN("no display registered to get its previous screen");
        return NULL;
    }

    return disp->prev_scr;
   155b2:	6c40      	ldr	r0, [r0, #68]	; 0x44
}
   155b4:	bd08      	pop	{r3, pc}

000155b6 <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
   155b6:	b508      	push	{r3, lr}
    if(!disp) disp = lv_disp_get_default();
   155b8:	b910      	cbnz	r0, 155c0 <lv_disp_get_layer_top+0xa>
   155ba:	f7f6 ffd5 	bl	c568 <lv_disp_get_default>
    if(!disp) {
   155be:	b100      	cbz	r0, 155c2 <lv_disp_get_layer_top+0xc>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
        return NULL;
    }

    return disp->top_layer;
   155c0:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
   155c2:	bd08      	pop	{r3, pc}

000155c4 <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
   155c4:	b508      	push	{r3, lr}
    if(!disp) disp = lv_disp_get_default();
   155c6:	b910      	cbnz	r0, 155ce <lv_disp_get_layer_sys+0xa>
   155c8:	f7f6 ffce 	bl	c568 <lv_disp_get_default>
    if(!disp) {
   155cc:	b100      	cbz	r0, 155d0 <lv_disp_get_layer_sys+0xc>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its sys. layer");
        return NULL;
    }

    return disp->sys_layer;
   155ce:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
   155d0:	bd08      	pop	{r3, pc}

000155d2 <get_dragged_obj>:
{
   155d2:	b510      	push	{r4, lr}
    if(obj == NULL) return NULL;
   155d4:	4604      	mov	r4, r0
   155d6:	b930      	cbnz	r0, 155e6 <get_dragged_obj+0x14>
   155d8:	2400      	movs	r4, #0
}
   155da:	4620      	mov	r0, r4
   155dc:	bd10      	pop	{r4, pc}
        drag_obj = lv_obj_get_parent(drag_obj);
   155de:	4620      	mov	r0, r4
   155e0:	f000 fa28 	bl	15a34 <lv_obj_get_parent>
   155e4:	4604      	mov	r4, r0
    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
   155e6:	4620      	mov	r0, r4
   155e8:	f000 fafb 	bl	15be2 <lv_obj_get_drag_parent>
   155ec:	2800      	cmp	r0, #0
   155ee:	d0f4      	beq.n	155da <get_dragged_obj+0x8>
   155f0:	2c00      	cmp	r4, #0
   155f2:	d1f4      	bne.n	155de <get_dragged_obj+0xc>
   155f4:	e7f0      	b.n	155d8 <get_dragged_obj+0x6>

000155f6 <_lv_indev_init>:
    if(indev) {
   155f6:	2000      	movs	r0, #0
   155f8:	f7f3 b8e8 	b.w	87cc <lv_indev_reset.part.0>

000155fc <lv_indev_is_dragging>:
    if(indev == NULL) return false;
   155fc:	b150      	cbz	r0, 15614 <lv_indev_is_dragging+0x18>
    if(indev->driver.type != LV_INDEV_TYPE_POINTER && indev->driver.type != LV_INDEV_TYPE_BUTTON) return false;
   155fe:	7803      	ldrb	r3, [r0, #0]
   15600:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
   15604:	2b01      	cmp	r3, #1
   15606:	d104      	bne.n	15612 <lv_indev_is_dragging+0x16>
    return indev->proc.types.pointer.drag_in_prog == 0 ? false : true;
   15608:	f890 004a 	ldrb.w	r0, [r0, #74]	; 0x4a
   1560c:	f3c0 0040 	ubfx	r0, r0, #1, #1
   15610:	4770      	bx	lr
    if(indev == NULL) return false;
   15612:	2000      	movs	r0, #0
}
   15614:	4770      	bx	lr

00015616 <lv_indev_search_obj>:
{
   15616:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15618:	4605      	mov	r5, r0
   1561a:	460e      	mov	r6, r1
    if(lv_obj_hittest(obj, point)) {
   1561c:	f000 fd94 	bl	16148 <lv_obj_hittest>
   15620:	b908      	cbnz	r0, 15626 <lv_indev_search_obj+0x10>
    lv_obj_t * found_p = NULL;
   15622:	2000      	movs	r0, #0
}
   15624:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        _LV_LL_READ(obj->child_ll, i) {
   15626:	1d2f      	adds	r7, r5, #4
   15628:	4638      	mov	r0, r7
   1562a:	f005 fdee 	bl	1b20a <_lv_ll_get_head>
   1562e:	4604      	mov	r4, r0
   15630:	b930      	cbnz	r0, 15640 <lv_indev_search_obj+0x2a>
        if(found_p == NULL && lv_obj_get_click(obj) != false) {
   15632:	4628      	mov	r0, r5
   15634:	f000 fac1 	bl	15bba <lv_obj_get_click>
   15638:	2800      	cmp	r0, #0
   1563a:	d0f2      	beq.n	15622 <lv_indev_search_obj+0xc>
            lv_obj_t * hidden_i = obj;
   1563c:	462c      	mov	r4, r5
   1563e:	e013      	b.n	15668 <lv_indev_search_obj+0x52>
            found_p = lv_indev_search_obj(i, point);
   15640:	4631      	mov	r1, r6
   15642:	4620      	mov	r0, r4
   15644:	f7ff ffe7 	bl	15616 <lv_indev_search_obj>
            if(found_p != NULL) {
   15648:	2800      	cmp	r0, #0
   1564a:	d1eb      	bne.n	15624 <lv_indev_search_obj+0xe>
        _LV_LL_READ(obj->child_ll, i) {
   1564c:	4621      	mov	r1, r4
   1564e:	4638      	mov	r0, r7
   15650:	f005 fde1 	bl	1b216 <_lv_ll_get_next>
   15654:	e7eb      	b.n	1562e <lv_indev_search_obj+0x18>
                if(lv_obj_get_hidden(hidden_i) == true) break;
   15656:	4620      	mov	r0, r4
   15658:	f000 faaa 	bl	15bb0 <lv_obj_get_hidden>
   1565c:	2800      	cmp	r0, #0
   1565e:	d1e0      	bne.n	15622 <lv_indev_search_obj+0xc>
                hidden_i = lv_obj_get_parent(hidden_i);
   15660:	4620      	mov	r0, r4
   15662:	f000 f9e7 	bl	15a34 <lv_obj_get_parent>
   15666:	4604      	mov	r4, r0
            while(hidden_i != NULL) {
   15668:	2c00      	cmp	r4, #0
   1566a:	d1f4      	bne.n	15656 <lv_indev_search_obj+0x40>
            if(hidden_i == NULL) found_p = obj;
   1566c:	4628      	mov	r0, r5
    return found_p;
   1566e:	e7d9      	b.n	15624 <lv_indev_search_obj+0xe>

00015670 <refresh_children_position>:
{
   15670:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _LV_LL_READ(obj->child_ll, i) {
   15672:	1d07      	adds	r7, r0, #4
   15674:	4638      	mov	r0, r7
{
   15676:	460d      	mov	r5, r1
   15678:	4616      	mov	r6, r2
    _LV_LL_READ(obj->child_ll, i) {
   1567a:	f005 fdc6 	bl	1b20a <_lv_ll_get_head>
   1567e:	4604      	mov	r4, r0
   15680:	b900      	cbnz	r0, 15684 <refresh_children_position+0x14>
}
   15682:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        i->coords.x1 += x_diff;
   15684:	8a23      	ldrh	r3, [r4, #16]
        refresh_children_position(i, x_diff, y_diff);
   15686:	4629      	mov	r1, r5
        i->coords.x1 += x_diff;
   15688:	442b      	add	r3, r5
   1568a:	8223      	strh	r3, [r4, #16]
        i->coords.y1 += y_diff;
   1568c:	8a63      	ldrh	r3, [r4, #18]
        refresh_children_position(i, x_diff, y_diff);
   1568e:	4620      	mov	r0, r4
        i->coords.y1 += y_diff;
   15690:	4433      	add	r3, r6
   15692:	8263      	strh	r3, [r4, #18]
        i->coords.x2 += x_diff;
   15694:	8aa3      	ldrh	r3, [r4, #20]
        refresh_children_position(i, x_diff, y_diff);
   15696:	4632      	mov	r2, r6
        i->coords.x2 += x_diff;
   15698:	442b      	add	r3, r5
   1569a:	82a3      	strh	r3, [r4, #20]
        i->coords.y2 += y_diff;
   1569c:	8ae3      	ldrh	r3, [r4, #22]
   1569e:	4433      	add	r3, r6
   156a0:	82e3      	strh	r3, [r4, #22]
        refresh_children_position(i, x_diff, y_diff);
   156a2:	f7ff ffe5 	bl	15670 <refresh_children_position>
    _LV_LL_READ(obj->child_ll, i) {
   156a6:	4621      	mov	r1, r4
   156a8:	4638      	mov	r0, r7
   156aa:	f005 fdb4 	bl	1b216 <_lv_ll_get_next>
   156ae:	e7e6      	b.n	1567e <refresh_children_position+0xe>

000156b0 <_lv_memset_00>:
{
   156b0:	460a      	mov	r2, r1
__ssp_bos_icheck3(memset, void *, int)
   156b2:	2100      	movs	r1, #0
   156b4:	f008 b962 	b.w	1d97c <memset>

000156b8 <_lv_memcpy>:
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   156b8:	f008 b953 	b.w	1d962 <memcpy>

000156bc <lv_area_copy>:
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
   156bc:	2208      	movs	r2, #8
   156be:	f7ff bffb 	b.w	156b8 <_lv_memcpy>

000156c2 <lv_obj_realign>:
}
   156c2:	4770      	bx	lr

000156c4 <lv_obj_set_adv_hittest>:
    obj->adv_hittest = en == false ? 0 : 1;
   156c4:	f890 3032 	ldrb.w	r3, [r0, #50]	; 0x32
   156c8:	f361 13c7 	bfi	r3, r1, #7, #1
   156cc:	f880 3032 	strb.w	r3, [r0, #50]	; 0x32
}
   156d0:	4770      	bx	lr

000156d2 <lv_obj_set_click>:
    obj->click = (en == true ? 1 : 0);
   156d2:	f890 3032 	ldrb.w	r3, [r0, #50]	; 0x32
   156d6:	f361 0300 	bfi	r3, r1, #0, #1
   156da:	f880 3032 	strb.w	r3, [r0, #50]	; 0x32
}
   156de:	4770      	bx	lr

000156e0 <lv_obj_add_protect>:
    obj->protect |= prot;
   156e0:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
   156e4:	4319      	orrs	r1, r3
   156e6:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34
}
   156ea:	4770      	bx	lr

000156ec <lv_obj_clear_protect>:
    obj->protect &= prot;
   156ec:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
   156f0:	ea23 0301 	bic.w	r3, r3, r1
   156f4:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
}
   156f8:	4770      	bx	lr

000156fa <lv_obj_set_event_cb>:
    obj->event_cb = event_cb;
   156fa:	6181      	str	r1, [r0, #24]
}
   156fc:	4770      	bx	lr

000156fe <lv_event_send>:
{
   156fe:	b410      	push	{r4}
   15700:	4613      	mov	r3, r2
   15702:	460c      	mov	r4, r1
    if(obj == NULL) return LV_RES_OK;
   15704:	4601      	mov	r1, r0
   15706:	b120      	cbz	r0, 15712 <lv_event_send+0x14>
    res = lv_event_send_func(obj->event_cb, obj, event, data);
   15708:	4622      	mov	r2, r4
   1570a:	6980      	ldr	r0, [r0, #24]
}
   1570c:	bc10      	pop	{r4}
    res = lv_event_send_func(obj->event_cb, obj, event, data);
   1570e:	f7f3 bdf3 	b.w	92f8 <lv_event_send_func>
}
   15712:	2001      	movs	r0, #1
   15714:	bc10      	pop	{r4}
   15716:	4770      	bx	lr

00015718 <lv_obj_set_signal_cb>:
    obj->signal_cb = signal_cb;
   15718:	61c1      	str	r1, [r0, #28]
}
   1571a:	4770      	bx	lr

0001571c <lv_signal_send>:
    if(obj == NULL) return LV_RES_OK;
   1571c:	b110      	cbz	r0, 15724 <lv_signal_send+0x8>
    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);
   1571e:	69c3      	ldr	r3, [r0, #28]
   15720:	b103      	cbz	r3, 15724 <lv_signal_send+0x8>
   15722:	4718      	bx	r3
}
   15724:	2001      	movs	r0, #1
   15726:	4770      	bx	lr

00015728 <lv_obj_set_design_cb>:
    obj->design_cb = design_cb;
   15728:	6201      	str	r1, [r0, #32]
}
   1572a:	4770      	bx	lr

0001572c <lv_obj_allocate_ext_attr>:
{
   1572c:	b510      	push	{r4, lr}
   1572e:	4604      	mov	r4, r0
    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);
   15730:	6a40      	ldr	r0, [r0, #36]	; 0x24
   15732:	f005 fe7b 	bl	1b42c <lv_mem_realloc>
    if(new_ext == NULL) return NULL;
   15736:	b100      	cbz	r0, 1573a <lv_obj_allocate_ext_attr+0xe>
    obj->ext_attr = new_ext;
   15738:	6260      	str	r0, [r4, #36]	; 0x24
}
   1573a:	bd10      	pop	{r4, pc}

0001573c <lv_obj_refresh_ext_draw_pad>:
    obj->ext_draw_pad = 0;
   1573c:	2200      	movs	r2, #0
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
   1573e:	2106      	movs	r1, #6
   15740:	69c3      	ldr	r3, [r0, #28]
    obj->ext_draw_pad = 0;
   15742:	8602      	strh	r2, [r0, #48]	; 0x30
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
   15744:	4718      	bx	r3

00015746 <lv_obj_area_is_visible>:
    return obj->hidden == 0 ? false : true;
   15746:	f890 3032 	ldrb.w	r3, [r0, #50]	; 0x32
{
   1574a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    if(lv_obj_get_hidden(obj)) return false;
   1574c:	06da      	lsls	r2, r3, #27
{
   1574e:	4605      	mov	r5, r0
   15750:	460e      	mov	r6, r1
    if(lv_obj_get_hidden(obj)) return false;
   15752:	d42e      	bmi.n	157b2 <lv_obj_area_is_visible+0x6c>
   15754:	4603      	mov	r3, r0
    return obj->parent;
   15756:	461c      	mov	r4, r3
   15758:	681b      	ldr	r3, [r3, #0]
    } while(par != NULL);
   1575a:	2b00      	cmp	r3, #0
   1575c:	d1fb      	bne.n	15756 <lv_obj_area_is_visible+0x10>
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
   1575e:	4620      	mov	r0, r4
   15760:	f7f3 fe0e 	bl	9380 <lv_obj_get_disp>
   15764:	4607      	mov	r7, r0
    if(obj_scr == lv_disp_get_scr_act(disp) ||
   15766:	f7ff ff18 	bl	1559a <lv_disp_get_scr_act>
   1576a:	4284      	cmp	r4, r0
   1576c:	d123      	bne.n	157b6 <lv_obj_area_is_visible+0x70>
        lv_area_copy(&obj_coords, &obj->coords);
   1576e:	4668      	mov	r0, sp
   15770:	f105 0110 	add.w	r1, r5, #16
        lv_coord_t ext_size = obj->ext_draw_pad;
   15774:	f9b5 4030 	ldrsh.w	r4, [r5, #48]	; 0x30
        lv_area_copy(&obj_coords, &obj->coords);
   15778:	f7ff ffa0 	bl	156bc <lv_area_copy>
        obj_coords.x1 -= ext_size;
   1577c:	f8bd 3000 	ldrh.w	r3, [sp]
        is_common = _lv_area_intersect(area, area, &obj_coords);
   15780:	466a      	mov	r2, sp
        obj_coords.x1 -= ext_size;
   15782:	1b1b      	subs	r3, r3, r4
   15784:	f8ad 3000 	strh.w	r3, [sp]
        obj_coords.y1 -= ext_size;
   15788:	f8bd 3002 	ldrh.w	r3, [sp, #2]
        is_common = _lv_area_intersect(area, area, &obj_coords);
   1578c:	4631      	mov	r1, r6
        obj_coords.y1 -= ext_size;
   1578e:	1b1b      	subs	r3, r3, r4
   15790:	f8ad 3002 	strh.w	r3, [sp, #2]
        obj_coords.x2 += ext_size;
   15794:	f8bd 3004 	ldrh.w	r3, [sp, #4]
        is_common = _lv_area_intersect(area, area, &obj_coords);
   15798:	4630      	mov	r0, r6
        obj_coords.x2 += ext_size;
   1579a:	4423      	add	r3, r4
   1579c:	f8ad 3004 	strh.w	r3, [sp, #4]
        obj_coords.y2 += ext_size;
   157a0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   157a4:	441c      	add	r4, r3
   157a6:	f8ad 4006 	strh.w	r4, [sp, #6]
        is_common = _lv_area_intersect(area, area, &obj_coords);
   157aa:	f005 fa77 	bl	1ac9c <_lv_area_intersect>
        if(is_common == false) return false;  /*The area is not on the object*/
   157ae:	4604      	mov	r4, r0
   157b0:	bb00      	cbnz	r0, 157f4 <lv_obj_area_is_visible+0xae>
    if(lv_obj_get_hidden(obj)) return false;
   157b2:	2400      	movs	r4, #0
   157b4:	e00f      	b.n	157d6 <lv_obj_area_is_visible+0x90>
       obj_scr == lv_disp_get_scr_prev(disp) ||
   157b6:	4638      	mov	r0, r7
   157b8:	f7ff fef6 	bl	155a8 <lv_disp_get_scr_prev>
    if(obj_scr == lv_disp_get_scr_act(disp) ||
   157bc:	4284      	cmp	r4, r0
   157be:	d0d6      	beq.n	1576e <lv_obj_area_is_visible+0x28>
       obj_scr == lv_disp_get_layer_top(disp) ||
   157c0:	4638      	mov	r0, r7
   157c2:	f7ff fef8 	bl	155b6 <lv_disp_get_layer_top>
       obj_scr == lv_disp_get_scr_prev(disp) ||
   157c6:	4284      	cmp	r4, r0
   157c8:	d0d1      	beq.n	1576e <lv_obj_area_is_visible+0x28>
       obj_scr == lv_disp_get_layer_sys(disp)) {
   157ca:	4638      	mov	r0, r7
   157cc:	f7ff fefa 	bl	155c4 <lv_disp_get_layer_sys>
       obj_scr == lv_disp_get_layer_top(disp) ||
   157d0:	4284      	cmp	r4, r0
   157d2:	d0cc      	beq.n	1576e <lv_obj_area_is_visible+0x28>
    return true;
   157d4:	2401      	movs	r4, #1
}
   157d6:	4620      	mov	r0, r4
   157d8:	b003      	add	sp, #12
   157da:	bdf0      	pop	{r4, r5, r6, r7, pc}
            is_common = _lv_area_intersect(area, area, &par->coords);
   157dc:	4631      	mov	r1, r6
   157de:	4630      	mov	r0, r6
   157e0:	f105 0210 	add.w	r2, r5, #16
   157e4:	f005 fa5a 	bl	1ac9c <_lv_area_intersect>
            if(is_common == false) return false;       /*If no common parts with parent break;*/
   157e8:	2800      	cmp	r0, #0
   157ea:	d0e2      	beq.n	157b2 <lv_obj_area_is_visible+0x6c>
    return obj->hidden == 0 ? false : true;
   157ec:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
            if(lv_obj_get_hidden(par)) return false; /*If the parent is hidden then the child is hidden and won't be drawn*/
   157f0:	06db      	lsls	r3, r3, #27
   157f2:	d4de      	bmi.n	157b2 <lv_obj_area_is_visible+0x6c>
    return obj->parent;
   157f4:	682d      	ldr	r5, [r5, #0]
        while(par != NULL) {
   157f6:	2d00      	cmp	r5, #0
   157f8:	d1f0      	bne.n	157dc <lv_obj_area_is_visible+0x96>
   157fa:	e7ec      	b.n	157d6 <lv_obj_area_is_visible+0x90>

000157fc <lv_obj_invalidate_area>:
{
   157fc:	b513      	push	{r0, r1, r4, lr}
   157fe:	4604      	mov	r4, r0
    lv_area_copy(&area_tmp, area);
   15800:	4668      	mov	r0, sp
   15802:	f7ff ff5b 	bl	156bc <lv_area_copy>
    bool visible = lv_obj_area_is_visible(obj, &area_tmp);
   15806:	4669      	mov	r1, sp
   15808:	4620      	mov	r0, r4
   1580a:	f7ff ff9c 	bl	15746 <lv_obj_area_is_visible>
    if(visible) _lv_inv_area(lv_obj_get_disp(obj), &area_tmp);
   1580e:	b128      	cbz	r0, 1581c <lv_obj_invalidate_area+0x20>
   15810:	4620      	mov	r0, r4
   15812:	f7f3 fdb5 	bl	9380 <lv_obj_get_disp>
   15816:	4669      	mov	r1, sp
   15818:	f001 f9b5 	bl	16b86 <_lv_inv_area>
}
   1581c:	b002      	add	sp, #8
   1581e:	bd10      	pop	{r4, pc}

00015820 <lv_obj_invalidate>:
{
   15820:	b537      	push	{r0, r1, r2, r4, r5, lr}
   15822:	4605      	mov	r5, r0
    lv_coord_t ext_size = obj->ext_draw_pad;
   15824:	f9b0 4030 	ldrsh.w	r4, [r0, #48]	; 0x30
    lv_area_copy(&obj_coords, &obj->coords);
   15828:	f100 0110 	add.w	r1, r0, #16
   1582c:	4668      	mov	r0, sp
   1582e:	f7ff ff45 	bl	156bc <lv_area_copy>
    obj_coords.x1 -= ext_size;
   15832:	f8bd 3000 	ldrh.w	r3, [sp]
    lv_obj_invalidate_area(obj, &obj_coords);
   15836:	4669      	mov	r1, sp
    obj_coords.x1 -= ext_size;
   15838:	1b1b      	subs	r3, r3, r4
   1583a:	f8ad 3000 	strh.w	r3, [sp]
    obj_coords.y1 -= ext_size;
   1583e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    lv_obj_invalidate_area(obj, &obj_coords);
   15842:	4628      	mov	r0, r5
    obj_coords.y1 -= ext_size;
   15844:	1b1b      	subs	r3, r3, r4
   15846:	f8ad 3002 	strh.w	r3, [sp, #2]
    obj_coords.x2 += ext_size;
   1584a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   1584e:	4423      	add	r3, r4
   15850:	f8ad 3004 	strh.w	r3, [sp, #4]
    obj_coords.y2 += ext_size;
   15854:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   15858:	441c      	add	r4, r3
   1585a:	f8ad 4006 	strh.w	r4, [sp, #6]
    lv_obj_invalidate_area(obj, &obj_coords);
   1585e:	f7ff ffcd 	bl	157fc <lv_obj_invalidate_area>
}
   15862:	b003      	add	sp, #12
   15864:	bd30      	pop	{r4, r5, pc}

00015866 <lv_obj_move_foreground>:
{
   15866:	b570      	push	{r4, r5, r6, lr}
    return obj->parent;
   15868:	6805      	ldr	r5, [r0, #0]
{
   1586a:	4604      	mov	r4, r0
    if(_lv_ll_get_head(&parent->child_ll) == obj) return;
   1586c:	1d2e      	adds	r6, r5, #4
   1586e:	4630      	mov	r0, r6
   15870:	f005 fccb 	bl	1b20a <_lv_ll_get_head>
   15874:	4284      	cmp	r4, r0
   15876:	d012      	beq.n	1589e <lv_obj_move_foreground+0x38>
    lv_obj_invalidate(parent);
   15878:	4628      	mov	r0, r5
   1587a:	f7ff ffd1 	bl	15820 <lv_obj_invalidate>
    _lv_ll_chg_list(&parent->child_ll, &parent->child_ll, obj, true);
   1587e:	4622      	mov	r2, r4
   15880:	4631      	mov	r1, r6
   15882:	4630      	mov	r0, r6
   15884:	2301      	movs	r3, #1
   15886:	f005 fd3a 	bl	1b2fe <_lv_ll_chg_list>
    parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, obj);
   1588a:	4622      	mov	r2, r4
   1588c:	4628      	mov	r0, r5
   1588e:	69eb      	ldr	r3, [r5, #28]
   15890:	2101      	movs	r1, #1
   15892:	4798      	blx	r3
    lv_obj_invalidate(parent);
   15894:	4628      	mov	r0, r5
}
   15896:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_obj_invalidate(parent);
   1589a:	f7ff bfc1 	b.w	15820 <lv_obj_invalidate>
}
   1589e:	bd70      	pop	{r4, r5, r6, pc}

000158a0 <lv_obj_set_pos>:
{
   158a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    lv_obj_t * par = obj->parent;
   158a2:	6807      	ldr	r7, [r0, #0]
{
   158a4:	4604      	mov	r4, r0
    if(par) {
   158a6:	b12f      	cbz	r7, 158b4 <lv_obj_set_pos+0x14>
        x = x + par->coords.x1;
   158a8:	8a3d      	ldrh	r5, [r7, #16]
        y = y + par->coords.y1;
   158aa:	8a7e      	ldrh	r6, [r7, #18]
        x = x + par->coords.x1;
   158ac:	4429      	add	r1, r5
        y = y + par->coords.y1;
   158ae:	4432      	add	r2, r6
        x = x + par->coords.x1;
   158b0:	b209      	sxth	r1, r1
        y = y + par->coords.y1;
   158b2:	b212      	sxth	r2, r2
    diff.x = x - obj->coords.x1;
   158b4:	8a25      	ldrh	r5, [r4, #16]
    diff.y = y - obj->coords.y1;
   158b6:	8a66      	ldrh	r6, [r4, #18]
    diff.x = x - obj->coords.x1;
   158b8:	1b49      	subs	r1, r1, r5
    diff.y = y - obj->coords.y1;
   158ba:	1b92      	subs	r2, r2, r6
    diff.x = x - obj->coords.x1;
   158bc:	b20d      	sxth	r5, r1
    diff.y = y - obj->coords.y1;
   158be:	b216      	sxth	r6, r2
    if(diff.x == 0 && diff.y == 0) return;
   158c0:	ea55 0306 	orrs.w	r3, r5, r6
   158c4:	d026      	beq.n	15914 <lv_obj_set_pos+0x74>
    lv_obj_invalidate(obj);
   158c6:	4620      	mov	r0, r4
   158c8:	f7ff ffaa 	bl	15820 <lv_obj_invalidate>
    lv_area_copy(cords_p, &obj->coords);
   158cc:	4668      	mov	r0, sp
   158ce:	f104 0110 	add.w	r1, r4, #16
   158d2:	f7ff fef3 	bl	156bc <lv_area_copy>
    obj->coords.x1 += diff.x;
   158d6:	8a23      	ldrh	r3, [r4, #16]
    refresh_children_position(obj, diff.x, diff.y);
   158d8:	4632      	mov	r2, r6
    obj->coords.x1 += diff.x;
   158da:	442b      	add	r3, r5
   158dc:	8223      	strh	r3, [r4, #16]
    obj->coords.y1 += diff.y;
   158de:	8a63      	ldrh	r3, [r4, #18]
    refresh_children_position(obj, diff.x, diff.y);
   158e0:	4629      	mov	r1, r5
    obj->coords.y1 += diff.y;
   158e2:	4433      	add	r3, r6
   158e4:	8263      	strh	r3, [r4, #18]
    obj->coords.x2 += diff.x;
   158e6:	8aa3      	ldrh	r3, [r4, #20]
    refresh_children_position(obj, diff.x, diff.y);
   158e8:	4620      	mov	r0, r4
    obj->coords.x2 += diff.x;
   158ea:	442b      	add	r3, r5
   158ec:	82a3      	strh	r3, [r4, #20]
    obj->coords.y2 += diff.y;
   158ee:	8ae3      	ldrh	r3, [r4, #22]
   158f0:	4433      	add	r3, r6
   158f2:	82e3      	strh	r3, [r4, #22]
    refresh_children_position(obj, diff.x, diff.y);
   158f4:	f7ff febc 	bl	15670 <refresh_children_position>
    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);
   158f8:	466a      	mov	r2, sp
   158fa:	2102      	movs	r1, #2
   158fc:	4620      	mov	r0, r4
   158fe:	69e3      	ldr	r3, [r4, #28]
   15900:	4798      	blx	r3
    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
   15902:	b127      	cbz	r7, 1590e <lv_obj_set_pos+0x6e>
   15904:	4622      	mov	r2, r4
   15906:	2101      	movs	r1, #1
   15908:	4638      	mov	r0, r7
   1590a:	69fb      	ldr	r3, [r7, #28]
   1590c:	4798      	blx	r3
    lv_obj_invalidate(obj);
   1590e:	4620      	mov	r0, r4
   15910:	f7ff ff86 	bl	15820 <lv_obj_invalidate>
}
   15914:	b003      	add	sp, #12
   15916:	bdf0      	pop	{r4, r5, r6, r7, pc}

00015918 <lv_obj_align>:
{
   15918:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1591a:	4605      	mov	r5, r0
   1591c:	461c      	mov	r4, r3
    if(base == NULL) base = lv_obj_get_parent(obj);
   1591e:	4608      	mov	r0, r1
   15920:	b901      	cbnz	r1, 15924 <lv_obj_align+0xc>
    return obj->parent;
   15922:	6828      	ldr	r0, [r5, #0]
    _lv_area_align(&base->coords, &obj->coords, align, &new_pos);
   15924:	ab01      	add	r3, sp, #4
   15926:	f105 0110 	add.w	r1, r5, #16
   1592a:	3010      	adds	r0, #16
   1592c:	f005 faf9 	bl	1af22 <_lv_area_align>
    return obj->parent;
   15930:	6828      	ldr	r0, [r5, #0]
    new_pos.x += x_ofs;
   15932:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    new_pos.y += y_ofs;
   15936:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   1593a:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
    lv_coord_t par_abs_y  = par->coords.y1;
   1593e:	f9b0 6012 	ldrsh.w	r6, [r0, #18]
    new_pos.x += x_ofs;
   15942:	4421      	add	r1, r4
    new_pos.x -= par_abs_x;
   15944:	8a04      	ldrh	r4, [r0, #16]
    new_pos.y += y_ofs;
   15946:	441a      	add	r2, r3
    new_pos.x -= par_abs_x;
   15948:	1b09      	subs	r1, r1, r4
    new_pos.y -= par_abs_y;
   1594a:	1b92      	subs	r2, r2, r6
    new_pos.x -= par_abs_x;
   1594c:	b209      	sxth	r1, r1
    new_pos.y -= par_abs_y;
   1594e:	b212      	sxth	r2, r2
    if(x_set && y_set) lv_obj_set_pos(obj, new_pos.x, new_pos.y);
   15950:	4628      	mov	r0, r5
    new_pos.x -= par_abs_x;
   15952:	f8ad 1004 	strh.w	r1, [sp, #4]
    new_pos.y -= par_abs_y;
   15956:	f8ad 2006 	strh.w	r2, [sp, #6]
    if(x_set && y_set) lv_obj_set_pos(obj, new_pos.x, new_pos.y);
   1595a:	f7ff ffa1 	bl	158a0 <lv_obj_set_pos>
}
   1595e:	b002      	add	sp, #8
   15960:	bd70      	pop	{r4, r5, r6, pc}

00015962 <lv_obj_set_hidden>:
    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */
   15962:	f890 3032 	ldrb.w	r3, [r0, #50]	; 0x32
{
   15966:	b570      	push	{r4, r5, r6, lr}
    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */
   15968:	06da      	lsls	r2, r3, #27
{
   1596a:	4604      	mov	r4, r0
   1596c:	460d      	mov	r5, r1
    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */
   1596e:	d401      	bmi.n	15974 <lv_obj_set_hidden+0x12>
   15970:	f7ff ff56 	bl	15820 <lv_obj_invalidate>
    obj->hidden = en == false ? 0 : 1;
   15974:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
   15978:	f365 1304 	bfi	r3, r5, #4, #1
   1597c:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */
   15980:	06db      	lsls	r3, r3, #27
   15982:	d402      	bmi.n	1598a <lv_obj_set_hidden+0x28>
   15984:	4620      	mov	r0, r4
   15986:	f7ff ff4b 	bl	15820 <lv_obj_invalidate>
    return obj->parent;
   1598a:	6820      	ldr	r0, [r4, #0]
    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
   1598c:	b128      	cbz	r0, 1599a <lv_obj_set_hidden+0x38>
   1598e:	4622      	mov	r2, r4
}
   15990:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
   15994:	2101      	movs	r1, #1
   15996:	69c3      	ldr	r3, [r0, #28]
   15998:	4718      	bx	r3
}
   1599a:	bd70      	pop	{r4, r5, r6, pc}

0001599c <lv_obj_set_size>:
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1599c:	8a83      	ldrh	r3, [r0, #20]
{
   1599e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   159a0:	4616      	mov	r6, r2
   159a2:	8a02      	ldrh	r2, [r0, #16]
   159a4:	3301      	adds	r3, #1
   159a6:	1a9b      	subs	r3, r3, r2
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
   159a8:	b21b      	sxth	r3, r3
   159aa:	428b      	cmp	r3, r1
{
   159ac:	4604      	mov	r4, r0
   159ae:	460d      	mov	r5, r1
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
   159b0:	d106      	bne.n	159c0 <lv_obj_set_size+0x24>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   159b2:	8ac3      	ldrh	r3, [r0, #22]
   159b4:	8a42      	ldrh	r2, [r0, #18]
   159b6:	3301      	adds	r3, #1
   159b8:	1a9b      	subs	r3, r3, r2
   159ba:	b21b      	sxth	r3, r3
   159bc:	429e      	cmp	r6, r3
   159be:	d023      	beq.n	15a08 <lv_obj_set_size+0x6c>
    lv_obj_invalidate(obj);
   159c0:	4620      	mov	r0, r4
   159c2:	f7ff ff2d 	bl	15820 <lv_obj_invalidate>
    lv_area_copy(cords_p, &obj->coords);
   159c6:	4668      	mov	r0, sp
   159c8:	f104 0110 	add.w	r1, r4, #16
   159cc:	f7ff fe76 	bl	156bc <lv_area_copy>
    obj->coords.y2 = obj->coords.y1 + h - 1;
   159d0:	8a62      	ldrh	r2, [r4, #18]
        obj->coords.x2 = obj->coords.x1 + w - 1;
   159d2:	8a21      	ldrh	r1, [r4, #16]
    obj->coords.y2 = obj->coords.y1 + h - 1;
   159d4:	3e01      	subs	r6, #1
        obj->coords.x2 = obj->coords.x1 + w - 1;
   159d6:	3d01      	subs	r5, #1
    obj->coords.y2 = obj->coords.y1 + h - 1;
   159d8:	4416      	add	r6, r2
        obj->coords.x2 = obj->coords.x1 + w - 1;
   159da:	440d      	add	r5, r1
    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);
   159dc:	466a      	mov	r2, sp
   159de:	2102      	movs	r1, #2
   159e0:	4620      	mov	r0, r4
   159e2:	69e3      	ldr	r3, [r4, #28]
    obj->coords.y2 = obj->coords.y1 + h - 1;
   159e4:	82e6      	strh	r6, [r4, #22]
        obj->coords.x2 = obj->coords.x1 + w - 1;
   159e6:	82a5      	strh	r5, [r4, #20]
    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);
   159e8:	4798      	blx	r3
    return obj->parent;
   159ea:	6820      	ldr	r0, [r4, #0]
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
   159ec:	b118      	cbz	r0, 159f6 <lv_obj_set_size+0x5a>
   159ee:	4622      	mov	r2, r4
   159f0:	2101      	movs	r1, #1
   159f2:	69c3      	ldr	r3, [r0, #28]
   159f4:	4798      	blx	r3
    _LV_LL_READ(obj->child_ll, i) {
   159f6:	1d26      	adds	r6, r4, #4
   159f8:	4630      	mov	r0, r6
   159fa:	f005 fc06 	bl	1b20a <_lv_ll_get_head>
   159fe:	4605      	mov	r5, r0
   15a00:	b920      	cbnz	r0, 15a0c <lv_obj_set_size+0x70>
    lv_obj_invalidate(obj);
   15a02:	4620      	mov	r0, r4
   15a04:	f7ff ff0c 	bl	15820 <lv_obj_invalidate>
}
   15a08:	b002      	add	sp, #8
   15a0a:	bd70      	pop	{r4, r5, r6, pc}
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG,  &ori);
   15a0c:	466a      	mov	r2, sp
   15a0e:	2103      	movs	r1, #3
   15a10:	4628      	mov	r0, r5
   15a12:	69eb      	ldr	r3, [r5, #28]
   15a14:	4798      	blx	r3
    _LV_LL_READ(obj->child_ll, i) {
   15a16:	4629      	mov	r1, r5
   15a18:	4630      	mov	r0, r6
   15a1a:	f005 fbfc 	bl	1b216 <_lv_ll_get_next>
   15a1e:	e7ee      	b.n	159fe <lv_obj_set_size+0x62>

00015a20 <lv_obj_set_height>:
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   15a20:	8a83      	ldrh	r3, [r0, #20]
{
   15a22:	460a      	mov	r2, r1
   15a24:	8a01      	ldrh	r1, [r0, #16]
   15a26:	3301      	adds	r3, #1
   15a28:	b410      	push	{r4}
   15a2a:	1a59      	subs	r1, r3, r1
}
   15a2c:	bc10      	pop	{r4}
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
   15a2e:	b209      	sxth	r1, r1
   15a30:	f7ff bfb4 	b.w	1599c <lv_obj_set_size>

00015a34 <lv_obj_get_parent>:
}
   15a34:	6800      	ldr	r0, [r0, #0]
   15a36:	4770      	bx	lr

00015a38 <lv_obj_get_child>:
    if(child == NULL) {
   15a38:	3004      	adds	r0, #4
   15a3a:	b909      	cbnz	r1, 15a40 <lv_obj_get_child+0x8>
        result = _lv_ll_get_head(&obj->child_ll);
   15a3c:	f005 bbe5 	b.w	1b20a <_lv_ll_get_head>
        result = _lv_ll_get_next(&obj->child_ll, child);
   15a40:	f005 bbe9 	b.w	1b216 <_lv_ll_get_next>

00015a44 <refresh_children_style>:
{
   15a44:	b538      	push	{r3, r4, r5, lr}
   15a46:	4605      	mov	r5, r0
        result = _lv_ll_get_head(&obj->child_ll);
   15a48:	3004      	adds	r0, #4
   15a4a:	f005 fbde 	bl	1b20a <_lv_ll_get_head>
        child = lv_obj_get_child(obj, child);
   15a4e:	4604      	mov	r4, r0
    while(child != NULL) {
   15a50:	b900      	cbnz	r0, 15a54 <refresh_children_style+0x10>
}
   15a52:	bd38      	pop	{r3, r4, r5, pc}
        lv_obj_invalidate(child);
   15a54:	4620      	mov	r0, r4
   15a56:	f7ff fee3 	bl	15820 <lv_obj_invalidate>
        child->signal_cb(child, LV_SIGNAL_STYLE_CHG, NULL);
   15a5a:	2200      	movs	r2, #0
   15a5c:	2104      	movs	r1, #4
   15a5e:	69e3      	ldr	r3, [r4, #28]
   15a60:	4620      	mov	r0, r4
   15a62:	4798      	blx	r3
        lv_obj_invalidate(child);
   15a64:	4620      	mov	r0, r4
   15a66:	f7ff fedb 	bl	15820 <lv_obj_invalidate>
        refresh_children_style(child); /*Check children too*/
   15a6a:	4620      	mov	r0, r4
   15a6c:	f7ff ffea 	bl	15a44 <refresh_children_style>
        child = lv_obj_get_child(obj, child);
   15a70:	4621      	mov	r1, r4
   15a72:	4628      	mov	r0, r5
   15a74:	f7ff ffe0 	bl	15a38 <lv_obj_get_child>
   15a78:	e7e9      	b.n	15a4e <refresh_children_style+0xa>

00015a7a <lv_obj_get_coords>:
{
   15a7a:	460b      	mov	r3, r1
    lv_area_copy(cords_p, &obj->coords);
   15a7c:	f100 0110 	add.w	r1, r0, #16
   15a80:	4618      	mov	r0, r3
   15a82:	f7ff be1b 	b.w	156bc <lv_area_copy>

00015a86 <lv_obj_get_x>:
    return obj->parent;
   15a86:	6803      	ldr	r3, [r0, #0]
    if(parent) {
   15a88:	f9b0 0010 	ldrsh.w	r0, [r0, #16]
   15a8c:	b113      	cbz	r3, 15a94 <lv_obj_get_x+0xe>
        rel_x             = obj->coords.x1 - parent->coords.x1;
   15a8e:	8a1b      	ldrh	r3, [r3, #16]
   15a90:	1ac0      	subs	r0, r0, r3
   15a92:	b200      	sxth	r0, r0
}
   15a94:	4770      	bx	lr

00015a96 <lv_obj_set_y>:
{
   15a96:	b510      	push	{r4, lr}
   15a98:	460a      	mov	r2, r1
   15a9a:	4604      	mov	r4, r0
    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);
   15a9c:	f7ff fff3 	bl	15a86 <lv_obj_get_x>
   15aa0:	4601      	mov	r1, r0
   15aa2:	4620      	mov	r0, r4
}
   15aa4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);
   15aa8:	f7ff befa 	b.w	158a0 <lv_obj_set_pos>

00015aac <lv_obj_get_y>:
    return obj->parent;
   15aac:	6803      	ldr	r3, [r0, #0]
    if(parent) {
   15aae:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
   15ab2:	b113      	cbz	r3, 15aba <lv_obj_get_y+0xe>
        rel_y             = obj->coords.y1 - parent->coords.y1;
   15ab4:	8a5b      	ldrh	r3, [r3, #18]
   15ab6:	1ac0      	subs	r0, r0, r3
   15ab8:	b200      	sxth	r0, r0
}
   15aba:	4770      	bx	lr

00015abc <lv_obj_set_x>:
{
   15abc:	b510      	push	{r4, lr}
   15abe:	4604      	mov	r4, r0
    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));
   15ac0:	f7ff fff4 	bl	15aac <lv_obj_get_y>
   15ac4:	4602      	mov	r2, r0
   15ac6:	4620      	mov	r0, r4
}
   15ac8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));
   15acc:	f7ff bee8 	b.w	158a0 <lv_obj_set_pos>

00015ad0 <lv_obj_get_width>:
   15ad0:	8a83      	ldrh	r3, [r0, #20]
   15ad2:	8a00      	ldrh	r0, [r0, #16]
   15ad4:	3301      	adds	r3, #1
   15ad6:	1a18      	subs	r0, r3, r0
}
   15ad8:	b200      	sxth	r0, r0
   15ada:	4770      	bx	lr

00015adc <lv_obj_get_height>:
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   15adc:	8ac3      	ldrh	r3, [r0, #22]
   15ade:	8a40      	ldrh	r0, [r0, #18]
   15ae0:	3301      	adds	r3, #1
   15ae2:	1a18      	subs	r0, r3, r0
}
   15ae4:	b200      	sxth	r0, r0
   15ae6:	4770      	bx	lr

00015ae8 <lv_obj_get_auto_realign>:
}
   15ae8:	2000      	movs	r0, #0
   15aea:	4770      	bx	lr

00015aec <lv_obj_get_style_list>:
{
   15aec:	b513      	push	{r0, r1, r4, lr}
    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;
   15aee:	b911      	cbnz	r1, 15af6 <lv_obj_get_style_list+0xa>
   15af0:	3028      	adds	r0, #40	; 0x28
}
   15af2:	b002      	add	sp, #8
   15af4:	bd10      	pop	{r4, pc}
    info.result = NULL;
   15af6:	2400      	movs	r4, #0
    info.part = part;
   15af8:	f88d 1000 	strb.w	r1, [sp]
    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);
   15afc:	466a      	mov	r2, sp
   15afe:	2108      	movs	r1, #8
    info.result = NULL;
   15b00:	9401      	str	r4, [sp, #4]
    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);
   15b02:	f7ff fe0b 	bl	1571c <lv_signal_send>
    if(res != LV_RES_OK) return NULL;
   15b06:	2801      	cmp	r0, #1
   15b08:	bf14      	ite	ne
   15b0a:	4620      	movne	r0, r4
    return info.result;
   15b0c:	9801      	ldreq	r0, [sp, #4]
   15b0e:	e7f0      	b.n	15af2 <lv_obj_get_style_list+0x6>

00015b10 <lv_obj_del>:
{
   15b10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15b12:	4605      	mov	r5, r0
    lv_obj_invalidate(obj);
   15b14:	f7ff fe84 	bl	15820 <lv_obj_invalidate>
    return obj->parent;
   15b18:	682f      	ldr	r7, [r5, #0]
    if(par == NULL) {
   15b1a:	b9b7      	cbnz	r7, 15b4a <lv_obj_del+0x3a>
        disp = lv_obj_get_disp(obj);
   15b1c:	4628      	mov	r0, r5
   15b1e:	f7f3 fc2f 	bl	9380 <lv_obj_get_disp>
        if(!disp) return LV_RES_INV;   /*Shouldn't happen*/
   15b22:	4604      	mov	r4, r0
   15b24:	b178      	cbz	r0, 15b46 <lv_obj_del+0x36>
        if(disp->act_scr == obj) act_scr_del = true;
   15b26:	6c06      	ldr	r6, [r0, #64]	; 0x40
   15b28:	1b73      	subs	r3, r6, r5
   15b2a:	425e      	negs	r6, r3
   15b2c:	415e      	adcs	r6, r3
    obj_del_core(obj);
   15b2e:	4628      	mov	r0, r5
   15b30:	f7f3 fde4 	bl	96fc <obj_del_core>
    if(par) {
   15b34:	b127      	cbz	r7, 15b40 <lv_obj_del+0x30>
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, NULL);
   15b36:	2200      	movs	r2, #0
   15b38:	2101      	movs	r1, #1
   15b3a:	4638      	mov	r0, r7
   15b3c:	69fb      	ldr	r3, [r7, #28]
   15b3e:	4798      	blx	r3
    if(act_scr_del)  {
   15b40:	b10e      	cbz	r6, 15b46 <lv_obj_del+0x36>
        disp->act_scr = NULL;
   15b42:	2300      	movs	r3, #0
   15b44:	6423      	str	r3, [r4, #64]	; 0x40
}
   15b46:	2000      	movs	r0, #0
   15b48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    bool act_scr_del = false;
   15b4a:	2600      	movs	r6, #0
    lv_disp_t * disp = NULL;
   15b4c:	4634      	mov	r4, r6
   15b4e:	e7ee      	b.n	15b2e <lv_obj_del+0x1e>

00015b50 <lv_obj_clean_style_list>:
{
   15b50:	b570      	push	{r4, r5, r6, lr}
   15b52:	4604      	mov	r4, r0
   15b54:	460d      	mov	r5, r1
    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);
   15b56:	f7ff ffc9 	bl	15aec <lv_obj_get_style_list>
    if(style_dsc == NULL) {
   15b5a:	b148      	cbz	r0, 15b70 <lv_obj_clean_style_list+0x20>
    _lv_style_list_reset(style_dsc);
   15b5c:	f001 fb5d 	bl	1721a <_lv_style_list_reset>
    trans_del(obj, part, 0xFF, NULL);
   15b60:	4629      	mov	r1, r5
   15b62:	4620      	mov	r0, r4
}
   15b64:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    trans_del(obj, part, 0xFF, NULL);
   15b68:	2300      	movs	r3, #0
   15b6a:	22ff      	movs	r2, #255	; 0xff
   15b6c:	f7f3 bd8c 	b.w	9688 <trans_del>
}
   15b70:	bd70      	pop	{r4, r5, r6, pc}

00015b72 <_lv_obj_disable_style_caching>:
{
   15b72:	b570      	push	{r4, r5, r6, lr}
   15b74:	4606      	mov	r6, r0
   15b76:	460d      	mov	r5, r1
   15b78:	2400      	movs	r4, #0
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   15b7a:	4630      	mov	r0, r6
   15b7c:	b2e1      	uxtb	r1, r4
   15b7e:	f7ff ffb5 	bl	15aec <lv_obj_get_style_list>
        if(list == NULL) break;
   15b82:	b130      	cbz	r0, 15b92 <_lv_obj_disable_style_caching+0x20>
        list->ignore_cache = dis;
   15b84:	7943      	ldrb	r3, [r0, #5]
   15b86:	3401      	adds	r4, #1
   15b88:	f365 03c3 	bfi	r3, r5, #3, #1
    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
   15b8c:	2c40      	cmp	r4, #64	; 0x40
        list->ignore_cache = dis;
   15b8e:	7143      	strb	r3, [r0, #5]
    for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
   15b90:	d1f3      	bne.n	15b7a <_lv_obj_disable_style_caching+0x8>
{
   15b92:	2440      	movs	r4, #64	; 0x40
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   15b94:	4621      	mov	r1, r4
   15b96:	4630      	mov	r0, r6
   15b98:	f7ff ffa8 	bl	15aec <lv_obj_get_style_list>
        if(list == NULL) break;
   15b9c:	b138      	cbz	r0, 15bae <_lv_obj_disable_style_caching+0x3c>
        list->ignore_cache = dis;
   15b9e:	7943      	ldrb	r3, [r0, #5]
    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   15ba0:	3401      	adds	r4, #1
   15ba2:	b2e4      	uxtb	r4, r4
        list->ignore_cache = dis;
   15ba4:	f365 03c3 	bfi	r3, r5, #3, #1
    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   15ba8:	2cff      	cmp	r4, #255	; 0xff
        list->ignore_cache = dis;
   15baa:	7143      	strb	r3, [r0, #5]
    for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   15bac:	d1f2      	bne.n	15b94 <_lv_obj_disable_style_caching+0x22>
}
   15bae:	bd70      	pop	{r4, r5, r6, pc}

00015bb0 <lv_obj_get_hidden>:
    return obj->hidden == 0 ? false : true;
   15bb0:	f890 0032 	ldrb.w	r0, [r0, #50]	; 0x32
}
   15bb4:	f3c0 1000 	ubfx	r0, r0, #4, #1
   15bb8:	4770      	bx	lr

00015bba <lv_obj_get_click>:
    return obj->click == 0 ? false : true;
   15bba:	f890 0032 	ldrb.w	r0, [r0, #50]	; 0x32
}
   15bbe:	f000 0001 	and.w	r0, r0, #1
   15bc2:	4770      	bx	lr

00015bc4 <lv_obj_get_drag>:
    return obj->drag == 0 ? false : true;
   15bc4:	f890 0032 	ldrb.w	r0, [r0, #50]	; 0x32
}
   15bc8:	f3c0 0040 	ubfx	r0, r0, #1, #1
   15bcc:	4770      	bx	lr

00015bce <lv_obj_get_drag_dir>:
    return obj->drag_dir;
   15bce:	f890 0033 	ldrb.w	r0, [r0, #51]	; 0x33
}
   15bd2:	f3c0 0082 	ubfx	r0, r0, #2, #3
   15bd6:	4770      	bx	lr

00015bd8 <lv_obj_get_drag_throw>:
    return obj->drag_throw == 0 ? false : true;
   15bd8:	f890 0032 	ldrb.w	r0, [r0, #50]	; 0x32
}
   15bdc:	f3c0 0080 	ubfx	r0, r0, #2, #1
   15be0:	4770      	bx	lr

00015be2 <lv_obj_get_drag_parent>:
    return obj->drag_parent == 0 ? false : true;
   15be2:	f890 0032 	ldrb.w	r0, [r0, #50]	; 0x32
}
   15be6:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   15bea:	4770      	bx	lr

00015bec <lv_obj_get_gesture_parent>:
    return obj->gesture_parent == 0 ? false : true;
   15bec:	f890 0033 	ldrb.w	r0, [r0, #51]	; 0x33
}
   15bf0:	f000 0001 	and.w	r0, r0, #1
   15bf4:	4770      	bx	lr

00015bf6 <lv_obj_get_base_dir>:
}
   15bf6:	2000      	movs	r0, #0
   15bf8:	4770      	bx	lr

00015bfa <lv_obj_is_protected>:
    return (obj->protect & prot) == 0 ? false : true;
   15bfa:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
   15bfe:	4219      	tst	r1, r3
}
   15c00:	bf14      	ite	ne
   15c02:	2001      	movne	r0, #1
   15c04:	2000      	moveq	r0, #0
   15c06:	4770      	bx	lr

00015c08 <lv_obj_get_state>:
    if(part < _LV_OBJ_PART_REAL_LAST) return ((lv_obj_t *)obj)->state;
   15c08:	293f      	cmp	r1, #63	; 0x3f
{
   15c0a:	b507      	push	{r0, r1, r2, lr}
    if(part < _LV_OBJ_PART_REAL_LAST) return ((lv_obj_t *)obj)->state;
   15c0c:	d804      	bhi.n	15c18 <lv_obj_get_state+0x10>
   15c0e:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
   15c12:	b003      	add	sp, #12
   15c14:	f85d fb04 	ldr.w	pc, [sp], #4
    info.result = LV_STATE_DEFAULT;
   15c18:	2300      	movs	r3, #0
    info.part = part;
   15c1a:	f88d 1004 	strb.w	r1, [sp, #4]
    lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STATE_DSC, &info);
   15c1e:	aa01      	add	r2, sp, #4
   15c20:	2109      	movs	r1, #9
    info.result = LV_STATE_DEFAULT;
   15c22:	f88d 3005 	strb.w	r3, [sp, #5]
    lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STATE_DSC, &info);
   15c26:	f7ff fd79 	bl	1571c <lv_signal_send>
    return info.result;
   15c2a:	f89d 0005 	ldrb.w	r0, [sp, #5]
   15c2e:	e7f0      	b.n	15c12 <lv_obj_get_state+0xa>

00015c30 <_lv_obj_get_style_color>:
{
   15c30:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   15c34:	4605      	mov	r5, r0
   15c36:	460e      	mov	r6, r1
   15c38:	4617      	mov	r7, r2
    while(parent) {
   15c3a:	4614      	mov	r4, r2
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
   15c3c:	f342 2907 	sbfx	r9, r2, #8, #8
    while(parent) {
   15c40:	b94d      	cbnz	r5, 15c56 <_lv_obj_get_style_color+0x26>
    prop = prop & (~LV_STYLE_STATE_MASK);
   15c42:	f424 44fe 	bic.w	r4, r4, #32512	; 0x7f00
    switch(prop) {
   15c46:	3c29      	subs	r4, #41	; 0x29
   15c48:	2c01      	cmp	r4, #1
   15c4a:	bf8c      	ite	hi
   15c4c:	f04f 407f 	movhi.w	r0, #4278190080	; 0xff000000
   15c50:	f04f 30ff 	movls.w	r0, #4294967295
   15c54:	e013      	b.n	15c7e <_lv_obj_get_style_color+0x4e>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   15c56:	4631      	mov	r1, r6
   15c58:	4628      	mov	r0, r5
   15c5a:	f7ff ff47 	bl	15aec <lv_obj_get_style_list>
        lv_state_t state = lv_obj_get_state(parent, part);
   15c5e:	4631      	mov	r1, r6
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   15c60:	4680      	mov	r8, r0
        lv_state_t state = lv_obj_get_state(parent, part);
   15c62:	4628      	mov	r0, r5
   15c64:	f7ff ffd0 	bl	15c08 <lv_obj_get_state>
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   15c68:	eb07 2400 	add.w	r4, r7, r0, lsl #8
   15c6c:	b2a4      	uxth	r4, r4
        res = _lv_style_list_get_color(list, prop, &value_act);
   15c6e:	4621      	mov	r1, r4
   15c70:	4640      	mov	r0, r8
   15c72:	aa01      	add	r2, sp, #4
   15c74:	f001 fbd1 	bl	1741a <_lv_style_list_get_color>
        if(res == LV_RES_OK) return value_act;
   15c78:	2801      	cmp	r0, #1
   15c7a:	d103      	bne.n	15c84 <_lv_obj_get_style_color+0x54>
   15c7c:	9801      	ldr	r0, [sp, #4]
}
   15c7e:	b003      	add	sp, #12
   15c80:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
   15c84:	f1b9 0f00 	cmp.w	r9, #0
   15c88:	dadb      	bge.n	15c42 <_lv_obj_get_style_color+0x12>
        if(part != LV_OBJ_PART_MAIN) {
   15c8a:	b906      	cbnz	r6, 15c8e <_lv_obj_get_style_color+0x5e>
    return obj->parent;
   15c8c:	682d      	ldr	r5, [r5, #0]
{
   15c8e:	2600      	movs	r6, #0
   15c90:	e7d6      	b.n	15c40 <_lv_obj_get_style_color+0x10>

00015c92 <lv_obj_get_style_clip_corner>:
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
   15c92:	2202      	movs	r2, #2
   15c94:	b508      	push	{r3, lr}
   15c96:	f7f3 fdb7 	bl	9808 <_lv_obj_get_style_int>
   15c9a:	3800      	subs	r0, #0
   15c9c:	bf18      	it	ne
   15c9e:	2001      	movne	r0, #1
   15ca0:	bd08      	pop	{r3, pc}

00015ca2 <lv_obj_get_width_fit>:
{
   15ca2:	b538      	push	{r3, r4, r5, lr}
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   15ca4:	2212      	movs	r2, #18
   15ca6:	2100      	movs	r1, #0
   15ca8:	4604      	mov	r4, r0
   15caa:	f7f3 fdad 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   15cae:	2213      	movs	r2, #19
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   15cb0:	4605      	mov	r5, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   15cb2:	2100      	movs	r1, #0
   15cb4:	4620      	mov	r0, r4
   15cb6:	f7f3 fda7 	bl	9808 <_lv_obj_get_style_int>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   15cba:	8aa3      	ldrh	r3, [r4, #20]
   15cbc:	8a22      	ldrh	r2, [r4, #16]
   15cbe:	3301      	adds	r3, #1
   15cc0:	1a9b      	subs	r3, r3, r2
    return lv_obj_get_width(obj) - left - right;
   15cc2:	1b5b      	subs	r3, r3, r5
   15cc4:	1a18      	subs	r0, r3, r0
}
   15cc6:	b200      	sxth	r0, r0
   15cc8:	bd38      	pop	{r3, r4, r5, pc}

00015cca <_lv_obj_get_style_opa>:
{
   15cca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15cce:	4605      	mov	r5, r0
   15cd0:	460f      	mov	r7, r1
   15cd2:	4690      	mov	r8, r2
    while(parent) {
   15cd4:	4614      	mov	r4, r2
            switch(prop & (~LV_STYLE_STATE_MASK)) {
   15cd6:	f248 0a0c 	movw	sl, #32780	; 0x800c
   15cda:	f248 0bad 	movw	fp, #32941	; 0x80ad
{
   15cde:	b085      	sub	sp, #20
    attr = prop_ori >> 8;
   15ce0:	ea4f 2912 	mov.w	r9, r2, lsr #8
    while(parent) {
   15ce4:	b96d      	cbnz	r5, 15d02 <_lv_obj_get_style_opa+0x38>
    prop = prop & (~LV_STYLE_STATE_MASK);
   15ce6:	f424 44fe 	bic.w	r4, r4, #32512	; 0x7f00
    switch(prop) {
   15cea:	2c6d      	cmp	r4, #109	; 0x6d
    prop = prop & (~LV_STYLE_STATE_MASK);
   15cec:	b2a0      	uxth	r0, r4
    switch(prop) {
   15cee:	d04f      	beq.n	15d90 <_lv_obj_get_style_opa+0xc6>
   15cf0:	f248 03ad 	movw	r3, #32941	; 0x80ad
   15cf4:	4298      	cmp	r0, r3
   15cf6:	d04b      	beq.n	15d90 <_lv_obj_get_style_opa+0xc6>
   15cf8:	282c      	cmp	r0, #44	; 0x2c
   15cfa:	bf14      	ite	ne
   15cfc:	20ff      	movne	r0, #255	; 0xff
   15cfe:	2000      	moveq	r0, #0
   15d00:	e036      	b.n	15d70 <_lv_obj_get_style_opa+0xa6>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   15d02:	4639      	mov	r1, r7
   15d04:	4628      	mov	r0, r5
   15d06:	f7ff fef1 	bl	15aec <lv_obj_get_style_list>
        if(!list->ignore_cache && list->style_cnt > 0) {
   15d0a:	7943      	ldrb	r3, [r0, #5]
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
   15d0c:	4606      	mov	r6, r0
        if(!list->ignore_cache && list->style_cnt > 0) {
   15d0e:	0718      	lsls	r0, r3, #28
   15d10:	d41d      	bmi.n	15d4e <_lv_obj_get_style_opa+0x84>
   15d12:	7932      	ldrb	r2, [r6, #4]
   15d14:	0691      	lsls	r1, r2, #26
   15d16:	d01a      	beq.n	15d4e <_lv_obj_get_style_opa+0x84>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
   15d18:	f013 0f04 	tst.w	r3, #4
   15d1c:	f424 42fe 	bic.w	r2, r4, #32512	; 0x7f00
   15d20:	d105      	bne.n	15d2e <_lv_obj_get_style_opa+0x64>
   15d22:	4639      	mov	r1, r7
   15d24:	4628      	mov	r0, r5
   15d26:	9201      	str	r2, [sp, #4]
   15d28:	f7f3 fe6a 	bl	9a00 <update_style_cache>
   15d2c:	9a01      	ldr	r2, [sp, #4]
            switch(prop & (~LV_STYLE_STATE_MASK)) {
   15d2e:	4552      	cmp	r2, sl
   15d30:	d009      	beq.n	15d46 <_lv_obj_get_style_opa+0x7c>
   15d32:	455a      	cmp	r2, fp
   15d34:	d01f      	beq.n	15d76 <_lv_obj_get_style_opa+0xac>
   15d36:	2a2c      	cmp	r2, #44	; 0x2c
   15d38:	d109      	bne.n	15d4e <_lv_obj_get_style_opa+0x84>
                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/
   15d3a:	79b3      	ldrb	r3, [r6, #6]
   15d3c:	06da      	lsls	r2, r3, #27
   15d3e:	d425      	bmi.n	15d8c <_lv_obj_get_style_opa+0xc2>
                    if(list->bg_opa_transp) def = true;
   15d40:	f013 0f08 	tst.w	r3, #8
   15d44:	e002      	b.n	15d4c <_lv_obj_get_style_opa+0x82>
                    if(list->opa_scale_cover) def = true;
   15d46:	7973      	ldrb	r3, [r6, #5]
   15d48:	f013 0f20 	tst.w	r3, #32
                    if(list->img_recolor_opa_transp) def = true;
   15d4c:	d1cb      	bne.n	15ce6 <_lv_obj_get_style_opa+0x1c>
        lv_state_t state = lv_obj_get_state(parent, part);
   15d4e:	4639      	mov	r1, r7
   15d50:	4628      	mov	r0, r5
   15d52:	f7ff ff59 	bl	15c08 <lv_obj_get_state>
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
   15d56:	eb08 2400 	add.w	r4, r8, r0, lsl #8
   15d5a:	b2a4      	uxth	r4, r4
        res = _lv_style_list_get_opa(list, prop, &value_act);
   15d5c:	4621      	mov	r1, r4
   15d5e:	4630      	mov	r0, r6
   15d60:	f10d 020f 	add.w	r2, sp, #15
   15d64:	f001 fb97 	bl	17496 <_lv_style_list_get_opa>
        if(res == LV_RES_OK) return value_act;
   15d68:	2801      	cmp	r0, #1
   15d6a:	d108      	bne.n	15d7e <_lv_obj_get_style_opa+0xb4>
   15d6c:	f89d 000f 	ldrb.w	r0, [sp, #15]
}
   15d70:	b005      	add	sp, #20
   15d72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    if(list->img_recolor_opa_transp) def = true;
   15d76:	79f3      	ldrb	r3, [r6, #7]
   15d78:	f013 0f10 	tst.w	r3, #16
   15d7c:	e7e6      	b.n	15d4c <_lv_obj_get_style_opa+0x82>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
   15d7e:	f019 0f80 	tst.w	r9, #128	; 0x80
   15d82:	d0b0      	beq.n	15ce6 <_lv_obj_get_style_opa+0x1c>
        if(part != LV_OBJ_PART_MAIN) {
   15d84:	b907      	cbnz	r7, 15d88 <_lv_obj_get_style_opa+0xbe>
    return obj->parent;
   15d86:	682d      	ldr	r5, [r5, #0]
{
   15d88:	2700      	movs	r7, #0
   15d8a:	e7ab      	b.n	15ce4 <_lv_obj_get_style_opa+0x1a>
                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/
   15d8c:	20ff      	movs	r0, #255	; 0xff
   15d8e:	e7ef      	b.n	15d70 <_lv_obj_get_style_opa+0xa6>
            return LV_OPA_TRANSP;
   15d90:	2000      	movs	r0, #0
   15d92:	e7ed      	b.n	15d70 <_lv_obj_get_style_opa+0xa6>

00015d94 <trans_anim_start_cb>:
{
   15d94:	b538      	push	{r3, r4, r5, lr}
    lv_style_trans_t * tr = a->var;
   15d96:	6804      	ldr	r4, [r0, #0]
    lv_style_property_t prop_tmp = tr->prop;
   15d98:	88a5      	ldrh	r5, [r4, #4]
    if((prop_tmp & 0xF) < LV_STYLE_ID_COLOR) { /*Int*/
   15d9a:	6820      	ldr	r0, [r4, #0]
   15d9c:	f005 030f 	and.w	r3, r5, #15
   15da0:	2b08      	cmp	r3, #8
        tr->start_value._int = _lv_obj_get_style_int(tr->obj, tr->part, prop_tmp);
   15da2:	462a      	mov	r2, r5
   15da4:	79a1      	ldrb	r1, [r4, #6]
    if((prop_tmp & 0xF) < LV_STYLE_ID_COLOR) { /*Int*/
   15da6:	d80c      	bhi.n	15dc2 <trans_anim_start_cb+0x2e>
        tr->start_value._int = _lv_obj_get_style_int(tr->obj, tr->part, prop_tmp);
   15da8:	f7f3 fd2e 	bl	9808 <_lv_obj_get_style_int>
   15dac:	8120      	strh	r0, [r4, #8]
    tr->prop = 0;
   15dae:	2300      	movs	r3, #0
    trans_del(tr->obj, tr->part, prop_tmp, tr);
   15db0:	462a      	mov	r2, r5
    tr->prop = 0;
   15db2:	80a3      	strh	r3, [r4, #4]
    trans_del(tr->obj, tr->part, prop_tmp, tr);
   15db4:	79a1      	ldrb	r1, [r4, #6]
   15db6:	4623      	mov	r3, r4
   15db8:	6820      	ldr	r0, [r4, #0]
   15dba:	f7f3 fc65 	bl	9688 <trans_del>
    tr->prop = prop_tmp;
   15dbe:	80a5      	strh	r5, [r4, #4]
}
   15dc0:	bd38      	pop	{r3, r4, r5, pc}
    else if((prop_tmp & 0xF) < LV_STYLE_ID_OPA) { /*Color*/
   15dc2:	2b0b      	cmp	r3, #11
   15dc4:	d803      	bhi.n	15dce <trans_anim_start_cb+0x3a>
        tr->start_value._color = _lv_obj_get_style_color(tr->obj, tr->part, prop_tmp);
   15dc6:	f7ff ff33 	bl	15c30 <_lv_obj_get_style_color>
        tr->start_value._ptr = _lv_obj_get_style_ptr(tr->obj, tr->part, prop_tmp);
   15dca:	60a0      	str	r0, [r4, #8]
   15dcc:	e7ef      	b.n	15dae <trans_anim_start_cb+0x1a>
    else if((prop_tmp & 0xF) < LV_STYLE_ID_PTR) { /*Opa*/
   15dce:	2b0d      	cmp	r3, #13
   15dd0:	d803      	bhi.n	15dda <trans_anim_start_cb+0x46>
        tr->start_value._opa = _lv_obj_get_style_opa(tr->obj, tr->part, prop_tmp);
   15dd2:	f7ff ff7a 	bl	15cca <_lv_obj_get_style_opa>
   15dd6:	7220      	strb	r0, [r4, #8]
   15dd8:	e7e9      	b.n	15dae <trans_anim_start_cb+0x1a>
        tr->start_value._ptr = _lv_obj_get_style_ptr(tr->obj, tr->part, prop_tmp);
   15dda:	f7f3 ff6b 	bl	9cb4 <_lv_obj_get_style_ptr>
   15dde:	e7f4      	b.n	15dca <trans_anim_start_cb+0x36>

00015de0 <update_style_cache_children>:
{
   15de0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   15de4:	4605      	mov	r5, r0
   15de6:	2700      	movs	r7, #0
   15de8:	b2fe      	uxtb	r6, r7
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   15dea:	4631      	mov	r1, r6
   15dec:	4628      	mov	r0, r5
   15dee:	f7ff fe7d 	bl	15aec <lv_obj_get_style_list>
        if(list == NULL) break;
   15df2:	4604      	mov	r4, r0
   15df4:	2800      	cmp	r0, #0
   15df6:	d055      	beq.n	15ea4 <update_style_cache_children+0xc4>
        bool ignore_cache_ori = list->ignore_cache;
   15df8:	7943      	ldrb	r3, [r0, #5]
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
   15dfa:	f248 020c 	movw	r2, #32780	; 0x800c
   15dfe:	f3c3 08c0 	ubfx	r8, r3, #3, #1
        list->ignore_cache = 1;
   15e02:	f043 0308 	orr.w	r3, r3, #8
   15e06:	7143      	strb	r3, [r0, #5]
   15e08:	4631      	mov	r1, r6
   15e0a:	4628      	mov	r0, r5
   15e0c:	f7ff ff5d 	bl	15cca <_lv_obj_get_style_opa>
        list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;
   15e10:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
   15e14:	4258      	negs	r0, r3
   15e16:	4158      	adcs	r0, r3
   15e18:	7963      	ldrb	r3, [r4, #5]
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
   15e1a:	f248 0282 	movw	r2, #32898	; 0x8082
   15e1e:	f360 1345 	bfi	r3, r0, #5, #1
   15e22:	4631      	mov	r1, r6
   15e24:	7163      	strb	r3, [r4, #5]
   15e26:	4628      	mov	r0, r5
   15e28:	f7f3 fcee 	bl	9808 <_lv_obj_get_style_int>
        list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;
   15e2c:	b2c0      	uxtb	r0, r0
   15e2e:	fab0 f080 	clz	r0, r0
   15e32:	79e3      	ldrb	r3, [r4, #7]
   15e34:	0940      	lsrs	r0, r0, #5
   15e36:	f360 1386 	bfi	r3, r0, #6, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   15e3a:	f248 028e 	movw	r2, #32910	; 0x808e
   15e3e:	4631      	mov	r1, r6
   15e40:	71e3      	strb	r3, [r4, #7]
   15e42:	4628      	mov	r0, r5
   15e44:	f7f3 ff36 	bl	9cb4 <_lv_obj_get_style_ptr>
   15e48:	4681      	mov	r9, r0
        list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == lv_theme_get_font_normal() ? 1 : 0;
   15e4a:	f7f7 fb15 	bl	d478 <lv_theme_get_font_normal>
   15e4e:	eba9 0200 	sub.w	r2, r9, r0
   15e52:	f1d2 0900 	rsbs	r9, r2, #0
   15e56:	79e3      	ldrb	r3, [r4, #7]
   15e58:	eb49 0902 	adc.w	r9, r9, r2
   15e5c:	f369 13c7 	bfi	r3, r9, #7, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
   15e60:	f248 02ad 	movw	r2, #32941	; 0x80ad
   15e64:	4631      	mov	r1, r6
   15e66:	71e3      	strb	r3, [r4, #7]
   15e68:	4628      	mov	r0, r5
   15e6a:	f7ff ff2e 	bl	15cca <_lv_obj_get_style_opa>
        list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;
   15e6e:	2800      	cmp	r0, #0
   15e70:	bf0c      	ite	eq
   15e72:	2030      	moveq	r0, #48	; 0x30
   15e74:	2020      	movne	r0, #32
   15e76:	79e3      	ldrb	r3, [r4, #7]
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   15e78:	f248 0280 	movw	r2, #32896	; 0x8080
   15e7c:	f023 0330 	bic.w	r3, r3, #48	; 0x30
   15e80:	4318      	orrs	r0, r3
   15e82:	71e0      	strb	r0, [r4, #7]
   15e84:	4631      	mov	r1, r6
   15e86:	4628      	mov	r0, r5
   15e88:	f7f3 fcbe 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
   15e8c:	b188      	cbz	r0, 15eb2 <update_style_cache_children+0xd2>
            list->text_space_zero = 0;
   15e8e:	79e3      	ldrb	r3, [r4, #7]
   15e90:	f36f 1345 	bfc	r3, #5, #1
   15e94:	71e3      	strb	r3, [r4, #7]
        list->ignore_cache = ignore_cache_ori;
   15e96:	7963      	ldrb	r3, [r4, #5]
   15e98:	3701      	adds	r7, #1
   15e9a:	f368 03c3 	bfi	r3, r8, #3, #1
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
   15e9e:	2f40      	cmp	r7, #64	; 0x40
        list->ignore_cache = ignore_cache_ori;
   15ea0:	7163      	strb	r3, [r4, #5]
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
   15ea2:	d1a1      	bne.n	15de8 <update_style_cache_children+0x8>
        result = _lv_ll_get_head(&obj->child_ll);
   15ea4:	1d28      	adds	r0, r5, #4
   15ea6:	f005 f9b0 	bl	1b20a <_lv_ll_get_head>
        child = lv_obj_get_child(obj, child);
   15eaa:	4604      	mov	r4, r0
    while(child) {
   15eac:	b950      	cbnz	r0, 15ec4 <update_style_cache_children+0xe4>
}
   15eae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   15eb2:	f248 0281 	movw	r2, #32897	; 0x8081
   15eb6:	4631      	mov	r1, r6
   15eb8:	4628      	mov	r0, r5
   15eba:	f7f3 fca5 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
   15ebe:	2800      	cmp	r0, #0
   15ec0:	d1e5      	bne.n	15e8e <update_style_cache_children+0xae>
   15ec2:	e7e8      	b.n	15e96 <update_style_cache_children+0xb6>
        update_style_cache_children(child);
   15ec4:	4620      	mov	r0, r4
   15ec6:	f7ff ff8b 	bl	15de0 <update_style_cache_children>
        child = lv_obj_get_child(obj, child);
   15eca:	4621      	mov	r1, r4
   15ecc:	4628      	mov	r0, r5
   15ece:	f7ff fdb3 	bl	15a38 <lv_obj_get_child>
   15ed2:	e7ea      	b.n	15eaa <update_style_cache_children+0xca>

00015ed4 <invalidate_style_cache>:
{
   15ed4:	b538      	push	{r3, r4, r5, lr}
   15ed6:	4605      	mov	r5, r0
    if(style_prop_is_cacheble(prop) == false) return;
   15ed8:	4610      	mov	r0, r2
   15eda:	f7f3 f943 	bl	9164 <style_prop_is_cacheble>
   15ede:	b170      	cbz	r0, 15efe <invalidate_style_cache+0x2a>
    if(part != LV_OBJ_PART_ALL) {
   15ee0:	29ff      	cmp	r1, #255	; 0xff
   15ee2:	d00d      	beq.n	15f00 <invalidate_style_cache+0x2c>
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   15ee4:	4628      	mov	r0, r5
   15ee6:	f7ff fe01 	bl	15aec <lv_obj_get_style_list>
        if(list == NULL) return;
   15eea:	b140      	cbz	r0, 15efe <invalidate_style_cache+0x2a>
        list->valid_cache = 0;
   15eec:	7943      	ldrb	r3, [r0, #5]
   15eee:	f36f 0382 	bfc	r3, #2, #1
   15ef2:	7143      	strb	r3, [r0, #5]
        result = _lv_ll_get_head(&obj->child_ll);
   15ef4:	1d28      	adds	r0, r5, #4
   15ef6:	f005 f988 	bl	1b20a <_lv_ll_get_head>
        child = lv_obj_get_child(obj, child);
   15efa:	4604      	mov	r4, r0
    while(child) {
   15efc:	b9e8      	cbnz	r0, 15f3a <invalidate_style_cache+0x66>
}
   15efe:	bd38      	pop	{r3, r4, r5, pc}
   15f00:	2400      	movs	r4, #0
            lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   15f02:	4628      	mov	r0, r5
   15f04:	b2e1      	uxtb	r1, r4
   15f06:	f7ff fdf1 	bl	15aec <lv_obj_get_style_list>
            if(list == NULL) break;
   15f0a:	b130      	cbz	r0, 15f1a <invalidate_style_cache+0x46>
            list->valid_cache = 0;
   15f0c:	7943      	ldrb	r3, [r0, #5]
   15f0e:	3401      	adds	r4, #1
   15f10:	f36f 0382 	bfc	r3, #2, #1
        for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
   15f14:	2c40      	cmp	r4, #64	; 0x40
            list->valid_cache = 0;
   15f16:	7143      	strb	r3, [r0, #5]
        for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
   15f18:	d1f3      	bne.n	15f02 <invalidate_style_cache+0x2e>
   15f1a:	2440      	movs	r4, #64	; 0x40
            lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   15f1c:	4621      	mov	r1, r4
   15f1e:	4628      	mov	r0, r5
   15f20:	f7ff fde4 	bl	15aec <lv_obj_get_style_list>
            if(list == NULL) break;
   15f24:	2800      	cmp	r0, #0
   15f26:	d0e5      	beq.n	15ef4 <invalidate_style_cache+0x20>
            list->valid_cache = 0;
   15f28:	7943      	ldrb	r3, [r0, #5]
        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   15f2a:	3401      	adds	r4, #1
   15f2c:	b2e4      	uxtb	r4, r4
            list->valid_cache = 0;
   15f2e:	f36f 0382 	bfc	r3, #2, #1
        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   15f32:	2cff      	cmp	r4, #255	; 0xff
            list->valid_cache = 0;
   15f34:	7143      	strb	r3, [r0, #5]
        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
   15f36:	d1f1      	bne.n	15f1c <invalidate_style_cache+0x48>
   15f38:	e7dc      	b.n	15ef4 <invalidate_style_cache+0x20>
        update_style_cache_children(child);
   15f3a:	4620      	mov	r0, r4
   15f3c:	f7ff ff50 	bl	15de0 <update_style_cache_children>
        child = lv_obj_get_child(obj, child);
   15f40:	4621      	mov	r1, r4
   15f42:	4628      	mov	r0, r5
   15f44:	f7ff fd78 	bl	15a38 <lv_obj_get_child>
   15f48:	e7d7      	b.n	15efa <invalidate_style_cache+0x26>

00015f4a <lv_obj_add_style>:
{
   15f4a:	b570      	push	{r4, r5, r6, lr}
   15f4c:	4604      	mov	r4, r0
   15f4e:	460d      	mov	r5, r1
    if(style == NULL) return;
   15f50:	4616      	mov	r6, r2
   15f52:	b192      	cbz	r2, 15f7a <lv_obj_add_style+0x30>
    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);
   15f54:	f7ff fdca 	bl	15aec <lv_obj_get_style_list>
    if(style_dsc == NULL) {
   15f58:	b178      	cbz	r0, 15f7a <lv_obj_add_style+0x30>
    _lv_style_list_add_style(style_dsc, style);
   15f5a:	4631      	mov	r1, r6
   15f5c:	f000 ff37 	bl	16dce <_lv_style_list_add_style>
    trans_del(obj, part, 0xFF, NULL);
   15f60:	4629      	mov	r1, r5
   15f62:	4620      	mov	r0, r4
   15f64:	22ff      	movs	r2, #255	; 0xff
   15f66:	2300      	movs	r3, #0
   15f68:	f7f3 fb8e 	bl	9688 <trans_del>
    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
   15f6c:	4629      	mov	r1, r5
   15f6e:	4620      	mov	r0, r4
}
   15f70:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
   15f74:	22ff      	movs	r2, #255	; 0xff
   15f76:	f7f3 beff 	b.w	9d78 <lv_obj_refresh_style>
}
   15f7a:	bd70      	pop	{r4, r5, r6, pc}

00015f7c <lv_obj_reset_style_list>:
{
   15f7c:	b538      	push	{r3, r4, r5, lr}
   15f7e:	4604      	mov	r4, r0
   15f80:	460d      	mov	r5, r1
    lv_obj_clean_style_list(obj, part);
   15f82:	f7ff fde5 	bl	15b50 <lv_obj_clean_style_list>
    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
   15f86:	4629      	mov	r1, r5
   15f88:	4620      	mov	r0, r4
}
   15f8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
   15f8e:	22ff      	movs	r2, #255	; 0xff
   15f90:	f7f3 bef2 	b.w	9d78 <lv_obj_refresh_style>

00015f94 <report_style_mod_core>:
{
   15f94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15f96:	4606      	mov	r6, r0
   15f98:	460d      	mov	r5, r1
   15f9a:	2400      	movs	r4, #0
   15f9c:	b2e7      	uxtb	r7, r4
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   15f9e:	4639      	mov	r1, r7
   15fa0:	4628      	mov	r0, r5
   15fa2:	f7ff fda3 	bl	15aec <lv_obj_get_style_list>
        if(list == NULL) break;
   15fa6:	b328      	cbz	r0, 15ff4 <report_style_mod_core+0x60>
        for(ci = 0; ci < list->style_cnt; ci++) {
   15fa8:	7902      	ldrb	r2, [r0, #4]
   15faa:	f04f 0c00 	mov.w	ip, #0
   15fae:	f002 0e3f 	and.w	lr, r2, #63	; 0x3f
void _lv_style_list_reset(lv_style_list_t * style_list);

static inline lv_style_t * lv_style_list_get_style(lv_style_list_t * list, uint8_t id)
{
    if(list->has_trans && list->skip_trans) id++;
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
   15fb2:	4672      	mov	r2, lr
   15fb4:	fa5f f38c 	uxtb.w	r3, ip
   15fb8:	459e      	cmp	lr, r3
   15fba:	d918      	bls.n	15fee <report_style_mod_core+0x5a>
    if(list->has_trans && list->skip_trans) id++;
   15fbc:	8881      	ldrh	r1, [r0, #4]
   15fbe:	f401 71c0 	and.w	r1, r1, #384	; 0x180
   15fc2:	f5b1 7fc0 	cmp.w	r1, #384	; 0x180
   15fc6:	bf04      	itt	eq
   15fc8:	3301      	addeq	r3, #1
   15fca:	b2db      	uxtbeq	r3, r3
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
   15fcc:	b1c2      	cbz	r2, 16000 <report_style_mod_core+0x6c>
   15fce:	459e      	cmp	lr, r3
   15fd0:	d916      	bls.n	16000 <report_style_mod_core+0x6c>
    return list->style_list[id];
   15fd2:	6801      	ldr	r1, [r0, #0]
   15fd4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            if(class == style || style == NULL) {
   15fd8:	429e      	cmp	r6, r3
   15fda:	d003      	beq.n	15fe4 <report_style_mod_core+0x50>
   15fdc:	f10c 0c01 	add.w	ip, ip, #1
   15fe0:	2e00      	cmp	r6, #0
   15fe2:	d1e7      	bne.n	15fb4 <report_style_mod_core+0x20>
                lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
   15fe4:	22ff      	movs	r2, #255	; 0xff
   15fe6:	4639      	mov	r1, r7
   15fe8:	4628      	mov	r0, r5
   15fea:	f7f3 fec5 	bl	9d78 <lv_obj_refresh_style>
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
   15fee:	3401      	adds	r4, #1
   15ff0:	2c40      	cmp	r4, #64	; 0x40
   15ff2:	d1d3      	bne.n	15f9c <report_style_mod_core+0x8>
        result = _lv_ll_get_head(&obj->child_ll);
   15ff4:	1d28      	adds	r0, r5, #4
   15ff6:	f005 f908 	bl	1b20a <_lv_ll_get_head>
        child = lv_obj_get_child(obj, child);
   15ffa:	4604      	mov	r4, r0
    while(child) {
   15ffc:	b910      	cbnz	r0, 16004 <report_style_mod_core+0x70>
}
   15ffe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
   16000:	2300      	movs	r3, #0
   16002:	e7e9      	b.n	15fd8 <report_style_mod_core+0x44>
        report_style_mod_core(style, child);
   16004:	4621      	mov	r1, r4
   16006:	4630      	mov	r0, r6
   16008:	f7ff ffc4 	bl	15f94 <report_style_mod_core>
        child = lv_obj_get_child(obj, child);
   1600c:	4621      	mov	r1, r4
   1600e:	4628      	mov	r0, r5
   16010:	f7ff fd12 	bl	15a38 <lv_obj_get_child>
   16014:	e7f1      	b.n	15ffa <report_style_mod_core+0x66>

00016016 <lv_obj_report_style_mod>:
{
   16016:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16018:	4606      	mov	r6, r0
    lv_disp_t * d = lv_disp_get_next(NULL);
   1601a:	2000      	movs	r0, #0
        d = lv_disp_get_next(d);
   1601c:	f7f6 fafc 	bl	c618 <lv_disp_get_next>
   16020:	4604      	mov	r4, r0
    while(d) {
   16022:	b900      	cbnz	r0, 16026 <lv_obj_report_style_mod+0x10>
}
   16024:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        _LV_LL_READ(d->scr_ll, i) {
   16026:	f104 0734 	add.w	r7, r4, #52	; 0x34
   1602a:	4638      	mov	r0, r7
   1602c:	f005 f8ed 	bl	1b20a <_lv_ll_get_head>
   16030:	4605      	mov	r5, r0
   16032:	b908      	cbnz	r0, 16038 <lv_obj_report_style_mod+0x22>
        d = lv_disp_get_next(d);
   16034:	4620      	mov	r0, r4
   16036:	e7f1      	b.n	1601c <lv_obj_report_style_mod+0x6>
            report_style_mod_core(style, i);
   16038:	4629      	mov	r1, r5
   1603a:	4630      	mov	r0, r6
   1603c:	f7ff ffaa 	bl	15f94 <report_style_mod_core>
        _LV_LL_READ(d->scr_ll, i) {
   16040:	4629      	mov	r1, r5
   16042:	4638      	mov	r0, r7
   16044:	f005 f8e7 	bl	1b216 <_lv_ll_get_next>
   16048:	e7f2      	b.n	16030 <lv_obj_report_style_mod+0x1a>

0001604a <trans_anim_cb>:
{
   1604a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1604c:	4604      	mov	r4, r0
   1604e:	460d      	mov	r5, r1
    lv_style_list_t * list = lv_obj_get_style_list(tr->obj, tr->part);
   16050:	7981      	ldrb	r1, [r0, #6]
   16052:	6800      	ldr	r0, [r0, #0]
   16054:	f7ff fd4a 	bl	15aec <lv_obj_get_style_list>
    lv_style_t * style = _lv_style_list_get_transition_style(list);
   16058:	f001 f8d7 	bl	1720a <_lv_style_list_get_transition_style>
    if((tr->prop & 0xF) < LV_STYLE_ID_COLOR) { /*Value*/
   1605c:	88a1      	ldrh	r1, [r4, #4]
   1605e:	f001 030f 	and.w	r3, r1, #15
   16062:	2b08      	cmp	r3, #8
   16064:	d817      	bhi.n	16096 <trans_anim_cb+0x4c>
        if(v == 0) x = tr->start_value._int;
   16066:	b955      	cbnz	r5, 1607e <trans_anim_cb+0x34>
   16068:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
        _lv_style_set_int(style, tr->prop, x);
   1606c:	f000 ff52 	bl	16f14 <_lv_style_set_int>
    lv_obj_refresh_style(tr->obj, tr->part, tr->prop);
   16070:	88a2      	ldrh	r2, [r4, #4]
   16072:	79a1      	ldrb	r1, [r4, #6]
   16074:	6820      	ldr	r0, [r4, #0]
}
   16076:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    lv_obj_refresh_style(tr->obj, tr->part, tr->prop);
   1607a:	f7f3 be7d 	b.w	9d78 <lv_obj_refresh_style>
        else if(v == 255) x = tr->end_value._int;
   1607e:	2dff      	cmp	r5, #255	; 0xff
   16080:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   16084:	d0f2      	beq.n	1606c <trans_anim_cb+0x22>
        else x = tr->start_value._int + ((int32_t)((int32_t)(tr->end_value._int - tr->start_value._int) * v) >> 8);
   16086:	f9b4 3008 	ldrsh.w	r3, [r4, #8]
   1608a:	1ad2      	subs	r2, r2, r3
   1608c:	4355      	muls	r5, r2
   1608e:	eb03 2525 	add.w	r5, r3, r5, asr #8
   16092:	b22a      	sxth	r2, r5
   16094:	e7ea      	b.n	1606c <trans_anim_cb+0x22>
    else if((tr->prop & 0xF) < LV_STYLE_ID_OPA) { /*Color*/
   16096:	2b0b      	cmp	r3, #11
   16098:	d833      	bhi.n	16102 <trans_anim_cb+0xb8>
        if(v <= 0) x = tr->start_value._color;
   1609a:	2d00      	cmp	r5, #0
   1609c:	dc03      	bgt.n	160a6 <trans_anim_cb+0x5c>
   1609e:	68a2      	ldr	r2, [r4, #8]
        _lv_style_set_color(style, tr->prop, x);
   160a0:	f000 ff7c 	bl	16f9c <_lv_style_set_color>
   160a4:	e7e4      	b.n	16070 <trans_anim_cb+0x26>
        else if(v >= 255) x = tr->end_value._color;
   160a6:	2dfe      	cmp	r5, #254	; 0xfe
   160a8:	dd01      	ble.n	160ae <trans_anim_cb+0x64>
   160aa:	68e2      	ldr	r2, [r4, #12]
   160ac:	e7f8      	b.n	160a0 <trans_anim_cb+0x56>
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   160ae:	7aa6      	ldrb	r6, [r4, #10]
   160b0:	f1c5 02ff 	rsb	r2, r5, #255	; 0xff
   160b4:	4356      	muls	r6, r2
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   160b6:	f894 c009 	ldrb.w	ip, [r4, #9]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   160ba:	7ba3      	ldrb	r3, [r4, #14]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   160bc:	fb02 fc0c 	mul.w	ip, r2, ip
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   160c0:	f894 e008 	ldrb.w	lr, [r4, #8]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   160c4:	f248 0781 	movw	r7, #32897	; 0x8081
   160c8:	fb15 6303 	smlabb	r3, r5, r3, r6
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   160cc:	fb02 f20e 	mul.w	r2, r2, lr
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   160d0:	7b66      	ldrb	r6, [r4, #13]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   160d2:	437b      	muls	r3, r7
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   160d4:	fb15 c606 	smlabb	r6, r5, r6, ip
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   160d8:	f894 c00c 	ldrb.w	ip, [r4, #12]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   160dc:	437e      	muls	r6, r7
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   160de:	fb15 250c 	smlabb	r5, r5, ip, r2
   160e2:	2200      	movs	r2, #0
   160e4:	437d      	muls	r5, r7
   160e6:	0ded      	lsrs	r5, r5, #23
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   160e8:	f3c6 56c7 	ubfx	r6, r6, #23, #8
   160ec:	f365 0207 	bfi	r2, r5, #0, #8
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   160f0:	f3c3 53c7 	ubfx	r3, r3, #23, #8
    return ret;
   160f4:	f366 220f 	bfi	r2, r6, #8, #8
   160f8:	f363 4217 	bfi	r2, r3, #16, #8
   160fc:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
   16100:	e7ce      	b.n	160a0 <trans_anim_cb+0x56>
    else if((tr->prop & 0xF) < LV_STYLE_ID_PTR) { /*Opa*/
   16102:	2b0d      	cmp	r3, #13
   16104:	d80f      	bhi.n	16126 <trans_anim_cb+0xdc>
        if(v <= 0) x = tr->start_value._opa;
   16106:	2d00      	cmp	r5, #0
   16108:	dc03      	bgt.n	16112 <trans_anim_cb+0xc8>
   1610a:	7a22      	ldrb	r2, [r4, #8]
        _lv_style_set_opa(style, tr->prop, x);
   1610c:	f000 ff8a 	bl	17024 <_lv_style_set_opa>
   16110:	e7ae      	b.n	16070 <trans_anim_cb+0x26>
        else if(v >= 255) x = tr->end_value._opa;
   16112:	2dfe      	cmp	r5, #254	; 0xfe
   16114:	7b22      	ldrb	r2, [r4, #12]
   16116:	dcf9      	bgt.n	1610c <trans_anim_cb+0xc2>
        else x = tr->start_value._opa + (((tr->end_value._opa - tr->start_value._opa) * v) >> 8);
   16118:	7a23      	ldrb	r3, [r4, #8]
   1611a:	1ad2      	subs	r2, r2, r3
   1611c:	4355      	muls	r5, r2
   1611e:	eb03 2525 	add.w	r5, r3, r5, asr #8
   16122:	b2ea      	uxtb	r2, r5
   16124:	e7f2      	b.n	1610c <trans_anim_cb+0xc2>
        if(v < 128) x = tr->start_value._ptr;
   16126:	2d7f      	cmp	r5, #127	; 0x7f
   16128:	bfd4      	ite	le
   1612a:	68a2      	ldrle	r2, [r4, #8]
        else x = tr->end_value._ptr;
   1612c:	68e2      	ldrgt	r2, [r4, #12]
        _lv_style_set_ptr(style, tr->prop, x);
   1612e:	f000 ffbf 	bl	170b0 <_lv_style_set_ptr>
   16132:	e79d      	b.n	16070 <trans_anim_cb+0x26>

00016134 <lv_obj_get_signal_cb>:
}
   16134:	69c0      	ldr	r0, [r0, #28]
   16136:	4770      	bx	lr

00016138 <lv_obj_get_design_cb>:
}
   16138:	6a00      	ldr	r0, [r0, #32]
   1613a:	4770      	bx	lr

0001613c <lv_obj_get_ext_attr>:
}
   1613c:	6a40      	ldr	r0, [r0, #36]	; 0x24
   1613e:	4770      	bx	lr

00016140 <lv_obj_is_point_on_coords>:
    if(!_lv_area_is_point_on(&obj->coords, point, 0)) {
   16140:	2200      	movs	r2, #0
   16142:	3010      	adds	r0, #16
   16144:	f004 bdf7 	b.w	1ad36 <_lv_area_is_point_on>

00016148 <lv_obj_hittest>:
{
   16148:	b513      	push	{r0, r1, r4, lr}
    if(obj->adv_hittest) {
   1614a:	f990 4032 	ldrsb.w	r4, [r0, #50]	; 0x32
   1614e:	2c00      	cmp	r4, #0
   16150:	da0b      	bge.n	1616a <lv_obj_hittest+0x22>
        hit_info.result = true;
   16152:	2201      	movs	r2, #1
        hit_info.point = point;
   16154:	9100      	str	r1, [sp, #0]
        hit_info.result = true;
   16156:	f88d 2004 	strb.w	r2, [sp, #4]
        obj->signal_cb(obj, LV_SIGNAL_HIT_TEST, &hit_info);
   1615a:	210a      	movs	r1, #10
   1615c:	466a      	mov	r2, sp
   1615e:	69c3      	ldr	r3, [r0, #28]
   16160:	4798      	blx	r3
        return hit_info.result;
   16162:	f89d 0004 	ldrb.w	r0, [sp, #4]
}
   16166:	b002      	add	sp, #8
   16168:	bd10      	pop	{r4, pc}
        return lv_obj_is_point_on_coords(obj, point);
   1616a:	f7ff ffe9 	bl	16140 <lv_obj_is_point_on_coords>
   1616e:	e7fa      	b.n	16166 <lv_obj_hittest+0x1e>

00016170 <lv_obj_handle_get_type_signal>:
{
   16170:	2300      	movs	r3, #0
   16172:	b510      	push	{r4, lr}
        if(buf->type[i] == NULL) break;
   16174:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   16178:	b2da      	uxtb	r2, r3
   1617a:	b11c      	cbz	r4, 16184 <lv_obj_handle_get_type_signal+0x14>
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
   1617c:	3301      	adds	r3, #1
   1617e:	2b07      	cmp	r3, #7
   16180:	d1f8      	bne.n	16174 <lv_obj_handle_get_type_signal+0x4>
   16182:	461a      	mov	r2, r3
    buf->type[i] = name;
   16184:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
}
   16188:	2001      	movs	r0, #1
   1618a:	bd10      	pop	{r4, pc}

0001618c <lv_obj_init_draw_rect_dsc>:
{
   1618c:	b570      	push	{r4, r5, r6, lr}
   1618e:	4614      	mov	r4, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   16190:	2201      	movs	r2, #1
   16192:	4605      	mov	r5, r0
   16194:	460e      	mov	r6, r1
   16196:	f7f3 fb37 	bl	9808 <_lv_obj_get_style_int>
    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {
   1619a:	7ca3      	ldrb	r3, [r4, #18]
    draw_dsc->radius = lv_obj_get_style_radius(obj, part);
   1619c:	8020      	strh	r0, [r4, #0]
    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {
   1619e:	b33b      	cbz	r3, 161f0 <lv_obj_init_draw_rect_dsc+0x64>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
   161a0:	222c      	movs	r2, #44	; 0x2c
   161a2:	4631      	mov	r1, r6
   161a4:	4628      	mov	r0, r5
   161a6:	f7ff fd90 	bl	15cca <_lv_obj_get_style_opa>
        if(draw_dsc->bg_opa > LV_OPA_MIN) {
   161aa:	2802      	cmp	r0, #2
        draw_dsc->bg_opa = lv_obj_get_style_bg_opa(obj, part);
   161ac:	74a0      	strb	r0, [r4, #18]
        if(draw_dsc->bg_opa > LV_OPA_MIN) {
   161ae:	d91f      	bls.n	161f0 <lv_obj_init_draw_rect_dsc+0x64>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
   161b0:	2229      	movs	r2, #41	; 0x29
   161b2:	4631      	mov	r1, r6
   161b4:	4628      	mov	r0, r5
   161b6:	f7ff fd3b 	bl	15c30 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
   161ba:	2223      	movs	r2, #35	; 0x23
            draw_dsc->bg_color = lv_obj_get_style_bg_color(obj, part);
   161bc:	6060      	str	r0, [r4, #4]
   161be:	4631      	mov	r1, r6
   161c0:	4628      	mov	r0, r5
   161c2:	f7f3 fb21 	bl	9808 <_lv_obj_get_style_int>
   161c6:	b2c0      	uxtb	r0, r0
            draw_dsc->bg_grad_dir =  lv_obj_get_style_bg_grad_dir(obj, part);
   161c8:	7320      	strb	r0, [r4, #12]
            if(draw_dsc->bg_grad_dir != LV_GRAD_DIR_NONE) {
   161ca:	b188      	cbz	r0, 161f0 <lv_obj_init_draw_rect_dsc+0x64>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
   161cc:	222a      	movs	r2, #42	; 0x2a
   161ce:	4631      	mov	r1, r6
   161d0:	4628      	mov	r0, r5
   161d2:	f7ff fd2d 	bl	15c30 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_MAIN_STOP, bg_main_stop, lv_style_int_t, _int, scalar)
   161d6:	2221      	movs	r2, #33	; 0x21
   161d8:	4631      	mov	r1, r6
                draw_dsc->bg_grad_color = lv_obj_get_style_bg_grad_color(obj, part);
   161da:	60a0      	str	r0, [r4, #8]
   161dc:	4628      	mov	r0, r5
   161de:	f7f3 fb13 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_STOP, bg_grad_stop, lv_style_int_t, _int, scalar)
   161e2:	2222      	movs	r2, #34	; 0x22
                draw_dsc->bg_main_color_stop =  lv_obj_get_style_bg_main_stop(obj, part);
   161e4:	81e0      	strh	r0, [r4, #14]
   161e6:	4631      	mov	r1, r6
   161e8:	4628      	mov	r0, r5
   161ea:	f7f3 fb0d 	bl	9808 <_lv_obj_get_style_int>
                draw_dsc->bg_grad_color_stop =  lv_obj_get_style_bg_grad_stop(obj, part);
   161ee:	8220      	strh	r0, [r4, #16]
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
   161f0:	2230      	movs	r2, #48	; 0x30
   161f2:	4631      	mov	r1, r6
   161f4:	4628      	mov	r0, r5
   161f6:	f7f3 fb07 	bl	9808 <_lv_obj_get_style_int>
    draw_dsc->border_width = lv_obj_get_style_border_width(obj, part);
   161fa:	8320      	strh	r0, [r4, #24]
    if(draw_dsc->border_width) {
   161fc:	b1b0      	cbz	r0, 1622c <lv_obj_init_draw_rect_dsc+0xa0>
        if(draw_dsc->border_opa != LV_OPA_TRANSP) {
   161fe:	7f23      	ldrb	r3, [r4, #28]
   16200:	b1a3      	cbz	r3, 1622c <lv_obj_init_draw_rect_dsc+0xa0>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_OPA, border_opa, lv_opa_t, _opa, scalar)
   16202:	223c      	movs	r2, #60	; 0x3c
   16204:	4631      	mov	r1, r6
   16206:	4628      	mov	r0, r5
   16208:	f7ff fd5f 	bl	15cca <_lv_obj_get_style_opa>
            if(draw_dsc->border_opa > LV_OPA_MIN) {
   1620c:	2802      	cmp	r0, #2
            draw_dsc->border_opa = lv_obj_get_style_border_opa(obj, part);
   1620e:	7720      	strb	r0, [r4, #28]
            if(draw_dsc->border_opa > LV_OPA_MIN) {
   16210:	d90c      	bls.n	1622c <lv_obj_init_draw_rect_dsc+0xa0>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_SIDE, border_side, lv_border_side_t, _int, scalar)
   16212:	2231      	movs	r2, #49	; 0x31
   16214:	4631      	mov	r1, r6
   16216:	4628      	mov	r0, r5
   16218:	f7f3 faf6 	bl	9808 <_lv_obj_get_style_int>
                draw_dsc->border_side = lv_obj_get_style_border_side(obj, part);
   1621c:	b2c0      	uxtb	r0, r0
   1621e:	8360      	strh	r0, [r4, #26]
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
   16220:	2239      	movs	r2, #57	; 0x39
   16222:	4631      	mov	r1, r6
   16224:	4628      	mov	r0, r5
   16226:	f7ff fd03 	bl	15c30 <_lv_obj_get_style_color>
                draw_dsc->border_color = lv_obj_get_style_border_color(obj, part);
   1622a:	6160      	str	r0, [r4, #20]
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
   1622c:	2250      	movs	r2, #80	; 0x50
   1622e:	4631      	mov	r1, r6
   16230:	4628      	mov	r0, r5
   16232:	f7f3 fae9 	bl	9808 <_lv_obj_get_style_int>
    draw_dsc->shadow_width = lv_obj_get_style_shadow_width(obj, part);
   16236:	8620      	strh	r0, [r4, #48]	; 0x30
    if(draw_dsc->shadow_width) {
   16238:	b320      	cbz	r0, 16284 <lv_obj_init_draw_rect_dsc+0xf8>
        if(draw_dsc->shadow_opa > LV_OPA_MIN) {
   1623a:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   1623e:	2b02      	cmp	r3, #2
   16240:	d920      	bls.n	16284 <lv_obj_init_draw_rect_dsc+0xf8>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OPA, shadow_opa, lv_opa_t, _opa, scalar)
   16242:	225c      	movs	r2, #92	; 0x5c
   16244:	4631      	mov	r1, r6
   16246:	4628      	mov	r0, r5
   16248:	f7ff fd3f 	bl	15cca <_lv_obj_get_style_opa>
            if(draw_dsc->shadow_opa > LV_OPA_MIN) {
   1624c:	2802      	cmp	r0, #2
            draw_dsc->shadow_opa = lv_obj_get_style_shadow_opa(obj, part);
   1624e:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
            if(draw_dsc->shadow_opa > LV_OPA_MIN) {
   16252:	d917      	bls.n	16284 <lv_obj_init_draw_rect_dsc+0xf8>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
   16254:	2251      	movs	r2, #81	; 0x51
   16256:	4631      	mov	r1, r6
   16258:	4628      	mov	r0, r5
   1625a:	f7f3 fad5 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
   1625e:	2252      	movs	r2, #82	; 0x52
   16260:	4631      	mov	r1, r6
                draw_dsc->shadow_ofs_x = lv_obj_get_style_shadow_ofs_x(obj, part);
   16262:	8660      	strh	r0, [r4, #50]	; 0x32
   16264:	4628      	mov	r0, r5
   16266:	f7f3 facf 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_SPREAD, shadow_spread, lv_style_int_t, _int, scalar)
   1626a:	2253      	movs	r2, #83	; 0x53
   1626c:	4631      	mov	r1, r6
                draw_dsc->shadow_ofs_y = lv_obj_get_style_shadow_ofs_y(obj, part);
   1626e:	86a0      	strh	r0, [r4, #52]	; 0x34
   16270:	4628      	mov	r0, r5
   16272:	f7f3 fac9 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_COLOR, shadow_color, lv_color_t, _color, nonscalar)
   16276:	2259      	movs	r2, #89	; 0x59
                draw_dsc->shadow_spread = lv_obj_get_style_shadow_spread(obj, part);
   16278:	86e0      	strh	r0, [r4, #54]	; 0x36
   1627a:	4631      	mov	r1, r6
   1627c:	4628      	mov	r0, r5
   1627e:	f7ff fcd7 	bl	15c30 <_lv_obj_get_style_color>
                draw_dsc->shadow_color = lv_obj_get_style_shadow_color(obj, part);
   16282:	62e0      	str	r0, [r4, #44]	; 0x2c
}
   16284:	bd70      	pop	{r4, r5, r6, pc}

00016286 <lv_obj_design>:
{
   16286:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if(mode == LV_DESIGN_COVER_CHK) {
   1628a:	2a02      	cmp	r2, #2
{
   1628c:	4604      	mov	r4, r0
   1628e:	4688      	mov	r8, r1
   16290:	4615      	mov	r5, r2
   16292:	b09e      	sub	sp, #120	; 0x78
    if(mode == LV_DESIGN_COVER_CHK) {
   16294:	d15b      	bne.n	1634e <lv_obj_design+0xc8>
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) return LV_DESIGN_RES_MASKED;
   16296:	2100      	movs	r1, #0
   16298:	f7ff fcfb 	bl	15c92 <lv_obj_get_style_clip_corner>
   1629c:	4606      	mov	r6, r0
   1629e:	2800      	cmp	r0, #0
   162a0:	d153      	bne.n	1634a <lv_obj_design+0xc4>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   162a2:	4601      	mov	r1, r0
   162a4:	2201      	movs	r2, #1
   162a6:	4620      	mov	r0, r4
   162a8:	f7f3 faae 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   162ac:	2204      	movs	r2, #4
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   162ae:	4682      	mov	sl, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   162b0:	4631      	mov	r1, r6
   162b2:	4620      	mov	r0, r4
   162b4:	f7f3 faa8 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   162b8:	2205      	movs	r2, #5
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   162ba:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   162bc:	4631      	mov	r1, r6
   162be:	4620      	mov	r0, r4
   162c0:	f7f3 faa2 	bl	9808 <_lv_obj_get_style_int>
   162c4:	4681      	mov	r9, r0
        lv_area_copy(&coords, &obj->coords);
   162c6:	f104 0110 	add.w	r1, r4, #16
   162ca:	a804      	add	r0, sp, #16
   162cc:	f7ff f9f6 	bl	156bc <lv_area_copy>
        coords.x1 -= w;
   162d0:	f8bd 3010 	ldrh.w	r3, [sp, #16]
        coords.x2 += w;
   162d4:	f8bd 0014 	ldrh.w	r0, [sp, #20]
        coords.x1 -= w;
   162d8:	1bdb      	subs	r3, r3, r7
   162da:	f8ad 3010 	strh.w	r3, [sp, #16]
        coords.x2 += w;
   162de:	4407      	add	r7, r0
        coords.y1 -= h;
   162e0:	f8bd 3012 	ldrh.w	r3, [sp, #18]
        coords.y2 += h;
   162e4:	f8bd 0016 	ldrh.w	r0, [sp, #22]
        coords.y1 -= h;
   162e8:	eba3 0309 	sub.w	r3, r3, r9
        if(_lv_area_is_in(clip_area, &coords, r) == false) return LV_DESIGN_RES_NOT_COVER;
   162ec:	4652      	mov	r2, sl
        coords.y2 += h;
   162ee:	4481      	add	r9, r0
        if(_lv_area_is_in(clip_area, &coords, r) == false) return LV_DESIGN_RES_NOT_COVER;
   162f0:	a904      	add	r1, sp, #16
   162f2:	4640      	mov	r0, r8
        coords.x2 += w;
   162f4:	f8ad 7014 	strh.w	r7, [sp, #20]
        coords.y1 -= h;
   162f8:	f8ad 3012 	strh.w	r3, [sp, #18]
        coords.y2 += h;
   162fc:	f8ad 9016 	strh.w	r9, [sp, #22]
        if(_lv_area_is_in(clip_area, &coords, r) == false) return LV_DESIGN_RES_NOT_COVER;
   16300:	f004 fdbf 	bl	1ae82 <_lv_area_is_in>
   16304:	b1e8      	cbz	r0, 16342 <lv_obj_design+0xbc>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
   16306:	222c      	movs	r2, #44	; 0x2c
   16308:	4631      	mov	r1, r6
   1630a:	4620      	mov	r0, r4
   1630c:	f7ff fcdd 	bl	15cca <_lv_obj_get_style_opa>
        if(lv_obj_get_style_bg_opa(obj, LV_OBJ_PART_MAIN) < LV_OPA_MAX) return LV_DESIGN_RES_NOT_COVER;
   16310:	28fc      	cmp	r0, #252	; 0xfc
   16312:	d916      	bls.n	16342 <lv_obj_design+0xbc>
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_BLEND_MODE, bg_blend_mode, lv_blend_mode_t, _int, scalar)
   16314:	4631      	mov	r1, r6
   16316:	2220      	movs	r2, #32
   16318:	4620      	mov	r0, r4
   1631a:	f7f3 fa75 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_bg_blend_mode(obj, LV_OBJ_PART_MAIN) != LV_BLEND_MODE_NORMAL) return LV_DESIGN_RES_NOT_COVER;
   1631e:	f010 01ff 	ands.w	r1, r0, #255	; 0xff
   16322:	d10e      	bne.n	16342 <lv_obj_design+0xbc>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_BLEND_MODE, border_blend_mode, lv_blend_mode_t, _int, scalar)
   16324:	2232      	movs	r2, #50	; 0x32
   16326:	4620      	mov	r0, r4
   16328:	f7f3 fa6e 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_border_blend_mode(obj, LV_OBJ_PART_MAIN) != LV_BLEND_MODE_NORMAL) return LV_DESIGN_RES_NOT_COVER;
   1632c:	f010 01ff 	ands.w	r1, r0, #255	; 0xff
   16330:	d107      	bne.n	16342 <lv_obj_design+0xbc>
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
   16332:	f248 020c 	movw	r2, #32780	; 0x800c
   16336:	4620      	mov	r0, r4
   16338:	f7ff fcc7 	bl	15cca <_lv_obj_get_style_opa>
        return  LV_DESIGN_RES_COVER;
   1633c:	28fc      	cmp	r0, #252	; 0xfc
   1633e:	bf88      	it	hi
   16340:	2501      	movhi	r5, #1
}
   16342:	4628      	mov	r0, r5
   16344:	b01e      	add	sp, #120	; 0x78
   16346:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) return LV_DESIGN_RES_MASKED;
   1634a:	2503      	movs	r5, #3
   1634c:	e7f9      	b.n	16342 <lv_obj_design+0xbc>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
   1634e:	2a00      	cmp	r2, #0
   16350:	d178      	bne.n	16444 <lv_obj_design+0x1be>
        lv_draw_rect_dsc_init(&draw_dsc);
   16352:	a804      	add	r0, sp, #16
   16354:	f7f5 fde2 	bl	bf1c <lv_draw_rect_dsc_init>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   16358:	2233      	movs	r2, #51	; 0x33
   1635a:	4629      	mov	r1, r5
   1635c:	4620      	mov	r0, r4
   1635e:	f7f3 fa53 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_border_post(obj, LV_OBJ_PART_MAIN)) {
   16362:	b128      	cbz	r0, 16370 <lv_obj_design+0xea>
            draw_dsc.border_post = 1;
   16364:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
   16368:	f043 0301 	orr.w	r3, r3, #1
   1636c:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
        lv_obj_init_draw_rect_dsc(obj, LV_OBJ_PART_MAIN, &draw_dsc);
   16370:	2100      	movs	r1, #0
   16372:	4620      	mov	r0, r4
   16374:	aa04      	add	r2, sp, #16
   16376:	f7ff ff09 	bl	1618c <lv_obj_init_draw_rect_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1637a:	2204      	movs	r2, #4
   1637c:	2100      	movs	r1, #0
   1637e:	4620      	mov	r0, r4
   16380:	f7f3 fa42 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   16384:	2205      	movs	r2, #5
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   16386:	4606      	mov	r6, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   16388:	2100      	movs	r1, #0
   1638a:	4620      	mov	r0, r4
   1638c:	f7f3 fa3c 	bl	9808 <_lv_obj_get_style_int>
   16390:	4607      	mov	r7, r0
        lv_area_copy(&coords, &obj->coords);
   16392:	f104 0910 	add.w	r9, r4, #16
   16396:	4649      	mov	r1, r9
   16398:	4668      	mov	r0, sp
   1639a:	f7ff f98f 	bl	156bc <lv_area_copy>
        coords.x1 -= w;
   1639e:	f8bd 3000 	ldrh.w	r3, [sp]
        coords.x2 += w;
   163a2:	f8bd 0004 	ldrh.w	r0, [sp, #4]
        coords.x1 -= w;
   163a6:	1b9b      	subs	r3, r3, r6
   163a8:	f8ad 3000 	strh.w	r3, [sp]
        coords.x2 += w;
   163ac:	4406      	add	r6, r0
        coords.y1 -= h;
   163ae:	f8bd 3002 	ldrh.w	r3, [sp, #2]
        coords.y2 += h;
   163b2:	f8bd 0006 	ldrh.w	r0, [sp, #6]
        coords.y1 -= h;
   163b6:	1bdb      	subs	r3, r3, r7
        lv_draw_rect(&coords, clip_area, &draw_dsc);
   163b8:	4641      	mov	r1, r8
        coords.y2 += h;
   163ba:	4407      	add	r7, r0
        lv_draw_rect(&coords, clip_area, &draw_dsc);
   163bc:	aa04      	add	r2, sp, #16
   163be:	4668      	mov	r0, sp
        coords.x2 += w;
   163c0:	f8ad 6004 	strh.w	r6, [sp, #4]
        coords.y1 -= h;
   163c4:	f8ad 3002 	strh.w	r3, [sp, #2]
        coords.y2 += h;
   163c8:	f8ad 7006 	strh.w	r7, [sp, #6]
        lv_draw_rect(&coords, clip_area, &draw_dsc);
   163cc:	f002 fe13 	bl	18ff6 <lv_draw_rect>
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) {
   163d0:	2100      	movs	r1, #0
   163d2:	4620      	mov	r0, r4
   163d4:	f7ff fc5d 	bl	15c92 <lv_obj_get_style_clip_corner>
   163d8:	2800      	cmp	r0, #0
   163da:	d0b2      	beq.n	16342 <lv_obj_design+0xbc>
            lv_draw_mask_radius_param_t * mp = _lv_mem_buf_get(sizeof(lv_draw_mask_radius_param_t));
   163dc:	201c      	movs	r0, #28
   163de:	f7f6 fb8d 	bl	cafc <_lv_mem_buf_get>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   163e2:	2201      	movs	r2, #1
   163e4:	4606      	mov	r6, r0
   163e6:	2100      	movs	r1, #0
   163e8:	4620      	mov	r0, r4
   163ea:	f7f3 fa0d 	bl	9808 <_lv_obj_get_style_int>
            if(draw_dsc.border_post && draw_dsc.border_opa >= LV_OPA_MIN && draw_dsc.border_width > 0) {
   163ee:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
   163f2:	4602      	mov	r2, r0
   163f4:	07db      	lsls	r3, r3, #31
   163f6:	d522      	bpl.n	1643e <lv_obj_design+0x1b8>
   163f8:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   163fc:	2b01      	cmp	r3, #1
   163fe:	d91e      	bls.n	1643e <lv_obj_design+0x1b8>
   16400:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
   16404:	2b00      	cmp	r3, #0
   16406:	dd1a      	ble.n	1643e <lv_obj_design+0x1b8>
                cc_area.x1 = obj->coords.x1 + 1;
   16408:	8a23      	ldrh	r3, [r4, #16]
                lv_draw_mask_radius_init(mp, &cc_area, r, false);
   1640a:	a902      	add	r1, sp, #8
                cc_area.x1 = obj->coords.x1 + 1;
   1640c:	3301      	adds	r3, #1
   1640e:	f8ad 3008 	strh.w	r3, [sp, #8]
                cc_area.y1 = obj->coords.y1 + 1;
   16412:	8a63      	ldrh	r3, [r4, #18]
   16414:	3301      	adds	r3, #1
   16416:	f8ad 300a 	strh.w	r3, [sp, #10]
                cc_area.x2 = obj->coords.x2 - 1;
   1641a:	8aa3      	ldrh	r3, [r4, #20]
   1641c:	3b01      	subs	r3, #1
   1641e:	f8ad 300c 	strh.w	r3, [sp, #12]
                cc_area.y2 = obj->coords.y2 - 1;
   16422:	8ae3      	ldrh	r3, [r4, #22]
   16424:	3b01      	subs	r3, #1
   16426:	f8ad 300e 	strh.w	r3, [sp, #14]
                lv_draw_mask_radius_init(mp, &cc_area, r, false);
   1642a:	2300      	movs	r3, #0
                lv_draw_mask_radius_init(mp, &obj->coords, r, false);
   1642c:	4630      	mov	r0, r6
   1642e:	f7f5 fd4b 	bl	bec8 <lv_draw_mask_radius_init>
            lv_draw_mask_add(mp, obj + 8);
   16432:	4630      	mov	r0, r6
   16434:	f504 71f0 	add.w	r1, r4, #480	; 0x1e0
   16438:	f7f5 fc56 	bl	bce8 <lv_draw_mask_add>
   1643c:	e781      	b.n	16342 <lv_obj_design+0xbc>
                lv_draw_mask_radius_init(mp, &obj->coords, r, false);
   1643e:	2300      	movs	r3, #0
   16440:	4649      	mov	r1, r9
   16442:	e7f3      	b.n	1642c <lv_obj_design+0x1a6>
    else if(mode == LV_DESIGN_DRAW_POST) {
   16444:	2a01      	cmp	r2, #1
   16446:	d001      	beq.n	1644c <lv_obj_design+0x1c6>
    return LV_DESIGN_RES_OK;
   16448:	2500      	movs	r5, #0
   1644a:	e77a      	b.n	16342 <lv_obj_design+0xbc>
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) {
   1644c:	2100      	movs	r1, #0
   1644e:	f7ff fc20 	bl	15c92 <lv_obj_get_style_clip_corner>
   16452:	b128      	cbz	r0, 16460 <lv_obj_design+0x1da>
            lv_draw_mask_radius_param_t * param = lv_draw_mask_remove_custom(obj + 8);
   16454:	f504 70f0 	add.w	r0, r4, #480	; 0x1e0
   16458:	f7f5 fc90 	bl	bd7c <lv_draw_mask_remove_custom>
            _lv_mem_buf_release(param);
   1645c:	f7f6 fbb0 	bl	cbc0 <_lv_mem_buf_release>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   16460:	2233      	movs	r2, #51	; 0x33
   16462:	2100      	movs	r1, #0
   16464:	4620      	mov	r0, r4
   16466:	f7f3 f9cf 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_border_post(obj, LV_OBJ_PART_MAIN)) {
   1646a:	2800      	cmp	r0, #0
   1646c:	d0ec      	beq.n	16448 <lv_obj_design+0x1c2>
            draw_dsc.bg_opa = LV_OPA_TRANSP;
   1646e:	2500      	movs	r5, #0
            lv_draw_rect_dsc_init(&draw_dsc);
   16470:	a804      	add	r0, sp, #16
   16472:	f7f5 fd53 	bl	bf1c <lv_draw_rect_dsc_init>
            lv_obj_init_draw_rect_dsc(obj, LV_OBJ_PART_MAIN, &draw_dsc);
   16476:	4629      	mov	r1, r5
   16478:	4620      	mov	r0, r4
   1647a:	aa04      	add	r2, sp, #16
            draw_dsc.bg_opa = LV_OPA_TRANSP;
   1647c:	f88d 5022 	strb.w	r5, [sp, #34]	; 0x22
            draw_dsc.pattern_opa = LV_OPA_TRANSP;
   16480:	f88d 5058 	strb.w	r5, [sp, #88]	; 0x58
            draw_dsc.shadow_opa = LV_OPA_TRANSP;
   16484:	f88d 5048 	strb.w	r5, [sp, #72]	; 0x48
            draw_dsc.value_opa = LV_OPA_TRANSP;
   16488:	f88d 5064 	strb.w	r5, [sp, #100]	; 0x64
            lv_obj_init_draw_rect_dsc(obj, LV_OBJ_PART_MAIN, &draw_dsc);
   1648c:	f7ff fe7e 	bl	1618c <lv_obj_init_draw_rect_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   16490:	4629      	mov	r1, r5
   16492:	2204      	movs	r2, #4
   16494:	4620      	mov	r0, r4
   16496:	f7f3 f9b7 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1649a:	2205      	movs	r2, #5
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1649c:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1649e:	4629      	mov	r1, r5
   164a0:	4620      	mov	r0, r4
   164a2:	f7f3 f9b1 	bl	9808 <_lv_obj_get_style_int>
   164a6:	4606      	mov	r6, r0
            lv_area_copy(&coords, &obj->coords);
   164a8:	f104 0110 	add.w	r1, r4, #16
   164ac:	a802      	add	r0, sp, #8
   164ae:	f7ff f905 	bl	156bc <lv_area_copy>
            coords.x1 -= w;
   164b2:	f8bd 3008 	ldrh.w	r3, [sp, #8]
            coords.x2 += w;
   164b6:	f8bd 000c 	ldrh.w	r0, [sp, #12]
            coords.x1 -= w;
   164ba:	1bdb      	subs	r3, r3, r7
   164bc:	f8ad 3008 	strh.w	r3, [sp, #8]
            coords.x2 += w;
   164c0:	4407      	add	r7, r0
            coords.y1 -= h;
   164c2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
            coords.y2 += h;
   164c6:	f8bd 000e 	ldrh.w	r0, [sp, #14]
            coords.y1 -= h;
   164ca:	1b9b      	subs	r3, r3, r6
            lv_draw_rect(&coords, clip_area, &draw_dsc);
   164cc:	4641      	mov	r1, r8
            coords.y2 += h;
   164ce:	4406      	add	r6, r0
            lv_draw_rect(&coords, clip_area, &draw_dsc);
   164d0:	aa04      	add	r2, sp, #16
   164d2:	a802      	add	r0, sp, #8
            coords.x2 += w;
   164d4:	f8ad 700c 	strh.w	r7, [sp, #12]
            coords.y1 -= h;
   164d8:	f8ad 300a 	strh.w	r3, [sp, #10]
            coords.y2 += h;
   164dc:	f8ad 600e 	strh.w	r6, [sp, #14]
            lv_draw_rect(&coords, clip_area, &draw_dsc);
   164e0:	f002 fd89 	bl	18ff6 <lv_draw_rect>
   164e4:	e72d      	b.n	16342 <lv_obj_design+0xbc>

000164e6 <lv_obj_init_draw_label_dsc>:
{
   164e6:	b570      	push	{r4, r5, r6, lr}
   164e8:	4614      	mov	r4, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
   164ea:	f248 028c 	movw	r2, #32908	; 0x808c
   164ee:	4605      	mov	r5, r0
   164f0:	460e      	mov	r6, r1
   164f2:	f7ff fbea 	bl	15cca <_lv_obj_get_style_opa>
    if(draw_dsc->opa <= LV_OPA_MIN) return;
   164f6:	2802      	cmp	r0, #2
    draw_dsc->opa = lv_obj_get_style_text_opa(obj, part);
   164f8:	7320      	strb	r0, [r4, #12]
    if(draw_dsc->opa <= LV_OPA_MIN) return;
   164fa:	d932      	bls.n	16562 <lv_obj_init_draw_label_dsc+0x7c>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
   164fc:	f248 0289 	movw	r2, #32905	; 0x8089
   16500:	4631      	mov	r1, r6
   16502:	4628      	mov	r0, r5
   16504:	f7ff fb94 	bl	15c30 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   16508:	f248 0280 	movw	r2, #32896	; 0x8080
   1650c:	4631      	mov	r1, r6
    draw_dsc->color = lv_obj_get_style_text_color(obj, part);
   1650e:	6020      	str	r0, [r4, #0]
   16510:	4628      	mov	r0, r5
   16512:	f7f3 f979 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   16516:	f248 0281 	movw	r2, #32897	; 0x8081
   1651a:	4631      	mov	r1, r6
    draw_dsc->letter_space = lv_obj_get_style_text_letter_space(obj, part);
   1651c:	8220      	strh	r0, [r4, #16]
   1651e:	4628      	mov	r0, r5
   16520:	f7f3 f972 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
   16524:	f248 0282 	movw	r2, #32898	; 0x8082
   16528:	4631      	mov	r1, r6
    draw_dsc->line_space = lv_obj_get_style_text_line_space(obj, part);
   1652a:	81e0      	strh	r0, [r4, #14]
   1652c:	4628      	mov	r0, r5
   1652e:	f7f3 f96b 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   16532:	f248 028e 	movw	r2, #32910	; 0x808e
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
   16536:	f884 0022 	strb.w	r0, [r4, #34]	; 0x22
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   1653a:	4631      	mov	r1, r6
   1653c:	4628      	mov	r0, r5
   1653e:	f7f3 fbb9 	bl	9cb4 <_lv_obj_get_style_ptr>
    if(draw_dsc->sel_start != LV_DRAW_LABEL_NO_TXT_SEL && draw_dsc->sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {
   16542:	f64f 73ff 	movw	r3, #65535	; 0xffff
   16546:	6962      	ldr	r2, [r4, #20]
    draw_dsc->font = lv_obj_get_style_text_font(obj, part);
   16548:	60a0      	str	r0, [r4, #8]
    if(draw_dsc->sel_start != LV_DRAW_LABEL_NO_TXT_SEL && draw_dsc->sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {
   1654a:	429a      	cmp	r2, r3
   1654c:	d009      	beq.n	16562 <lv_obj_init_draw_label_dsc+0x7c>
   1654e:	69a2      	ldr	r2, [r4, #24]
   16550:	429a      	cmp	r2, r3
   16552:	d006      	beq.n	16562 <lv_obj_init_draw_label_dsc+0x7c>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
   16554:	f248 028a 	movw	r2, #32906	; 0x808a
   16558:	4631      	mov	r1, r6
   1655a:	4628      	mov	r0, r5
   1655c:	f7ff fb68 	bl	15c30 <_lv_obj_get_style_color>
        draw_dsc->color = lv_obj_get_style_text_sel_color(obj, part);
   16560:	6020      	str	r0, [r4, #0]
}
   16562:	bd70      	pop	{r4, r5, r6, pc}

00016564 <lv_obj_init_draw_img_dsc>:
{
   16564:	b570      	push	{r4, r5, r6, lr}
   16566:	4614      	mov	r4, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_OPA, image_opa, lv_opa_t, _opa, scalar)
   16568:	f248 02ac 	movw	r2, #32940	; 0x80ac
   1656c:	4605      	mov	r5, r0
   1656e:	460e      	mov	r6, r1
   16570:	f7ff fbab 	bl	15cca <_lv_obj_get_style_opa>
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
   16574:	2802      	cmp	r0, #2
    draw_dsc->opa = lv_obj_get_style_image_opa(obj, part);
   16576:	7020      	strb	r0, [r4, #0]
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
   16578:	d927      	bls.n	165ca <lv_obj_init_draw_img_dsc+0x66>
    draw_dsc->angle = 0;
   1657a:	2300      	movs	r3, #0
   1657c:	8063      	strh	r3, [r4, #2]
    draw_dsc->zoom = LV_IMG_ZOOM_NONE;
   1657e:	f44f 7380 	mov.w	r3, #256	; 0x100
   16582:	8123      	strh	r3, [r4, #8]
   16584:	8aab      	ldrh	r3, [r5, #20]
   16586:	8a2a      	ldrh	r2, [r5, #16]
   16588:	3301      	adds	r3, #1
   1658a:	1a9b      	subs	r3, r3, r2
    draw_dsc->pivot.x = lv_area_get_width(&obj->coords) / 2;
   1658c:	f3c3 32c0 	ubfx	r2, r3, #15, #1
   16590:	fa02 f383 	sxtah	r3, r2, r3
   16594:	105b      	asrs	r3, r3, #1
   16596:	80a3      	strh	r3, [r4, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   16598:	8aeb      	ldrh	r3, [r5, #22]
   1659a:	8a6a      	ldrh	r2, [r5, #18]
   1659c:	3301      	adds	r3, #1
   1659e:	1a9b      	subs	r3, r3, r2
    draw_dsc->pivot.y = lv_area_get_height(&obj->coords) / 2;
   165a0:	f3c3 32c0 	ubfx	r2, r3, #15, #1
   165a4:	fa02 f383 	sxtah	r3, r2, r3
   165a8:	105b      	asrs	r3, r3, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
   165aa:	f248 02ad 	movw	r2, #32941	; 0x80ad
   165ae:	4631      	mov	r1, r6
   165b0:	4628      	mov	r0, r5
   165b2:	80e3      	strh	r3, [r4, #6]
   165b4:	f7ff fb89 	bl	15cca <_lv_obj_get_style_opa>
    draw_dsc->recolor_opa = lv_obj_get_style_image_recolor_opa(obj, part);
   165b8:	72a0      	strb	r0, [r4, #10]
    if(draw_dsc->recolor_opa > 0) {
   165ba:	b130      	cbz	r0, 165ca <lv_obj_init_draw_img_dsc+0x66>
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
   165bc:	f248 02a9 	movw	r2, #32937	; 0x80a9
   165c0:	4631      	mov	r1, r6
   165c2:	4628      	mov	r0, r5
   165c4:	f7ff fb34 	bl	15c30 <_lv_obj_get_style_color>
        draw_dsc->recolor = lv_obj_get_style_image_recolor(obj, part);
   165c8:	60e0      	str	r0, [r4, #12]
}
   165ca:	bd70      	pop	{r4, r5, r6, pc}

000165cc <lv_obj_init_draw_line_dsc>:
{
   165cc:	b570      	push	{r4, r5, r6, lr}
   165ce:	4614      	mov	r4, r2
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_WIDTH, line_width, lv_style_int_t, _int, scalar)
   165d0:	2290      	movs	r2, #144	; 0x90
   165d2:	4605      	mov	r5, r0
   165d4:	460e      	mov	r6, r1
   165d6:	f7f3 f917 	bl	9808 <_lv_obj_get_style_int>
    draw_dsc->width = lv_obj_get_style_line_width(obj, part);
   165da:	80a0      	strh	r0, [r4, #4]
    if(draw_dsc->width == 0) return;
   165dc:	b340      	cbz	r0, 16630 <lv_obj_init_draw_line_dsc+0x64>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_OPA, line_opa, lv_opa_t, _opa, scalar)
   165de:	229c      	movs	r2, #156	; 0x9c
   165e0:	4631      	mov	r1, r6
   165e2:	4628      	mov	r0, r5
   165e4:	f7ff fb71 	bl	15cca <_lv_obj_get_style_opa>
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
   165e8:	2802      	cmp	r0, #2
    draw_dsc->opa = lv_obj_get_style_line_opa(obj, part);
   165ea:	72a0      	strb	r0, [r4, #10]
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
   165ec:	d920      	bls.n	16630 <lv_obj_init_draw_line_dsc+0x64>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
   165ee:	2299      	movs	r2, #153	; 0x99
   165f0:	4631      	mov	r1, r6
   165f2:	4628      	mov	r0, r5
   165f4:	f7ff fb1c 	bl	15c30 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_WIDTH, line_dash_width, lv_style_int_t, _int, scalar)
   165f8:	2292      	movs	r2, #146	; 0x92
    draw_dsc->color = lv_obj_get_style_line_color(obj, part);
   165fa:	6020      	str	r0, [r4, #0]
   165fc:	4631      	mov	r1, r6
   165fe:	4628      	mov	r0, r5
   16600:	f7f3 f902 	bl	9808 <_lv_obj_get_style_int>
    draw_dsc->dash_width = lv_obj_get_style_line_dash_width(obj, part);
   16604:	80e0      	strh	r0, [r4, #6]
    if(draw_dsc->dash_width) {
   16606:	b128      	cbz	r0, 16614 <lv_obj_init_draw_line_dsc+0x48>
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_GAP, line_dash_gap, lv_style_int_t, _int, scalar)
   16608:	2293      	movs	r2, #147	; 0x93
   1660a:	4631      	mov	r1, r6
   1660c:	4628      	mov	r0, r5
   1660e:	f7f3 f8fb 	bl	9808 <_lv_obj_get_style_int>
        draw_dsc->dash_gap = lv_obj_get_style_line_dash_gap(obj, part);
   16612:	8120      	strh	r0, [r4, #8]
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_ROUNDED, line_rounded, bool, _int, scalar)
   16614:	2294      	movs	r2, #148	; 0x94
   16616:	4631      	mov	r1, r6
   16618:	4628      	mov	r0, r5
   1661a:	f7f3 f8f5 	bl	9808 <_lv_obj_get_style_int>
   1661e:	3800      	subs	r0, #0
   16620:	bf18      	it	ne
   16622:	2001      	movne	r0, #1
    draw_dsc->round_start = lv_obj_get_style_line_rounded(obj, part);
   16624:	7ae3      	ldrb	r3, [r4, #11]
   16626:	f360 0382 	bfi	r3, r0, #2, #1
    draw_dsc->round_end = draw_dsc->round_start;
   1662a:	f360 03c3 	bfi	r3, r0, #3, #1
   1662e:	72e3      	strb	r3, [r4, #11]
}
   16630:	bd70      	pop	{r4, r5, r6, pc}

00016632 <style_snapshot>:
{
   16632:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16636:	4614      	mov	r4, r2
   16638:	4605      	mov	r5, r0
   1663a:	460e      	mov	r6, r1
    _lv_obj_disable_style_caching(obj, true);
   1663c:	2101      	movs	r1, #1
   1663e:	f7ff fa98 	bl	15b72 <_lv_obj_disable_style_caching>
    _lv_memset_00(shot, sizeof(style_snapshot_t));
   16642:	21dc      	movs	r1, #220	; 0xdc
   16644:	4620      	mov	r0, r4
   16646:	f7ff f833 	bl	156b0 <_lv_memset_00>
    lv_draw_label_dsc_init(&shot->label);
   1664a:	f104 0a68 	add.w	sl, r4, #104	; 0x68
    lv_draw_rect_dsc_init(&shot->rect);
   1664e:	4620      	mov	r0, r4
   16650:	f7f5 fc64 	bl	bf1c <lv_draw_rect_dsc_init>
    lv_draw_img_dsc_init(&shot->img);
   16654:	f104 0998 	add.w	r9, r4, #152	; 0x98
    lv_draw_label_dsc_init(&shot->label);
   16658:	4650      	mov	r0, sl
   1665a:	f7f4 fae3 	bl	ac24 <lv_draw_label_dsc_init>
    lv_draw_line_dsc_init(&shot->line);
   1665e:	f104 088c 	add.w	r8, r4, #140	; 0x8c
    lv_draw_img_dsc_init(&shot->img);
   16662:	4648      	mov	r0, r9
   16664:	f001 ff43 	bl	184ee <lv_draw_img_dsc_init>
    lv_draw_line_dsc_init(&shot->line);
   16668:	4640      	mov	r0, r8
   1666a:	f001 ff98 	bl	1859e <lv_draw_line_dsc_init>
    lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   1666e:	4631      	mov	r1, r6
   16670:	4628      	mov	r0, r5
   16672:	f7ff fa3b 	bl	15aec <lv_obj_get_style_list>
    bool trans_ori = list->skip_trans;
   16676:	7943      	ldrb	r3, [r0, #5]
    lv_style_list_t * list = lv_obj_get_style_list(obj, part);
   16678:	4607      	mov	r7, r0
    bool trans_ori = list->skip_trans;
   1667a:	f003 0b01 	and.w	fp, r3, #1
    list->skip_trans = 1;
   1667e:	f043 0301 	orr.w	r3, r3, #1
   16682:	7143      	strb	r3, [r0, #5]
    lv_obj_init_draw_rect_dsc(obj, part, &shot->rect);
   16684:	4622      	mov	r2, r4
   16686:	4631      	mov	r1, r6
   16688:	4628      	mov	r0, r5
   1668a:	f7ff fd7f 	bl	1618c <lv_obj_init_draw_rect_dsc>
    lv_obj_init_draw_label_dsc(obj, part, &shot->label);
   1668e:	4652      	mov	r2, sl
   16690:	4631      	mov	r1, r6
   16692:	4628      	mov	r0, r5
   16694:	f7ff ff27 	bl	164e6 <lv_obj_init_draw_label_dsc>
    lv_obj_init_draw_img_dsc(obj, part, &shot->img);
   16698:	464a      	mov	r2, r9
   1669a:	4631      	mov	r1, r6
   1669c:	4628      	mov	r0, r5
   1669e:	f7ff ff61 	bl	16564 <lv_obj_init_draw_img_dsc>
    lv_obj_init_draw_line_dsc(obj, part, &shot->line);
   166a2:	4642      	mov	r2, r8
   166a4:	4631      	mov	r1, r6
   166a6:	4628      	mov	r0, r5
   166a8:	f7ff ff90 	bl	165cc <lv_obj_init_draw_line_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   166ac:	2210      	movs	r2, #16
   166ae:	4631      	mov	r1, r6
   166b0:	4628      	mov	r0, r5
   166b2:	f7f3 f8a9 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   166b6:	2211      	movs	r2, #17
   166b8:	4631      	mov	r1, r6
    shot->pad_top = lv_obj_get_style_pad_top(obj, part);
   166ba:	f8a4 00ac 	strh.w	r0, [r4, #172]	; 0xac
   166be:	4628      	mov	r0, r5
   166c0:	f7f3 f8a2 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   166c4:	2213      	movs	r2, #19
   166c6:	4631      	mov	r1, r6
    shot->pad_bottom = lv_obj_get_style_pad_bottom(obj, part);
   166c8:	f8a4 00ae 	strh.w	r0, [r4, #174]	; 0xae
   166cc:	4628      	mov	r0, r5
   166ce:	f7f3 f89b 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   166d2:	2212      	movs	r2, #18
   166d4:	4631      	mov	r1, r6
    shot->pad_right = lv_obj_get_style_pad_right(obj, part);
   166d6:	f8a4 00b0 	strh.w	r0, [r4, #176]	; 0xb0
   166da:	4628      	mov	r0, r5
   166dc:	f7f3 f894 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   166e0:	2214      	movs	r2, #20
   166e2:	4631      	mov	r1, r6
    shot->pad_left = lv_obj_get_style_pad_left(obj, part);
   166e4:	f8a4 00b2 	strh.w	r0, [r4, #178]	; 0xb2
   166e8:	4628      	mov	r0, r5
   166ea:	f7f3 f88d 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   166ee:	2215      	movs	r2, #21
   166f0:	4631      	mov	r1, r6
    shot->pad_inner = lv_obj_get_style_pad_inner(obj, part);
   166f2:	f8a4 00b4 	strh.w	r0, [r4, #180]	; 0xb4
   166f6:	4628      	mov	r0, r5
   166f8:	f7f3 f886 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   166fc:	2216      	movs	r2, #22
   166fe:	4631      	mov	r1, r6
    shot->margin_top = lv_obj_get_style_margin_top(obj, part);
   16700:	f8a4 00b6 	strh.w	r0, [r4, #182]	; 0xb6
   16704:	4628      	mov	r0, r5
   16706:	f7f3 f87f 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   1670a:	2217      	movs	r2, #23
   1670c:	4631      	mov	r1, r6
    shot->margin_bottom = lv_obj_get_style_margin_bottom(obj, part);
   1670e:	f8a4 00b8 	strh.w	r0, [r4, #184]	; 0xb8
   16712:	4628      	mov	r0, r5
   16714:	f7f3 f878 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   16718:	2218      	movs	r2, #24
   1671a:	4631      	mov	r1, r6
    shot->margin_left = lv_obj_get_style_margin_left(obj, part);
   1671c:	f8a4 00ba 	strh.w	r0, [r4, #186]	; 0xba
   16720:	4628      	mov	r0, r5
   16722:	f7f3 f871 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SIZE, size, lv_style_int_t, _int, scalar)
   16726:	2203      	movs	r2, #3
   16728:	4631      	mov	r1, r6
    shot->margin_right = lv_obj_get_style_margin_right(obj, part);
   1672a:	f8a4 00bc 	strh.w	r0, [r4, #188]	; 0xbc
   1672e:	4628      	mov	r0, r5
   16730:	f7f3 f86a 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   16734:	2204      	movs	r2, #4
   16736:	4631      	mov	r1, r6
    shot->size = lv_obj_get_style_size(obj, part);
   16738:	f8a4 00be 	strh.w	r0, [r4, #190]	; 0xbe
   1673c:	4628      	mov	r0, r5
   1673e:	f7f3 f863 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   16742:	2205      	movs	r2, #5
   16744:	4631      	mov	r1, r6
    shot->transform_width = lv_obj_get_style_transform_width(obj, part);
   16746:	f8a4 00c0 	strh.w	r0, [r4, #192]	; 0xc0
   1674a:	4628      	mov	r0, r5
   1674c:	f7f3 f85c 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
   16750:	2206      	movs	r2, #6
   16752:	4631      	mov	r1, r6
    shot->transform_height = lv_obj_get_style_transform_height(obj, part);
   16754:	f8a4 00c2 	strh.w	r0, [r4, #194]	; 0xc2
   16758:	4628      	mov	r0, r5
   1675a:	f7f3 f855 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
   1675e:	2207      	movs	r2, #7
   16760:	4631      	mov	r1, r6
    shot->transform_angle = lv_obj_get_style_transform_angle(obj, part);
   16762:	f8a4 00c4 	strh.w	r0, [r4, #196]	; 0xc4
   16766:	4628      	mov	r0, r5
   16768:	f7f3 f84e 	bl	9808 <_lv_obj_get_style_int>
#else
/*For compatibility*/
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, const void *, _ptr, scalar)
#endif
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_WIDTH, scale_width, lv_style_int_t, _int, scalar)
   1676c:	22c0      	movs	r2, #192	; 0xc0
   1676e:	4631      	mov	r1, r6
    shot->transform_zoom = lv_obj_get_style_transform_zoom(obj, part);
   16770:	f8a4 00c6 	strh.w	r0, [r4, #198]	; 0xc6
   16774:	4628      	mov	r0, r5
   16776:	f7f3 f847 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_BORDER_WIDTH, scale_border_width, lv_style_int_t, _int, scalar)
   1677a:	22c1      	movs	r2, #193	; 0xc1
   1677c:	4631      	mov	r1, r6
    shot->scale_width = lv_obj_get_style_scale_width(obj, part);
   1677e:	f8a4 00c8 	strh.w	r0, [r4, #200]	; 0xc8
   16782:	4628      	mov	r0, r5
   16784:	f7f3 f840 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_BORDER_WIDTH, scale_end_border_width, lv_style_int_t, _int, scalar)
   16788:	22c2      	movs	r2, #194	; 0xc2
   1678a:	4631      	mov	r1, r6
    shot->scale_border_width = lv_obj_get_style_scale_border_width(obj, part);
   1678c:	f8a4 00ca 	strh.w	r0, [r4, #202]	; 0xca
   16790:	4628      	mov	r0, r5
   16792:	f7f3 f839 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_LINE_WIDTH, scale_end_line_width, lv_style_int_t, _int, scalar)
   16796:	22c3      	movs	r2, #195	; 0xc3
   16798:	4631      	mov	r1, r6
    shot->scale_end_border_width = lv_obj_get_style_scale_end_border_width(obj, part);
   1679a:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
   1679e:	4628      	mov	r0, r5
   167a0:	f7f3 f832 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_GRAD_COLOR, scale_grad_color, lv_color_t, _color, nonscalar)
   167a4:	22c9      	movs	r2, #201	; 0xc9
   167a6:	4631      	mov	r1, r6
    shot->scale_end_line_width = lv_obj_get_style_scale_end_line_width(obj, part);
   167a8:	f8a4 00ce 	strh.w	r0, [r4, #206]	; 0xce
   167ac:	4628      	mov	r0, r5
   167ae:	f7ff fa3f 	bl	15c30 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_COLOR, scale_end_color, lv_color_t, _color, nonscalar)
   167b2:	22ca      	movs	r2, #202	; 0xca
   167b4:	4631      	mov	r1, r6
    shot->scale_grad_color = lv_obj_get_style_scale_grad_color(obj, part);
   167b6:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0
   167ba:	4628      	mov	r0, r5
   167bc:	f7ff fa38 	bl	15c30 <_lv_obj_get_style_color>
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
   167c0:	f248 020c 	movw	r2, #32780	; 0x800c
   167c4:	4631      	mov	r1, r6
    shot->scale_end_color = lv_obj_get_style_scale_end_color(obj, part);
   167c6:	f8c4 00d4 	str.w	r0, [r4, #212]	; 0xd4
   167ca:	4628      	mov	r0, r5
   167cc:	f7ff fa7d 	bl	15cca <_lv_obj_get_style_opa>
    shot->clip_corder = lv_obj_get_style_clip_corner(obj, part);
   167d0:	4631      	mov	r1, r6
    shot->opa_scale = lv_obj_get_style_opa_scale(obj, part);
   167d2:	f884 00d8 	strb.w	r0, [r4, #216]	; 0xd8
    shot->clip_corder = lv_obj_get_style_clip_corner(obj, part);
   167d6:	4628      	mov	r0, r5
   167d8:	f7ff fa5b 	bl	15c92 <lv_obj_get_style_clip_corner>
   167dc:	f894 30d9 	ldrb.w	r3, [r4, #217]	; 0xd9
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   167e0:	2233      	movs	r2, #51	; 0x33
   167e2:	f360 0300 	bfi	r3, r0, #0, #1
   167e6:	4631      	mov	r1, r6
   167e8:	f884 30d9 	strb.w	r3, [r4, #217]	; 0xd9
   167ec:	4628      	mov	r0, r5
   167ee:	f7f3 f80b 	bl	9808 <_lv_obj_get_style_int>
   167f2:	3800      	subs	r0, #0
   167f4:	bf18      	it	ne
   167f6:	2001      	movne	r0, #1
    shot->border_post  = lv_obj_get_style_border_post(obj, part);
   167f8:	f894 30d9 	ldrb.w	r3, [r4, #217]	; 0xd9
    _lv_obj_disable_style_caching(obj, false);
   167fc:	2100      	movs	r1, #0
    shot->border_post  = lv_obj_get_style_border_post(obj, part);
   167fe:	f360 0341 	bfi	r3, r0, #1, #1
   16802:	f884 30d9 	strb.w	r3, [r4, #217]	; 0xd9
    _lv_obj_disable_style_caching(obj, false);
   16806:	4628      	mov	r0, r5
   16808:	f7ff f9b3 	bl	15b72 <_lv_obj_disable_style_caching>
    list->skip_trans = trans_ori;
   1680c:	797b      	ldrb	r3, [r7, #5]
   1680e:	f36b 0300 	bfi	r3, fp, #0, #1
   16812:	717b      	strb	r3, [r7, #5]
}
   16814:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00016818 <lv_obj_add_state>:
{
   16818:	460b      	mov	r3, r1
    lv_state_t new_state = obj->state | state;
   1681a:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
    if(obj->state != new_state) {
   1681e:	4393      	bics	r3, r2
    lv_state_t new_state = obj->state | state;
   16820:	ea42 0101 	orr.w	r1, r2, r1
    if(obj->state != new_state) {
   16824:	d001      	beq.n	1682a <lv_obj_add_state+0x12>
        lv_obj_set_state(obj, new_state);
   16826:	f7f3 bb29 	b.w	9e7c <lv_obj_set_state>
}
   1682a:	4770      	bx	lr

0001682c <lv_obj_clear_state>:
{
   1682c:	460a      	mov	r2, r1
    lv_state_t new_state = obj->state & (~state);
   1682e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    if(obj->state != new_state) {
   16832:	421a      	tst	r2, r3
    lv_state_t new_state = obj->state & (~state);
   16834:	ea23 0101 	bic.w	r1, r3, r1
    if(obj->state != new_state) {
   16838:	d001      	beq.n	1683e <lv_obj_clear_state+0x12>
        lv_obj_set_state(obj, new_state);
   1683a:	f7f3 bb1f 	b.w	9e7c <lv_obj_set_state>
}
   1683e:	4770      	bx	lr

00016840 <lv_obj_get_draw_rect_ext_pad_size>:
{
   16840:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
   16844:	2250      	movs	r2, #80	; 0x50
   16846:	b088      	sub	sp, #32
   16848:	4605      	mov	r5, r0
   1684a:	460e      	mov	r6, r1
   1684c:	f7f2 ffdc 	bl	9808 <_lv_obj_get_style_int>
    if(sh_width) {
   16850:	4604      	mov	r4, r0
   16852:	2800      	cmp	r0, #0
   16854:	f040 80bb 	bne.w	169ce <lv_obj_get_draw_rect_ext_pad_size+0x18e>
    lv_coord_t s = 0;
   16858:	2400      	movs	r4, #0
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
   1685a:	227f      	movs	r2, #127	; 0x7f
   1685c:	4631      	mov	r1, r6
   1685e:	4628      	mov	r0, r5
   16860:	f7f3 fa28 	bl	9cb4 <_lv_obj_get_style_ptr>
    if(value_str) {
   16864:	4607      	mov	r7, r0
   16866:	2800      	cmp	r0, #0
   16868:	f000 8082 	beq.w	16970 <lv_obj_get_draw_rect_ext_pad_size+0x130>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OPA, value_opa, lv_opa_t, _opa, scalar)
   1686c:	227c      	movs	r2, #124	; 0x7c
   1686e:	4631      	mov	r1, r6
   16870:	4628      	mov	r0, r5
   16872:	f7ff fa2a 	bl	15cca <_lv_obj_get_style_opa>
        if(value_opa > LV_OPA_MIN) {
   16876:	2802      	cmp	r0, #2
   16878:	d97a      	bls.n	16970 <lv_obj_get_draw_rect_ext_pad_size+0x130>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_LETTER_SPACE, value_letter_space, lv_style_int_t, _int, scalar)
   1687a:	2270      	movs	r2, #112	; 0x70
   1687c:	4631      	mov	r1, r6
   1687e:	4628      	mov	r0, r5
   16880:	f7f2 ffc2 	bl	9808 <_lv_obj_get_style_int>
   16884:	2270      	movs	r2, #112	; 0x70
   16886:	4680      	mov	r8, r0
   16888:	4631      	mov	r1, r6
   1688a:	4628      	mov	r0, r5
   1688c:	f7f2 ffbc 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
   16890:	227e      	movs	r2, #126	; 0x7e
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_LETTER_SPACE, value_letter_space, lv_style_int_t, _int, scalar)
   16892:	4681      	mov	r9, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
   16894:	4631      	mov	r1, r6
   16896:	4628      	mov	r0, r5
   16898:	f7f3 fa0c 	bl	9cb4 <_lv_obj_get_style_ptr>
            _lv_txt_get_size(&txt_size, value_str, font, letter_space, line_space, LV_COORD_MAX, LV_TXT_FLAG_NONE);
   1689c:	f04f 0a00 	mov.w	sl, #0
   168a0:	f647 4318 	movw	r3, #31768	; 0x7c18
   168a4:	4602      	mov	r2, r0
   168a6:	4639      	mov	r1, r7
   168a8:	e9cd 3a01 	strd	r3, sl, [sp, #4]
   168ac:	f8cd 9000 	str.w	r9, [sp]
   168b0:	4643      	mov	r3, r8
   168b2:	a804      	add	r0, sp, #16
   168b4:	f004 fe34 	bl	1b520 <_lv_txt_get_size>
            value_area.x2 = txt_size.x - 1;
   168b8:	f8bd 3010 	ldrh.w	r3, [sp, #16]
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_ALIGN, value_align, lv_align_t, _int, scalar)
   168bc:	2275      	movs	r2, #117	; 0x75
   168be:	3b01      	subs	r3, #1
   168c0:	f8ad 301c 	strh.w	r3, [sp, #28]
            value_area.y2 = txt_size.y - 1;
   168c4:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   168c8:	4631      	mov	r1, r6
   168ca:	3b01      	subs	r3, #1
   168cc:	4628      	mov	r0, r5
   168ce:	f8ad 301e 	strh.w	r3, [sp, #30]
            value_area.x1 = 0;
   168d2:	f8cd a018 	str.w	sl, [sp, #24]
   168d6:	f7f2 ff97 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_X, value_ofs_x, lv_style_int_t, _int, scalar)
   168da:	2273      	movs	r2, #115	; 0x73
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_ALIGN, value_align, lv_align_t, _int, scalar)
   168dc:	4681      	mov	r9, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_X, value_ofs_x, lv_style_int_t, _int, scalar)
   168de:	4631      	mov	r1, r6
   168e0:	4628      	mov	r0, r5
   168e2:	f7f2 ff91 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_Y, value_ofs_y, lv_style_int_t, _int, scalar)
   168e6:	2274      	movs	r2, #116	; 0x74
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_X, value_ofs_x, lv_style_int_t, _int, scalar)
   168e8:	4680      	mov	r8, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_Y, value_ofs_y, lv_style_int_t, _int, scalar)
   168ea:	4631      	mov	r1, r6
   168ec:	4628      	mov	r0, r5
   168ee:	f7f2 ff8b 	bl	9808 <_lv_obj_get_style_int>
            _lv_area_align(&obj->coords, &value_area, align, &p_align);
   168f2:	ab05      	add	r3, sp, #20
   168f4:	4607      	mov	r7, r0
   168f6:	fa5f f289 	uxtb.w	r2, r9
   168fa:	a906      	add	r1, sp, #24
   168fc:	f105 0010 	add.w	r0, r5, #16
   16900:	f004 fb0f 	bl	1af22 <_lv_area_align>
            value_area.x1 += p_align.x + xofs;
   16904:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   16908:	f8bd 1018 	ldrh.w	r1, [sp, #24]
   1690c:	4443      	add	r3, r8
   1690e:	fa01 f183 	sxtah	r1, r1, r3
            s = LV_MATH_MAX(s, obj->coords.x1 - value_area.x1);
   16912:	f9b5 2010 	ldrsh.w	r2, [r5, #16]
   16916:	b209      	sxth	r1, r1
   16918:	1a52      	subs	r2, r2, r1
   1691a:	4294      	cmp	r4, r2
   1691c:	bfb8      	it	lt
   1691e:	4614      	movlt	r4, r2
            value_area.y1 += p_align.y + yofs;
   16920:	f8bd 0016 	ldrh.w	r0, [sp, #22]
   16924:	f8bd 101a 	ldrh.w	r1, [sp, #26]
   16928:	4438      	add	r0, r7
   1692a:	fa01 f180 	sxtah	r1, r1, r0
            s = LV_MATH_MAX(s, obj->coords.y1 - value_area.y1);
   1692e:	f9b5 2012 	ldrsh.w	r2, [r5, #18]
   16932:	b209      	sxth	r1, r1
   16934:	1a52      	subs	r2, r2, r1
   16936:	b224      	sxth	r4, r4
   16938:	42a2      	cmp	r2, r4
   1693a:	bfb8      	it	lt
   1693c:	4622      	movlt	r2, r4
            value_area.x2 += p_align.x + xofs;
   1693e:	f8bd 401c 	ldrh.w	r4, [sp, #28]
   16942:	fa04 f383 	sxtah	r3, r4, r3
            s = LV_MATH_MAX(s, value_area.x2 - obj->coords.x2);
   16946:	f9b5 4014 	ldrsh.w	r4, [r5, #20]
   1694a:	b21b      	sxth	r3, r3
   1694c:	1b1c      	subs	r4, r3, r4
   1694e:	b213      	sxth	r3, r2
   16950:	42a3      	cmp	r3, r4
   16952:	bfb8      	it	lt
   16954:	4623      	movlt	r3, r4
            value_area.y2 += p_align.y + yofs;
   16956:	f8bd 401e 	ldrh.w	r4, [sp, #30]
   1695a:	fa04 f080 	sxtah	r0, r4, r0
            s = LV_MATH_MAX(s, value_area.y2 - obj->coords.y2);
   1695e:	b204      	sxth	r4, r0
   16960:	f9b5 0016 	ldrsh.w	r0, [r5, #22]
   16964:	1a20      	subs	r0, r4, r0
   16966:	b21c      	sxth	r4, r3
   16968:	4284      	cmp	r4, r0
   1696a:	bfb8      	it	lt
   1696c:	4604      	movlt	r4, r0
   1696e:	b224      	sxth	r4, r4
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_WIDTH, outline_width, lv_style_int_t, _int, scalar)
   16970:	2240      	movs	r2, #64	; 0x40
   16972:	4631      	mov	r1, r6
   16974:	4628      	mov	r0, r5
   16976:	f7f2 ff47 	bl	9808 <_lv_obj_get_style_int>
    if(outline_width) {
   1697a:	4607      	mov	r7, r0
   1697c:	b180      	cbz	r0, 169a0 <lv_obj_get_draw_rect_ext_pad_size+0x160>
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_OPA, outline_opa, lv_opa_t, _opa, scalar)
   1697e:	224c      	movs	r2, #76	; 0x4c
   16980:	4631      	mov	r1, r6
   16982:	4628      	mov	r0, r5
   16984:	f7ff f9a1 	bl	15cca <_lv_obj_get_style_opa>
        if(outline_opa > LV_OPA_MIN) {
   16988:	2802      	cmp	r0, #2
   1698a:	d909      	bls.n	169a0 <lv_obj_get_draw_rect_ext_pad_size+0x160>
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_PAD, outline_pad, lv_style_int_t, _int, scalar)
   1698c:	2241      	movs	r2, #65	; 0x41
   1698e:	4631      	mov	r1, r6
   16990:	4628      	mov	r0, r5
   16992:	f7f2 ff39 	bl	9808 <_lv_obj_get_style_int>
            s = LV_MATH_MAX(s, outline_pad + outline_width);
   16996:	4438      	add	r0, r7
   16998:	4284      	cmp	r4, r0
   1699a:	bfb8      	it	lt
   1699c:	4604      	movlt	r4, r0
   1699e:	b224      	sxth	r4, r4
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   169a0:	4631      	mov	r1, r6
   169a2:	2204      	movs	r2, #4
   169a4:	4628      	mov	r0, r5
   169a6:	f7f2 ff2f 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   169aa:	2205      	movs	r2, #5
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   169ac:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   169ae:	4631      	mov	r1, r6
   169b0:	4628      	mov	r0, r5
   169b2:	f7f2 ff29 	bl	9808 <_lv_obj_get_style_int>
    lv_coord_t wh = LV_MATH_MAX(w, h);
   169b6:	42b8      	cmp	r0, r7
   169b8:	bfb8      	it	lt
   169ba:	4638      	movlt	r0, r7
   169bc:	b200      	sxth	r0, r0
    if(wh > 0) s += wh;
   169be:	2800      	cmp	r0, #0
   169c0:	bfc4      	itt	gt
   169c2:	1824      	addgt	r4, r4, r0
   169c4:	b224      	sxthgt	r4, r4
}
   169c6:	4620      	mov	r0, r4
   169c8:	b008      	add	sp, #32
   169ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OPA, shadow_opa, lv_opa_t, _opa, scalar)
   169ce:	225c      	movs	r2, #92	; 0x5c
   169d0:	4631      	mov	r1, r6
   169d2:	4628      	mov	r0, r5
   169d4:	f7ff f979 	bl	15cca <_lv_obj_get_style_opa>
        if(sh_opa > LV_OPA_MIN) {
   169d8:	2802      	cmp	r0, #2
   169da:	f67f af3d 	bls.w	16858 <lv_obj_get_draw_rect_ext_pad_size+0x18>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_SPREAD, shadow_spread, lv_style_int_t, _int, scalar)
   169de:	2253      	movs	r2, #83	; 0x53
   169e0:	4631      	mov	r1, r6
   169e2:	4628      	mov	r0, r5
   169e4:	f7f2 ff10 	bl	9808 <_lv_obj_get_style_int>
            sh_width = sh_width / 2;    /*THe blur adds only half width*/
   169e8:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
   169ec:	f344 044f 	sbfx	r4, r4, #1, #16
            sh_width++;
   169f0:	3401      	adds	r4, #1
   169f2:	b224      	sxth	r4, r4
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
   169f4:	2251      	movs	r2, #81	; 0x51
   169f6:	4631      	mov	r1, r6
            sh_width += lv_obj_get_style_shadow_spread(obj, part);
   169f8:	4404      	add	r4, r0
   169fa:	4628      	mov	r0, r5
   169fc:	f7f2 ff04 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
   16a00:	2252      	movs	r2, #82	; 0x52
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
   16a02:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
   16a04:	4631      	mov	r1, r6
   16a06:	4628      	mov	r0, r5
   16a08:	f7f2 fefe 	bl	9808 <_lv_obj_get_style_int>
            sh_width += LV_MATH_MAX(LV_MATH_ABS(sh_ofs_x), LV_MATH_ABS(sh_ofs_y));
   16a0c:	2800      	cmp	r0, #0
   16a0e:	bfb8      	it	lt
   16a10:	4240      	neglt	r0, r0
   16a12:	2f00      	cmp	r7, #0
   16a14:	bfb8      	it	lt
   16a16:	427f      	neglt	r7, r7
            sh_width += lv_obj_get_style_shadow_spread(obj, part);
   16a18:	b224      	sxth	r4, r4
            sh_width += LV_MATH_MAX(LV_MATH_ABS(sh_ofs_x), LV_MATH_ABS(sh_ofs_y));
   16a1a:	b280      	uxth	r0, r0
   16a1c:	b2bf      	uxth	r7, r7
   16a1e:	42b8      	cmp	r0, r7
   16a20:	bf2c      	ite	cs
   16a22:	1824      	addcs	r4, r4, r0
   16a24:	19e4      	addcc	r4, r4, r7
            s = LV_MATH_MAX(s, sh_width);
   16a26:	b224      	sxth	r4, r4
   16a28:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   16a2c:	e715      	b.n	1685a <lv_obj_get_draw_rect_ext_pad_size+0x1a>

00016a2e <lv_obj_get_focused_obj>:
    if(obj == NULL) return NULL;
   16a2e:	b908      	cbnz	r0, 16a34 <lv_obj_get_focused_obj+0x6>
   16a30:	4770      	bx	lr
    return obj->parent;
   16a32:	6800      	ldr	r0, [r0, #0]
    return obj->focus_parent == 0 ? false : true;
   16a34:	f890 3033 	ldrb.w	r3, [r0, #51]	; 0x33
    while(lv_obj_get_focus_parent(focus_obj) != false && focus_obj != NULL) {
   16a38:	079b      	lsls	r3, r3, #30
   16a3a:	d4fa      	bmi.n	16a32 <lv_obj_get_focused_obj+0x4>
}
   16a3c:	4770      	bx	lr

00016a3e <_lv_memcpy>:
   16a3e:	f006 bf90 	b.w	1d962 <memcpy>

00016a42 <lv_refr_get_top_obj>:
{
   16a42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(_lv_area_is_in(area_p, &obj->coords, 0) && obj->hidden == 0) {
   16a46:	2200      	movs	r2, #0
{
   16a48:	460c      	mov	r4, r1
    if(_lv_area_is_in(area_p, &obj->coords, 0) && obj->hidden == 0) {
   16a4a:	3110      	adds	r1, #16
{
   16a4c:	4607      	mov	r7, r0
    if(_lv_area_is_in(area_p, &obj->coords, 0) && obj->hidden == 0) {
   16a4e:	f004 fa18 	bl	1ae82 <_lv_area_is_in>
   16a52:	b910      	cbnz	r0, 16a5a <lv_refr_get_top_obj+0x18>
    lv_obj_t * found_p = NULL;
   16a54:	2000      	movs	r0, #0
}
   16a56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(_lv_area_is_in(area_p, &obj->coords, 0) && obj->hidden == 0) {
   16a5a:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
   16a5e:	06db      	lsls	r3, r3, #27
   16a60:	d4f8      	bmi.n	16a54 <lv_refr_get_top_obj+0x12>
        lv_design_res_t design_res = obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK);
   16a62:	2202      	movs	r2, #2
   16a64:	4639      	mov	r1, r7
   16a66:	4620      	mov	r0, r4
   16a68:	6a23      	ldr	r3, [r4, #32]
   16a6a:	4798      	blx	r3
        if(design_res == LV_DESIGN_RES_MASKED) return NULL;
   16a6c:	2803      	cmp	r0, #3
        lv_design_res_t design_res = obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK);
   16a6e:	4606      	mov	r6, r0
        if(design_res == LV_DESIGN_RES_MASKED) return NULL;
   16a70:	d0f0      	beq.n	16a54 <lv_refr_get_top_obj+0x12>
        _LV_LL_READ(obj->child_ll, i) {
   16a72:	f104 0804 	add.w	r8, r4, #4
   16a76:	4640      	mov	r0, r8
   16a78:	f004 fbc7 	bl	1b20a <_lv_ll_get_head>
   16a7c:	4605      	mov	r5, r0
   16a7e:	b918      	cbnz	r0, 16a88 <lv_refr_get_top_obj+0x46>
            if(design_res == LV_DESIGN_RES_COVER) {
   16a80:	2e01      	cmp	r6, #1
   16a82:	d1e7      	bne.n	16a54 <lv_refr_get_top_obj+0x12>
   16a84:	4620      	mov	r0, r4
   16a86:	e7e6      	b.n	16a56 <lv_refr_get_top_obj+0x14>
            found_p = lv_refr_get_top_obj(area_p, i);
   16a88:	4629      	mov	r1, r5
   16a8a:	4638      	mov	r0, r7
   16a8c:	f7ff ffd9 	bl	16a42 <lv_refr_get_top_obj>
            if(found_p != NULL) {
   16a90:	2800      	cmp	r0, #0
   16a92:	d1e0      	bne.n	16a56 <lv_refr_get_top_obj+0x14>
        _LV_LL_READ(obj->child_ll, i) {
   16a94:	4629      	mov	r1, r5
   16a96:	4640      	mov	r0, r8
   16a98:	f004 fbbd 	bl	1b216 <_lv_ll_get_next>
   16a9c:	e7ee      	b.n	16a7c <lv_refr_get_top_obj+0x3a>

00016a9e <lv_refr_obj>:
{
   16a9e:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(obj->hidden != 0) return;
   16aa0:	f890 7032 	ldrb.w	r7, [r0, #50]	; 0x32
{
   16aa4:	4604      	mov	r4, r0
    if(obj->hidden != 0) return;
   16aa6:	f017 0710 	ands.w	r7, r7, #16
{
   16aaa:	460e      	mov	r6, r1
   16aac:	b08b      	sub	sp, #44	; 0x2c
    if(obj->hidden != 0) return;
   16aae:	d13a      	bne.n	16b26 <lv_refr_obj+0x88>
    lv_obj_get_coords(obj, &obj_area);
   16ab0:	a904      	add	r1, sp, #16
    lv_coord_t ext_size = obj->ext_draw_pad;
   16ab2:	f9b0 5030 	ldrsh.w	r5, [r0, #48]	; 0x30
    lv_obj_get_coords(obj, &obj_area);
   16ab6:	f7fe ffe0 	bl	15a7a <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
   16aba:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    union_ok = _lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   16abe:	4631      	mov	r1, r6
    obj_area.x1 -= ext_size;
   16ac0:	1b5b      	subs	r3, r3, r5
   16ac2:	f8ad 3010 	strh.w	r3, [sp, #16]
    obj_area.y1 -= ext_size;
   16ac6:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    union_ok = _lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   16aca:	aa04      	add	r2, sp, #16
    obj_area.y1 -= ext_size;
   16acc:	1b5b      	subs	r3, r3, r5
   16ace:	f8ad 3012 	strh.w	r3, [sp, #18]
    obj_area.x2 += ext_size;
   16ad2:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    union_ok = _lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   16ad6:	a802      	add	r0, sp, #8
    obj_area.x2 += ext_size;
   16ad8:	442b      	add	r3, r5
   16ada:	f8ad 3014 	strh.w	r3, [sp, #20]
    obj_area.y2 += ext_size;
   16ade:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   16ae2:	441d      	add	r5, r3
   16ae4:	f8ad 5016 	strh.w	r5, [sp, #22]
    union_ok = _lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
   16ae8:	f004 f8d8 	bl	1ac9c <_lv_area_intersect>
    if(union_ok != false) {
   16aec:	b1d8      	cbz	r0, 16b26 <lv_refr_obj+0x88>
        if(obj->design_cb) obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
   16aee:	6a23      	ldr	r3, [r4, #32]
   16af0:	b11b      	cbz	r3, 16afa <lv_refr_obj+0x5c>
   16af2:	463a      	mov	r2, r7
   16af4:	4620      	mov	r0, r4
   16af6:	a902      	add	r1, sp, #8
   16af8:	4798      	blx	r3
        lv_obj_get_coords(obj, &obj_area);
   16afa:	4620      	mov	r0, r4
   16afc:	a904      	add	r1, sp, #16
   16afe:	f7fe ffbc 	bl	15a7a <lv_obj_get_coords>
        union_ok = _lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
   16b02:	4631      	mov	r1, r6
   16b04:	4668      	mov	r0, sp
   16b06:	aa04      	add	r2, sp, #16
   16b08:	f004 f8c8 	bl	1ac9c <_lv_area_intersect>
        if(union_ok != false) {
   16b0c:	b128      	cbz	r0, 16b1a <lv_refr_obj+0x7c>
            _LV_LL_READ_BACK(obj->child_ll, child_p) {
   16b0e:	1d26      	adds	r6, r4, #4
   16b10:	4630      	mov	r0, r6
   16b12:	f004 fb7d 	bl	1b210 <_lv_ll_get_tail>
   16b16:	4605      	mov	r5, r0
   16b18:	b938      	cbnz	r0, 16b2a <lv_refr_obj+0x8c>
        if(obj->design_cb) obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
   16b1a:	6a23      	ldr	r3, [r4, #32]
   16b1c:	b11b      	cbz	r3, 16b26 <lv_refr_obj+0x88>
   16b1e:	2201      	movs	r2, #1
   16b20:	4620      	mov	r0, r4
   16b22:	a902      	add	r1, sp, #8
   16b24:	4798      	blx	r3
}
   16b26:	b00b      	add	sp, #44	; 0x2c
   16b28:	bdf0      	pop	{r4, r5, r6, r7, pc}
                lv_obj_get_coords(child_p, &child_area);
   16b2a:	4628      	mov	r0, r5
   16b2c:	a908      	add	r1, sp, #32
   16b2e:	f7fe ffa4 	bl	15a7a <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
   16b32:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
                child_area.x1 -= ext_size;
   16b36:	f8bd 2020 	ldrh.w	r2, [sp, #32]
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
   16b3a:	4669      	mov	r1, sp
                child_area.x1 -= ext_size;
   16b3c:	1ad2      	subs	r2, r2, r3
   16b3e:	f8ad 2020 	strh.w	r2, [sp, #32]
                child_area.y1 -= ext_size;
   16b42:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
   16b46:	a806      	add	r0, sp, #24
                child_area.y1 -= ext_size;
   16b48:	1ad2      	subs	r2, r2, r3
   16b4a:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
                child_area.x2 += ext_size;
   16b4e:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   16b52:	441a      	add	r2, r3
   16b54:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                child_area.y2 += ext_size;
   16b58:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
   16b5c:	4413      	add	r3, r2
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
   16b5e:	aa08      	add	r2, sp, #32
                child_area.y2 += ext_size;
   16b60:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
   16b64:	f004 f89a 	bl	1ac9c <_lv_area_intersect>
                if(union_ok) {
   16b68:	b118      	cbz	r0, 16b72 <lv_refr_obj+0xd4>
                    lv_refr_obj(child_p, &mask_child);
   16b6a:	4628      	mov	r0, r5
   16b6c:	a906      	add	r1, sp, #24
   16b6e:	f7ff ff96 	bl	16a9e <lv_refr_obj>
            _LV_LL_READ_BACK(obj->child_ll, child_p) {
   16b72:	4629      	mov	r1, r5
   16b74:	4630      	mov	r0, r6
   16b76:	f004 fb53 	bl	1b220 <_lv_ll_get_prev>
   16b7a:	e7cc      	b.n	16b16 <lv_refr_obj+0x78>

00016b7c <_lv_memset_00>:
   16b7c:	460a      	mov	r2, r1
__ssp_bos_icheck3(memset, void *, int)
   16b7e:	2100      	movs	r1, #0
   16b80:	f006 befc 	b.w	1d97c <memset>

00016b84 <_lv_refr_init>:
}
   16b84:	4770      	bx	lr

00016b86 <_lv_inv_area>:
{
   16b86:	b5f0      	push	{r4, r5, r6, r7, lr}
   16b88:	460d      	mov	r5, r1
    if(!disp) disp = lv_disp_get_default();
   16b8a:	4604      	mov	r4, r0
{
   16b8c:	b085      	sub	sp, #20
    if(!disp) disp = lv_disp_get_default();
   16b8e:	b918      	cbnz	r0, 16b98 <_lv_inv_area+0x12>
   16b90:	f7f5 fcea 	bl	c568 <lv_disp_get_default>
    if(!disp) return;
   16b94:	4604      	mov	r4, r0
   16b96:	b130      	cbz	r0, 16ba6 <_lv_inv_area+0x20>
    if(area_p == NULL) {
   16b98:	b93d      	cbnz	r5, 16baa <_lv_inv_area+0x24>
        disp->inv_p = 0;
   16b9a:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
   16b9e:	f365 0309 	bfi	r3, r5, #0, #10
   16ba2:	f8a4 317e 	strh.w	r3, [r4, #382]	; 0x17e
}
   16ba6:	b005      	add	sp, #20
   16ba8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    scr_area.x1 = 0;
   16baa:	2300      	movs	r3, #0
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
   16bac:	4620      	mov	r0, r4
    scr_area.x1 = 0;
   16bae:	9300      	str	r3, [sp, #0]
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
   16bb0:	f7f5 fce0 	bl	c574 <lv_disp_get_hor_res>
   16bb4:	3801      	subs	r0, #1
   16bb6:	f8ad 0004 	strh.w	r0, [sp, #4]
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
   16bba:	4620      	mov	r0, r4
   16bbc:	f7f5 fcec 	bl	c598 <lv_disp_get_ver_res>
   16bc0:	3801      	subs	r0, #1
   16bc2:	f8ad 0006 	strh.w	r0, [sp, #6]
    suc = _lv_area_intersect(&com_area, area_p, &scr_area);
   16bc6:	466a      	mov	r2, sp
   16bc8:	4629      	mov	r1, r5
   16bca:	a802      	add	r0, sp, #8
   16bcc:	f004 f866 	bl	1ac9c <_lv_area_intersect>
    if(suc != false) {
   16bd0:	2800      	cmp	r0, #0
   16bd2:	d0e8      	beq.n	16ba6 <_lv_inv_area+0x20>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
   16bd4:	6923      	ldr	r3, [r4, #16]
   16bd6:	b113      	cbz	r3, 16bde <_lv_inv_area+0x58>
   16bd8:	4620      	mov	r0, r4
   16bda:	a902      	add	r1, sp, #8
   16bdc:	4798      	blx	r3
   16bde:	f104 055e 	add.w	r5, r4, #94	; 0x5e
{
   16be2:	2600      	movs	r6, #0
   16be4:	462f      	mov	r7, r5
        for(i = 0; i < disp->inv_p; i++) {
   16be6:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
   16bea:	b2b2      	uxth	r2, r6
   16bec:	f3c3 0009 	ubfx	r0, r3, #0, #10
   16bf0:	4290      	cmp	r0, r2
   16bf2:	d815      	bhi.n	16c20 <_lv_inv_area+0x9a>
        if(disp->inv_p < LV_INV_BUF_SIZE) {
   16bf4:	281f      	cmp	r0, #31
   16bf6:	d81d      	bhi.n	16c34 <_lv_inv_area+0xae>
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
   16bf8:	2208      	movs	r2, #8
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
   16bfa:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
   16bfe:	eb0d 0102 	add.w	r1, sp, r2
   16c02:	305e      	adds	r0, #94	; 0x5e
   16c04:	f7ff ff1b 	bl	16a3e <_lv_memcpy>
        disp->inv_p++;
   16c08:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
        lv_task_set_prio(disp->refr_task, LV_REFR_TASK_PRIO);
   16c0c:	2103      	movs	r1, #3
        disp->inv_p++;
   16c0e:	1c5a      	adds	r2, r3, #1
   16c10:	f362 0309 	bfi	r3, r2, #0, #10
        lv_task_set_prio(disp->refr_task, LV_REFR_TASK_PRIO);
   16c14:	6b20      	ldr	r0, [r4, #48]	; 0x30
        disp->inv_p++;
   16c16:	f8a4 317e 	strh.w	r3, [r4, #382]	; 0x17e
        lv_task_set_prio(disp->refr_task, LV_REFR_TASK_PRIO);
   16c1a:	f7f6 f979 	bl	cf10 <lv_task_set_prio>
   16c1e:	e7c2      	b.n	16ba6 <_lv_inv_area+0x20>
            if(_lv_area_is_in(&com_area, &disp->inv_areas[i], 0) != false) return;
   16c20:	4629      	mov	r1, r5
   16c22:	2200      	movs	r2, #0
   16c24:	a802      	add	r0, sp, #8
   16c26:	f004 f92c 	bl	1ae82 <_lv_area_is_in>
   16c2a:	3601      	adds	r6, #1
   16c2c:	3508      	adds	r5, #8
   16c2e:	2800      	cmp	r0, #0
   16c30:	d0d9      	beq.n	16be6 <_lv_inv_area+0x60>
   16c32:	e7b8      	b.n	16ba6 <_lv_inv_area+0x20>
            disp->inv_p = 0;
   16c34:	f36f 0309 	bfc	r3, #0, #10
   16c38:	2208      	movs	r2, #8
   16c3a:	4669      	mov	r1, sp
   16c3c:	4638      	mov	r0, r7
   16c3e:	f8a4 317e 	strh.w	r3, [r4, #382]	; 0x17e
   16c42:	e7df      	b.n	16c04 <_lv_inv_area+0x7e>

00016c44 <lv_style_list_get_style>:
    if(list->has_trans && list->skip_trans) id++;
   16c44:	8882      	ldrh	r2, [r0, #4]
{
   16c46:	4603      	mov	r3, r0
    if(list->has_trans && list->skip_trans) id++;
   16c48:	f402 72c0 	and.w	r2, r2, #384	; 0x180
   16c4c:	f5b2 7fc0 	cmp.w	r2, #384	; 0x180
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
   16c50:	7902      	ldrb	r2, [r0, #4]
    if(list->has_trans && list->skip_trans) id++;
   16c52:	bf04      	itt	eq
   16c54:	3101      	addeq	r1, #1
   16c56:	b2c9      	uxtbeq	r1, r1
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
   16c58:	f012 003f 	ands.w	r0, r2, #63	; 0x3f
   16c5c:	d006      	beq.n	16c6c <lv_style_list_get_style+0x28>
   16c5e:	4288      	cmp	r0, r1
   16c60:	d903      	bls.n	16c6a <lv_style_list_get_style+0x26>
    return list->style_list[id];
   16c62:	681b      	ldr	r3, [r3, #0]
   16c64:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
   16c68:	4770      	bx	lr
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
   16c6a:	2000      	movs	r0, #0
}
   16c6c:	4770      	bx	lr

00016c6e <get_prop_size>:
 * @param idx index of the style in style->map
 * @return attribute of property in style->map + idx
 */
static inline size_t get_prop_size(uint8_t prop_id)
{
    prop_id &= 0xF;
   16c6e:	f000 000f 	and.w	r0, r0, #15
    size_t size = sizeof(lv_style_property_t);
    if(prop_id < LV_STYLE_ID_COLOR) size += sizeof(lv_style_int_t);
   16c72:	2808      	cmp	r0, #8
   16c74:	d906      	bls.n	16c84 <get_prop_size+0x16>
    else if(prop_id < LV_STYLE_ID_OPA) size += sizeof(lv_color_t);
   16c76:	280b      	cmp	r0, #11
   16c78:	d906      	bls.n	16c88 <get_prop_size+0x1a>
    else if(prop_id < LV_STYLE_ID_PTR) size += sizeof(lv_opa_t);
   16c7a:	280d      	cmp	r0, #13
   16c7c:	bf8c      	ite	hi
   16c7e:	2006      	movhi	r0, #6
   16c80:	2003      	movls	r0, #3
   16c82:	4770      	bx	lr
    if(prop_id < LV_STYLE_ID_COLOR) size += sizeof(lv_style_int_t);
   16c84:	2004      	movs	r0, #4
   16c86:	4770      	bx	lr
    else size += sizeof(const void *);
   16c88:	2006      	movs	r0, #6
    return size;
}
   16c8a:	4770      	bx	lr

00016c8c <get_style_prop.isra.0>:
    prop_p[0] = style->map[idx];
   16c8c:	5c43      	ldrb	r3, [r0, r1]
static inline lv_style_property_t get_style_prop(const lv_style_t * style, size_t idx)
   16c8e:	b082      	sub	sp, #8
    prop_p[1] = style->map[idx + 1];
   16c90:	4408      	add	r0, r1
    prop_p[0] = style->map[idx];
   16c92:	f88d 3006 	strb.w	r3, [sp, #6]
    prop_p[1] = style->map[idx + 1];
   16c96:	7843      	ldrb	r3, [r0, #1]
   16c98:	f88d 3007 	strb.w	r3, [sp, #7]
}
   16c9c:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   16ca0:	b002      	add	sp, #8
   16ca2:	4770      	bx	lr

00016ca4 <get_style_prop_attr>:
{
   16ca4:	b508      	push	{r3, lr}
    return ((get_style_prop(style, idx) >> 8) & 0xFFU);
   16ca6:	6800      	ldr	r0, [r0, #0]
   16ca8:	f7ff fff0 	bl	16c8c <get_style_prop.isra.0>
}
   16cac:	f3c0 2007 	ubfx	r0, r0, #8, #8
   16cb0:	bd08      	pop	{r3, pc}

00016cb2 <get_property_index>:
{
   16cb2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(style->map == NULL) return -1;
   16cb6:	6803      	ldr	r3, [r0, #0]
{
   16cb8:	4605      	mov	r5, r0
   16cba:	460a      	mov	r2, r1
    if(style->map == NULL) return -1;
   16cbc:	b37b      	cbz	r3, 16d1e <get_property_index+0x6c>
    int16_t id_guess = -1;
   16cbe:	f04f 34ff 	mov.w	r4, #4294967295
            else if((LV_STYLE_ATTR_GET_STATE(attr_i) & (~LV_STYLE_ATTR_GET_STATE(attr))) == 0) {
   16cc2:	f3c2 2206 	ubfx	r2, r2, #8, #7
    uint8_t id_to_find = prop & 0xFF;
   16cc6:	b2cf      	uxtb	r7, r1
    attr = (prop >> 8) & 0xFF;
   16cc8:	ea4f 2811 	mov.w	r8, r1, lsr #8
    int16_t weight = -1;
   16ccc:	4626      	mov	r6, r4
    size_t i = 0;
   16cce:	2100      	movs	r1, #0
            else if((LV_STYLE_ATTR_GET_STATE(attr_i) & (~LV_STYLE_ATTR_GET_STATE(attr))) == 0) {
   16cd0:	43d2      	mvns	r2, r2
    return get_style_prop(style, idx) & 0xFF;
   16cd2:	6828      	ldr	r0, [r5, #0]
   16cd4:	f7ff ffda 	bl	16c8c <get_style_prop.isra.0>
   16cd8:	fa5f f980 	uxtb.w	r9, r0
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
   16cdc:	f1b9 0fff 	cmp.w	r9, #255	; 0xff
   16ce0:	d101      	bne.n	16ce6 <get_property_index+0x34>
    return id_guess;
   16ce2:	4620      	mov	r0, r4
   16ce4:	e00a      	b.n	16cfc <get_property_index+0x4a>
        if(prop_id == id_to_find) {
   16ce6:	454f      	cmp	r7, r9
   16ce8:	d114      	bne.n	16d14 <get_property_index+0x62>
            attr_i = get_style_prop_attr(style, i);
   16cea:	4628      	mov	r0, r5
   16cec:	f7ff ffda 	bl	16ca4 <get_style_prop_attr>
   16cf0:	4603      	mov	r3, r0
            if(LV_STYLE_ATTR_GET_STATE(attr_i) == LV_STYLE_ATTR_GET_STATE(attr)) {
   16cf2:	ea88 0000 	eor.w	r0, r8, r0
   16cf6:	0640      	lsls	r0, r0, #25
   16cf8:	d102      	bne.n	16d00 <get_property_index+0x4e>
                return i;
   16cfa:	4608      	mov	r0, r1
}
   16cfc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            else if((LV_STYLE_ATTR_GET_STATE(attr_i) & (~LV_STYLE_ATTR_GET_STATE(attr))) == 0) {
   16d00:	ea02 0003 	and.w	r0, r2, r3
   16d04:	0640      	lsls	r0, r0, #25
   16d06:	d105      	bne.n	16d14 <get_property_index+0x62>
                if(LV_STYLE_ATTR_GET_STATE(attr_i) > weight) {
   16d08:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   16d0c:	42b3      	cmp	r3, r6
                    weight = LV_STYLE_ATTR_GET_STATE(attr_i);
   16d0e:	bfc4      	itt	gt
   16d10:	b21e      	sxthgt	r6, r3
                    id_guess = i;
   16d12:	b20c      	sxthgt	r4, r1
 * @param idx index of the style in style->map
 * @return index of next property in style->map
 */
static inline size_t get_next_prop_index(uint8_t prop_id, size_t idx)
{
    return idx + get_prop_size(prop_id);
   16d14:	4648      	mov	r0, r9
   16d16:	f7ff ffaa 	bl	16c6e <get_prop_size>
   16d1a:	4401      	add	r1, r0
   16d1c:	e7d9      	b.n	16cd2 <get_property_index+0x20>
    if(style->map == NULL) return -1;
   16d1e:	f04f 30ff 	mov.w	r0, #4294967295
   16d22:	e7eb      	b.n	16cfc <get_property_index+0x4a>

00016d24 <_lv_memset_00>:
   16d24:	460a      	mov	r2, r1
   16d26:	2100      	movs	r1, #0
   16d28:	f006 be28 	b.w	1d97c <memset>

00016d2c <_lv_memcpy>:
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   16d2c:	f006 be19 	b.w	1d962 <memcpy>

00016d30 <style_resize.isra.0>:
static inline void style_resize(lv_style_t * style, size_t sz)
   16d30:	b510      	push	{r4, lr}
   16d32:	4604      	mov	r4, r0
    style->map = lv_mem_realloc(style->map, sz);
   16d34:	6800      	ldr	r0, [r0, #0]
   16d36:	f004 fb79 	bl	1b42c <lv_mem_realloc>
   16d3a:	6020      	str	r0, [r4, #0]
}
   16d3c:	bd10      	pop	{r4, pc}

00016d3e <lv_style_init>:
    _lv_memset_00(style, sizeof(lv_style_t));
   16d3e:	2104      	movs	r1, #4
   16d40:	f7ff bff0 	b.w	16d24 <_lv_memset_00>

00016d44 <lv_style_list_init>:
    _lv_memset_00(list, sizeof(lv_style_list_t));
   16d44:	2108      	movs	r1, #8
   16d46:	f7ff bfed 	b.w	16d24 <_lv_memset_00>

00016d4a <_lv_style_list_remove_style>:
{
   16d4a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16d4c:	4604      	mov	r4, r0
    if(list->style_cnt == 0) return;
   16d4e:	7900      	ldrb	r0, [r0, #4]
{
   16d50:	460e      	mov	r6, r1
    if(list->style_cnt == 0) return;
   16d52:	f010 013f 	ands.w	r1, r0, #63	; 0x3f
   16d56:	d004      	beq.n	16d62 <_lv_style_list_remove_style+0x18>
    for(i = 0; i < list->style_cnt; i++) {
   16d58:	460b      	mov	r3, r1
   16d5a:	2200      	movs	r2, #0
   16d5c:	b2d0      	uxtb	r0, r2
   16d5e:	4283      	cmp	r3, r0
   16d60:	d800      	bhi.n	16d64 <_lv_style_list_remove_style+0x1a>
}
   16d62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if(list->style_list[i] == style) {
   16d64:	6820      	ldr	r0, [r4, #0]
   16d66:	f850 5022 	ldr.w	r5, [r0, r2, lsl #2]
   16d6a:	3201      	adds	r2, #1
   16d6c:	42b5      	cmp	r5, r6
   16d6e:	d1f5      	bne.n	16d5c <_lv_style_list_remove_style+0x12>
    if(list->style_cnt == 1) {
   16d70:	2901      	cmp	r1, #1
   16d72:	d108      	bne.n	16d86 <_lv_style_list_remove_style+0x3c>
        lv_mem_free(list->style_list);
   16d74:	f7f5 fea4 	bl	cac0 <lv_mem_free>
        list->style_list = NULL;
   16d78:	2300      	movs	r3, #0
   16d7a:	6023      	str	r3, [r4, #0]
        list->style_cnt = 0;
   16d7c:	7923      	ldrb	r3, [r4, #4]
   16d7e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   16d82:	7123      	strb	r3, [r4, #4]
        return;
   16d84:	e7ed      	b.n	16d62 <_lv_style_list_remove_style+0x18>
    lv_style_t ** new_classes = lv_mem_alloc(sizeof(lv_style_t *) * (list->style_cnt - 1));
   16d86:	1e58      	subs	r0, r3, #1
   16d88:	0080      	lsls	r0, r0, #2
   16d8a:	f7f5 fe85 	bl	ca98 <lv_mem_alloc>
    if(new_classes == NULL) {
   16d8e:	4605      	mov	r5, r0
   16d90:	2800      	cmp	r0, #0
   16d92:	d0e6      	beq.n	16d62 <_lv_style_list_remove_style+0x18>
    for(i = 0, j = 0; i < list->style_cnt; i++) {
   16d94:	2300      	movs	r3, #0
   16d96:	461a      	mov	r2, r3
   16d98:	7921      	ldrb	r1, [r4, #4]
   16d9a:	6820      	ldr	r0, [r4, #0]
   16d9c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
   16da0:	b2df      	uxtb	r7, r3
   16da2:	42b9      	cmp	r1, r7
   16da4:	d809      	bhi.n	16dba <_lv_style_list_remove_style+0x70>
    lv_mem_free(list->style_list);
   16da6:	f7f5 fe8b 	bl	cac0 <lv_mem_free>
    list->style_cnt--;
   16daa:	7923      	ldrb	r3, [r4, #4]
    list->style_list = new_classes;
   16dac:	6025      	str	r5, [r4, #0]
    list->style_cnt--;
   16dae:	f103 023f 	add.w	r2, r3, #63	; 0x3f
   16db2:	f362 0305 	bfi	r3, r2, #0, #6
   16db6:	7123      	strb	r3, [r4, #4]
    list->style_list = new_classes;
   16db8:	e7d3      	b.n	16d62 <_lv_style_list_remove_style+0x18>
        if(list->style_list[i] == style) continue;
   16dba:	f850 7023 	ldr.w	r7, [r0, r3, lsl #2]
   16dbe:	3301      	adds	r3, #1
   16dc0:	42b7      	cmp	r7, r6
        new_classes[j] = list->style_list[i];
   16dc2:	bf1e      	ittt	ne
   16dc4:	f845 7022 	strne.w	r7, [r5, r2, lsl #2]
        j++;
   16dc8:	3201      	addne	r2, #1
   16dca:	b2d2      	uxtbne	r2, r2
    for(i = 0, j = 0; i < list->style_cnt; i++) {
   16dcc:	e7e8      	b.n	16da0 <_lv_style_list_remove_style+0x56>

00016dce <_lv_style_list_add_style>:
{
   16dce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16dd0:	460d      	mov	r5, r1
    if(list == NULL) return;
   16dd2:	4604      	mov	r4, r0
   16dd4:	b1e8      	cbz	r0, 16e12 <_lv_style_list_add_style+0x44>
    _lv_style_list_remove_style(list, style);
   16dd6:	f7ff ffb8 	bl	16d4a <_lv_style_list_remove_style>
    if(list->style_cnt == 0) new_classes = lv_mem_alloc(sizeof(lv_style_t *));
   16dda:	7921      	ldrb	r1, [r4, #4]
   16ddc:	0688      	lsls	r0, r1, #26
   16dde:	d119      	bne.n	16e14 <_lv_style_list_add_style+0x46>
   16de0:	2004      	movs	r0, #4
   16de2:	f7f5 fe59 	bl	ca98 <lv_mem_alloc>
    if(new_classes == NULL) {
   16de6:	b1a0      	cbz	r0, 16e12 <_lv_style_list_add_style+0x44>
    if(list->has_trans) first_style++;
   16de8:	7923      	ldrb	r3, [r4, #4]
    if(list->has_local) first_style++;
   16dea:	0659      	lsls	r1, r3, #25
    if(list->has_trans) first_style++;
   16dec:	ea4f 12d3 	mov.w	r2, r3, lsr #7
    for(i = list->style_cnt; i > first_style; i--) {
   16df0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   16df4:	4619      	mov	r1, r3
    if(list->has_local) first_style++;
   16df6:	bf48      	it	mi
   16df8:	3201      	addmi	r2, #1
    for(i = list->style_cnt; i > first_style; i--) {
   16dfa:	eb00 0683 	add.w	r6, r0, r3, lsl #2
   16dfe:	4291      	cmp	r1, r2
   16e00:	d810      	bhi.n	16e24 <_lv_style_list_add_style+0x56>
    new_classes[first_style] = style;
   16e02:	f840 5022 	str.w	r5, [r0, r2, lsl #2]
    list->style_cnt++;
   16e06:	7922      	ldrb	r2, [r4, #4]
   16e08:	3301      	adds	r3, #1
   16e0a:	f363 0205 	bfi	r2, r3, #0, #6
   16e0e:	7122      	strb	r2, [r4, #4]
    list->style_list = new_classes;
   16e10:	6020      	str	r0, [r4, #0]
}
   16e12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else new_classes = lv_mem_realloc(list->style_list, sizeof(lv_style_t *) * (list->style_cnt + 1));
   16e14:	f001 013f 	and.w	r1, r1, #63	; 0x3f
   16e18:	3101      	adds	r1, #1
   16e1a:	6820      	ldr	r0, [r4, #0]
   16e1c:	0089      	lsls	r1, r1, #2
   16e1e:	f004 fb05 	bl	1b42c <lv_mem_realloc>
   16e22:	e7e0      	b.n	16de6 <_lv_style_list_add_style+0x18>
        new_classes[i] = new_classes[i - 1];
   16e24:	f856 7c04 	ldr.w	r7, [r6, #-4]
    for(i = list->style_cnt; i > first_style; i--) {
   16e28:	3901      	subs	r1, #1
        new_classes[i] = new_classes[i - 1];
   16e2a:	f846 7904 	str.w	r7, [r6], #-4
    for(i = list->style_cnt; i > first_style; i--) {
   16e2e:	b2c9      	uxtb	r1, r1
   16e30:	e7e5      	b.n	16dfe <_lv_style_list_add_style+0x30>

00016e32 <get_alloc_local_style>:
    if(list->has_local) return lv_style_list_get_style(list, list->has_trans ? 1 : 0);
   16e32:	7901      	ldrb	r1, [r0, #4]
{
   16e34:	b538      	push	{r3, r4, r5, lr}
    if(list->has_local) return lv_style_list_get_style(list, list->has_trans ? 1 : 0);
   16e36:	064b      	lsls	r3, r1, #25
{
   16e38:	4604      	mov	r4, r0
    if(list->has_local) return lv_style_list_get_style(list, list->has_trans ? 1 : 0);
   16e3a:	d504      	bpl.n	16e46 <get_alloc_local_style+0x14>
}
   16e3c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if(list->has_local) return lv_style_list_get_style(list, list->has_trans ? 1 : 0);
   16e40:	09c9      	lsrs	r1, r1, #7
   16e42:	f7ff beff 	b.w	16c44 <lv_style_list_get_style>
    lv_style_t * local_style = lv_mem_alloc(sizeof(lv_style_t));
   16e46:	2004      	movs	r0, #4
   16e48:	f7f5 fe26 	bl	ca98 <lv_mem_alloc>
    if(local_style == NULL) {
   16e4c:	4605      	mov	r5, r0
   16e4e:	b148      	cbz	r0, 16e64 <get_alloc_local_style+0x32>
    lv_style_init(local_style);
   16e50:	f7ff ff75 	bl	16d3e <lv_style_init>
    _lv_style_list_add_style(list, local_style);
   16e54:	4629      	mov	r1, r5
   16e56:	4620      	mov	r0, r4
   16e58:	f7ff ffb9 	bl	16dce <_lv_style_list_add_style>
    list->has_local = 1;
   16e5c:	7923      	ldrb	r3, [r4, #4]
   16e5e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   16e62:	7123      	strb	r3, [r4, #4]
}
   16e64:	4628      	mov	r0, r5
   16e66:	bd38      	pop	{r3, r4, r5, pc}

00016e68 <lv_style_reset>:
{
   16e68:	b510      	push	{r4, lr}
   16e6a:	4604      	mov	r4, r0
    lv_mem_free(style->map);
   16e6c:	6800      	ldr	r0, [r0, #0]
   16e6e:	f7f5 fe27 	bl	cac0 <lv_mem_free>
    style->map = NULL;
   16e72:	2300      	movs	r3, #0
   16e74:	6023      	str	r3, [r4, #0]
}
   16e76:	bd10      	pop	{r4, pc}

00016e78 <_lv_style_get_mem_size>:
{
   16e78:	4602      	mov	r2, r0
    if(style->map == NULL) return 0;
   16e7a:	6800      	ldr	r0, [r0, #0]
{
   16e7c:	b508      	push	{r3, lr}
    if(style->map == NULL) return 0;
   16e7e:	b140      	cbz	r0, 16e92 <_lv_style_get_mem_size+0x1a>
    size_t i = 0;
   16e80:	2100      	movs	r1, #0
    return get_style_prop(style, idx) & 0xFF;
   16e82:	6810      	ldr	r0, [r2, #0]
   16e84:	f7ff ff02 	bl	16c8c <get_style_prop.isra.0>
   16e88:	b2c0      	uxtb	r0, r0
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
   16e8a:	28ff      	cmp	r0, #255	; 0xff
   16e8c:	d102      	bne.n	16e94 <_lv_style_get_mem_size+0x1c>
    return i + sizeof(lv_style_property_t);
   16e8e:	3102      	adds	r1, #2
   16e90:	b288      	uxth	r0, r1
}
   16e92:	bd08      	pop	{r3, pc}
    return idx + get_prop_size(prop_id);
   16e94:	f7ff feeb 	bl	16c6e <get_prop_size>
   16e98:	4401      	add	r1, r0
   16e9a:	e7f2      	b.n	16e82 <_lv_style_get_mem_size+0xa>

00016e9c <lv_style_copy>:
{
   16e9c:	b570      	push	{r4, r5, r6, lr}
   16e9e:	4606      	mov	r6, r0
    if(style_src == NULL) return;
   16ea0:	460c      	mov	r4, r1
   16ea2:	b171      	cbz	r1, 16ec2 <lv_style_copy+0x26>
    if(style_src->map == NULL) return;
   16ea4:	680b      	ldr	r3, [r1, #0]
   16ea6:	b163      	cbz	r3, 16ec2 <lv_style_copy+0x26>
    uint16_t size = _lv_style_get_mem_size(style_src);
   16ea8:	4608      	mov	r0, r1
   16eaa:	f7ff ffe5 	bl	16e78 <_lv_style_get_mem_size>
   16eae:	4605      	mov	r5, r0
    style_dest->map = lv_mem_alloc(size);
   16eb0:	f7f5 fdf2 	bl	ca98 <lv_mem_alloc>
   16eb4:	6030      	str	r0, [r6, #0]
    _lv_memcpy(style_dest->map, style_src->map, size);
   16eb6:	462a      	mov	r2, r5
   16eb8:	6821      	ldr	r1, [r4, #0]
}
   16eba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    _lv_memcpy(style_dest->map, style_src->map, size);
   16ebe:	f7ff bf35 	b.w	16d2c <_lv_memcpy>
}
   16ec2:	bd70      	pop	{r4, r5, r6, pc}

00016ec4 <lv_style_remove_prop>:
{
   16ec4:	b570      	push	{r4, r5, r6, lr}
   16ec6:	460e      	mov	r6, r1
    if(style == NULL) return false;
   16ec8:	4605      	mov	r5, r0
   16eca:	b908      	cbnz	r0, 16ed0 <lv_style_remove_prop+0xc>
   16ecc:	2000      	movs	r0, #0
}
   16ece:	bd70      	pop	{r4, r5, r6, pc}
    int32_t id = get_property_index(style, prop);
   16ed0:	f7ff feef 	bl	16cb2 <get_property_index>
    if(id >= 0) {
   16ed4:	1e04      	subs	r4, r0, #0
   16ed6:	dbf9      	blt.n	16ecc <lv_style_remove_prop+0x8>
        attr_found = get_style_prop_attr(style, id);
   16ed8:	4621      	mov	r1, r4
   16eda:	4628      	mov	r0, r5
   16edc:	f7ff fee2 	bl	16ca4 <get_style_prop_attr>
        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
   16ee0:	ea80 2016 	eor.w	r0, r0, r6, lsr #8
   16ee4:	0643      	lsls	r3, r0, #25
   16ee6:	d1f1      	bne.n	16ecc <lv_style_remove_prop+0x8>
            uint32_t map_size = _lv_style_get_mem_size(style);
   16ee8:	4628      	mov	r0, r5
   16eea:	f7ff ffc5 	bl	16e78 <_lv_style_get_mem_size>
   16eee:	4601      	mov	r1, r0
            uint8_t prop_size = get_prop_size(prop);
   16ef0:	b2f0      	uxtb	r0, r6
   16ef2:	f7ff febc 	bl	16c6e <get_prop_size>
            for(i = id; i < map_size - prop_size; i++) {
   16ef6:	b2c3      	uxtb	r3, r0
   16ef8:	1ac9      	subs	r1, r1, r3
   16efa:	42a1      	cmp	r1, r4
   16efc:	d804      	bhi.n	16f08 <lv_style_remove_prop+0x44>
            style_resize(style, map_size - prop_size);
   16efe:	4628      	mov	r0, r5
   16f00:	f7ff ff16 	bl	16d30 <style_resize.isra.0>
            return true;
   16f04:	2001      	movs	r0, #1
   16f06:	e7e2      	b.n	16ece <lv_style_remove_prop+0xa>
                style->map[i] = style->map[i + prop_size];
   16f08:	682a      	ldr	r2, [r5, #0]
   16f0a:	1910      	adds	r0, r2, r4
   16f0c:	5cc0      	ldrb	r0, [r0, r3]
   16f0e:	5510      	strb	r0, [r2, r4]
            for(i = id; i < map_size - prop_size; i++) {
   16f10:	3401      	adds	r4, #1
   16f12:	e7f2      	b.n	16efa <lv_style_remove_prop+0x36>

00016f14 <_lv_style_set_int>:
{
   16f14:	b530      	push	{r4, r5, lr}
   16f16:	b085      	sub	sp, #20
   16f18:	f8ad 1006 	strh.w	r1, [sp, #6]
   16f1c:	4605      	mov	r5, r0
   16f1e:	f8ad 2004 	strh.w	r2, [sp, #4]
    int32_t id = get_property_index(style, prop);
   16f22:	f7ff fec6 	bl	16cb2 <get_property_index>
    if(id >= 0) {
   16f26:	1e01      	subs	r1, r0, #0
   16f28:	db11      	blt.n	16f4e <_lv_style_set_int+0x3a>
        attr_found = get_style_prop_attr(style, id);
   16f2a:	4628      	mov	r0, r5
   16f2c:	f7ff feba 	bl	16ca4 <get_style_prop_attr>
        attr_goal = (prop >> 8) & 0xFFU;
   16f30:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
   16f34:	ea80 2013 	eor.w	r0, r0, r3, lsr #8
   16f38:	0643      	lsls	r3, r0, #25
   16f3a:	d108      	bne.n	16f4e <_lv_style_set_int+0x3a>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &value, sizeof(lv_style_int_t));
   16f3c:	2202      	movs	r2, #2
   16f3e:	682b      	ldr	r3, [r5, #0]
   16f40:	1c88      	adds	r0, r1, #2
   16f42:	4418      	add	r0, r3
   16f44:	a901      	add	r1, sp, #4
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   16f46:	f7ff fef1 	bl	16d2c <_lv_memcpy>
}
   16f4a:	b005      	add	sp, #20
   16f4c:	bd30      	pop	{r4, r5, pc}
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   16f4e:	23ff      	movs	r3, #255	; 0xff
    uint16_t size = _lv_style_get_mem_size(style);
   16f50:	4628      	mov	r0, r5
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   16f52:	f8ad 300e 	strh.w	r3, [sp, #14]
    uint16_t size = _lv_style_get_mem_size(style);
   16f56:	f7ff ff8f 	bl	16e78 <_lv_style_get_mem_size>
    if(size == 0) size += end_mark_size;
   16f5a:	1e04      	subs	r4, r0, #0
   16f5c:	bf08      	it	eq
   16f5e:	2402      	moveq	r4, #2
    size += sizeof(lv_style_property_t) + sizeof(lv_style_int_t);
   16f60:	3404      	adds	r4, #4
    style_resize(style, size);
   16f62:	b2a4      	uxth	r4, r4
   16f64:	4621      	mov	r1, r4
   16f66:	4628      	mov	r0, r5
   16f68:	f7ff fee2 	bl	16d30 <style_resize.isra.0>
    if(style == NULL) return;
   16f6c:	2d00      	cmp	r5, #0
   16f6e:	d0ec      	beq.n	16f4a <_lv_style_set_int+0x36>
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   16f70:	6828      	ldr	r0, [r5, #0]
   16f72:	1fa3      	subs	r3, r4, #6
   16f74:	2202      	movs	r2, #2
   16f76:	f10d 0106 	add.w	r1, sp, #6
   16f7a:	4418      	add	r0, r3
   16f7c:	f7ff fed6 	bl	16d2c <_lv_memcpy>
    _lv_memcpy_small(style->map + size - sizeof(lv_style_int_t) - end_mark_size, &value, sizeof(lv_style_int_t));
   16f80:	6828      	ldr	r0, [r5, #0]
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   16f82:	1f23      	subs	r3, r4, #4
    _lv_memcpy_small(style->map + size - sizeof(lv_style_int_t) - end_mark_size, &value, sizeof(lv_style_int_t));
   16f84:	2202      	movs	r2, #2
   16f86:	a901      	add	r1, sp, #4
   16f88:	4418      	add	r0, r3
   16f8a:	f7ff fecf 	bl	16d2c <_lv_memcpy>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   16f8e:	6828      	ldr	r0, [r5, #0]
    _lv_memcpy_small(style->map + size - sizeof(lv_style_int_t) - end_mark_size, &value, sizeof(lv_style_int_t));
   16f90:	3c02      	subs	r4, #2
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   16f92:	2202      	movs	r2, #2
   16f94:	f10d 010e 	add.w	r1, sp, #14
   16f98:	4420      	add	r0, r4
   16f9a:	e7d4      	b.n	16f46 <_lv_style_set_int+0x32>

00016f9c <_lv_style_set_color>:
{
   16f9c:	b530      	push	{r4, r5, lr}
   16f9e:	b085      	sub	sp, #20
   16fa0:	f8ad 1006 	strh.w	r1, [sp, #6]
   16fa4:	4605      	mov	r5, r0
   16fa6:	9200      	str	r2, [sp, #0]
    int32_t id = get_property_index(style, prop);
   16fa8:	f7ff fe83 	bl	16cb2 <get_property_index>
    if(id >= 0) {
   16fac:	1e01      	subs	r1, r0, #0
   16fae:	db11      	blt.n	16fd4 <_lv_style_set_color+0x38>
        attr_found = get_style_prop_attr(style, id);
   16fb0:	4628      	mov	r0, r5
   16fb2:	f7ff fe77 	bl	16ca4 <get_style_prop_attr>
        attr_goal = (prop >> 8) & 0xFFU;
   16fb6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
   16fba:	ea80 2013 	eor.w	r0, r0, r3, lsr #8
   16fbe:	0643      	lsls	r3, r0, #25
   16fc0:	d108      	bne.n	16fd4 <_lv_style_set_color+0x38>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &color, sizeof(lv_color_t));
   16fc2:	1c88      	adds	r0, r1, #2
   16fc4:	2204      	movs	r2, #4
   16fc6:	4669      	mov	r1, sp
   16fc8:	682b      	ldr	r3, [r5, #0]
   16fca:	4418      	add	r0, r3
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   16fcc:	f7ff feae 	bl	16d2c <_lv_memcpy>
}
   16fd0:	b005      	add	sp, #20
   16fd2:	bd30      	pop	{r4, r5, pc}
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   16fd4:	23ff      	movs	r3, #255	; 0xff
    uint16_t size = _lv_style_get_mem_size(style);
   16fd6:	4628      	mov	r0, r5
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   16fd8:	f8ad 300e 	strh.w	r3, [sp, #14]
    uint16_t size = _lv_style_get_mem_size(style);
   16fdc:	f7ff ff4c 	bl	16e78 <_lv_style_get_mem_size>
    if(size == 0) size += end_mark_size;
   16fe0:	1e04      	subs	r4, r0, #0
   16fe2:	bf08      	it	eq
   16fe4:	2402      	moveq	r4, #2
    size += sizeof(lv_style_property_t) + sizeof(lv_color_t);
   16fe6:	3406      	adds	r4, #6
    style_resize(style, size);
   16fe8:	b2a4      	uxth	r4, r4
   16fea:	4621      	mov	r1, r4
   16fec:	4628      	mov	r0, r5
   16fee:	f7ff fe9f 	bl	16d30 <style_resize.isra.0>
    if(style == NULL) return;
   16ff2:	2d00      	cmp	r5, #0
   16ff4:	d0ec      	beq.n	16fd0 <_lv_style_set_color+0x34>
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   16ff6:	6828      	ldr	r0, [r5, #0]
   16ff8:	f1a4 0308 	sub.w	r3, r4, #8
   16ffc:	2202      	movs	r2, #2
   16ffe:	f10d 0106 	add.w	r1, sp, #6
   17002:	4418      	add	r0, r3
   17004:	f7ff fe92 	bl	16d2c <_lv_memcpy>
    _lv_memcpy_small(style->map + size - sizeof(lv_color_t) - end_mark_size, &color, sizeof(lv_color_t));
   17008:	6828      	ldr	r0, [r5, #0]
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   1700a:	1fa3      	subs	r3, r4, #6
    _lv_memcpy_small(style->map + size - sizeof(lv_color_t) - end_mark_size, &color, sizeof(lv_color_t));
   1700c:	2204      	movs	r2, #4
   1700e:	4669      	mov	r1, sp
   17010:	4418      	add	r0, r3
   17012:	f7ff fe8b 	bl	16d2c <_lv_memcpy>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   17016:	6828      	ldr	r0, [r5, #0]
    _lv_memcpy_small(style->map + size - sizeof(lv_color_t) - end_mark_size, &color, sizeof(lv_color_t));
   17018:	3c02      	subs	r4, #2
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   1701a:	2202      	movs	r2, #2
   1701c:	f10d 010e 	add.w	r1, sp, #14
   17020:	4420      	add	r0, r4
   17022:	e7d3      	b.n	16fcc <_lv_style_set_color+0x30>

00017024 <_lv_style_set_opa>:
{
   17024:	b530      	push	{r4, r5, lr}
   17026:	b085      	sub	sp, #20
   17028:	f8ad 1006 	strh.w	r1, [sp, #6]
   1702c:	4605      	mov	r5, r0
   1702e:	f88d 2005 	strb.w	r2, [sp, #5]
    int32_t id = get_property_index(style, prop);
   17032:	f7ff fe3e 	bl	16cb2 <get_property_index>
    if(id >= 0) {
   17036:	1e01      	subs	r1, r0, #0
   17038:	db12      	blt.n	17060 <_lv_style_set_opa+0x3c>
        attr_found = get_style_prop_attr(style, id);
   1703a:	4628      	mov	r0, r5
   1703c:	f7ff fe32 	bl	16ca4 <get_style_prop_attr>
        attr_goal = (prop >> 8) & 0xFFU;
   17040:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
   17044:	ea80 2013 	eor.w	r0, r0, r3, lsr #8
   17048:	0643      	lsls	r3, r0, #25
   1704a:	d109      	bne.n	17060 <_lv_style_set_opa+0x3c>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &opa, sizeof(lv_opa_t));
   1704c:	2201      	movs	r2, #1
   1704e:	682b      	ldr	r3, [r5, #0]
   17050:	1c88      	adds	r0, r1, #2
   17052:	4418      	add	r0, r3
   17054:	f10d 0105 	add.w	r1, sp, #5
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   17058:	f7ff fe68 	bl	16d2c <_lv_memcpy>
}
   1705c:	b005      	add	sp, #20
   1705e:	bd30      	pop	{r4, r5, pc}
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   17060:	23ff      	movs	r3, #255	; 0xff
    uint16_t size = _lv_style_get_mem_size(style);
   17062:	4628      	mov	r0, r5
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   17064:	f8ad 300e 	strh.w	r3, [sp, #14]
    uint16_t size = _lv_style_get_mem_size(style);
   17068:	f7ff ff06 	bl	16e78 <_lv_style_get_mem_size>
    if(size == 0) size += end_mark_size;
   1706c:	1e04      	subs	r4, r0, #0
   1706e:	bf08      	it	eq
   17070:	2402      	moveq	r4, #2
    size += sizeof(lv_style_property_t) + sizeof(lv_opa_t);
   17072:	3403      	adds	r4, #3
    style_resize(style, size);
   17074:	b2a4      	uxth	r4, r4
   17076:	4621      	mov	r1, r4
   17078:	4628      	mov	r0, r5
   1707a:	f7ff fe59 	bl	16d30 <style_resize.isra.0>
    if(style == NULL) return;
   1707e:	2d00      	cmp	r5, #0
   17080:	d0ec      	beq.n	1705c <_lv_style_set_opa+0x38>
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   17082:	6828      	ldr	r0, [r5, #0]
   17084:	1f63      	subs	r3, r4, #5
   17086:	2202      	movs	r2, #2
   17088:	f10d 0106 	add.w	r1, sp, #6
   1708c:	4418      	add	r0, r3
   1708e:	f7ff fe4d 	bl	16d2c <_lv_memcpy>
    _lv_memcpy_small(style->map + size - sizeof(lv_opa_t) - end_mark_size, &opa, sizeof(lv_opa_t));
   17092:	6828      	ldr	r0, [r5, #0]
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   17094:	1ee3      	subs	r3, r4, #3
    _lv_memcpy_small(style->map + size - sizeof(lv_opa_t) - end_mark_size, &opa, sizeof(lv_opa_t));
   17096:	2201      	movs	r2, #1
   17098:	f10d 0105 	add.w	r1, sp, #5
   1709c:	4418      	add	r0, r3
   1709e:	f7ff fe45 	bl	16d2c <_lv_memcpy>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   170a2:	6828      	ldr	r0, [r5, #0]
    _lv_memcpy_small(style->map + size - sizeof(lv_opa_t) - end_mark_size, &opa, sizeof(lv_opa_t));
   170a4:	3c02      	subs	r4, #2
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   170a6:	2202      	movs	r2, #2
   170a8:	f10d 010e 	add.w	r1, sp, #14
   170ac:	4420      	add	r0, r4
   170ae:	e7d3      	b.n	17058 <_lv_style_set_opa+0x34>

000170b0 <_lv_style_set_ptr>:
{
   170b0:	b530      	push	{r4, r5, lr}
   170b2:	b085      	sub	sp, #20
   170b4:	f8ad 1006 	strh.w	r1, [sp, #6]
   170b8:	4605      	mov	r5, r0
   170ba:	9200      	str	r2, [sp, #0]
    int32_t id = get_property_index(style, prop);
   170bc:	f7ff fdf9 	bl	16cb2 <get_property_index>
    if(id >= 0) {
   170c0:	1e01      	subs	r1, r0, #0
   170c2:	db11      	blt.n	170e8 <_lv_style_set_ptr+0x38>
        attr_found = get_style_prop_attr(style, id);
   170c4:	4628      	mov	r0, r5
   170c6:	f7ff fded 	bl	16ca4 <get_style_prop_attr>
        attr_goal = (prop >> 8) & 0xFFU;
   170ca:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
   170ce:	ea80 2013 	eor.w	r0, r0, r3, lsr #8
   170d2:	0643      	lsls	r3, r0, #25
   170d4:	d108      	bne.n	170e8 <_lv_style_set_ptr+0x38>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &p, sizeof(const void *));
   170d6:	1c88      	adds	r0, r1, #2
   170d8:	2204      	movs	r2, #4
   170da:	4669      	mov	r1, sp
   170dc:	682b      	ldr	r3, [r5, #0]
   170de:	4418      	add	r0, r3
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   170e0:	f7ff fe24 	bl	16d2c <_lv_memcpy>
}
   170e4:	b005      	add	sp, #20
   170e6:	bd30      	pop	{r4, r5, pc}
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   170e8:	23ff      	movs	r3, #255	; 0xff
    uint16_t size = _lv_style_get_mem_size(style);
   170ea:	4628      	mov	r0, r5
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
   170ec:	f8ad 300e 	strh.w	r3, [sp, #14]
    uint16_t size = _lv_style_get_mem_size(style);
   170f0:	f7ff fec2 	bl	16e78 <_lv_style_get_mem_size>
    if(size == 0) size += end_mark_size;
   170f4:	1e04      	subs	r4, r0, #0
   170f6:	bf08      	it	eq
   170f8:	2402      	moveq	r4, #2
    size += sizeof(lv_style_property_t) + sizeof(const void *);
   170fa:	3406      	adds	r4, #6
    style_resize(style, size);
   170fc:	b2a4      	uxth	r4, r4
   170fe:	4621      	mov	r1, r4
   17100:	4628      	mov	r0, r5
   17102:	f7ff fe15 	bl	16d30 <style_resize.isra.0>
    if(style == NULL) return;
   17106:	2d00      	cmp	r5, #0
   17108:	d0ec      	beq.n	170e4 <_lv_style_set_ptr+0x34>
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   1710a:	6828      	ldr	r0, [r5, #0]
   1710c:	f1a4 0308 	sub.w	r3, r4, #8
   17110:	2202      	movs	r2, #2
   17112:	f10d 0106 	add.w	r1, sp, #6
   17116:	4418      	add	r0, r3
   17118:	f7ff fe08 	bl	16d2c <_lv_memcpy>
    _lv_memcpy_small(style->map + size - sizeof(const void *) - end_mark_size, &p, sizeof(const void *));
   1711c:	6828      	ldr	r0, [r5, #0]
    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
   1711e:	1fa3      	subs	r3, r4, #6
    _lv_memcpy_small(style->map + size - sizeof(const void *) - end_mark_size, &p, sizeof(const void *));
   17120:	2204      	movs	r2, #4
   17122:	4669      	mov	r1, sp
   17124:	4418      	add	r0, r3
   17126:	f7ff fe01 	bl	16d2c <_lv_memcpy>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   1712a:	6828      	ldr	r0, [r5, #0]
    _lv_memcpy_small(style->map + size - sizeof(const void *) - end_mark_size, &p, sizeof(const void *));
   1712c:	3c02      	subs	r4, #2
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
   1712e:	2202      	movs	r2, #2
   17130:	f10d 010e 	add.w	r1, sp, #14
   17134:	4420      	add	r0, r4
   17136:	e7d3      	b.n	170e0 <_lv_style_set_ptr+0x30>

00017138 <_lv_style_get_int>:
{
   17138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1713a:	4604      	mov	r4, r0
   1713c:	460e      	mov	r6, r1
   1713e:	4617      	mov	r7, r2
    if(style == NULL) return -1;
   17140:	b910      	cbnz	r0, 17148 <_lv_style_get_int+0x10>
   17142:	f04f 30ff 	mov.w	r0, #4294967295
}
   17146:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(style->map == NULL) return -1;
   17148:	6803      	ldr	r3, [r0, #0]
   1714a:	2b00      	cmp	r3, #0
   1714c:	d0f9      	beq.n	17142 <_lv_style_get_int+0xa>
    int32_t id = get_property_index(style, prop);
   1714e:	f7ff fdb0 	bl	16cb2 <get_property_index>
    if(id < 0) {
   17152:	1e05      	subs	r5, r0, #0
   17154:	dbf5      	blt.n	17142 <_lv_style_get_int+0xa>
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_style_int_t));
   17156:	6821      	ldr	r1, [r4, #0]
   17158:	1cab      	adds	r3, r5, #2
   1715a:	4419      	add	r1, r3
   1715c:	2202      	movs	r2, #2
   1715e:	4638      	mov	r0, r7
   17160:	f7ff fde4 	bl	16d2c <_lv_memcpy>
        attr_act = get_style_prop_attr(style, id);
   17164:	4629      	mov	r1, r5
   17166:	4620      	mov	r0, r4
   17168:	f7ff fd9c 	bl	16ca4 <get_style_prop_attr>
        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
   1716c:	ea00 2016 	and.w	r0, r0, r6, lsr #8
   17170:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   17174:	e7e7      	b.n	17146 <_lv_style_get_int+0xe>

00017176 <_lv_style_get_opa>:
{
   17176:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17178:	4604      	mov	r4, r0
   1717a:	460e      	mov	r6, r1
   1717c:	4617      	mov	r7, r2
    if(style == NULL) return -1;
   1717e:	b910      	cbnz	r0, 17186 <_lv_style_get_opa+0x10>
   17180:	f04f 30ff 	mov.w	r0, #4294967295
}
   17184:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(style->map == NULL) return -1;
   17186:	6803      	ldr	r3, [r0, #0]
   17188:	2b00      	cmp	r3, #0
   1718a:	d0f9      	beq.n	17180 <_lv_style_get_opa+0xa>
    int32_t id = get_property_index(style, prop);
   1718c:	f7ff fd91 	bl	16cb2 <get_property_index>
    if(id < 0) {
   17190:	1e05      	subs	r5, r0, #0
   17192:	dbf5      	blt.n	17180 <_lv_style_get_opa+0xa>
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_opa_t));
   17194:	6821      	ldr	r1, [r4, #0]
   17196:	1cab      	adds	r3, r5, #2
   17198:	4419      	add	r1, r3
   1719a:	2201      	movs	r2, #1
   1719c:	4638      	mov	r0, r7
   1719e:	f7ff fdc5 	bl	16d2c <_lv_memcpy>
        attr_act = get_style_prop_attr(style, id);
   171a2:	4629      	mov	r1, r5
   171a4:	4620      	mov	r0, r4
   171a6:	f7ff fd7d 	bl	16ca4 <get_style_prop_attr>
        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
   171aa:	ea00 2016 	and.w	r0, r0, r6, lsr #8
   171ae:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   171b2:	e7e7      	b.n	17184 <_lv_style_get_opa+0xe>

000171b4 <_lv_style_get_color>:
{
   171b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   171b6:	4604      	mov	r4, r0
   171b8:	460e      	mov	r6, r1
   171ba:	4617      	mov	r7, r2
    if(style == NULL) return -1;
   171bc:	b910      	cbnz	r0, 171c4 <_lv_style_get_color+0x10>
   171be:	f04f 30ff 	mov.w	r0, #4294967295
}
   171c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(style->map == NULL) return -1;
   171c4:	6803      	ldr	r3, [r0, #0]
   171c6:	2b00      	cmp	r3, #0
   171c8:	d0f9      	beq.n	171be <_lv_style_get_color+0xa>
    int32_t id = get_property_index(style, prop);
   171ca:	f7ff fd72 	bl	16cb2 <get_property_index>
    if(id < 0) {
   171ce:	1e05      	subs	r5, r0, #0
   171d0:	dbf5      	blt.n	171be <_lv_style_get_color+0xa>
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_color_t));
   171d2:	6821      	ldr	r1, [r4, #0]
   171d4:	1cab      	adds	r3, r5, #2
   171d6:	4419      	add	r1, r3
   171d8:	2204      	movs	r2, #4
   171da:	4638      	mov	r0, r7
   171dc:	f7ff fda6 	bl	16d2c <_lv_memcpy>
        attr_act = get_style_prop_attr(style, id);
   171e0:	4629      	mov	r1, r5
   171e2:	4620      	mov	r0, r4
   171e4:	f7ff fd5e 	bl	16ca4 <get_style_prop_attr>
        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
   171e8:	ea00 2016 	and.w	r0, r0, r6, lsr #8
   171ec:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   171f0:	e7e7      	b.n	171c2 <_lv_style_get_color+0xe>

000171f2 <lv_style_list_get_local_style>:
    if(!list->has_local) return NULL;
   171f2:	7902      	ldrb	r2, [r0, #4]
{
   171f4:	4603      	mov	r3, r0
    if(!list->has_local) return NULL;
   171f6:	f012 0040 	ands.w	r0, r2, #64	; 0x40
   171fa:	d005      	beq.n	17208 <lv_style_list_get_local_style+0x16>
    if(list->has_trans) return list->style_list[1];
   171fc:	0612      	lsls	r2, r2, #24
   171fe:	681b      	ldr	r3, [r3, #0]
   17200:	d501      	bpl.n	17206 <lv_style_list_get_local_style+0x14>
   17202:	6858      	ldr	r0, [r3, #4]
   17204:	4770      	bx	lr
    else return list->style_list[0];
   17206:	6818      	ldr	r0, [r3, #0]
}
   17208:	4770      	bx	lr

0001720a <_lv_style_list_get_transition_style>:
    if(!list->has_trans) return NULL;
   1720a:	f990 3004 	ldrsb.w	r3, [r0, #4]
   1720e:	2b00      	cmp	r3, #0
    return list->style_list[0];
   17210:	bfba      	itte	lt
   17212:	6803      	ldrlt	r3, [r0, #0]
   17214:	6818      	ldrlt	r0, [r3, #0]
    if(!list->has_trans) return NULL;
   17216:	2000      	movge	r0, #0
}
   17218:	4770      	bx	lr

0001721a <_lv_style_list_reset>:
{
   1721a:	b538      	push	{r3, r4, r5, lr}
    if(list == NULL) return;
   1721c:	4604      	mov	r4, r0
   1721e:	b338      	cbz	r0, 17270 <_lv_style_list_reset+0x56>
    if(list->has_local) {
   17220:	7903      	ldrb	r3, [r0, #4]
   17222:	065a      	lsls	r2, r3, #25
   17224:	d508      	bpl.n	17238 <_lv_style_list_reset+0x1e>
        lv_style_t * local = lv_style_list_get_local_style(list);
   17226:	f7ff ffe4 	bl	171f2 <lv_style_list_get_local_style>
        if(local) {
   1722a:	4605      	mov	r5, r0
   1722c:	b120      	cbz	r0, 17238 <_lv_style_list_reset+0x1e>
            lv_style_reset(local);
   1722e:	f7ff fe1b 	bl	16e68 <lv_style_reset>
            lv_mem_free(local);
   17232:	4628      	mov	r0, r5
   17234:	f7f5 fc44 	bl	cac0 <lv_mem_free>
    if(list->has_trans) {
   17238:	f994 3004 	ldrsb.w	r3, [r4, #4]
   1723c:	2b00      	cmp	r3, #0
   1723e:	da09      	bge.n	17254 <_lv_style_list_reset+0x3a>
        lv_style_t * trans = _lv_style_list_get_transition_style(list);
   17240:	4620      	mov	r0, r4
   17242:	f7ff ffe2 	bl	1720a <_lv_style_list_get_transition_style>
        if(trans) {
   17246:	4605      	mov	r5, r0
   17248:	b120      	cbz	r0, 17254 <_lv_style_list_reset+0x3a>
            lv_style_reset(trans);
   1724a:	f7ff fe0d 	bl	16e68 <lv_style_reset>
            lv_mem_free(trans);
   1724e:	4628      	mov	r0, r5
   17250:	f7f5 fc36 	bl	cac0 <lv_mem_free>
    if(list->style_cnt > 0) lv_mem_free(list->style_list);
   17254:	7923      	ldrb	r3, [r4, #4]
   17256:	069b      	lsls	r3, r3, #26
   17258:	d002      	beq.n	17260 <_lv_style_list_reset+0x46>
   1725a:	6820      	ldr	r0, [r4, #0]
   1725c:	f7f5 fc30 	bl	cac0 <lv_mem_free>
    list->style_list = NULL;
   17260:	2300      	movs	r3, #0
   17262:	6023      	str	r3, [r4, #0]
    list->style_cnt = 0;
   17264:	88a3      	ldrh	r3, [r4, #4]
   17266:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   1726a:	f023 0301 	bic.w	r3, r3, #1
   1726e:	80a3      	strh	r3, [r4, #4]
}
   17270:	bd38      	pop	{r3, r4, r5, pc}

00017272 <lv_style_list_copy>:
{
   17272:	b538      	push	{r3, r4, r5, lr}
   17274:	460c      	mov	r4, r1
   17276:	4605      	mov	r5, r0
    _lv_style_list_reset(list_dest);
   17278:	f7ff ffcf 	bl	1721a <_lv_style_list_reset>
    if(list_src->style_list == NULL) return;
   1727c:	6823      	ldr	r3, [r4, #0]
   1727e:	b1f3      	cbz	r3, 172be <lv_style_list_copy+0x4c>
    if(list_src->has_local == 0) {
   17280:	7922      	ldrb	r2, [r4, #4]
   17282:	f994 3004 	ldrsb.w	r3, [r4, #4]
   17286:	f002 003f 	and.w	r0, r2, #63	; 0x3f
   1728a:	0652      	lsls	r2, r2, #25
   1728c:	d429      	bmi.n	172e2 <lv_style_list_copy+0x70>
        if(list_src->has_trans) {
   1728e:	2b00      	cmp	r3, #0
   17290:	da16      	bge.n	172c0 <lv_style_list_copy+0x4e>
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
   17292:	3801      	subs	r0, #1
   17294:	0080      	lsls	r0, r0, #2
   17296:	f7f5 fbff 	bl	ca98 <lv_mem_alloc>
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1729a:	7922      	ldrb	r2, [r4, #4]
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1729c:	6028      	str	r0, [r5, #0]
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1729e:	6821      	ldr	r1, [r4, #0]
   172a0:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   172a4:	3a01      	subs	r2, #1
   172a6:	0092      	lsls	r2, r2, #2
   172a8:	3104      	adds	r1, #4
   172aa:	f7ff fd3f 	bl	16d2c <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 1;
   172ae:	7923      	ldrb	r3, [r4, #4]
   172b0:	792a      	ldrb	r2, [r5, #4]
   172b2:	f3c3 0305 	ubfx	r3, r3, #0, #6
   172b6:	3b01      	subs	r3, #1
   172b8:	f363 0205 	bfi	r2, r3, #0, #6
   172bc:	712a      	strb	r2, [r5, #4]
}
   172be:	bd38      	pop	{r3, r4, r5, pc}
            list_dest->style_list = lv_mem_alloc(list_src->style_cnt * sizeof(lv_style_t *));
   172c0:	0080      	lsls	r0, r0, #2
   172c2:	f7f5 fbe9 	bl	ca98 <lv_mem_alloc>
            _lv_memcpy(list_dest->style_list, list_src->style_list, list_src->style_cnt * sizeof(lv_style_t *));
   172c6:	7922      	ldrb	r2, [r4, #4]
            list_dest->style_list = lv_mem_alloc(list_src->style_cnt * sizeof(lv_style_t *));
   172c8:	6028      	str	r0, [r5, #0]
            _lv_memcpy(list_dest->style_list, list_src->style_list, list_src->style_cnt * sizeof(lv_style_t *));
   172ca:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   172ce:	0092      	lsls	r2, r2, #2
   172d0:	6821      	ldr	r1, [r4, #0]
   172d2:	f7ff fd2b 	bl	16d2c <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt;
   172d6:	7922      	ldrb	r2, [r4, #4]
   172d8:	792b      	ldrb	r3, [r5, #4]
   172da:	f362 0305 	bfi	r3, r2, #0, #6
   172de:	712b      	strb	r3, [r5, #4]
   172e0:	e7ed      	b.n	172be <lv_style_list_copy+0x4c>
        if(list_src->has_trans) {
   172e2:	2b00      	cmp	r3, #0
   172e4:	da22      	bge.n	1732c <lv_style_list_copy+0xba>
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 2) * sizeof(lv_style_t *));
   172e6:	3802      	subs	r0, #2
   172e8:	0080      	lsls	r0, r0, #2
   172ea:	f7f5 fbd5 	bl	ca98 <lv_mem_alloc>
            _lv_memcpy(list_dest->style_list, list_src->style_list + 2, (list_src->style_cnt - 2) * sizeof(lv_style_t *));
   172ee:	7922      	ldrb	r2, [r4, #4]
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 2) * sizeof(lv_style_t *));
   172f0:	6028      	str	r0, [r5, #0]
            _lv_memcpy(list_dest->style_list, list_src->style_list + 2, (list_src->style_cnt - 2) * sizeof(lv_style_t *));
   172f2:	6821      	ldr	r1, [r4, #0]
   172f4:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   172f8:	3a02      	subs	r2, #2
   172fa:	0092      	lsls	r2, r2, #2
   172fc:	3108      	adds	r1, #8
   172fe:	f7ff fd15 	bl	16d2c <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 2;
   17302:	7923      	ldrb	r3, [r4, #4]
   17304:	f3c3 0305 	ubfx	r3, r3, #0, #6
   17308:	3b02      	subs	r3, #2
            list_dest->style_cnt = list_src->style_cnt - 1;
   1730a:	792a      	ldrb	r2, [r5, #4]
        lv_style_t * local_style = get_alloc_local_style(list_dest);
   1730c:	4628      	mov	r0, r5
            list_dest->style_cnt = list_src->style_cnt - 1;
   1730e:	f363 0205 	bfi	r2, r3, #0, #6
   17312:	712a      	strb	r2, [r5, #4]
        lv_style_t * local_style = get_alloc_local_style(list_dest);
   17314:	f7ff fd8d 	bl	16e32 <get_alloc_local_style>
   17318:	4605      	mov	r5, r0
        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));
   1731a:	4620      	mov	r0, r4
   1731c:	f7ff fd89 	bl	16e32 <get_alloc_local_style>
   17320:	4601      	mov	r1, r0
   17322:	4628      	mov	r0, r5
}
   17324:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));
   17328:	f7ff bdb8 	b.w	16e9c <lv_style_copy>
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
   1732c:	3801      	subs	r0, #1
   1732e:	0080      	lsls	r0, r0, #2
   17330:	f7f5 fbb2 	bl	ca98 <lv_mem_alloc>
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
   17334:	7922      	ldrb	r2, [r4, #4]
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
   17336:	6028      	str	r0, [r5, #0]
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
   17338:	6821      	ldr	r1, [r4, #0]
   1733a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   1733e:	3a01      	subs	r2, #1
   17340:	0092      	lsls	r2, r2, #2
   17342:	3104      	adds	r1, #4
   17344:	f7ff fcf2 	bl	16d2c <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 1;
   17348:	7923      	ldrb	r3, [r4, #4]
   1734a:	f3c3 0305 	ubfx	r3, r3, #0, #6
   1734e:	3b01      	subs	r3, #1
   17350:	e7db      	b.n	1730a <lv_style_list_copy+0x98>

00017352 <_lv_style_list_add_trans_style>:
{
   17352:	b538      	push	{r3, r4, r5, lr}
    if(list->has_trans) return _lv_style_list_get_transition_style(list);
   17354:	f990 3004 	ldrsb.w	r3, [r0, #4]
{
   17358:	4604      	mov	r4, r0
    if(list->has_trans) return _lv_style_list_get_transition_style(list);
   1735a:	2b00      	cmp	r3, #0
   1735c:	da03      	bge.n	17366 <_lv_style_list_add_trans_style+0x14>
}
   1735e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if(list->has_trans) return _lv_style_list_get_transition_style(list);
   17362:	f7ff bf52 	b.w	1720a <_lv_style_list_get_transition_style>
    lv_style_t * trans_style = lv_mem_alloc(sizeof(lv_style_t));
   17366:	2004      	movs	r0, #4
   17368:	f7f5 fb96 	bl	ca98 <lv_mem_alloc>
    if(trans_style == NULL) {
   1736c:	4605      	mov	r5, r0
   1736e:	b180      	cbz	r0, 17392 <_lv_style_list_add_trans_style+0x40>
    lv_style_init(trans_style);
   17370:	f7ff fce5 	bl	16d3e <lv_style_init>
    _lv_style_list_add_style(list, trans_style);
   17374:	4629      	mov	r1, r5
   17376:	4620      	mov	r0, r4
   17378:	f7ff fd29 	bl	16dce <_lv_style_list_add_style>
    list->has_trans = 1;
   1737c:	7923      	ldrb	r3, [r4, #4]
   1737e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   17382:	7123      	strb	r3, [r4, #4]
    if(list->has_local) {
   17384:	065b      	lsls	r3, r3, #25
        lv_style_t * tmp = list->style_list[0];
   17386:	bf42      	ittt	mi
   17388:	6823      	ldrmi	r3, [r4, #0]
        list->style_list[0] = list->style_list[1];
   1738a:	e9d3 2100 	ldrdmi	r2, r1, [r3]
        list->style_list[1] = tmp;
   1738e:	e9c3 1200 	strdmi	r1, r2, [r3]
}
   17392:	4628      	mov	r0, r5
   17394:	bd38      	pop	{r3, r4, r5, pc}

00017396 <_lv_style_list_get_int>:
{
   17396:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1739a:	460f      	mov	r7, r1
   1739c:	4690      	mov	r8, r2
    if(list == NULL) return LV_RES_INV;
   1739e:	4605      	mov	r5, r0
   173a0:	b318      	cbz	r0, 173ea <_lv_style_list_get_int+0x54>
    if(list->style_list == NULL) return LV_RES_INV;
   173a2:	6800      	ldr	r0, [r0, #0]
   173a4:	b308      	cbz	r0, 173ea <_lv_style_list_get_int+0x54>
    lv_style_int_t value_act = 0;
   173a6:	2600      	movs	r6, #0
    int16_t weight = -1;
   173a8:	f04f 34ff 	mov.w	r4, #4294967295
    int16_t weight_goal = attr;
   173ac:	ea4f 2a11 	mov.w	sl, r1, lsr #8
    lv_style_int_t value_act = 0;
   173b0:	f8ad 6006 	strh.w	r6, [sp, #6]
    for(ci = 0; ci < list->style_cnt; ci++) {
   173b4:	792b      	ldrb	r3, [r5, #4]
   173b6:	fa0f f986 	sxth.w	r9, r6
   173ba:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   173be:	4599      	cmp	r9, r3
   173c0:	db03      	blt.n	173ca <_lv_style_list_get_int+0x34>
    if(weight >= 0) return LV_RES_OK;
   173c2:	43e0      	mvns	r0, r4
    if(list == NULL) return LV_RES_INV;
   173c4:	f3c0 30c0 	ubfx	r0, r0, #15, #1
   173c8:	e00f      	b.n	173ea <_lv_style_list_get_int+0x54>
        lv_style_t * class = lv_style_list_get_style(list, ci);
   173ca:	b2f1      	uxtb	r1, r6
   173cc:	4628      	mov	r0, r5
   173ce:	f7ff fc39 	bl	16c44 <lv_style_list_get_style>
        int16_t weight_act = _lv_style_get_int(class, prop, &value_act);
   173d2:	4639      	mov	r1, r7
   173d4:	f10d 0206 	add.w	r2, sp, #6
   173d8:	f7ff feae 	bl	17138 <_lv_style_get_int>
        if(weight_act == weight_goal) {
   173dc:	4582      	cmp	sl, r0
   173de:	d107      	bne.n	173f0 <_lv_style_list_get_int+0x5a>
            return LV_RES_OK;
   173e0:	2001      	movs	r0, #1
            *res = value_act;
   173e2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   173e6:	f8a8 3000 	strh.w	r3, [r8]
}
   173ea:	b002      	add	sp, #8
   173ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
   173f0:	f995 3004 	ldrsb.w	r3, [r5, #4]
   173f4:	2b00      	cmp	r3, #0
   173f6:	da07      	bge.n	17408 <_lv_style_list_get_int+0x72>
   173f8:	2800      	cmp	r0, #0
   173fa:	db05      	blt.n	17408 <_lv_style_list_get_int+0x72>
   173fc:	f1b9 0f00 	cmp.w	r9, #0
   17400:	d102      	bne.n	17408 <_lv_style_list_get_int+0x72>
   17402:	796b      	ldrb	r3, [r5, #5]
   17404:	07db      	lsls	r3, r3, #31
   17406:	d5eb      	bpl.n	173e0 <_lv_style_list_get_int+0x4a>
        else if(weight_act > weight) {
   17408:	4284      	cmp	r4, r0
            *res = value_act;
   1740a:	bfbe      	ittt	lt
   1740c:	f8bd 3006 	ldrhlt.w	r3, [sp, #6]
   17410:	4604      	movlt	r4, r0
   17412:	f8a8 3000 	strhlt.w	r3, [r8]
   17416:	3601      	adds	r6, #1
   17418:	e7cc      	b.n	173b4 <_lv_style_list_get_int+0x1e>

0001741a <_lv_style_list_get_color>:
{
   1741a:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1741e:	460f      	mov	r7, r1
   17420:	4690      	mov	r8, r2
    if(list == NULL) return LV_RES_INV;
   17422:	4605      	mov	r5, r0
   17424:	b300      	cbz	r0, 17468 <_lv_style_list_get_color+0x4e>
    if(list->style_list == NULL) return LV_RES_INV;
   17426:	6800      	ldr	r0, [r0, #0]
   17428:	b1f0      	cbz	r0, 17468 <_lv_style_list_get_color+0x4e>
    value_act.full = 0;
   1742a:	2600      	movs	r6, #0
    int16_t weight = -1;
   1742c:	f04f 34ff 	mov.w	r4, #4294967295
    int16_t weight_goal = attr;
   17430:	ea4f 2a11 	mov.w	sl, r1, lsr #8
    value_act.full = 0;
   17434:	9601      	str	r6, [sp, #4]
    for(ci = 0; ci < list->style_cnt; ci++) {
   17436:	792b      	ldrb	r3, [r5, #4]
   17438:	fa0f f986 	sxth.w	r9, r6
   1743c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   17440:	4599      	cmp	r9, r3
   17442:	db03      	blt.n	1744c <_lv_style_list_get_color+0x32>
    if(weight >= 0)  return LV_RES_OK;
   17444:	43e0      	mvns	r0, r4
    if(list == NULL) return LV_RES_INV;
   17446:	f3c0 30c0 	ubfx	r0, r0, #15, #1
   1744a:	e00d      	b.n	17468 <_lv_style_list_get_color+0x4e>
        lv_style_t * class = lv_style_list_get_style(list, ci);
   1744c:	b2f1      	uxtb	r1, r6
   1744e:	4628      	mov	r0, r5
   17450:	f7ff fbf8 	bl	16c44 <lv_style_list_get_style>
        int16_t weight_act = _lv_style_get_color(class, prop, &value_act);
   17454:	4639      	mov	r1, r7
   17456:	aa01      	add	r2, sp, #4
   17458:	f7ff feac 	bl	171b4 <_lv_style_get_color>
        if(weight_act == weight_goal) {
   1745c:	4582      	cmp	sl, r0
   1745e:	d106      	bne.n	1746e <_lv_style_list_get_color+0x54>
            return LV_RES_OK;
   17460:	2001      	movs	r0, #1
            *res = value_act;
   17462:	9b01      	ldr	r3, [sp, #4]
   17464:	f8c8 3000 	str.w	r3, [r8]
}
   17468:	b002      	add	sp, #8
   1746a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
   1746e:	f995 3004 	ldrsb.w	r3, [r5, #4]
   17472:	2b00      	cmp	r3, #0
   17474:	da07      	bge.n	17486 <_lv_style_list_get_color+0x6c>
   17476:	2800      	cmp	r0, #0
   17478:	db05      	blt.n	17486 <_lv_style_list_get_color+0x6c>
   1747a:	f1b9 0f00 	cmp.w	r9, #0
   1747e:	d102      	bne.n	17486 <_lv_style_list_get_color+0x6c>
   17480:	796b      	ldrb	r3, [r5, #5]
   17482:	07db      	lsls	r3, r3, #31
   17484:	d5ec      	bpl.n	17460 <_lv_style_list_get_color+0x46>
        else if(weight_act > weight) {
   17486:	4284      	cmp	r4, r0
            *res = value_act;
   17488:	bfbe      	ittt	lt
   1748a:	9b01      	ldrlt	r3, [sp, #4]
   1748c:	4604      	movlt	r4, r0
   1748e:	f8c8 3000 	strlt.w	r3, [r8]
   17492:	3601      	adds	r6, #1
   17494:	e7cf      	b.n	17436 <_lv_style_list_get_color+0x1c>

00017496 <_lv_style_list_get_opa>:
{
   17496:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1749a:	460f      	mov	r7, r1
   1749c:	4690      	mov	r8, r2
    if(list == NULL) return LV_RES_INV;
   1749e:	4605      	mov	r5, r0
   174a0:	b318      	cbz	r0, 174ea <_lv_style_list_get_opa+0x54>
    if(list->style_list == NULL) return LV_RES_INV;
   174a2:	6800      	ldr	r0, [r0, #0]
   174a4:	b308      	cbz	r0, 174ea <_lv_style_list_get_opa+0x54>
    lv_opa_t value_act = LV_OPA_TRANSP;
   174a6:	2600      	movs	r6, #0
    int16_t weight = -1;
   174a8:	f04f 34ff 	mov.w	r4, #4294967295
    int16_t weight_goal = attr;
   174ac:	ea4f 2a11 	mov.w	sl, r1, lsr #8
    lv_opa_t value_act = LV_OPA_TRANSP;
   174b0:	f88d 6007 	strb.w	r6, [sp, #7]
    for(ci = 0; ci < list->style_cnt; ci++) {
   174b4:	792b      	ldrb	r3, [r5, #4]
   174b6:	fa0f f986 	sxth.w	r9, r6
   174ba:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   174be:	4599      	cmp	r9, r3
   174c0:	db03      	blt.n	174ca <_lv_style_list_get_opa+0x34>
    if(weight >= 0)  return LV_RES_OK;
   174c2:	43e0      	mvns	r0, r4
    if(list == NULL) return LV_RES_INV;
   174c4:	f3c0 30c0 	ubfx	r0, r0, #15, #1
   174c8:	e00f      	b.n	174ea <_lv_style_list_get_opa+0x54>
        lv_style_t * class = lv_style_list_get_style(list, ci);
   174ca:	b2f1      	uxtb	r1, r6
   174cc:	4628      	mov	r0, r5
   174ce:	f7ff fbb9 	bl	16c44 <lv_style_list_get_style>
        int16_t weight_act = _lv_style_get_opa(class, prop, &value_act);
   174d2:	4639      	mov	r1, r7
   174d4:	f10d 0207 	add.w	r2, sp, #7
   174d8:	f7ff fe4d 	bl	17176 <_lv_style_get_opa>
        if(weight_act == weight_goal) {
   174dc:	4582      	cmp	sl, r0
   174de:	d107      	bne.n	174f0 <_lv_style_list_get_opa+0x5a>
            return LV_RES_OK;
   174e0:	2001      	movs	r0, #1
            *res = value_act;
   174e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   174e6:	f888 3000 	strb.w	r3, [r8]
}
   174ea:	b002      	add	sp, #8
   174ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
   174f0:	f995 3004 	ldrsb.w	r3, [r5, #4]
   174f4:	2b00      	cmp	r3, #0
   174f6:	da07      	bge.n	17508 <_lv_style_list_get_opa+0x72>
   174f8:	2800      	cmp	r0, #0
   174fa:	db05      	blt.n	17508 <_lv_style_list_get_opa+0x72>
   174fc:	f1b9 0f00 	cmp.w	r9, #0
   17500:	d102      	bne.n	17508 <_lv_style_list_get_opa+0x72>
   17502:	796b      	ldrb	r3, [r5, #5]
   17504:	07db      	lsls	r3, r3, #31
   17506:	d5eb      	bpl.n	174e0 <_lv_style_list_get_opa+0x4a>
        else if(weight_act > weight) {
   17508:	4284      	cmp	r4, r0
            *res = value_act;
   1750a:	bfbe      	ittt	lt
   1750c:	f89d 3007 	ldrblt.w	r3, [sp, #7]
   17510:	4604      	movlt	r4, r0
   17512:	f888 3000 	strblt.w	r3, [r8]
   17516:	3601      	adds	r6, #1
   17518:	e7cc      	b.n	174b4 <_lv_style_list_get_opa+0x1e>

0001751a <_lv_style_list_get_ptr>:
{
   1751a:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1751e:	460f      	mov	r7, r1
   17520:	4690      	mov	r8, r2
    if(list == NULL) return LV_RES_INV;
   17522:	4605      	mov	r5, r0
   17524:	b1f8      	cbz	r0, 17566 <_lv_style_list_get_ptr+0x4c>
    if(list->style_list == NULL) return LV_RES_INV;
   17526:	6800      	ldr	r0, [r0, #0]
   17528:	b1e8      	cbz	r0, 17566 <_lv_style_list_get_ptr+0x4c>
    for(ci = 0; ci < list->style_cnt; ci++) {
   1752a:	2600      	movs	r6, #0
    int16_t weight = -1;
   1752c:	f04f 34ff 	mov.w	r4, #4294967295
    int16_t weight_goal = attr;
   17530:	ea4f 2a11 	mov.w	sl, r1, lsr #8
    for(ci = 0; ci < list->style_cnt; ci++) {
   17534:	792b      	ldrb	r3, [r5, #4]
   17536:	fa0f f986 	sxth.w	r9, r6
   1753a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   1753e:	4599      	cmp	r9, r3
   17540:	db03      	blt.n	1754a <_lv_style_list_get_ptr+0x30>
    if(weight >= 0)  return LV_RES_OK;
   17542:	43e0      	mvns	r0, r4
    if(list == NULL) return LV_RES_INV;
   17544:	f3c0 30c0 	ubfx	r0, r0, #15, #1
   17548:	e00d      	b.n	17566 <_lv_style_list_get_ptr+0x4c>
        lv_style_t * class = lv_style_list_get_style(list, ci);
   1754a:	b2f1      	uxtb	r1, r6
   1754c:	4628      	mov	r0, r5
   1754e:	f7ff fb79 	bl	16c44 <lv_style_list_get_style>
        int16_t weight_act = _lv_style_get_ptr(class, prop, &value_act);
   17552:	4639      	mov	r1, r7
   17554:	aa01      	add	r2, sp, #4
   17556:	f7ff fe2d 	bl	171b4 <_lv_style_get_color>
        if(weight_act == weight_goal) {
   1755a:	4582      	cmp	sl, r0
   1755c:	d106      	bne.n	1756c <_lv_style_list_get_ptr+0x52>
            return LV_RES_OK;
   1755e:	2001      	movs	r0, #1
            *res = value_act;
   17560:	9b01      	ldr	r3, [sp, #4]
   17562:	f8c8 3000 	str.w	r3, [r8]
}
   17566:	b002      	add	sp, #8
   17568:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
   1756c:	f995 3004 	ldrsb.w	r3, [r5, #4]
   17570:	2b00      	cmp	r3, #0
   17572:	da07      	bge.n	17584 <_lv_style_list_get_ptr+0x6a>
   17574:	2800      	cmp	r0, #0
   17576:	db05      	blt.n	17584 <_lv_style_list_get_ptr+0x6a>
   17578:	f1b9 0f00 	cmp.w	r9, #0
   1757c:	d102      	bne.n	17584 <_lv_style_list_get_ptr+0x6a>
   1757e:	796b      	ldrb	r3, [r5, #5]
   17580:	07db      	lsls	r3, r3, #31
   17582:	d5ec      	bpl.n	1755e <_lv_style_list_get_ptr+0x44>
        else if(weight_act > weight) {
   17584:	4284      	cmp	r4, r0
            *res = value_act;
   17586:	bfbe      	ittt	lt
   17588:	9b01      	ldrlt	r3, [sp, #4]
   1758a:	4604      	movlt	r4, r0
   1758c:	f8c8 3000 	strlt.w	r3, [r8]
   17590:	3601      	adds	r6, #1
   17592:	e7cf      	b.n	17534 <_lv_style_list_get_ptr+0x1a>

00017594 <lv_color_mix.isra.0>:
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
   17594:	b570      	push	{r4, r5, r6, lr}
   17596:	f89d 5018 	ldrb.w	r5, [sp, #24]
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1759a:	f248 0481 	movw	r4, #32897	; 0x8081
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   1759e:	f1c5 06ff 	rsb	r6, r5, #255	; 0xff
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   175a2:	4373      	muls	r3, r6
   175a4:	fb05 3300 	mla	r3, r5, r0, r3
    return ret;
   175a8:	2000      	movs	r0, #0
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   175aa:	4363      	muls	r3, r4
   175ac:	0ddb      	lsrs	r3, r3, #23
    return ret;
   175ae:	f363 0007 	bfi	r0, r3, #0, #8
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   175b2:	f89d 3010 	ldrb.w	r3, [sp, #16]
   175b6:	4373      	muls	r3, r6
   175b8:	fb05 3101 	mla	r1, r5, r1, r3
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   175bc:	f89d 3014 	ldrb.w	r3, [sp, #20]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   175c0:	4361      	muls	r1, r4
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   175c2:	435e      	muls	r6, r3
   175c4:	fb02 6505 	mla	r5, r2, r5, r6
   175c8:	436c      	muls	r4, r5
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   175ca:	0dc9      	lsrs	r1, r1, #23
    return ret;
   175cc:	f361 200f 	bfi	r0, r1, #8, #8
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   175d0:	0de4      	lsrs	r4, r4, #23
    return ret;
   175d2:	f364 4017 	bfi	r0, r4, #16, #8
}
   175d6:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
   175da:	bd70      	pop	{r4, r5, r6, pc}

000175dc <_lv_blend_fill>:
 * @param mode blend mode from `lv_blend_mode_t`
 */
LV_ATTRIBUTE_FAST_MEM void _lv_blend_fill(const lv_area_t * clip_area, const lv_area_t * fill_area,
                                          lv_color_t color, lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_opa_t opa,
                                          lv_blend_mode_t mode)
{
   175dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   175e0:	b08f      	sub	sp, #60	; 0x3c
   175e2:	f89d 4064 	ldrb.w	r4, [sp, #100]	; 0x64
   175e6:	e9cd 3205 	strd	r3, r2, [sp, #20]
   175ea:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
    /*Do not draw transparent things*/
    if(opa < LV_OPA_MIN) return;
   175ee:	2c01      	cmp	r4, #1
{
   175f0:	4606      	mov	r6, r0
   175f2:	4688      	mov	r8, r1
   175f4:	f89d 7068 	ldrb.w	r7, [sp, #104]	; 0x68
   175f8:	930a      	str	r3, [sp, #40]	; 0x28
    if(opa < LV_OPA_MIN) return;
   175fa:	f240 80b8 	bls.w	1776e <_lv_blend_fill+0x192>
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
   175fe:	2b00      	cmp	r3, #0
   17600:	f000 80b5 	beq.w	1776e <_lv_blend_fill+0x192>

    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   17604:	f7f3 f80c 	bl	a620 <_lv_refr_get_disp_refreshing>
   17608:	4605      	mov	r5, r0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1760a:	f003 fa5b 	bl	1aac4 <lv_disp_get_buf>
    const lv_area_t * disp_area = &vdb->area;
    lv_color_t * disp_buf = vdb->buf_act;
   1760e:	6883      	ldr	r3, [r0, #8]
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   17610:	4681      	mov	r9, r0
    lv_color_t * disp_buf = vdb->buf_act;
   17612:	9307      	str	r3, [sp, #28]

    if(disp->driver.gpu_wait_cb) disp->driver.gpu_wait_cb(&disp->driver);
   17614:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   17616:	b10b      	cbz	r3, 1761c <_lv_blend_fill+0x40>
   17618:	4628      	mov	r0, r5
   1761a:	4798      	blx	r3

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, clip_area, fill_area);
   1761c:	4642      	mov	r2, r8
   1761e:	4631      	mov	r1, r6
   17620:	a80c      	add	r0, sp, #48	; 0x30
   17622:	f003 fb3b 	bl	1ac9c <_lv_area_intersect>
    if(!is_common) return;
   17626:	2800      	cmp	r0, #0
   17628:	f000 80a1 	beq.w	1776e <_lv_blend_fill+0x192>

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
   1762c:	f9bd 2030 	ldrsh.w	r2, [sp, #48]	; 0x30
   17630:	f9b9 0010 	ldrsh.w	r0, [r9, #16]
    draw_area.y1 -= disp_area->y1;
   17634:	f9bd b032 	ldrsh.w	fp, [sp, #50]	; 0x32
   17638:	f9b9 1012 	ldrsh.w	r1, [r9, #18]
    draw_area.x1 -= disp_area->x1;
   1763c:	1a13      	subs	r3, r2, r0
   1763e:	fa0f fe83 	sxth.w	lr, r3
    draw_area.y1 -= disp_area->y1;
   17642:	ebab 0301 	sub.w	r3, fp, r1
   17646:	b21b      	sxth	r3, r3
   17648:	9308      	str	r3, [sp, #32]
   1764a:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
    draw_area.x2 -= disp_area->x1;
   1764e:	f9bd 3034 	ldrsh.w	r3, [sp, #52]	; 0x34
    draw_area.x1 -= disp_area->x1;
   17652:	f8ad e030 	strh.w	lr, [sp, #48]	; 0x30
    draw_area.x2 -= disp_area->x1;
   17656:	1a18      	subs	r0, r3, r0
   17658:	f8ad 0034 	strh.w	r0, [sp, #52]	; 0x34
    draw_area.y2 -= disp_area->y1;
   1765c:	f9bd 0036 	ldrsh.w	r0, [sp, #54]	; 0x36
   17660:	1a41      	subs	r1, r0, r1
   17662:	f8ad 1036 	strh.w	r1, [sp, #54]	; 0x36

    /*Round the values in the mask if anti-aliasing is disabled*/
#if LV_ANTIALIAS
    if(mask && disp->driver.antialiasing == 0)
   17666:	9905      	ldr	r1, [sp, #20]
   17668:	2900      	cmp	r1, #0
   1766a:	d150      	bne.n	1770e <_lv_blend_fill+0x132>
        int32_t mask_w = lv_area_get_width(&draw_area);
        int32_t i;
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
    }

    if(disp->driver.set_px_cb) {
   1766c:	6969      	ldr	r1, [r5, #20]
   1766e:	2900      	cmp	r1, #0
   17670:	d169      	bne.n	17746 <_lv_blend_fill+0x16a>
        fill_set_px(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res);
    }
    else if(mode == LV_BLEND_MODE_NORMAL) {
   17672:	2f00      	cmp	r7, #0
   17674:	d17b      	bne.n	1776e <_lv_blend_fill+0x192>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   17676:	f8b9 1014 	ldrh.w	r1, [r9, #20]
   1767a:	f8b9 c010 	ldrh.w	ip, [r9, #16]
   1767e:	f1c2 0201 	rsb	r2, r2, #1
   17682:	441a      	add	r2, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   17684:	f1cb 0b01 	rsb	fp, fp, #1
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   17688:	3101      	adds	r1, #1
   1768a:	b213      	sxth	r3, r2

    int32_t draw_area_w = lv_area_get_width(draw_area);
    int32_t draw_area_h = lv_area_get_height(draw_area);

    /*Create a temp. disp_buf which always point to the first pixel of the destination area*/
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   1768c:	f8dd 9020 	ldr.w	r9, [sp, #32]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   17690:	4458      	add	r0, fp
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   17692:	eba1 010c 	sub.w	r1, r1, ip
   17696:	9d06      	ldr	r5, [sp, #24]
   17698:	b209      	sxth	r1, r1
   1769a:	9306      	str	r3, [sp, #24]
    int32_t draw_area_h = lv_area_get_height(draw_area);
   1769c:	b203      	sxth	r3, r0
   1769e:	9309      	str	r3, [sp, #36]	; 0x24
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   176a0:	fb01 e309 	mla	r3, r1, r9, lr
   176a4:	9a07      	ldr	r2, [sp, #28]
   176a6:	fa5f fa85 	uxtb.w	sl, r5
   176aa:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
   176ae:	008a      	lsls	r2, r1, #2
   176b0:	9208      	str	r2, [sp, #32]

    int32_t x;
    int32_t y;

    /*Simple fill (maybe with opacity), no masking*/
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   176b2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   176b4:	f3c5 2607 	ubfx	r6, r5, #8, #8
   176b8:	2a01      	cmp	r2, #1
   176ba:	f3c5 4807 	ubfx	r8, r5, #16, #8
   176be:	f040 80e2 	bne.w	17886 <_lv_blend_fill+0x2aa>
        if(opa > LV_OPA_MAX) {
   176c2:	2cfd      	cmp	r4, #253	; 0xfd
   176c4:	f200 80ac 	bhi.w	17820 <_lv_blend_fill+0x244>

                return;
            }
#endif
            lv_color_t last_dest_color = LV_COLOR_BLACK;
            lv_color_t last_res_color = lv_color_mix(color, last_dest_color, opa);
   176c8:	4631      	mov	r1, r6
   176ca:	463b      	mov	r3, r7
   176cc:	e9cd 7401 	strd	r7, r4, [sp, #4]
   176d0:	4642      	mov	r2, r8
   176d2:	4650      	mov	r0, sl
   176d4:	9700      	str	r7, [sp, #0]
   176d6:	f7ff ff5d 	bl	17594 <lv_color_mix.isra.0>
    out[0] = (uint16_t) LV_COLOR_GET_R(c) * mix;
   176da:	fb08 f304 	mul.w	r3, r8, r4
    out[1] = (uint16_t) LV_COLOR_GET_G(c) * mix;
   176de:	4366      	muls	r6, r4
    out[0] = (uint16_t) LV_COLOR_GET_R(c) * mix;
   176e0:	9305      	str	r3, [sp, #20]
    out[2] = (uint16_t) LV_COLOR_GET_B(c) * mix;
   176e2:	fb0a f304 	mul.w	r3, sl, r4

            uint16_t color_premult[3];
            lv_color_premult(color, opa, color_premult);
            lv_opa_t opa_inv = 255 - opa;
   176e6:	43e4      	mvns	r4, r4
            lv_color_t last_dest_color = LV_COLOR_BLACK;
   176e8:	f04f 457f 	mov.w	r5, #4278190080	; 0xff000000
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   176ec:	f248 0981 	movw	r9, #32897	; 0x8081
            lv_color_t last_res_color = lv_color_mix(color, last_dest_color, opa);
   176f0:	b2c1      	uxtb	r1, r0
   176f2:	f3c0 2c07 	ubfx	ip, r0, #8, #8
   176f6:	f3c0 4e07 	ubfx	lr, r0, #16, #8
    out[2] = (uint16_t) LV_COLOR_GET_B(c) * mix;
   176fa:	9307      	str	r3, [sp, #28]
   176fc:	0e00      	lsrs	r0, r0, #24
            lv_opa_t opa_inv = 255 - opa;
   176fe:	b2e4      	uxtb	r4, r4

            for(y = 0; y < draw_area_h; y++) {
   17700:	9b09      	ldr	r3, [sp, #36]	; 0x24
   17702:	42bb      	cmp	r3, r7
   17704:	dd33      	ble.n	1776e <_lv_blend_fill+0x192>
   17706:	465a      	mov	r2, fp
                for(x = 0; x < draw_area_w; x++) {
   17708:	f04f 0800 	mov.w	r8, #0
   1770c:	e0b4      	b.n	17878 <_lv_blend_fill+0x29c>
    if(mask && disp->driver.antialiasing == 0)
   1770e:	7a29      	ldrb	r1, [r5, #8]
   17710:	07c9      	lsls	r1, r1, #31
   17712:	d4ab      	bmi.n	1766c <_lv_blend_fill+0x90>
   17714:	1c59      	adds	r1, r3, #1
   17716:	1a89      	subs	r1, r1, r2
   17718:	9e05      	ldr	r6, [sp, #20]
        int32_t mask_w = lv_area_get_width(&draw_area);
   1771a:	fa0f fa81 	sxth.w	sl, r1
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
   1771e:	9905      	ldr	r1, [sp, #20]
   17720:	3e01      	subs	r6, #1
   17722:	f1c1 0801 	rsb	r8, r1, #1
   17726:	eb08 0c06 	add.w	ip, r8, r6
   1772a:	45e2      	cmp	sl, ip
   1772c:	dd9e      	ble.n	1766c <_lv_blend_fill+0x90>
   1772e:	f816 cf01 	ldrb.w	ip, [r6, #1]!
   17732:	f1bc 0f80 	cmp.w	ip, #128	; 0x80
   17736:	f04f 3cff 	mov.w	ip, #4294967295
   1773a:	bf98      	it	ls
   1773c:	f04f 0c00 	movls.w	ip, #0
   17740:	f886 c000 	strb.w	ip, [r6]
   17744:	e7ef      	b.n	17726 <_lv_blend_fill+0x14a>
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   17746:	f7f2 ff6b 	bl	a620 <_lv_refr_get_disp_refreshing>
   1774a:	f8b9 6014 	ldrh.w	r6, [r9, #20]
   1774e:	f8b9 2010 	ldrh.w	r2, [r9, #16]
   17752:	3601      	adds	r6, #1
   17754:	1ab6      	subs	r6, r6, r2
   17756:	b233      	sxth	r3, r6
   17758:	9308      	str	r3, [sp, #32]
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1775a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   1775c:	4607      	mov	r7, r0
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   1775e:	2b01      	cmp	r3, #1
   17760:	f9bd 5032 	ldrsh.w	r5, [sp, #50]	; 0x32
   17764:	d11e      	bne.n	177a4 <_lv_blend_fill+0x1c8>
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17766:	f9bd 3036 	ldrsh.w	r3, [sp, #54]	; 0x36
   1776a:	429d      	cmp	r5, r3
   1776c:	dd02      	ble.n	17774 <_lv_blend_fill+0x198>
}
   1776e:	b00f      	add	sp, #60	; 0x3c
   17770:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   17774:	f9bd 8030 	ldrsh.w	r8, [sp, #48]	; 0x30
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color, opa);
   17778:	fa0f f985 	sxth.w	r9, r5
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   1777c:	f9bd 3034 	ldrsh.w	r3, [sp, #52]	; 0x34
   17780:	4598      	cmp	r8, r3
   17782:	dd01      	ble.n	17788 <_lv_blend_fill+0x1ac>
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17784:	3501      	adds	r5, #1
   17786:	e7ee      	b.n	17766 <_lv_blend_fill+0x18a>
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color, opa);
   17788:	9b06      	ldr	r3, [sp, #24]
   1778a:	9402      	str	r4, [sp, #8]
   1778c:	e9cd 9300 	strd	r9, r3, [sp]
   17790:	e9dd 1207 	ldrd	r1, r2, [sp, #28]
   17794:	fa0f f388 	sxth.w	r3, r8
   17798:	4638      	mov	r0, r7
   1779a:	697e      	ldr	r6, [r7, #20]
   1779c:	47b0      	blx	r6
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   1779e:	f108 0801 	add.w	r8, r8, #1
   177a2:	e7eb      	b.n	1777c <_lv_blend_fill+0x1a0>
   177a4:	f8bd 8034 	ldrh.w	r8, [sp, #52]	; 0x34
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
   177a8:	f9bd 3030 	ldrsh.w	r3, [sp, #48]	; 0x30
   177ac:	9a05      	ldr	r2, [sp, #20]
   177ae:	f108 0801 	add.w	r8, r8, #1
   177b2:	eba8 0803 	sub.w	r8, r8, r3
   177b6:	eba2 0a03 	sub.w	sl, r2, r3
   177ba:	fa0f f888 	sxth.w	r8, r8
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   177be:	f9bd 3036 	ldrsh.w	r3, [sp, #54]	; 0x36
   177c2:	429d      	cmp	r5, r3
   177c4:	dcd3      	bgt.n	1776e <_lv_blend_fill+0x192>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   177c6:	f9bd 9030 	ldrsh.w	r9, [sp, #48]	; 0x30
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
   177ca:	fa0f fb85 	sxth.w	fp, r5
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   177ce:	f9bd 3034 	ldrsh.w	r3, [sp, #52]	; 0x34
   177d2:	4599      	cmp	r9, r3
   177d4:	dd02      	ble.n	177dc <_lv_blend_fill+0x200>
            mask_tmp += draw_area_w;
   177d6:	44c2      	add	sl, r8
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   177d8:	3501      	adds	r5, #1
   177da:	e7f0      	b.n	177be <_lv_blend_fill+0x1e2>
                if(mask_tmp[x]) {
   177dc:	f81a 3009 	ldrb.w	r3, [sl, r9]
   177e0:	b16b      	cbz	r3, 177fe <_lv_blend_fill+0x222>
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
   177e2:	e9dd 1207 	ldrd	r1, r2, [sp, #28]
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   177e6:	fb14 f303 	smulbb	r3, r4, r3
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
   177ea:	0a1b      	lsrs	r3, r3, #8
   177ec:	9302      	str	r3, [sp, #8]
   177ee:	9b06      	ldr	r3, [sp, #24]
   177f0:	4638      	mov	r0, r7
   177f2:	e9cd b300 	strd	fp, r3, [sp]
   177f6:	fa0f f389 	sxth.w	r3, r9
   177fa:	697e      	ldr	r6, [r7, #20]
   177fc:	47b0      	blx	r6
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   177fe:	f109 0901 	add.w	r9, r9, #1
   17802:	e7e4      	b.n	177ce <_lv_blend_fill+0x1f2>
                lv_color_fill(disp_buf_first, color, draw_area_w);
   17804:	f36a 0507 	bfi	r5, sl, #0, #8
   17808:	f366 250f 	bfi	r5, r6, #8, #8
   1780c:	f368 4517 	bfi	r5, r8, #16, #8
   17810:	4658      	mov	r0, fp
   17812:	4629      	mov	r1, r5
   17814:	9a06      	ldr	r2, [sp, #24]
   17816:	f003 fc72 	bl	1b0fe <lv_color_fill>
                disp_buf_first += disp_w;
   1781a:	9b08      	ldr	r3, [sp, #32]
            for(y = 0; y < draw_area_h; y++) {
   1781c:	3701      	adds	r7, #1
                disp_buf_first += disp_w;
   1781e:	449b      	add	fp, r3
            for(y = 0; y < draw_area_h; y++) {
   17820:	9b09      	ldr	r3, [sp, #36]	; 0x24
   17822:	42bb      	cmp	r3, r7
   17824:	dcee      	bgt.n	17804 <_lv_blend_fill+0x228>
   17826:	e7a2      	b.n	1776e <_lv_blend_fill+0x192>
                    if(last_dest_color.full != disp_buf_first[x].full) {
   17828:	f8d2 a000 	ldr.w	sl, [r2]
   1782c:	4555      	cmp	r5, sl
   1782e:	d01a      	beq.n	17866 <_lv_blend_fill+0x28a>
                        last_dest_color = disp_buf_first[x];
   17830:	4655      	mov	r5, sl
    return ret;
   17832:	20ff      	movs	r0, #255	; 0xff
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   17834:	9905      	ldr	r1, [sp, #20]
   17836:	f892 e002 	ldrb.w	lr, [r2, #2]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1783a:	f892 c001 	ldrb.w	ip, [r2, #1]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1783e:	fb0e 1e04 	mla	lr, lr, r4, r1
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   17842:	9b07      	ldr	r3, [sp, #28]
   17844:	7811      	ldrb	r1, [r2, #0]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   17846:	fb0c 6c04 	mla	ip, ip, r4, r6
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1784a:	fb01 3104 	mla	r1, r1, r4, r3
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1784e:	fb09 fe0e 	mul.w	lr, r9, lr
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   17852:	fb09 fc0c 	mul.w	ip, r9, ip
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   17856:	fb09 f101 	mul.w	r1, r9, r1
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1785a:	f3ce 5ec7 	ubfx	lr, lr, #23, #8
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1785e:	f3cc 5cc7 	ubfx	ip, ip, #23, #8
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   17862:	f3c1 51c7 	ubfx	r1, r1, #23, #8
#endif
                        {
                            last_res_color = lv_color_mix_premult(color_premult, disp_buf_first[x], opa_inv);
                        }
                    }
                    disp_buf_first[x] = last_res_color;
   17866:	7011      	strb	r1, [r2, #0]
   17868:	f882 c001 	strb.w	ip, [r2, #1]
   1786c:	f882 e002 	strb.w	lr, [r2, #2]
   17870:	70d0      	strb	r0, [r2, #3]
                for(x = 0; x < draw_area_w; x++) {
   17872:	f108 0801 	add.w	r8, r8, #1
   17876:	3204      	adds	r2, #4
   17878:	9b06      	ldr	r3, [sp, #24]
   1787a:	4543      	cmp	r3, r8
   1787c:	dcd4      	bgt.n	17828 <_lv_blend_fill+0x24c>
                }
                disp_buf_first += disp_w;
   1787e:	9b08      	ldr	r3, [sp, #32]
            for(y = 0; y < draw_area_h; y++) {
   17880:	3701      	adds	r7, #1
                disp_buf_first += disp_w;
   17882:	449b      	add	fp, r3
            for(y = 0; y < draw_area_h; y++) {
   17884:	e73c      	b.n	17700 <_lv_blend_fill+0x124>
        last_res_color.full = disp_buf_first[0].full;

        int32_t x_end4 = draw_area_w - 4;

        /*Only the mask matters*/
        if(opa > LV_OPA_MAX) {
   17886:	2cfd      	cmp	r4, #253	; 0xfd
   17888:	d80d      	bhi.n	178a6 <_lv_blend_fill+0x2ca>
        last_dest_color.full = disp_buf_first[0].full;
   1788a:	9a07      	ldr	r2, [sp, #28]
                mask += draw_area_w;
            }
        }
        /*Handle opa and mask values too*/
        else {
            lv_opa_t opa_tmp = LV_OPA_TRANSP;
   1788c:	9709      	str	r7, [sp, #36]	; 0x24
        last_dest_color.full = disp_buf_first[0].full;
   1788e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
        last_res_color.full = disp_buf_first[0].full;
   17892:	4610      	mov	r0, r2
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17894:	f9bd 3036 	ldrsh.w	r3, [sp, #54]	; 0x36
   17898:	4599      	cmp	r9, r3
   1789a:	f73f af68 	bgt.w	1776e <_lv_blend_fill+0x192>
                const lv_opa_t * mask_tmp_x = mask;
                for(x = 0; x < draw_area_w; x++) {
   1789e:	2300      	movs	r3, #0
   178a0:	465d      	mov	r5, fp
   178a2:	9307      	str	r3, [sp, #28]
   178a4:	e11d      	b.n	17ae2 <_lv_blend_fill+0x506>
        int32_t x_end4 = draw_area_w - 4;
   178a6:	9b06      	ldr	r3, [sp, #24]
   178a8:	3b04      	subs	r3, #4
            for(y = 0; y < draw_area_h; y++) {
   178aa:	e9cd 730a 	strd	r7, r3, [sp, #40]	; 0x28
   178ae:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
   178b2:	4293      	cmp	r3, r2
   178b4:	f77f af5b 	ble.w	1776e <_lv_blend_fill+0x192>
   178b8:	9b05      	ldr	r3, [sp, #20]
   178ba:	46d9      	mov	r9, fp
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
   178bc:	2700      	movs	r7, #0
   178be:	9307      	str	r3, [sp, #28]
   178c0:	e011      	b.n	178e6 <_lv_blend_fill+0x30a>
                    FILL_NORMAL_MASK_PX(x, color)
   178c2:	9b07      	ldr	r3, [sp, #28]
   178c4:	f813 2b01 	ldrb.w	r2, [r3], #1
   178c8:	9307      	str	r3, [sp, #28]
   178ca:	b14a      	cbz	r2, 178e0 <_lv_blend_fill+0x304>
   178cc:	2aff      	cmp	r2, #255	; 0xff
   178ce:	d127      	bne.n	17920 <_lv_blend_fill+0x344>
   178d0:	f36a 0507 	bfi	r5, sl, #0, #8
   178d4:	f366 250f 	bfi	r5, r6, #8, #8
   178d8:	f368 4517 	bfi	r5, r8, #16, #8
   178dc:	f8c9 5000 	str.w	r5, [r9]
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
   178e0:	3701      	adds	r7, #1
   178e2:	f109 0904 	add.w	r9, r9, #4
   178e6:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
   178ea:	42bb      	cmp	r3, r7
   178ec:	dd02      	ble.n	178f4 <_lv_blend_fill+0x318>
   178ee:	4623      	mov	r3, r4
   178f0:	079b      	lsls	r3, r3, #30
   178f2:	d1e6      	bne.n	178c2 <_lv_blend_fill+0x2e6>
   178f4:	eb0b 0987 	add.w	r9, fp, r7, lsl #2
                for(; x <= x_end4; x += 4) {
   178f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   178fa:	42bb      	cmp	r3, r7
   178fc:	da21      	bge.n	17942 <_lv_blend_fill+0x366>
   178fe:	eb0b 0987 	add.w	r9, fp, r7, lsl #2
                for(; x < draw_area_w ; x++) {
   17902:	1b3f      	subs	r7, r7, r4
   17904:	9a06      	ldr	r2, [sp, #24]
   17906:	193b      	adds	r3, r7, r4
   17908:	429a      	cmp	r2, r3
   1790a:	f300 80a3 	bgt.w	17a54 <_lv_blend_fill+0x478>
                disp_buf_first += disp_w;
   1790e:	9b08      	ldr	r3, [sp, #32]
   17910:	449b      	add	fp, r3
                mask += draw_area_w;
   17912:	9b05      	ldr	r3, [sp, #20]
   17914:	4413      	add	r3, r2
   17916:	9305      	str	r3, [sp, #20]
            for(y = 0; y < draw_area_h; y++) {
   17918:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1791a:	3301      	adds	r3, #1
   1791c:	930a      	str	r3, [sp, #40]	; 0x28
   1791e:	e7c6      	b.n	178ae <_lv_blend_fill+0x2d2>
                    FILL_NORMAL_MASK_PX(x, color)
   17920:	f899 3000 	ldrb.w	r3, [r9]
   17924:	9202      	str	r2, [sp, #8]
   17926:	f899 2002 	ldrb.w	r2, [r9, #2]
   1792a:	4631      	mov	r1, r6
   1792c:	9201      	str	r2, [sp, #4]
   1792e:	f899 2001 	ldrb.w	r2, [r9, #1]
   17932:	4650      	mov	r0, sl
   17934:	9200      	str	r2, [sp, #0]
   17936:	4642      	mov	r2, r8
   17938:	f7ff fe2c 	bl	17594 <lv_color_mix.isra.0>
   1793c:	f8c9 0000 	str.w	r0, [r9]
   17940:	e7ce      	b.n	178e0 <_lv_blend_fill+0x304>
                    if(*mask32) {
   17942:	6823      	ldr	r3, [r4, #0]
   17944:	b16b      	cbz	r3, 17962 <_lv_blend_fill+0x386>
                        if((*mask32) == 0xFFFFFFFF) {
   17946:	3301      	adds	r3, #1
   17948:	d110      	bne.n	1796c <_lv_blend_fill+0x390>
                            disp_buf_first[x] = color;
   1794a:	f36a 0507 	bfi	r5, sl, #0, #8
   1794e:	f366 250f 	bfi	r5, r6, #8, #8
   17952:	f368 4517 	bfi	r5, r8, #16, #8
                            disp_buf_first[x + 1] = color;
   17956:	e9c9 5500 	strd	r5, r5, [r9]
                            disp_buf_first[x + 2] = color;
   1795a:	f8c9 5008 	str.w	r5, [r9, #8]
                            FILL_NORMAL_MASK_PX(x + 3, color)
   1795e:	f8c9 500c 	str.w	r5, [r9, #12]
                    mask32++;
   17962:	3404      	adds	r4, #4
                for(; x <= x_end4; x += 4) {
   17964:	3704      	adds	r7, #4
   17966:	f109 0910 	add.w	r9, r9, #16
   1796a:	e7c5      	b.n	178f8 <_lv_blend_fill+0x31c>
                            FILL_NORMAL_MASK_PX(x, color)
   1796c:	7822      	ldrb	r2, [r4, #0]
   1796e:	b14a      	cbz	r2, 17984 <_lv_blend_fill+0x3a8>
   17970:	2aff      	cmp	r2, #255	; 0xff
   17972:	d12b      	bne.n	179cc <_lv_blend_fill+0x3f0>
   17974:	f36a 0507 	bfi	r5, sl, #0, #8
   17978:	f366 250f 	bfi	r5, r6, #8, #8
   1797c:	f368 4517 	bfi	r5, r8, #16, #8
   17980:	f8c9 5000 	str.w	r5, [r9]
                            FILL_NORMAL_MASK_PX(x + 1, color)
   17984:	7862      	ldrb	r2, [r4, #1]
   17986:	b14a      	cbz	r2, 1799c <_lv_blend_fill+0x3c0>
   17988:	2aff      	cmp	r2, #255	; 0xff
   1798a:	d130      	bne.n	179ee <_lv_blend_fill+0x412>
   1798c:	f36a 0507 	bfi	r5, sl, #0, #8
   17990:	f366 250f 	bfi	r5, r6, #8, #8
   17994:	f368 4517 	bfi	r5, r8, #16, #8
   17998:	f8c9 5004 	str.w	r5, [r9, #4]
                            FILL_NORMAL_MASK_PX(x + 2, color)
   1799c:	78a2      	ldrb	r2, [r4, #2]
   1799e:	b14a      	cbz	r2, 179b4 <_lv_blend_fill+0x3d8>
   179a0:	2aff      	cmp	r2, #255	; 0xff
   179a2:	d135      	bne.n	17a10 <_lv_blend_fill+0x434>
   179a4:	f36a 0507 	bfi	r5, sl, #0, #8
   179a8:	f366 250f 	bfi	r5, r6, #8, #8
   179ac:	f368 4517 	bfi	r5, r8, #16, #8
   179b0:	f8c9 5008 	str.w	r5, [r9, #8]
                            FILL_NORMAL_MASK_PX(x + 3, color)
   179b4:	78e2      	ldrb	r2, [r4, #3]
   179b6:	2a00      	cmp	r2, #0
   179b8:	d0d3      	beq.n	17962 <_lv_blend_fill+0x386>
   179ba:	2aff      	cmp	r2, #255	; 0xff
   179bc:	d139      	bne.n	17a32 <_lv_blend_fill+0x456>
   179be:	f36a 0507 	bfi	r5, sl, #0, #8
   179c2:	f366 250f 	bfi	r5, r6, #8, #8
   179c6:	f368 4517 	bfi	r5, r8, #16, #8
   179ca:	e7c8      	b.n	1795e <_lv_blend_fill+0x382>
                            FILL_NORMAL_MASK_PX(x, color)
   179cc:	f899 3000 	ldrb.w	r3, [r9]
   179d0:	9202      	str	r2, [sp, #8]
   179d2:	f899 2002 	ldrb.w	r2, [r9, #2]
   179d6:	4631      	mov	r1, r6
   179d8:	9201      	str	r2, [sp, #4]
   179da:	f899 2001 	ldrb.w	r2, [r9, #1]
   179de:	4650      	mov	r0, sl
   179e0:	9200      	str	r2, [sp, #0]
   179e2:	4642      	mov	r2, r8
   179e4:	f7ff fdd6 	bl	17594 <lv_color_mix.isra.0>
   179e8:	f8c9 0000 	str.w	r0, [r9]
   179ec:	e7ca      	b.n	17984 <_lv_blend_fill+0x3a8>
                            FILL_NORMAL_MASK_PX(x + 1, color)
   179ee:	f899 3004 	ldrb.w	r3, [r9, #4]
   179f2:	9202      	str	r2, [sp, #8]
   179f4:	f899 2006 	ldrb.w	r2, [r9, #6]
   179f8:	4631      	mov	r1, r6
   179fa:	9201      	str	r2, [sp, #4]
   179fc:	f899 2005 	ldrb.w	r2, [r9, #5]
   17a00:	4650      	mov	r0, sl
   17a02:	9200      	str	r2, [sp, #0]
   17a04:	4642      	mov	r2, r8
   17a06:	f7ff fdc5 	bl	17594 <lv_color_mix.isra.0>
   17a0a:	f8c9 0004 	str.w	r0, [r9, #4]
   17a0e:	e7c5      	b.n	1799c <_lv_blend_fill+0x3c0>
                            FILL_NORMAL_MASK_PX(x + 2, color)
   17a10:	f899 3008 	ldrb.w	r3, [r9, #8]
   17a14:	9202      	str	r2, [sp, #8]
   17a16:	f899 200a 	ldrb.w	r2, [r9, #10]
   17a1a:	4631      	mov	r1, r6
   17a1c:	9201      	str	r2, [sp, #4]
   17a1e:	f899 2009 	ldrb.w	r2, [r9, #9]
   17a22:	4650      	mov	r0, sl
   17a24:	9200      	str	r2, [sp, #0]
   17a26:	4642      	mov	r2, r8
   17a28:	f7ff fdb4 	bl	17594 <lv_color_mix.isra.0>
   17a2c:	f8c9 0008 	str.w	r0, [r9, #8]
   17a30:	e7c0      	b.n	179b4 <_lv_blend_fill+0x3d8>
                            FILL_NORMAL_MASK_PX(x + 3, color)
   17a32:	f899 300c 	ldrb.w	r3, [r9, #12]
   17a36:	9202      	str	r2, [sp, #8]
   17a38:	f899 200e 	ldrb.w	r2, [r9, #14]
   17a3c:	4631      	mov	r1, r6
   17a3e:	9201      	str	r2, [sp, #4]
   17a40:	f899 200d 	ldrb.w	r2, [r9, #13]
   17a44:	4650      	mov	r0, sl
   17a46:	9200      	str	r2, [sp, #0]
   17a48:	4642      	mov	r2, r8
   17a4a:	f7ff fda3 	bl	17594 <lv_color_mix.isra.0>
   17a4e:	f8c9 000c 	str.w	r0, [r9, #12]
   17a52:	e786      	b.n	17962 <_lv_blend_fill+0x386>
                    FILL_NORMAL_MASK_PX(x, color)
   17a54:	f814 2b01 	ldrb.w	r2, [r4], #1
   17a58:	b14a      	cbz	r2, 17a6e <_lv_blend_fill+0x492>
   17a5a:	2aff      	cmp	r2, #255	; 0xff
   17a5c:	d10a      	bne.n	17a74 <_lv_blend_fill+0x498>
   17a5e:	f36a 0507 	bfi	r5, sl, #0, #8
   17a62:	f366 250f 	bfi	r5, r6, #8, #8
   17a66:	f368 4517 	bfi	r5, r8, #16, #8
   17a6a:	f8c9 5000 	str.w	r5, [r9]
                for(; x < draw_area_w ; x++) {
   17a6e:	f109 0904 	add.w	r9, r9, #4
   17a72:	e747      	b.n	17904 <_lv_blend_fill+0x328>
                    FILL_NORMAL_MASK_PX(x, color)
   17a74:	f899 3000 	ldrb.w	r3, [r9]
   17a78:	9202      	str	r2, [sp, #8]
   17a7a:	f899 2002 	ldrb.w	r2, [r9, #2]
   17a7e:	4631      	mov	r1, r6
   17a80:	9201      	str	r2, [sp, #4]
   17a82:	f899 2001 	ldrb.w	r2, [r9, #1]
   17a86:	4650      	mov	r0, sl
   17a88:	9200      	str	r2, [sp, #0]
   17a8a:	4642      	mov	r2, r8
   17a8c:	f7ff fd82 	bl	17594 <lv_color_mix.isra.0>
   17a90:	f8c9 0000 	str.w	r0, [r9]
   17a94:	e7eb      	b.n	17a6e <_lv_blend_fill+0x492>
                    if(*mask_tmp_x) {
   17a96:	9b05      	ldr	r3, [sp, #20]
   17a98:	9907      	ldr	r1, [sp, #28]
   17a9a:	5c5b      	ldrb	r3, [r3, r1]
   17a9c:	b1eb      	cbz	r3, 17ada <_lv_blend_fill+0x4fe>
                        if(*mask_tmp_x != last_mask) opa_tmp = *mask_tmp_x == LV_OPA_COVER ? opa :
   17a9e:	42bb      	cmp	r3, r7
   17aa0:	d017      	beq.n	17ad2 <_lv_blend_fill+0x4f6>
   17aa2:	2bff      	cmp	r3, #255	; 0xff
                                                                   (uint32_t)((uint32_t)(*mask_tmp_x) * opa) >> 8;
   17aa4:	bf1d      	ittte	ne
   17aa6:	fb13 f304 	smulbbne	r3, r3, r4
                        if(*mask_tmp_x != last_mask) opa_tmp = *mask_tmp_x == LV_OPA_COVER ? opa :
   17aaa:	0a1b      	lsrne	r3, r3, #8
   17aac:	9309      	strne	r3, [sp, #36]	; 0x24
   17aae:	9409      	streq	r4, [sp, #36]	; 0x24
                            }
                            else
#endif
                            {
                                if(opa_tmp == LV_OPA_COVER) last_res_color = color;
                                else last_res_color = lv_color_mix(color, disp_buf_first[x], opa_tmp);
   17ab0:	9a09      	ldr	r2, [sp, #36]	; 0x24
   17ab2:	782b      	ldrb	r3, [r5, #0]
   17ab4:	9202      	str	r2, [sp, #8]
   17ab6:	78aa      	ldrb	r2, [r5, #2]
   17ab8:	4631      	mov	r1, r6
   17aba:	9201      	str	r2, [sp, #4]
   17abc:	786a      	ldrb	r2, [r5, #1]
   17abe:	4650      	mov	r0, sl
   17ac0:	9200      	str	r2, [sp, #0]
   17ac2:	4642      	mov	r2, r8
   17ac4:	f7ff fd66 	bl	17594 <lv_color_mix.isra.0>
                            }
                            last_mask = *mask_tmp_x;
   17ac8:	9a07      	ldr	r2, [sp, #28]
   17aca:	9b05      	ldr	r3, [sp, #20]
   17acc:	5c9f      	ldrb	r7, [r3, r2]
                            last_dest_color.full = disp_buf_first[x].full;
   17ace:	682a      	ldr	r2, [r5, #0]
   17ad0:	e002      	b.n	17ad8 <_lv_blend_fill+0x4fc>
                        if(*mask_tmp_x != last_mask || last_dest_color.full != disp_buf_first[x].full) {
   17ad2:	682b      	ldr	r3, [r5, #0]
   17ad4:	4293      	cmp	r3, r2
   17ad6:	d1eb      	bne.n	17ab0 <_lv_blend_fill+0x4d4>
                        }
                        disp_buf_first[x] = last_res_color;
   17ad8:	6028      	str	r0, [r5, #0]
                for(x = 0; x < draw_area_w; x++) {
   17ada:	9b07      	ldr	r3, [sp, #28]
   17adc:	3504      	adds	r5, #4
   17ade:	3301      	adds	r3, #1
   17ae0:	9307      	str	r3, [sp, #28]
   17ae2:	e9dd 3106 	ldrd	r3, r1, [sp, #24]
   17ae6:	428b      	cmp	r3, r1
   17ae8:	dcd5      	bgt.n	17a96 <_lv_blend_fill+0x4ba>
                    }
                    mask_tmp_x++;
                }
                disp_buf_first += disp_w;
   17aea:	9b08      	ldr	r3, [sp, #32]
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17aec:	f109 0901 	add.w	r9, r9, #1
                disp_buf_first += disp_w;
   17af0:	449b      	add	fp, r3
                mask += draw_area_w;
   17af2:	e9dd 3105 	ldrd	r3, r1, [sp, #20]
   17af6:	440b      	add	r3, r1
   17af8:	9305      	str	r3, [sp, #20]
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17afa:	e6cb      	b.n	17894 <_lv_blend_fill+0x2b8>

00017afc <_lv_blend_map>:
{
   17afc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17b00:	b08d      	sub	sp, #52	; 0x34
   17b02:	469b      	mov	fp, r3
   17b04:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
   17b08:	4689      	mov	r9, r1
    if(opa < LV_OPA_MIN) return;
   17b0a:	2b01      	cmp	r3, #1
{
   17b0c:	f89d 8058 	ldrb.w	r8, [sp, #88]	; 0x58
   17b10:	f89d 5060 	ldrb.w	r5, [sp, #96]	; 0x60
   17b14:	9208      	str	r2, [sp, #32]
   17b16:	9305      	str	r3, [sp, #20]
    if(opa < LV_OPA_MIN) return;
   17b18:	f240 80d4 	bls.w	17cc4 <_lv_blend_map+0x1c8>
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
   17b1c:	f1b8 0f00 	cmp.w	r8, #0
   17b20:	f000 80d0 	beq.w	17cc4 <_lv_blend_map+0x1c8>
    is_common = _lv_area_intersect(&draw_area, clip_area, map_area);
   17b24:	460a      	mov	r2, r1
   17b26:	4601      	mov	r1, r0
   17b28:	a80a      	add	r0, sp, #40	; 0x28
   17b2a:	f003 f8b7 	bl	1ac9c <_lv_area_intersect>
    if(!is_common) return;
   17b2e:	2800      	cmp	r0, #0
   17b30:	f000 80c8 	beq.w	17cc4 <_lv_blend_map+0x1c8>
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   17b34:	f7f2 fd74 	bl	a620 <_lv_refr_get_disp_refreshing>
   17b38:	4604      	mov	r4, r0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   17b3a:	f002 ffc3 	bl	1aac4 <lv_disp_get_buf>
    lv_color_t * disp_buf = vdb->buf_act;
   17b3e:	6883      	ldr	r3, [r0, #8]
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   17b40:	4607      	mov	r7, r0
    lv_color_t * disp_buf = vdb->buf_act;
   17b42:	9307      	str	r3, [sp, #28]
    if(disp->driver.gpu_wait_cb) disp->driver.gpu_wait_cb(&disp->driver);
   17b44:	6a63      	ldr	r3, [r4, #36]	; 0x24
   17b46:	b10b      	cbz	r3, 17b4c <_lv_blend_map+0x50>
   17b48:	4620      	mov	r0, r4
   17b4a:	4798      	blx	r3
    draw_area.x1 -= disp_area->x1;
   17b4c:	f9bd 1028 	ldrsh.w	r1, [sp, #40]	; 0x28
   17b50:	f9b7 6010 	ldrsh.w	r6, [r7, #16]
    draw_area.x2 -= disp_area->x1;
   17b54:	f9bd 202c 	ldrsh.w	r2, [sp, #44]	; 0x2c
    draw_area.y1 -= disp_area->y1;
   17b58:	f9bd 302a 	ldrsh.w	r3, [sp, #42]	; 0x2a
   17b5c:	f9b7 0012 	ldrsh.w	r0, [r7, #18]
    draw_area.x1 -= disp_area->x1;
   17b60:	eba1 0a06 	sub.w	sl, r1, r6
    draw_area.x2 -= disp_area->x1;
   17b64:	1b96      	subs	r6, r2, r6
   17b66:	f8ad 602c 	strh.w	r6, [sp, #44]	; 0x2c
    draw_area.y2 -= disp_area->y1;
   17b6a:	f9bd 602e 	ldrsh.w	r6, [sp, #46]	; 0x2e
    draw_area.y1 -= disp_area->y1;
   17b6e:	9306      	str	r3, [sp, #24]
   17b70:	1a1b      	subs	r3, r3, r0
    draw_area.x1 -= disp_area->x1;
   17b72:	fa0f fa8a 	sxth.w	sl, sl
    draw_area.y1 -= disp_area->y1;
   17b76:	b21b      	sxth	r3, r3
    draw_area.y2 -= disp_area->y1;
   17b78:	1a30      	subs	r0, r6, r0
    draw_area.x1 -= disp_area->x1;
   17b7a:	f8ad a028 	strh.w	sl, [sp, #40]	; 0x28
    draw_area.y1 -= disp_area->y1;
   17b7e:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
    draw_area.y2 -= disp_area->y1;
   17b82:	f8ad 002e 	strh.w	r0, [sp, #46]	; 0x2e
    if(mask && disp->driver.antialiasing == 0)
   17b86:	f1bb 0f00 	cmp.w	fp, #0
   17b8a:	d150      	bne.n	17c2e <_lv_blend_map+0x132>
    if(disp->driver.set_px_cb) {
   17b8c:	6960      	ldr	r0, [r4, #20]
   17b8e:	2800      	cmp	r0, #0
   17b90:	d16b      	bne.n	17c6a <_lv_blend_map+0x16e>
    else if(mode == LV_BLEND_MODE_NORMAL) {
   17b92:	2d00      	cmp	r5, #0
   17b94:	f040 8096 	bne.w	17cc4 <_lv_blend_map+0x1c8>
   17b98:	f1c1 0101 	rsb	r1, r1, #1
   17b9c:	4411      	add	r1, r2
   17b9e:	b20a      	sxth	r2, r1
   17ba0:	8ab8      	ldrh	r0, [r7, #20]
   17ba2:	f9b7 c010 	ldrsh.w	ip, [r7, #16]
   17ba6:	9204      	str	r2, [sp, #16]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   17ba8:	9a06      	ldr	r2, [sp, #24]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   17baa:	3001      	adds	r0, #1
   17bac:	eba0 000c 	sub.w	r0, r0, ip
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   17bb0:	f1c2 0201 	rsb	r2, r2, #1
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   17bb4:	b200      	sxth	r0, r0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   17bb6:	4416      	add	r6, r2

    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);

    int32_t draw_area_w = lv_area_get_width(draw_area);
    int32_t draw_area_h = lv_area_get_height(draw_area);
   17bb8:	b232      	sxth	r2, r6

    /*Get the width of the `mask_area` it will be used to go to the next line*/
    int32_t map_w = lv_area_get_width(map_area);

    /*Create a temp. disp_buf which always point to first pixel to draw*/
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   17bba:	fb00 a603 	mla	r6, r0, r3, sl
   17bbe:	9c07      	ldr	r4, [sp, #28]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   17bc0:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    int32_t draw_area_h = lv_area_get_height(draw_area);
   17bc4:	9206      	str	r2, [sp, #24]
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
   17bc6:	eb04 0686 	add.w	r6, r4, r6, lsl #2
   17bca:	f9b9 2000 	ldrsh.w	r2, [r9]

    /*Create a temp. map_buf which always point to first pixel to draw from the map*/
    const lv_color_t * map_buf_first = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   17bce:	f9b7 4012 	ldrsh.w	r4, [r7, #18]
   17bd2:	f9b9 7002 	ldrsh.w	r7, [r9, #2]
   17bd6:	3101      	adds	r1, #1
   17bd8:	1a89      	subs	r1, r1, r2
   17bda:	1be4      	subs	r4, r4, r7
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   17bdc:	ebac 0c02 	sub.w	ip, ip, r2
   17be0:	b209      	sxth	r1, r1
    const lv_color_t * map_buf_first = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   17be2:	441c      	add	r4, r3
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   17be4:	44e2      	add	sl, ip
   17be6:	fb01 a404 	mla	r4, r1, r4, sl
   17bea:	9b08      	ldr	r3, [sp, #32]

    int32_t x;
    int32_t y;

    /*Simple fill (maybe with opacity), no masking*/
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   17bec:	f1b8 0f01 	cmp.w	r8, #1
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
   17bf0:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   17bf4:	ea4f 0380 	mov.w	r3, r0, lsl #2
   17bf8:	9308      	str	r3, [sp, #32]
   17bfa:	ea4f 0381 	mov.w	r3, r1, lsl #2
   17bfe:	9307      	str	r3, [sp, #28]
            }
            return;
        }
#endif

        if(opa > LV_OPA_MAX) {
   17c00:	9b05      	ldr	r3, [sp, #20]
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   17c02:	f040 80dd 	bne.w	17dc0 <_lv_blend_map+0x2c4>
        if(opa > LV_OPA_MAX) {
   17c06:	2bfd      	cmp	r3, #253	; 0xfd
   17c08:	f240 80d2 	bls.w	17db0 <_lv_blend_map+0x2b4>
            }
#endif

            /*Software rendering*/
            for(y = 0; y < draw_area_h; y++) {
                _lv_memcpy(disp_buf_first, map_buf_first, draw_area_w * sizeof(lv_color_t));
   17c0c:	9b04      	ldr	r3, [sp, #16]
   17c0e:	ea4f 0b83 	mov.w	fp, r3, lsl #2
            for(y = 0; y < draw_area_h; y++) {
   17c12:	9b06      	ldr	r3, [sp, #24]
   17c14:	42ab      	cmp	r3, r5
   17c16:	dd55      	ble.n	17cc4 <_lv_blend_map+0x1c8>
   17c18:	4621      	mov	r1, r4
   17c1a:	4630      	mov	r0, r6
   17c1c:	465a      	mov	r2, fp
   17c1e:	f005 fea0 	bl	1d962 <memcpy>
                disp_buf_first += disp_w;
   17c22:	9b08      	ldr	r3, [sp, #32]
            for(y = 0; y < draw_area_h; y++) {
   17c24:	3501      	adds	r5, #1
                disp_buf_first += disp_w;
   17c26:	441e      	add	r6, r3
                map_buf_first += map_w;
   17c28:	9b07      	ldr	r3, [sp, #28]
   17c2a:	441c      	add	r4, r3
            for(y = 0; y < draw_area_h; y++) {
   17c2c:	e7f1      	b.n	17c12 <_lv_blend_map+0x116>
    if(mask && disp->driver.antialiasing == 0)
   17c2e:	7a20      	ldrb	r0, [r4, #8]
   17c30:	07c0      	lsls	r0, r0, #31
   17c32:	d4ab      	bmi.n	17b8c <_lv_blend_map+0x90>
   17c34:	1c50      	adds	r0, r2, #1
   17c36:	1a40      	subs	r0, r0, r1
        int32_t mask_w = lv_area_get_width(&draw_area);
   17c38:	b200      	sxth	r0, r0
   17c3a:	9004      	str	r0, [sp, #16]
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
   17c3c:	f1cb 0001 	rsb	r0, fp, #1
   17c40:	f10b 3cff 	add.w	ip, fp, #4294967295
   17c44:	9009      	str	r0, [sp, #36]	; 0x24
   17c46:	9809      	ldr	r0, [sp, #36]	; 0x24
   17c48:	eb00 0e0c 	add.w	lr, r0, ip
   17c4c:	9804      	ldr	r0, [sp, #16]
   17c4e:	4570      	cmp	r0, lr
   17c50:	dd9c      	ble.n	17b8c <_lv_blend_map+0x90>
   17c52:	f81c ef01 	ldrb.w	lr, [ip, #1]!
   17c56:	f1be 0f80 	cmp.w	lr, #128	; 0x80
   17c5a:	f04f 3eff 	mov.w	lr, #4294967295
   17c5e:	bf98      	it	ls
   17c60:	f04f 0e00 	movls.w	lr, #0
   17c64:	f88c e000 	strb.w	lr, [ip]
   17c68:	e7ed      	b.n	17c46 <_lv_blend_map+0x14a>
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
   17c6a:	f7f2 fcd9 	bl	a620 <_lv_refr_get_disp_refreshing>
   17c6e:	f8b9 5004 	ldrh.w	r5, [r9, #4]
   17c72:	8aba      	ldrh	r2, [r7, #20]
   17c74:	f9b9 c000 	ldrsh.w	ip, [r9]
    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   17c78:	f9bd 602a 	ldrsh.w	r6, [sp, #42]	; 0x2a
   17c7c:	f9b9 4002 	ldrsh.w	r4, [r9, #2]
   17c80:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
   17c84:	3501      	adds	r5, #1
   17c86:	f9b7 7012 	ldrsh.w	r7, [r7, #18]
   17c8a:	3201      	adds	r2, #1
   17c8c:	eba5 050c 	sub.w	r5, r5, ip
   17c90:	1b34      	subs	r4, r6, r4
   17c92:	1ad2      	subs	r2, r2, r3
   17c94:	b22d      	sxth	r5, r5
    map_buf_tmp -= draw_area->x1;
   17c96:	eba3 030c 	sub.w	r3, r3, ip
    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
   17c9a:	443c      	add	r4, r7
    map_buf_tmp -= draw_area->x1;
   17c9c:	fb05 3404 	mla	r4, r5, r4, r3
   17ca0:	9b08      	ldr	r3, [sp, #32]
   17ca2:	f9bd 1028 	ldrsh.w	r1, [sp, #40]	; 0x28
   17ca6:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
   17caa:	f1b8 0f01 	cmp.w	r8, #1
   17cae:	ea4f 0385 	mov.w	r3, r5, lsl #2
   17cb2:	b212      	sxth	r2, r2
   17cb4:	f1c1 0a00 	rsb	sl, r1, #0
   17cb8:	9304      	str	r3, [sp, #16]
   17cba:	d123      	bne.n	17d04 <_lv_blend_map+0x208>
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17cbc:	f9bd 302e 	ldrsh.w	r3, [sp, #46]	; 0x2e
   17cc0:	429e      	cmp	r6, r3
   17cc2:	dd02      	ble.n	17cca <_lv_blend_map+0x1ce>
}
   17cc4:	b00d      	add	sp, #52	; 0x34
   17cc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   17cca:	f9bd 8028 	ldrsh.w	r8, [sp, #40]	; 0x28
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x], opa);
   17cce:	b237      	sxth	r7, r6
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   17cd0:	f9bd 302c 	ldrsh.w	r3, [sp, #44]	; 0x2c
   17cd4:	4598      	cmp	r8, r3
   17cd6:	dd03      	ble.n	17ce0 <_lv_blend_map+0x1e4>
            map_buf_tmp += map_w;
   17cd8:	9b04      	ldr	r3, [sp, #16]
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17cda:	3601      	adds	r6, #1
            map_buf_tmp += map_w;
   17cdc:	441c      	add	r4, r3
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17cde:	e7ed      	b.n	17cbc <_lv_blend_map+0x1c0>
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x], opa);
   17ce0:	9b05      	ldr	r3, [sp, #20]
   17ce2:	9907      	ldr	r1, [sp, #28]
   17ce4:	9302      	str	r3, [sp, #8]
   17ce6:	f854 3028 	ldr.w	r3, [r4, r8, lsl #2]
   17cea:	9208      	str	r2, [sp, #32]
   17cec:	e9cd 7300 	strd	r7, r3, [sp]
   17cf0:	fa0f f388 	sxth.w	r3, r8
   17cf4:	6945      	ldr	r5, [r0, #20]
   17cf6:	9006      	str	r0, [sp, #24]
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   17cf8:	f108 0801 	add.w	r8, r8, #1
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x], opa);
   17cfc:	47a8      	blx	r5
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   17cfe:	9a08      	ldr	r2, [sp, #32]
   17d00:	9806      	ldr	r0, [sp, #24]
   17d02:	e7e5      	b.n	17cd0 <_lv_blend_map+0x1d4>
   17d04:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
   17d08:	44da      	add	sl, fp
   17d0a:	f108 0801 	add.w	r8, r8, #1
   17d0e:	eba8 0801 	sub.w	r8, r8, r1
   17d12:	fa0f f888 	sxth.w	r8, r8
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17d16:	f9bd 302e 	ldrsh.w	r3, [sp, #46]	; 0x2e
   17d1a:	429e      	cmp	r6, r3
   17d1c:	dcd2      	bgt.n	17cc4 <_lv_blend_map+0x1c8>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   17d1e:	f9bd 9028 	ldrsh.w	r9, [sp, #40]	; 0x28
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
   17d22:	b237      	sxth	r7, r6
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   17d24:	f9bd 302c 	ldrsh.w	r3, [sp, #44]	; 0x2c
   17d28:	4599      	cmp	r9, r3
   17d2a:	dd04      	ble.n	17d36 <_lv_blend_map+0x23a>
            map_buf_tmp += map_w;
   17d2c:	9b04      	ldr	r3, [sp, #16]
            mask_tmp += draw_area_w;
   17d2e:	44c2      	add	sl, r8
            map_buf_tmp += map_w;
   17d30:	441c      	add	r4, r3
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
   17d32:	3601      	adds	r6, #1
   17d34:	e7ef      	b.n	17d16 <_lv_blend_map+0x21a>
                if(mask_tmp[x]) {
   17d36:	f81a 3009 	ldrb.w	r3, [sl, r9]
   17d3a:	b18b      	cbz	r3, 17d60 <_lv_blend_map+0x264>
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   17d3c:	9905      	ldr	r1, [sp, #20]
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
   17d3e:	9208      	str	r2, [sp, #32]
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
   17d40:	fb11 f303 	smulbb	r3, r1, r3
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
   17d44:	0a1b      	lsrs	r3, r3, #8
   17d46:	9302      	str	r3, [sp, #8]
   17d48:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
   17d4c:	9907      	ldr	r1, [sp, #28]
   17d4e:	e9cd 7300 	strd	r7, r3, [sp]
   17d52:	fa0f f389 	sxth.w	r3, r9
   17d56:	6945      	ldr	r5, [r0, #20]
   17d58:	9006      	str	r0, [sp, #24]
   17d5a:	47a8      	blx	r5
   17d5c:	9a08      	ldr	r2, [sp, #32]
   17d5e:	9806      	ldr	r0, [sp, #24]
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
   17d60:	f109 0901 	add.w	r9, r9, #1
   17d64:	e7de      	b.n	17d24 <_lv_blend_map+0x228>
                                                &disp_buf_first[x].ch.alpha);
                    }
                    else
#endif
                    {
                        disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa);
   17d66:	9b05      	ldr	r3, [sp, #20]
   17d68:	f818 ec04 	ldrb.w	lr, [r8, #-4]
   17d6c:	f817 2c02 	ldrb.w	r2, [r7, #-2]
   17d70:	f817 1c03 	ldrb.w	r1, [r7, #-3]
   17d74:	f817 0c04 	ldrb.w	r0, [r7, #-4]
   17d78:	9302      	str	r3, [sp, #8]
   17d7a:	f818 cc02 	ldrb.w	ip, [r8, #-2]
   17d7e:	4673      	mov	r3, lr
   17d80:	f8cd c004 	str.w	ip, [sp, #4]
   17d84:	f818 cc03 	ldrb.w	ip, [r8, #-3]
                for(x = 0; x < draw_area_w; x++) {
   17d88:	f109 0901 	add.w	r9, r9, #1
                        disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa);
   17d8c:	f8cd c000 	str.w	ip, [sp]
   17d90:	f7ff fc00 	bl	17594 <lv_color_mix.isra.0>
   17d94:	f8ca 0000 	str.w	r0, [sl]
                for(x = 0; x < draw_area_w; x++) {
   17d98:	46c2      	mov	sl, r8
   17d9a:	9b04      	ldr	r3, [sp, #16]
   17d9c:	3704      	adds	r7, #4
   17d9e:	454b      	cmp	r3, r9
   17da0:	f10a 0804 	add.w	r8, sl, #4
   17da4:	dcdf      	bgt.n	17d66 <_lv_blend_map+0x26a>
                    }
                }
                disp_buf_first += disp_w;
   17da6:	9b08      	ldr	r3, [sp, #32]
            for(y = 0; y < draw_area_h; y++) {
   17da8:	3501      	adds	r5, #1
                disp_buf_first += disp_w;
   17daa:	441e      	add	r6, r3
                map_buf_first += map_w;
   17dac:	9b07      	ldr	r3, [sp, #28]
   17dae:	441c      	add	r4, r3
            for(y = 0; y < draw_area_h; y++) {
   17db0:	9b06      	ldr	r3, [sp, #24]
   17db2:	42ab      	cmp	r3, r5
   17db4:	dd86      	ble.n	17cc4 <_lv_blend_map+0x1c8>
   17db6:	4627      	mov	r7, r4
   17db8:	46b2      	mov	sl, r6
                for(x = 0; x < draw_area_w; x++) {
   17dba:	f04f 0900 	mov.w	r9, #0
   17dbe:	e7ec      	b.n	17d9a <_lv_blend_map+0x29e>
        }
    }
    /*Masked*/
    else {
        /*Only the mask matters*/
        if(opa > LV_OPA_MAX) {
   17dc0:	2bfd      	cmp	r3, #253	; 0xfd
   17dc2:	f240 8126 	bls.w	18012 <_lv_blend_map+0x516>
            /*Go to the first pixel of the row */

            int32_t x_end4 = draw_area_w - 4;
   17dc6:	9b04      	ldr	r3, [sp, #16]

            for(y = 0; y < draw_area_h; y++) {
   17dc8:	9505      	str	r5, [sp, #20]
            int32_t x_end4 = draw_area_w - 4;
   17dca:	3b04      	subs	r3, #4
   17dcc:	9309      	str	r3, [sp, #36]	; 0x24
            for(y = 0; y < draw_area_h; y++) {
   17dce:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
   17dd2:	4293      	cmp	r3, r2
   17dd4:	f77f af76 	ble.w	17cc4 <_lv_blend_map+0x1c8>
   17dd8:	46a1      	mov	r9, r4
   17dda:	46b0      	mov	r8, r6
   17ddc:	46da      	mov	sl, fp
#if 0
                for(x = 0; x < draw_area_w; x++) {
                    MAP_NORMAL_MASK_PX(x);
                }
#else
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
   17dde:	2500      	movs	r5, #0
   17de0:	e00d      	b.n	17dfe <_lv_blend_map+0x302>
#if LV_COLOR_SCREEN_TRANSP
                    MAP_NORMAL_MASK_PX_SCR_TRANSP(x)
#else
                    MAP_NORMAL_MASK_PX(x)
   17de2:	f81a 0b01 	ldrb.w	r0, [sl], #1
   17de6:	b128      	cbz	r0, 17df4 <_lv_blend_map+0x2f8>
   17de8:	28ff      	cmp	r0, #255	; 0xff
   17dea:	d129      	bne.n	17e40 <_lv_blend_map+0x344>
   17dec:	f8d9 3000 	ldr.w	r3, [r9]
   17df0:	f8c8 3000 	str.w	r3, [r8]
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
   17df4:	3501      	adds	r5, #1
   17df6:	f109 0904 	add.w	r9, r9, #4
   17dfa:	f108 0804 	add.w	r8, r8, #4
   17dfe:	9b04      	ldr	r3, [sp, #16]
   17e00:	4657      	mov	r7, sl
   17e02:	42ab      	cmp	r3, r5
   17e04:	dd02      	ble.n	17e0c <_lv_blend_map+0x310>
   17e06:	f01a 0f03 	tst.w	sl, #3
   17e0a:	d1ea      	bne.n	17de2 <_lv_blend_map+0x2e6>
   17e0c:	eb04 0985 	add.w	r9, r4, r5, lsl #2
   17e10:	eb06 0885 	add.w	r8, r6, r5, lsl #2
#endif
                }

                uint32_t * mask32 = (uint32_t *) mask_tmp_x;
                for(; x < x_end4; x += 4) {
   17e14:	9b09      	ldr	r3, [sp, #36]	; 0x24
   17e16:	42ab      	cmp	r3, r5
   17e18:	dc26      	bgt.n	17e68 <_lv_blend_map+0x36c>
   17e1a:	eb04 0985 	add.w	r9, r4, r5, lsl #2
   17e1e:	eb06 0885 	add.w	r8, r6, r5, lsl #2
                    }
                    mask32++;
                }

                mask_tmp_x = (const lv_opa_t *)mask32;
                for(; x < draw_area_w ; x++) {
   17e22:	1bed      	subs	r5, r5, r7
   17e24:	9a04      	ldr	r2, [sp, #16]
   17e26:	19eb      	adds	r3, r5, r7
   17e28:	429a      	cmp	r2, r3
   17e2a:	f300 80a8 	bgt.w	17f7e <_lv_blend_map+0x482>
#else
                    MAP_NORMAL_MASK_PX(x)
#endif
                }
#endif
                disp_buf_first += disp_w;
   17e2e:	9b08      	ldr	r3, [sp, #32]
                mask += draw_area_w;
   17e30:	4493      	add	fp, r2
                disp_buf_first += disp_w;
   17e32:	441e      	add	r6, r3
                map_buf_first += map_w;
   17e34:	9b07      	ldr	r3, [sp, #28]
   17e36:	441c      	add	r4, r3
            for(y = 0; y < draw_area_h; y++) {
   17e38:	9b05      	ldr	r3, [sp, #20]
   17e3a:	3301      	adds	r3, #1
   17e3c:	9305      	str	r3, [sp, #20]
   17e3e:	e7c6      	b.n	17dce <_lv_blend_map+0x2d2>
                    MAP_NORMAL_MASK_PX(x)
   17e40:	f898 3000 	ldrb.w	r3, [r8]
   17e44:	f899 2002 	ldrb.w	r2, [r9, #2]
   17e48:	f899 1001 	ldrb.w	r1, [r9, #1]
   17e4c:	9002      	str	r0, [sp, #8]
   17e4e:	f898 0002 	ldrb.w	r0, [r8, #2]
   17e52:	9001      	str	r0, [sp, #4]
   17e54:	f898 0001 	ldrb.w	r0, [r8, #1]
   17e58:	9000      	str	r0, [sp, #0]
   17e5a:	f899 0000 	ldrb.w	r0, [r9]
   17e5e:	f7ff fb99 	bl	17594 <lv_color_mix.isra.0>
   17e62:	f8c8 0000 	str.w	r0, [r8]
   17e66:	e7c5      	b.n	17df4 <_lv_blend_map+0x2f8>
                    if(*mask32) {
   17e68:	683b      	ldr	r3, [r7, #0]
   17e6a:	b18b      	cbz	r3, 17e90 <_lv_blend_map+0x394>
                        if((*mask32) == 0xFFFFFFFF) {
   17e6c:	3301      	adds	r3, #1
   17e6e:	d116      	bne.n	17e9e <_lv_blend_map+0x3a2>
                            disp_buf_first[x] = map_buf_first[x];
   17e70:	f8d9 3000 	ldr.w	r3, [r9]
   17e74:	f8c8 3000 	str.w	r3, [r8]
                            disp_buf_first[x + 1] = map_buf_first[x + 1];
   17e78:	f8d9 3004 	ldr.w	r3, [r9, #4]
   17e7c:	f8c8 3004 	str.w	r3, [r8, #4]
                            disp_buf_first[x + 2] = map_buf_first[x + 2];
   17e80:	f8d9 3008 	ldr.w	r3, [r9, #8]
   17e84:	f8c8 3008 	str.w	r3, [r8, #8]
                            MAP_NORMAL_MASK_PX(x + 3)
   17e88:	f8d9 300c 	ldr.w	r3, [r9, #12]
   17e8c:	f8c8 300c 	str.w	r3, [r8, #12]
                    mask32++;
   17e90:	3704      	adds	r7, #4
                for(; x < x_end4; x += 4) {
   17e92:	3504      	adds	r5, #4
   17e94:	f109 0910 	add.w	r9, r9, #16
   17e98:	f108 0810 	add.w	r8, r8, #16
   17e9c:	e7ba      	b.n	17e14 <_lv_blend_map+0x318>
                            MAP_NORMAL_MASK_PX(x)
   17e9e:	7838      	ldrb	r0, [r7, #0]
   17ea0:	b128      	cbz	r0, 17eae <_lv_blend_map+0x3b2>
   17ea2:	28ff      	cmp	r0, #255	; 0xff
   17ea4:	d12d      	bne.n	17f02 <_lv_blend_map+0x406>
   17ea6:	f8d9 3000 	ldr.w	r3, [r9]
   17eaa:	f8c8 3000 	str.w	r3, [r8]
                            MAP_NORMAL_MASK_PX(x + 1)
   17eae:	787b      	ldrb	r3, [r7, #1]
   17eb0:	b12b      	cbz	r3, 17ebe <_lv_blend_map+0x3c2>
   17eb2:	2bff      	cmp	r3, #255	; 0xff
   17eb4:	d139      	bne.n	17f2a <_lv_blend_map+0x42e>
   17eb6:	f8d9 3004 	ldr.w	r3, [r9, #4]
   17eba:	f8c8 3004 	str.w	r3, [r8, #4]
                            MAP_NORMAL_MASK_PX(x + 2)
   17ebe:	78bb      	ldrb	r3, [r7, #2]
   17ec0:	b12b      	cbz	r3, 17ece <_lv_blend_map+0x3d2>
   17ec2:	2bff      	cmp	r3, #255	; 0xff
   17ec4:	d146      	bne.n	17f54 <_lv_blend_map+0x458>
   17ec6:	f8d9 3008 	ldr.w	r3, [r9, #8]
   17eca:	f8c8 3008 	str.w	r3, [r8, #8]
                            MAP_NORMAL_MASK_PX(x + 3)
   17ece:	78fb      	ldrb	r3, [r7, #3]
   17ed0:	2b00      	cmp	r3, #0
   17ed2:	d0dd      	beq.n	17e90 <_lv_blend_map+0x394>
   17ed4:	2bff      	cmp	r3, #255	; 0xff
   17ed6:	d0d7      	beq.n	17e88 <_lv_blend_map+0x38c>
   17ed8:	f898 c00c 	ldrb.w	ip, [r8, #12]
   17edc:	f899 200e 	ldrb.w	r2, [r9, #14]
   17ee0:	f899 100d 	ldrb.w	r1, [r9, #13]
   17ee4:	f899 000c 	ldrb.w	r0, [r9, #12]
   17ee8:	9302      	str	r3, [sp, #8]
   17eea:	f898 300e 	ldrb.w	r3, [r8, #14]
   17eee:	9301      	str	r3, [sp, #4]
   17ef0:	f898 300d 	ldrb.w	r3, [r8, #13]
   17ef4:	9300      	str	r3, [sp, #0]
   17ef6:	4663      	mov	r3, ip
   17ef8:	f7ff fb4c 	bl	17594 <lv_color_mix.isra.0>
   17efc:	f8c8 000c 	str.w	r0, [r8, #12]
   17f00:	e7c6      	b.n	17e90 <_lv_blend_map+0x394>
                            MAP_NORMAL_MASK_PX(x)
   17f02:	f898 3000 	ldrb.w	r3, [r8]
   17f06:	f899 2002 	ldrb.w	r2, [r9, #2]
   17f0a:	f899 1001 	ldrb.w	r1, [r9, #1]
   17f0e:	9002      	str	r0, [sp, #8]
   17f10:	f898 0002 	ldrb.w	r0, [r8, #2]
   17f14:	9001      	str	r0, [sp, #4]
   17f16:	f898 0001 	ldrb.w	r0, [r8, #1]
   17f1a:	9000      	str	r0, [sp, #0]
   17f1c:	f899 0000 	ldrb.w	r0, [r9]
   17f20:	f7ff fb38 	bl	17594 <lv_color_mix.isra.0>
   17f24:	f8c8 0000 	str.w	r0, [r8]
   17f28:	e7c1      	b.n	17eae <_lv_blend_map+0x3b2>
                            MAP_NORMAL_MASK_PX(x + 1)
   17f2a:	f898 c004 	ldrb.w	ip, [r8, #4]
   17f2e:	f899 2006 	ldrb.w	r2, [r9, #6]
   17f32:	f899 1005 	ldrb.w	r1, [r9, #5]
   17f36:	f899 0004 	ldrb.w	r0, [r9, #4]
   17f3a:	9302      	str	r3, [sp, #8]
   17f3c:	f898 3006 	ldrb.w	r3, [r8, #6]
   17f40:	9301      	str	r3, [sp, #4]
   17f42:	f898 3005 	ldrb.w	r3, [r8, #5]
   17f46:	9300      	str	r3, [sp, #0]
   17f48:	4663      	mov	r3, ip
   17f4a:	f7ff fb23 	bl	17594 <lv_color_mix.isra.0>
   17f4e:	f8c8 0004 	str.w	r0, [r8, #4]
   17f52:	e7b4      	b.n	17ebe <_lv_blend_map+0x3c2>
                            MAP_NORMAL_MASK_PX(x + 2)
   17f54:	f898 c008 	ldrb.w	ip, [r8, #8]
   17f58:	f899 200a 	ldrb.w	r2, [r9, #10]
   17f5c:	f899 1009 	ldrb.w	r1, [r9, #9]
   17f60:	f899 0008 	ldrb.w	r0, [r9, #8]
   17f64:	9302      	str	r3, [sp, #8]
   17f66:	f898 300a 	ldrb.w	r3, [r8, #10]
   17f6a:	9301      	str	r3, [sp, #4]
   17f6c:	f898 3009 	ldrb.w	r3, [r8, #9]
   17f70:	9300      	str	r3, [sp, #0]
   17f72:	4663      	mov	r3, ip
   17f74:	f7ff fb0e 	bl	17594 <lv_color_mix.isra.0>
   17f78:	f8c8 0008 	str.w	r0, [r8, #8]
   17f7c:	e7a7      	b.n	17ece <_lv_blend_map+0x3d2>
                    MAP_NORMAL_MASK_PX(x)
   17f7e:	f817 0b01 	ldrb.w	r0, [r7], #1
   17f82:	b128      	cbz	r0, 17f90 <_lv_blend_map+0x494>
   17f84:	28ff      	cmp	r0, #255	; 0xff
   17f86:	d108      	bne.n	17f9a <_lv_blend_map+0x49e>
   17f88:	f8d9 3000 	ldr.w	r3, [r9]
   17f8c:	f8c8 3000 	str.w	r3, [r8]
                for(; x < draw_area_w ; x++) {
   17f90:	f109 0904 	add.w	r9, r9, #4
   17f94:	f108 0804 	add.w	r8, r8, #4
   17f98:	e744      	b.n	17e24 <_lv_blend_map+0x328>
                    MAP_NORMAL_MASK_PX(x)
   17f9a:	f898 3000 	ldrb.w	r3, [r8]
   17f9e:	f899 2002 	ldrb.w	r2, [r9, #2]
   17fa2:	f899 1001 	ldrb.w	r1, [r9, #1]
   17fa6:	9002      	str	r0, [sp, #8]
   17fa8:	f898 0002 	ldrb.w	r0, [r8, #2]
   17fac:	9001      	str	r0, [sp, #4]
   17fae:	f898 0001 	ldrb.w	r0, [r8, #1]
   17fb2:	9000      	str	r0, [sp, #0]
   17fb4:	f899 0000 	ldrb.w	r0, [r9]
   17fb8:	f7ff faec 	bl	17594 <lv_color_mix.isra.0>
   17fbc:	f8c8 0000 	str.w	r0, [r8]
   17fc0:	e7e6      	b.n	17f90 <_lv_blend_map+0x494>
        }
        /*Handle opa and mask values too*/
        else {
            for(y = 0; y < draw_area_h; y++) {
                for(x = 0; x < draw_area_w; x++) {
                    if(mask[x]) {
   17fc2:	f81b 3009 	ldrb.w	r3, [fp, r9]
   17fc6:	b1ab      	cbz	r3, 17ff4 <_lv_blend_map+0x4f8>
                        lv_opa_t opa_tmp = mask[x] >= LV_OPA_MAX ? opa : ((opa * mask[x]) >> 8);
   17fc8:	2bfc      	cmp	r3, #252	; 0xfc
   17fca:	bf97      	itett	ls
   17fcc:	9a05      	ldrls	r2, [sp, #20]
   17fce:	9805      	ldrhi	r0, [sp, #20]
   17fd0:	fb12 f303 	smulbbls	r3, r2, r3
   17fd4:	0a18      	lsrls	r0, r3, #8
                                                    &disp_buf_first[x].ch.alpha);
                        }
                        else
#endif
                        {
                            disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa_tmp);
   17fd6:	f898 2002 	ldrb.w	r2, [r8, #2]
   17fda:	783b      	ldrb	r3, [r7, #0]
   17fdc:	f898 1001 	ldrb.w	r1, [r8, #1]
   17fe0:	9002      	str	r0, [sp, #8]
   17fe2:	78b8      	ldrb	r0, [r7, #2]
   17fe4:	9001      	str	r0, [sp, #4]
   17fe6:	7878      	ldrb	r0, [r7, #1]
   17fe8:	9000      	str	r0, [sp, #0]
   17fea:	f898 0000 	ldrb.w	r0, [r8]
   17fee:	f7ff fad1 	bl	17594 <lv_color_mix.isra.0>
   17ff2:	6038      	str	r0, [r7, #0]
                for(x = 0; x < draw_area_w; x++) {
   17ff4:	f109 0901 	add.w	r9, r9, #1
   17ff8:	f108 0804 	add.w	r8, r8, #4
   17ffc:	3704      	adds	r7, #4
   17ffe:	9b04      	ldr	r3, [sp, #16]
   18000:	454b      	cmp	r3, r9
   18002:	dcde      	bgt.n	17fc2 <_lv_blend_map+0x4c6>
                        }
                    }
                }
                disp_buf_first += disp_w;
   18004:	9b08      	ldr	r3, [sp, #32]
            for(y = 0; y < draw_area_h; y++) {
   18006:	3501      	adds	r5, #1
                disp_buf_first += disp_w;
   18008:	441e      	add	r6, r3
                mask += draw_area_w;
   1800a:	9b04      	ldr	r3, [sp, #16]
   1800c:	449b      	add	fp, r3
                map_buf_first += map_w;
   1800e:	9b07      	ldr	r3, [sp, #28]
   18010:	441c      	add	r4, r3
            for(y = 0; y < draw_area_h; y++) {
   18012:	9b06      	ldr	r3, [sp, #24]
   18014:	42ab      	cmp	r3, r5
   18016:	f77f ae55 	ble.w	17cc4 <_lv_blend_map+0x1c8>
   1801a:	46a0      	mov	r8, r4
   1801c:	4637      	mov	r7, r6
                for(x = 0; x < draw_area_w; x++) {
   1801e:	f04f 0900 	mov.w	r9, #0
   18022:	e7ec      	b.n	17ffe <_lv_blend_map+0x502>

00018024 <show_error>:
        }
    }
}

static void show_error(const lv_area_t * coords, const lv_area_t * clip_area, const char * msg)
{
   18024:	b570      	push	{r4, r5, r6, lr}
   18026:	b0a6      	sub	sp, #152	; 0x98
   18028:	4604      	mov	r4, r0
   1802a:	460d      	mov	r5, r1
    lv_draw_rect_dsc_t rect_dsc;
    lv_draw_rect_dsc_init(&rect_dsc);
   1802c:	a80c      	add	r0, sp, #48	; 0x30
{
   1802e:	4616      	mov	r6, r2
    lv_draw_rect_dsc_init(&rect_dsc);
   18030:	f7f3 ff74 	bl	bf1c <lv_draw_rect_dsc_init>
    rect_dsc.bg_color = LV_COLOR_WHITE;
   18034:	f04f 33ff 	mov.w	r3, #4294967295
    lv_draw_rect(coords, clip_area, &rect_dsc);
   18038:	4629      	mov	r1, r5
   1803a:	aa0c      	add	r2, sp, #48	; 0x30
   1803c:	4620      	mov	r0, r4
    rect_dsc.bg_color = LV_COLOR_WHITE;
   1803e:	930d      	str	r3, [sp, #52]	; 0x34
    lv_draw_rect(coords, clip_area, &rect_dsc);
   18040:	f000 ffd9 	bl	18ff6 <lv_draw_rect>

    lv_draw_label_dsc_t label_dsc;
    lv_draw_label_dsc_init(&label_dsc);
   18044:	a803      	add	r0, sp, #12
   18046:	f7f2 fded 	bl	ac24 <lv_draw_label_dsc_init>
    lv_draw_label(coords, clip_area, &label_dsc, msg, NULL);
   1804a:	2300      	movs	r3, #0
   1804c:	4629      	mov	r1, r5
   1804e:	9300      	str	r3, [sp, #0]
   18050:	4620      	mov	r0, r4
   18052:	4633      	mov	r3, r6
   18054:	aa03      	add	r2, sp, #12
   18056:	f7f2 fdfd 	bl	ac54 <lv_draw_label>
}
   1805a:	b026      	add	sp, #152	; 0x98
   1805c:	bd70      	pop	{r4, r5, r6, pc}

0001805e <_lv_memset_00>:
   1805e:	460a      	mov	r2, r1
__ssp_bos_icheck3(memset, void *, int)
   18060:	2100      	movs	r1, #0
   18062:	f005 bc8b 	b.w	1d97c <memset>

00018066 <_lv_memset_ff>:
 * Wrapper for the standard memset with fixed 0xFF value
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void _lv_memset_ff(void * dst, size_t len)
{
   18066:	460a      	mov	r2, r1
   18068:	21ff      	movs	r1, #255	; 0xff
   1806a:	f005 bc87 	b.w	1d97c <memset>

0001806e <lv_area_copy>:
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1806e:	4603      	mov	r3, r0
   18070:	6808      	ldr	r0, [r1, #0]
   18072:	6849      	ldr	r1, [r1, #4]
   18074:	c303      	stmia	r3!, {r0, r1}
}
   18076:	4770      	bx	lr

00018078 <lv_draw_map>:
{
   18078:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1807c:	b097      	sub	sp, #92	; 0x5c
   1807e:	461c      	mov	r4, r3
   18080:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
   18084:	4605      	mov	r5, r0
   18086:	9308      	str	r3, [sp, #32]
   18088:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
    lv_area_copy(&draw_area, clip_area);
   1808c:	a812      	add	r0, sp, #72	; 0x48
{
   1808e:	468b      	mov	fp, r1
   18090:	4691      	mov	r9, r2
   18092:	9309      	str	r3, [sp, #36]	; 0x24
    lv_area_copy(&draw_area, clip_area);
   18094:	f7ff ffeb 	bl	1806e <lv_area_copy>
    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   18098:	f7f2 fac2 	bl	a620 <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1809c:	f002 fd12 	bl	1aac4 <lv_disp_get_buf>
    draw_area.x1 -= disp_area->x1;
   180a0:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   180a4:	f9b0 6010 	ldrsh.w	r6, [r0, #16]
    draw_area.y1 -= disp_area->y1;
   180a8:	f8bd 104a 	ldrh.w	r1, [sp, #74]	; 0x4a
    draw_area.x1 -= disp_area->x1;
   180ac:	1b9b      	subs	r3, r3, r6
    draw_area.x2 -= disp_area->x1;
   180ae:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
    draw_area.x1 -= disp_area->x1;
   180b2:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   180b6:	4682      	mov	sl, r0
    draw_area.y2 -= disp_area->y1;
   180b8:	f8bd 304e 	ldrh.w	r3, [sp, #78]	; 0x4e
    draw_area.y1 -= disp_area->y1;
   180bc:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
    draw_area.x2 -= disp_area->x1;
   180c0:	1b92      	subs	r2, r2, r6
    draw_area.y1 -= disp_area->y1;
   180c2:	1a09      	subs	r1, r1, r0
    draw_area.y2 -= disp_area->y1;
   180c4:	1a1b      	subs	r3, r3, r0
    draw_area.y1 -= disp_area->y1;
   180c6:	f8ad 104a 	strh.w	r1, [sp, #74]	; 0x4a
    draw_area.x2 -= disp_area->x1;
   180ca:	f8ad 204c 	strh.w	r2, [sp, #76]	; 0x4c
    draw_area.y2 -= disp_area->y1;
   180ce:	f8ad 304e 	strh.w	r3, [sp, #78]	; 0x4e
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
   180d2:	f7f3 fe67 	bl	bda4 <lv_draw_mask_get_cnt>
    if(other_mask_cnt == 0 && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE &&
   180d6:	9004      	str	r0, [sp, #16]
   180d8:	b9c8      	cbnz	r0, 1810e <lv_draw_map+0x96>
   180da:	8863      	ldrh	r3, [r4, #2]
   180dc:	b9bb      	cbnz	r3, 1810e <lv_draw_map+0x96>
   180de:	8923      	ldrh	r3, [r4, #8]
   180e0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   180e4:	d113      	bne.n	1810e <lv_draw_map+0x96>
   180e6:	9b08      	ldr	r3, [sp, #32]
   180e8:	b98b      	cbnz	r3, 1810e <lv_draw_map+0x96>
       chroma_key == false && alpha_byte == false && draw_dsc->recolor_opa == LV_OPA_TRANSP) {
   180ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
   180ec:	b97b      	cbnz	r3, 1810e <lv_draw_map+0x96>
   180ee:	7aa3      	ldrb	r3, [r4, #10]
   180f0:	b96b      	cbnz	r3, 1810e <lv_draw_map+0x96>
        _lv_blend_map(clip_area, map_area, (lv_color_t *)map_p, NULL, LV_DRAW_MASK_RES_FULL_COVER, draw_dsc->opa,
   180f2:	7c22      	ldrb	r2, [r4, #16]
   180f4:	4629      	mov	r1, r5
   180f6:	9202      	str	r2, [sp, #8]
   180f8:	7822      	ldrb	r2, [r4, #0]
   180fa:	4658      	mov	r0, fp
   180fc:	9201      	str	r2, [sp, #4]
   180fe:	2201      	movs	r2, #1
   18100:	9200      	str	r2, [sp, #0]
   18102:	464a      	mov	r2, r9
   18104:	f7ff fcfa 	bl	17afc <_lv_blend_map>
}
   18108:	b017      	add	sp, #92	; 0x5c
   1810a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1810e:	88ab      	ldrh	r3, [r5, #4]
   18110:	f9b5 2000 	ldrsh.w	r2, [r5]
   18114:	3301      	adds	r3, #1
   18116:	1a9b      	subs	r3, r3, r2
   18118:	b21b      	sxth	r3, r3
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1811a:	f9bd 6048 	ldrsh.w	r6, [sp, #72]	; 0x48
   1811e:	009b      	lsls	r3, r3, #2
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   18120:	f9bd 004a 	ldrsh.w	r0, [sp, #74]	; 0x4a
   18124:	930d      	str	r3, [sp, #52]	; 0x34
   18126:	f9b5 5002 	ldrsh.w	r5, [r5, #2]
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1812a:	f9ba 3010 	ldrsh.w	r3, [sl, #16]
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   1812e:	f9ba 1012 	ldrsh.w	r1, [sl, #18]
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   18132:	1ab2      	subs	r2, r6, r2
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   18134:	1b45      	subs	r5, r0, r5
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   18136:	441a      	add	r2, r3
   18138:	9f0d      	ldr	r7, [sp, #52]	; 0x34
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
   1813a:	440d      	add	r5, r1
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
   1813c:	0092      	lsls	r2, r2, #2
   1813e:	fb07 2205 	mla	r2, r7, r5, r2
   18142:	444a      	add	r2, r9
   18144:	920a      	str	r2, [sp, #40]	; 0x28
   18146:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
        blend_area.x1 = draw_area.x1 + disp_area->x1;
   1814a:	4433      	add	r3, r6
   1814c:	3201      	adds	r2, #1
   1814e:	1b96      	subs	r6, r2, r6
   18150:	b232      	sxth	r2, r6
   18152:	b21b      	sxth	r3, r3
   18154:	9207      	str	r2, [sp, #28]
        blend_area.x2 = blend_area.x1 + lv_area_get_width(&draw_area) - 1;
   18156:	3a01      	subs	r2, #1
        blend_area.x1 = draw_area.x1 + disp_area->x1;
   18158:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
        blend_area.x2 = blend_area.x1 + lv_area_get_width(&draw_area) - 1;
   1815c:	4413      	add	r3, r2
   1815e:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   18162:	f8bd 304e 	ldrh.w	r3, [sp, #78]	; 0x4e
        blend_area.y1 = disp_area->y1 + draw_area.y1;
   18166:	4401      	add	r1, r0
   18168:	3301      	adds	r3, #1
   1816a:	1a18      	subs	r0, r3, r0
   1816c:	b203      	sxth	r3, r0
   1816e:	930f      	str	r3, [sp, #60]	; 0x3c
        if(other_mask_cnt == 0 && !transform && !chroma_key && draw_dsc->recolor_opa == LV_OPA_TRANSP && alpha_byte) {
   18170:	9b04      	ldr	r3, [sp, #16]
        blend_area.y1 = disp_area->y1 + draw_area.y1;
   18172:	b209      	sxth	r1, r1
   18174:	f8ad 1052 	strh.w	r1, [sp, #82]	; 0x52
        blend_area.y2 = blend_area.y1;
   18178:	f8ad 1056 	strh.w	r1, [sp, #86]	; 0x56
        if(other_mask_cnt == 0 && !transform && !chroma_key && draw_dsc->recolor_opa == LV_OPA_TRANSP && alpha_byte) {
   1817c:	2b00      	cmp	r3, #0
   1817e:	f040 8093 	bne.w	182a8 <lv_draw_map+0x230>
   18182:	9b08      	ldr	r3, [sp, #32]
   18184:	2b00      	cmp	r3, #0
   18186:	f040 808f 	bne.w	182a8 <lv_draw_map+0x230>
   1818a:	7aa3      	ldrb	r3, [r4, #10]
   1818c:	2b00      	cmp	r3, #0
   1818e:	f040 808b 	bne.w	182a8 <lv_draw_map+0x230>
   18192:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18194:	2b00      	cmp	r3, #0
   18196:	f000 8087 	beq.w	182a8 <lv_draw_map+0x230>
            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : lv_area_get_size(&draw_area);
   1819a:	a812      	add	r0, sp, #72	; 0x48
   1819c:	f002 fd70 	bl	1ac80 <lv_area_get_size>
   181a0:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
   181a4:	d822      	bhi.n	181ec <lv_draw_map+0x174>
   181a6:	a812      	add	r0, sp, #72	; 0x48
   181a8:	f002 fd6a 	bl	1ac80 <lv_area_get_size>
   181ac:	4607      	mov	r7, r0
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
   181ae:	00b8      	lsls	r0, r7, #2
   181b0:	f7f4 fca4 	bl	cafc <_lv_mem_buf_get>
   181b4:	4605      	mov	r5, r0
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   181b6:	4638      	mov	r0, r7
   181b8:	f7f4 fca0 	bl	cafc <_lv_mem_buf_get>
            for(y = 0; y < draw_area_h; y++) {
   181bc:	f04f 0800 	mov.w	r8, #0
   181c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   181c2:	4606      	mov	r6, r0
            for(y = 0; y < draw_area_h; y++) {
   181c4:	f103 0903 	add.w	r9, r3, #3
                    map2[px_i].ch.alpha = 0xFF;
   181c8:	f04f 0aff 	mov.w	sl, #255	; 0xff
        uint32_t px_i = 0;
   181cc:	4643      	mov	r3, r8
   181ce:	9a07      	ldr	r2, [sp, #28]
   181d0:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   181d4:	9205      	str	r2, [sp, #20]
            for(y = 0; y < draw_area_h; y++) {
   181d6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   181d8:	f1a9 0e03 	sub.w	lr, r9, #3
   181dc:	4542      	cmp	r2, r8
   181de:	dd47      	ble.n	18270 <lv_draw_map+0x1f8>
   181e0:	18f2      	adds	r2, r6, r3
   181e2:	9204      	str	r2, [sp, #16]
   181e4:	eb05 0183 	add.w	r1, r5, r3, lsl #2
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
   181e8:	2200      	movs	r2, #0
   181ea:	e012      	b.n	18212 <lv_draw_map+0x19a>
            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : lv_area_get_size(&draw_area);
   181ec:	f44f 77a0 	mov.w	r7, #320	; 0x140
   181f0:	e7dd      	b.n	181ae <lv_draw_map+0x136>
                    mask_buf[px_i] = px_opa;
   181f2:	9804      	ldr	r0, [sp, #16]
                    lv_opa_t px_opa = map_px[LV_IMG_PX_SIZE_ALPHA_BYTE - 1];
   181f4:	f819 c022 	ldrb.w	ip, [r9, r2, lsl #2]
                    mask_buf[px_i] = px_opa;
   181f8:	f800 cb01 	strb.w	ip, [r0], #1
   181fc:	9004      	str	r0, [sp, #16]
                    if(px_opa) {
   181fe:	f1bc 0f00 	cmp.w	ip, #0
   18202:	d002      	beq.n	1820a <lv_draw_map+0x192>
                        map2[px_i].full =  *((uint32_t *)map_px);
   18204:	f85e 0022 	ldr.w	r0, [lr, r2, lsl #2]
   18208:	6008      	str	r0, [r1, #0]
                    map2[px_i].ch.alpha = 0xFF;
   1820a:	f881 a003 	strb.w	sl, [r1, #3]
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
   1820e:	3201      	adds	r2, #1
   18210:	3104      	adds	r1, #4
   18212:	9807      	ldr	r0, [sp, #28]
   18214:	4290      	cmp	r0, r2
   18216:	dcec      	bgt.n	181f2 <lv_draw_map+0x17a>
   18218:	9a05      	ldr	r2, [sp, #20]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1821a:	f8bd 1048 	ldrh.w	r1, [sp, #72]	; 0x48
   1821e:	4413      	add	r3, r2
   18220:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
   18224:	3201      	adds	r2, #1
   18226:	1a52      	subs	r2, r2, r1
                if(px_i + lv_area_get_width(&draw_area) < mask_buf_size) {
   18228:	fa03 f282 	sxtah	r2, r3, r2
   1822c:	42ba      	cmp	r2, r7
   1822e:	d209      	bcs.n	18244 <lv_draw_map+0x1cc>
                    blend_area.y2 ++;
   18230:	f8bd 2056 	ldrh.w	r2, [sp, #86]	; 0x56
   18234:	3201      	adds	r2, #1
   18236:	f8ad 2056 	strh.w	r2, [sp, #86]	; 0x56
            for(y = 0; y < draw_area_h; y++) {
   1823a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1823c:	f108 0801 	add.w	r8, r8, #1
   18240:	4491      	add	r9, r2
   18242:	e7c8      	b.n	181d6 <lv_draw_map+0x15e>
                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);
   18244:	7c23      	ldrb	r3, [r4, #16]
   18246:	462a      	mov	r2, r5
   18248:	9302      	str	r3, [sp, #8]
   1824a:	7823      	ldrb	r3, [r4, #0]
   1824c:	4658      	mov	r0, fp
   1824e:	9301      	str	r3, [sp, #4]
   18250:	2302      	movs	r3, #2
   18252:	a914      	add	r1, sp, #80	; 0x50
   18254:	9300      	str	r3, [sp, #0]
   18256:	4633      	mov	r3, r6
   18258:	f7ff fc50 	bl	17afc <_lv_blend_map>
                    blend_area.y1 = blend_area.y2 + 1;
   1825c:	f8bd 3056 	ldrh.w	r3, [sp, #86]	; 0x56
   18260:	3301      	adds	r3, #1
   18262:	b21b      	sxth	r3, r3
   18264:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
                    blend_area.y2 = blend_area.y1;
   18268:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
                    px_i = 0;
   1826c:	2300      	movs	r3, #0
   1826e:	e7e4      	b.n	1823a <lv_draw_map+0x1c2>
            if(blend_area.y1 != blend_area.y2) {
   18270:	f9bd 3056 	ldrsh.w	r3, [sp, #86]	; 0x56
   18274:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
   18278:	429a      	cmp	r2, r3
   1827a:	d00e      	beq.n	1829a <lv_draw_map+0x222>
                blend_area.y2--;
   1827c:	3b01      	subs	r3, #1
   1827e:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);
   18282:	7c23      	ldrb	r3, [r4, #16]
   18284:	462a      	mov	r2, r5
   18286:	9302      	str	r3, [sp, #8]
   18288:	7823      	ldrb	r3, [r4, #0]
   1828a:	4658      	mov	r0, fp
   1828c:	9301      	str	r3, [sp, #4]
   1828e:	2302      	movs	r3, #2
   18290:	a914      	add	r1, sp, #80	; 0x50
   18292:	9300      	str	r3, [sp, #0]
   18294:	4633      	mov	r3, r6
   18296:	f7ff fc31 	bl	17afc <_lv_blend_map>
            _lv_mem_buf_release(mask_buf);
   1829a:	4630      	mov	r0, r6
   1829c:	f7f4 fc90 	bl	cbc0 <_lv_mem_buf_release>
            _lv_mem_buf_release(map2);
   182a0:	4628      	mov	r0, r5
            _lv_mem_buf_release(map2);
   182a2:	f7f4 fc8d 	bl	cbc0 <_lv_mem_buf_release>
}
   182a6:	e72f      	b.n	18108 <lv_draw_map+0x90>
            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : lv_area_get_size(&draw_area);
   182a8:	a812      	add	r0, sp, #72	; 0x48
   182aa:	f002 fce9 	bl	1ac80 <lv_area_get_size>
   182ae:	f5b0 7fa0 	cmp.w	r0, #320	; 0x140
   182b2:	d83d      	bhi.n	18330 <lv_draw_map+0x2b8>
   182b4:	a812      	add	r0, sp, #72	; 0x48
   182b6:	f002 fce3 	bl	1ac80 <lv_area_get_size>
   182ba:	4680      	mov	r8, r0
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
   182bc:	ea4f 0088 	mov.w	r0, r8, lsl #2
   182c0:	f7f4 fc1c 	bl	cafc <_lv_mem_buf_get>
   182c4:	4607      	mov	r7, r0
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   182c6:	4640      	mov	r0, r8
   182c8:	f7f4 fc18 	bl	cafc <_lv_mem_buf_get>
            lv_opa_t recolor_opa_inv = 255 - draw_dsc->recolor_opa;
   182cc:	7aa3      	ldrb	r3, [r4, #10]
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
   182ce:	4606      	mov	r6, r0
            lv_opa_t recolor_opa_inv = 255 - draw_dsc->recolor_opa;
   182d0:	43da      	mvns	r2, r3
   182d2:	b2d2      	uxtb	r2, r2
   182d4:	920c      	str	r2, [sp, #48]	; 0x30
            if(draw_dsc->recolor_opa != 0) {
   182d6:	2b00      	cmp	r3, #0
   182d8:	d02d      	beq.n	18336 <lv_draw_map+0x2be>
    out[0] = (uint16_t) LV_COLOR_GET_R(c) * mix;
   182da:	7ba2      	ldrb	r2, [r4, #14]
   182dc:	435a      	muls	r2, r3
   182de:	920e      	str	r2, [sp, #56]	; 0x38
    out[1] = (uint16_t) LV_COLOR_GET_G(c) * mix;
   182e0:	7b62      	ldrb	r2, [r4, #13]
   182e2:	435a      	muls	r2, r3
   182e4:	9210      	str	r2, [sp, #64]	; 0x40
    out[2] = (uint16_t) LV_COLOR_GET_B(c) * mix;
   182e6:	7b22      	ldrb	r2, [r4, #12]
   182e8:	4353      	muls	r3, r2
   182ea:	930b      	str	r3, [sp, #44]	; 0x2c
            mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
   182ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
   182ee:	bb33      	cbnz	r3, 1833e <lv_draw_map+0x2c6>
   182f0:	9b08      	ldr	r3, [sp, #32]
   182f2:	bb23      	cbnz	r3, 1833e <lv_draw_map+0x2c6>
   182f4:	8863      	ldrh	r3, [r4, #2]
   182f6:	bb13      	cbnz	r3, 1833e <lv_draw_map+0x2c6>
   182f8:	8923      	ldrh	r3, [r4, #8]
   182fa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   182fe:	bf14      	ite	ne
   18300:	2502      	movne	r5, #2
   18302:	2501      	moveq	r5, #1
            if(other_mask_cnt) {
   18304:	9b04      	ldr	r3, [sp, #16]
   18306:	b11b      	cbz	r3, 18310 <lv_draw_map+0x298>
                _lv_memset_ff(mask_buf, mask_buf_size);
   18308:	4641      	mov	r1, r8
   1830a:	4630      	mov	r0, r6
   1830c:	f7ff feab 	bl	18066 <_lv_memset_ff>
                map_buf_tmp += map_w * px_size_byte;
   18310:	2300      	movs	r3, #0
   18312:	e9cd 3305 	strd	r3, r3, [sp, #20]
   18316:	9b07      	ldr	r3, [sp, #28]
   18318:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   1831c:	9311      	str	r3, [sp, #68]	; 0x44
            for(y = 0; y < draw_area_h; y++) {
   1831e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   18320:	9a06      	ldr	r2, [sp, #24]
   18322:	4293      	cmp	r3, r2
   18324:	f340 80ca 	ble.w	184bc <lv_draw_map+0x444>
                map_px = map_buf_tmp;
   18328:	f8dd e028 	ldr.w	lr, [sp, #40]	; 0x28
                            if(c.full == chroma_keyed_color.full) {
   1832c:	9a05      	ldr	r2, [sp, #20]
   1832e:	e015      	b.n	1835c <lv_draw_map+0x2e4>
            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : lv_area_get_size(&draw_area);
   18330:	f44f 78a0 	mov.w	r8, #320	; 0x140
   18334:	e7c2      	b.n	182bc <lv_draw_map+0x244>
            uint16_t recolor_premult[3] = {0};
   18336:	930b      	str	r3, [sp, #44]	; 0x2c
   18338:	9310      	str	r3, [sp, #64]	; 0x40
   1833a:	930e      	str	r3, [sp, #56]	; 0x38
   1833c:	e7d6      	b.n	182ec <lv_draw_map+0x274>
            mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
   1833e:	2502      	movs	r5, #2
   18340:	e7e0      	b.n	18304 <lv_draw_map+0x28c>
                        if(alpha_byte) {
   18342:	9b09      	ldr	r3, [sp, #36]	; 0x24
   18344:	2b00      	cmp	r3, #0
   18346:	d052      	beq.n	183ee <lv_draw_map+0x376>
                            lv_opa_t px_opa = map_px[LV_IMG_PX_SIZE_ALPHA_BYTE - 1];
   18348:	f89e 3003 	ldrb.w	r3, [lr, #3]
                            mask_buf[px_i] = px_opa;
   1834c:	54b3      	strb	r3, [r6, r2]
                            if(px_opa == 0) {
   1834e:	2b00      	cmp	r3, #0
   18350:	d150      	bne.n	183f4 <lv_draw_map+0x37c>
                                map2[px_i].full = 0;
   18352:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
   18356:	f10e 0e04 	add.w	lr, lr, #4
   1835a:	3201      	adds	r2, #1
   1835c:	9b05      	ldr	r3, [sp, #20]
   1835e:	9907      	ldr	r1, [sp, #28]
   18360:	1ad3      	subs	r3, r2, r3
   18362:	4299      	cmp	r1, r3
   18364:	dced      	bgt.n	18342 <lv_draw_map+0x2ca>
   18366:	9b11      	ldr	r3, [sp, #68]	; 0x44
   18368:	9a05      	ldr	r2, [sp, #20]
   1836a:	eb03 0902 	add.w	r9, r3, r2
                if(other_mask_cnt) {
   1836e:	9b04      	ldr	r3, [sp, #16]
   18370:	b32b      	cbz	r3, 183be <lv_draw_map+0x346>
                    mask_res_sub = lv_draw_mask_apply(mask_buf + px_i_start, draw_area.x1 + vdb->area.x1, y + draw_area.y1 + vdb->area.y1,
   18372:	4613      	mov	r3, r2
   18374:	f8ba 0012 	ldrh.w	r0, [sl, #18]
   18378:	f8bd 204a 	ldrh.w	r2, [sp, #74]	; 0x4a
   1837c:	4433      	add	r3, r6
   1837e:	4402      	add	r2, r0
   18380:	9806      	ldr	r0, [sp, #24]
   18382:	9305      	str	r3, [sp, #20]
   18384:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
   18388:	f9bd 1048 	ldrsh.w	r1, [sp, #72]	; 0x48
   1838c:	4402      	add	r2, r0
   1838e:	f8ba 0010 	ldrh.w	r0, [sl, #16]
   18392:	3301      	adds	r3, #1
   18394:	1a5b      	subs	r3, r3, r1
   18396:	4401      	add	r1, r0
   18398:	b21b      	sxth	r3, r3
   1839a:	9805      	ldr	r0, [sp, #20]
   1839c:	b212      	sxth	r2, r2
   1839e:	b209      	sxth	r1, r1
   183a0:	f7f3 fcb8 	bl	bd14 <lv_draw_mask_apply>
                    if(mask_res_sub == LV_DRAW_MASK_RES_TRANSP) {
   183a4:	2800      	cmp	r0, #0
   183a6:	d158      	bne.n	1845a <lv_draw_map+0x3e2>
   183a8:	f8bd 104c 	ldrh.w	r1, [sp, #76]	; 0x4c
   183ac:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   183b0:	3101      	adds	r1, #1
   183b2:	1ac9      	subs	r1, r1, r3
                        _lv_memset_00(mask_buf + px_i_start, lv_area_get_width(&draw_area));
   183b4:	9805      	ldr	r0, [sp, #20]
   183b6:	b209      	sxth	r1, r1
   183b8:	f7ff fe51 	bl	1805e <_lv_memset_00>
                        mask_res = LV_DRAW_MASK_RES_CHANGED;
   183bc:	2502      	movs	r5, #2
                map_buf_tmp += map_w * px_size_byte;
   183be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   183c0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   183c2:	4413      	add	r3, r2
   183c4:	930a      	str	r3, [sp, #40]	; 0x28
   183c6:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
   183ca:	f8bd 2048 	ldrh.w	r2, [sp, #72]	; 0x48
   183ce:	3301      	adds	r3, #1
   183d0:	1a9b      	subs	r3, r3, r2
                if(px_i + lv_area_get_width(&draw_area) < mask_buf_size) {
   183d2:	fa09 f383 	sxtah	r3, r9, r3
   183d6:	4543      	cmp	r3, r8
   183d8:	d243      	bcs.n	18462 <lv_draw_map+0x3ea>
                    blend_area.y2 ++;
   183da:	f8bd 3056 	ldrh.w	r3, [sp, #86]	; 0x56
   183de:	3301      	adds	r3, #1
   183e0:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
            for(y = 0; y < draw_area_h; y++) {
   183e4:	9b06      	ldr	r3, [sp, #24]
   183e6:	3301      	adds	r3, #1
   183e8:	e9cd 9305 	strd	r9, r3, [sp, #20]
   183ec:	e797      	b.n	1831e <lv_draw_map+0x2a6>
                            mask_buf[px_i] = 0xFF;
   183ee:	f04f 33ff 	mov.w	r3, #4294967295
   183f2:	54b3      	strb	r3, [r6, r2]
                        c.full =  *((uint32_t *)map_px);
   183f4:	f8de 3000 	ldr.w	r3, [lr]
                        if(chroma_key) {
   183f8:	9908      	ldr	r1, [sp, #32]
                        c.ch.alpha = 0xFF;
   183fa:	f043 4c7f 	orr.w	ip, r3, #4278190080	; 0xff000000
                        if(chroma_key) {
   183fe:	b139      	cbz	r1, 18410 <lv_draw_map+0x398>
                            if(c.full == chroma_keyed_color.full) {
   18400:	f1bc 2fff 	cmp.w	ip, #4278255360	; 0xff00ff00
   18404:	d104      	bne.n	18410 <lv_draw_map+0x398>
                                mask_buf[px_i] = LV_OPA_TRANSP;
   18406:	f04f 0300 	mov.w	r3, #0
   1840a:	54b3      	strb	r3, [r6, r2]
                                map2[px_i].full = 0;
   1840c:	2300      	movs	r3, #0
   1840e:	e7a0      	b.n	18352 <lv_draw_map+0x2da>
                    if(draw_dsc->recolor_opa != 0) {
   18410:	7aa1      	ldrb	r1, [r4, #10]
   18412:	b1f9      	cbz	r1, 18454 <lv_draw_map+0x3dc>
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   18414:	980c      	ldr	r0, [sp, #48]	; 0x30
   18416:	b2d9      	uxtb	r1, r3
   18418:	4681      	mov	r9, r0
   1841a:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1841c:	fb09 0101 	mla	r1, r9, r1, r0
   18420:	f248 0081 	movw	r0, #32897	; 0x8081
   18424:	4341      	muls	r1, r0
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   18426:	9810      	ldr	r0, [sp, #64]	; 0x40
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   18428:	0dc9      	lsrs	r1, r1, #23
   1842a:	f361 0c07 	bfi	ip, r1, #0, #8
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   1842e:	f3c3 2107 	ubfx	r1, r3, #8, #8
   18432:	fb01 0109 	mla	r1, r1, r9, r0
   18436:	f248 0081 	movw	r0, #32897	; 0x8081
   1843a:	4341      	muls	r1, r0
   1843c:	0dc9      	lsrs	r1, r1, #23
   1843e:	f361 2c0f 	bfi	ip, r1, #8, #8
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
   18442:	990e      	ldr	r1, [sp, #56]	; 0x38
   18444:	f3c3 4307 	ubfx	r3, r3, #16, #8
   18448:	fb03 1309 	mla	r3, r3, r9, r1
   1844c:	4343      	muls	r3, r0
   1844e:	0ddb      	lsrs	r3, r3, #23
   18450:	f363 4c17 	bfi	ip, r3, #16, #8
                    map2[px_i].full = c.full;
   18454:	f847 c022 	str.w	ip, [r7, r2, lsl #2]
   18458:	e77d      	b.n	18356 <lv_draw_map+0x2de>
                        mask_res = LV_DRAW_MASK_RES_CHANGED;
   1845a:	2802      	cmp	r0, #2
   1845c:	bf08      	it	eq
   1845e:	2502      	moveq	r5, #2
   18460:	e7ad      	b.n	183be <lv_draw_map+0x346>
                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);
   18462:	7c23      	ldrb	r3, [r4, #16]
   18464:	463a      	mov	r2, r7
   18466:	9302      	str	r3, [sp, #8]
   18468:	7823      	ldrb	r3, [r4, #0]
   1846a:	4658      	mov	r0, fp
   1846c:	e9cd 5300 	strd	r5, r3, [sp]
   18470:	a914      	add	r1, sp, #80	; 0x50
   18472:	4633      	mov	r3, r6
   18474:	f7ff fb42 	bl	17afc <_lv_blend_map>
                    blend_area.y1 = blend_area.y2 + 1;
   18478:	f8bd 3056 	ldrh.w	r3, [sp, #86]	; 0x56
   1847c:	3301      	adds	r3, #1
   1847e:	b21b      	sxth	r3, r3
   18480:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
                    blend_area.y2 = blend_area.y1;
   18484:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
                    mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
   18488:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1848a:	b993      	cbnz	r3, 184b2 <lv_draw_map+0x43a>
   1848c:	9b08      	ldr	r3, [sp, #32]
   1848e:	b983      	cbnz	r3, 184b2 <lv_draw_map+0x43a>
   18490:	8863      	ldrh	r3, [r4, #2]
   18492:	b973      	cbnz	r3, 184b2 <lv_draw_map+0x43a>
   18494:	8923      	ldrh	r3, [r4, #8]
   18496:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1849a:	bf14      	ite	ne
   1849c:	2502      	movne	r5, #2
   1849e:	2501      	moveq	r5, #1
                    if(other_mask_cnt) {
   184a0:	9b04      	ldr	r3, [sp, #16]
   184a2:	b143      	cbz	r3, 184b6 <lv_draw_map+0x43e>
                        _lv_memset_ff(mask_buf, mask_buf_size);
   184a4:	4641      	mov	r1, r8
   184a6:	4630      	mov	r0, r6
   184a8:	f7ff fddd 	bl	18066 <_lv_memset_ff>
                    px_i = 0;
   184ac:	f04f 0900 	mov.w	r9, #0
   184b0:	e798      	b.n	183e4 <lv_draw_map+0x36c>
                    mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
   184b2:	2502      	movs	r5, #2
   184b4:	e7f4      	b.n	184a0 <lv_draw_map+0x428>
                    px_i = 0;
   184b6:	f8dd 9010 	ldr.w	r9, [sp, #16]
   184ba:	e793      	b.n	183e4 <lv_draw_map+0x36c>
            if(blend_area.y1 != blend_area.y2) {
   184bc:	f9bd 3056 	ldrsh.w	r3, [sp, #86]	; 0x56
   184c0:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
   184c4:	429a      	cmp	r2, r3
   184c6:	d00d      	beq.n	184e4 <lv_draw_map+0x46c>
                blend_area.y2--;
   184c8:	3b01      	subs	r3, #1
   184ca:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);
   184ce:	7c23      	ldrb	r3, [r4, #16]
   184d0:	463a      	mov	r2, r7
   184d2:	9302      	str	r3, [sp, #8]
   184d4:	7823      	ldrb	r3, [r4, #0]
   184d6:	4658      	mov	r0, fp
   184d8:	e9cd 5300 	strd	r5, r3, [sp]
   184dc:	a914      	add	r1, sp, #80	; 0x50
   184de:	4633      	mov	r3, r6
   184e0:	f7ff fb0c 	bl	17afc <_lv_blend_map>
            _lv_mem_buf_release(mask_buf);
   184e4:	4630      	mov	r0, r6
   184e6:	f7f4 fb6b 	bl	cbc0 <_lv_mem_buf_release>
            _lv_mem_buf_release(map2);
   184ea:	4638      	mov	r0, r7
   184ec:	e6d9      	b.n	182a2 <lv_draw_map+0x22a>

000184ee <lv_draw_img_dsc_init>:
{
   184ee:	b510      	push	{r4, lr}
    _lv_memset_00(dsc, sizeof(lv_draw_img_dsc_t));
   184f0:	2114      	movs	r1, #20
{
   184f2:	4604      	mov	r4, r0
    _lv_memset_00(dsc, sizeof(lv_draw_img_dsc_t));
   184f4:	f7ff fdb3 	bl	1805e <_lv_memset_00>
    dsc->recolor = LV_COLOR_BLACK;
   184f8:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
   184fc:	60e3      	str	r3, [r4, #12]
    dsc->opa = LV_OPA_COVER;
   184fe:	23ff      	movs	r3, #255	; 0xff
   18500:	7023      	strb	r3, [r4, #0]
    dsc->zoom = LV_IMG_ZOOM_NONE;
   18502:	f44f 7380 	mov.w	r3, #256	; 0x100
   18506:	8123      	strh	r3, [r4, #8]
    dsc->antialias = LV_ANTIALIAS;
   18508:	7c63      	ldrb	r3, [r4, #17]
   1850a:	f043 0301 	orr.w	r3, r3, #1
   1850e:	7463      	strb	r3, [r4, #17]
}
   18510:	bd10      	pop	{r4, pc}

00018512 <lv_img_cf_is_chroma_keyed>:
    switch(cf) {
   18512:	2803      	cmp	r0, #3
   18514:	d005      	beq.n	18522 <lv_img_cf_is_chroma_keyed+0x10>
   18516:	3806      	subs	r0, #6
   18518:	2804      	cmp	r0, #4
   1851a:	bf8c      	ite	hi
   1851c:	2000      	movhi	r0, #0
   1851e:	2001      	movls	r0, #1
   18520:	4770      	bx	lr
            is_chroma_keyed = true;
   18522:	2001      	movs	r0, #1
}
   18524:	4770      	bx	lr

00018526 <lv_img_cf_has_alpha>:
    switch(cf) {
   18526:	280e      	cmp	r0, #14
   18528:	d809      	bhi.n	1853e <lv_img_cf_has_alpha+0x18>
   1852a:	2301      	movs	r3, #1
   1852c:	fa03 f000 	lsl.w	r0, r3, r0
   18530:	f647 73a4 	movw	r3, #32676	; 0x7fa4
   18534:	4218      	tst	r0, r3
   18536:	bf14      	ite	ne
   18538:	2001      	movne	r0, #1
   1853a:	2000      	moveq	r0, #0
   1853c:	4770      	bx	lr
{
   1853e:	2000      	movs	r0, #0
}
   18540:	4770      	bx	lr

00018542 <lv_img_src_get_type>:
    if(src == NULL) return img_src_type;
   18542:	b150      	cbz	r0, 1855a <lv_img_src_get_type+0x18>
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
   18544:	7803      	ldrb	r3, [r0, #0]
   18546:	f1a3 0220 	sub.w	r2, r3, #32
   1854a:	2a5f      	cmp	r2, #95	; 0x5f
   1854c:	d907      	bls.n	1855e <lv_img_src_get_type+0x1c>
    else if(u8_p[0] >= 0x80) {
   1854e:	f013 0f80 	tst.w	r3, #128	; 0x80
        img_src_type = LV_IMG_SRC_VARIABLE; /*`lv_img_dsc_t` is design to the first byte < 0x20*/
   18552:	bf14      	ite	ne
   18554:	2002      	movne	r0, #2
   18556:	2000      	moveq	r0, #0
   18558:	4770      	bx	lr
    if(src == NULL) return img_src_type;
   1855a:	2003      	movs	r0, #3
   1855c:	4770      	bx	lr
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
   1855e:	2001      	movs	r0, #1
}
   18560:	4770      	bx	lr

00018562 <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
   18562:	4603      	mov	r3, r0
    uint8_t result = 0;

    if(hex >= '0' && hex <= '9') {
   18564:	3830      	subs	r0, #48	; 0x30
   18566:	b2c0      	uxtb	r0, r0
   18568:	2809      	cmp	r0, #9
   1856a:	d90b      	bls.n	18584 <hex_char_to_num+0x22>
        result = hex - '0';
    }
    else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
   1856c:	2b60      	cmp	r3, #96	; 0x60
   1856e:	bf84      	itt	hi
   18570:	3b20      	subhi	r3, #32
   18572:	b2db      	uxtbhi	r3, r3

        switch(hex) {
   18574:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
   18578:	2a05      	cmp	r2, #5
   1857a:	d802      	bhi.n	18582 <hex_char_to_num+0x20>
   1857c:	3b37      	subs	r3, #55	; 0x37
   1857e:	b2d8      	uxtb	r0, r3
   18580:	4770      	bx	lr
{
   18582:	2000      	movs	r0, #0
                break;
        }
    }

    return result;
}
   18584:	4770      	bx	lr

00018586 <_lv_memset_00>:
{
   18586:	460a      	mov	r2, r1
__ssp_bos_icheck3(memset, void *, int)
   18588:	2100      	movs	r1, #0
   1858a:	f005 b9f7 	b.w	1d97c <memset>

0001858e <_lv_memset_00>:
   1858e:	460a      	mov	r2, r1
   18590:	2100      	movs	r1, #0
   18592:	f005 b9f3 	b.w	1d97c <memset>

00018596 <_lv_memset_ff>:
{
   18596:	460a      	mov	r2, r1
   18598:	21ff      	movs	r1, #255	; 0xff
   1859a:	f005 b9ef 	b.w	1d97c <memset>

0001859e <lv_draw_line_dsc_init>:
{
   1859e:	b510      	push	{r4, lr}
    _lv_memset_00(dsc, sizeof(lv_draw_line_dsc_t));
   185a0:	210c      	movs	r1, #12
{
   185a2:	4604      	mov	r4, r0
    _lv_memset_00(dsc, sizeof(lv_draw_line_dsc_t));
   185a4:	f7ff fff3 	bl	1858e <_lv_memset_00>
    dsc->opa = LV_OPA_COVER;
   185a8:	23ff      	movs	r3, #255	; 0xff
   185aa:	72a3      	strb	r3, [r4, #10]
    dsc->color = LV_COLOR_BLACK;
   185ac:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
   185b0:	6023      	str	r3, [r4, #0]
    dsc->width = 1;
   185b2:	2301      	movs	r3, #1
   185b4:	80a3      	strh	r3, [r4, #4]
}
   185b6:	bd10      	pop	{r4, pc}

000185b8 <mask_mix>:
}


LV_ATTRIBUTE_FAST_MEM static inline lv_opa_t mask_mix(lv_opa_t mask_act, lv_opa_t mask_new)
{
    if(mask_new >= LV_OPA_MAX) return mask_act;
   185b8:	29fc      	cmp	r1, #252	; 0xfc
   185ba:	d80a      	bhi.n	185d2 <mask_mix+0x1a>
    if(mask_new <= LV_OPA_MIN) return 0;
   185bc:	2902      	cmp	r1, #2
   185be:	d907      	bls.n	185d0 <mask_mix+0x18>

    return LV_MATH_UDIV255(mask_act * mask_new);// >> 8);
   185c0:	fb10 f001 	smulbb	r0, r0, r1
   185c4:	f248 0181 	movw	r1, #32897	; 0x8081
   185c8:	4348      	muls	r0, r1
   185ca:	f3c0 50c7 	ubfx	r0, r0, #23, #8
   185ce:	4770      	bx	lr
    if(mask_new <= LV_OPA_MIN) return 0;
   185d0:	2000      	movs	r0, #0
}
   185d2:	4770      	bx	lr

000185d4 <_lv_memset_00>:
{
   185d4:	460a      	mov	r2, r1
   185d6:	2100      	movs	r1, #0
   185d8:	f005 b9d0 	b.w	1d97c <memset>

000185dc <lv_draw_mask_line>:
{
   185dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   185e0:	9e08      	ldr	r6, [sp, #32]
   185e2:	4604      	mov	r4, r0
    abs_x -= p->origo.x;
   185e4:	8a75      	ldrh	r5, [r6, #18]
    abs_y -= p->origo.y;
   185e6:	8ab0      	ldrh	r0, [r6, #20]
    abs_x -= p->origo.x;
   185e8:	1b49      	subs	r1, r1, r5
   185ea:	f896 c028 	ldrb.w	ip, [r6, #40]	; 0x28
   185ee:	b20d      	sxth	r5, r1
    if(p->steep == 0) {
   185f0:	6a31      	ldr	r1, [r6, #32]
    abs_y -= p->origo.y;
   185f2:	1a12      	subs	r2, r2, r0
   185f4:	b212      	sxth	r2, r2
    if(p->steep == 0) {
   185f6:	f00c 0001 	and.w	r0, ip, #1
   185fa:	bb89      	cbnz	r1, 18660 <lv_draw_mask_line+0x84>
        if(p->flat) {
   185fc:	7c31      	ldrb	r1, [r6, #16]
   185fe:	f001 0602 	and.w	r6, r1, #2
   18602:	b170      	cbz	r0, 18622 <lv_draw_mask_line+0x46>
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT ||
   18604:	b12e      	cbz	r6, 18612 <lv_draw_mask_line+0x36>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP && abs_y + 1 < 0) return LV_DRAW_MASK_RES_FULL_COVER;
   18606:	f001 0103 	and.w	r1, r1, #3
   1860a:	2902      	cmp	r1, #2
   1860c:	d103      	bne.n	18616 <lv_draw_mask_line+0x3a>
   1860e:	1c50      	adds	r0, r2, #1
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
   18610:	0fc0      	lsrs	r0, r0, #31
}
   18612:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM && abs_y > 0) return LV_DRAW_MASK_RES_FULL_COVER;
   18616:	2903      	cmp	r1, #3
   18618:	d101      	bne.n	1861e <lv_draw_mask_line+0x42>
   1861a:	2a00      	cmp	r2, #0
   1861c:	dcf9      	bgt.n	18612 <lv_draw_mask_line+0x36>
                return LV_DRAW_MASK_RES_TRANSP;
   1861e:	2000      	movs	r0, #0
   18620:	e7f7      	b.n	18612 <lv_draw_mask_line+0x36>
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP ||
   18622:	2e00      	cmp	r6, #0
   18624:	f040 816b 	bne.w	188fe <lv_draw_mask_line+0x322>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT && abs_x > 0) return LV_DRAW_MASK_RES_FULL_COVER;
   18628:	f001 0003 	and.w	r0, r1, #3
   1862c:	2801      	cmp	r0, #1
   1862e:	d10a      	bne.n	18646 <lv_draw_mask_line+0x6a>
   18630:	2d00      	cmp	r5, #0
   18632:	dcee      	bgt.n	18612 <lv_draw_mask_line+0x36>
                if(abs_x + len < 0) return LV_DRAW_MASK_RES_TRANSP;
   18634:	42dd      	cmn	r5, r3
   18636:	d4f2      	bmi.n	1861e <lv_draw_mask_line+0x42>
                    int32_t k = - abs_x;
   18638:	4269      	negs	r1, r5
                    if(k < 0) k = 0;
   1863a:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
                    if(k >= len) return LV_DRAW_MASK_RES_TRANSP;
   1863e:	428b      	cmp	r3, r1
   18640:	dded      	ble.n	1861e <lv_draw_mask_line+0x42>
                if(k >= 0) _lv_memset_00(&mask_buf[0],  k);
   18642:	4620      	mov	r0, r4
   18644:	e0a2      	b.n	1878c <lv_draw_mask_line+0x1b0>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) {
   18646:	2800      	cmp	r0, #0
   18648:	d1f4      	bne.n	18634 <lv_draw_mask_line+0x58>
                if(abs_x + len < 0) return LV_DRAW_MASK_RES_FULL_COVER;
   1864a:	1959      	adds	r1, r3, r5
   1864c:	f100 8157 	bmi.w	188fe <lv_draw_mask_line+0x322>
                    int32_t k = - abs_x;
   18650:	4268      	negs	r0, r5
                    if(k < 0) return LV_DRAW_MASK_RES_TRANSP;
   18652:	2800      	cmp	r0, #0
   18654:	dbe3      	blt.n	1861e <lv_draw_mask_line+0x42>
                    if(k >= 0 && k < len) _lv_memset_00(&mask_buf[k], len - k);
   18656:	4298      	cmp	r0, r3
   18658:	f2c0 8097 	blt.w	1878a <lv_draw_mask_line+0x1ae>
    return LV_DRAW_MASK_RES_CHANGED;
   1865c:	2002      	movs	r0, #2
   1865e:	e7d8      	b.n	18612 <lv_draw_mask_line+0x36>
    if(p->flat) {
   18660:	f00c 0c02 	and.w	ip, ip, #2
   18664:	2800      	cmp	r0, #0
   18666:	f000 8094 	beq.w	18792 <lv_draw_mask_line+0x1b6>
    y_at_x = (int32_t)((int32_t)p->yx_steep * abs_x) >> 10;
   1866a:	69f7      	ldr	r7, [r6, #28]
   1866c:	fa5f f08c 	uxtb.w	r0, ip
   18670:	fb05 f107 	mul.w	r1, r5, r7
    if(p->yx_steep > 0) {
   18674:	2f00      	cmp	r7, #0
    y_at_x = (int32_t)((int32_t)p->yx_steep * abs_x) >> 10;
   18676:	ea4f 21a1 	mov.w	r1, r1, asr #10
    if(p->yx_steep > 0) {
   1867a:	dd05      	ble.n	18688 <lv_draw_mask_line+0xac>
        if(y_at_x > abs_y) {
   1867c:	4291      	cmp	r1, r2
   1867e:	dd05      	ble.n	1868c <lv_draw_mask_line+0xb0>
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
   18680:	3800      	subs	r0, #0
   18682:	bf18      	it	ne
   18684:	2001      	movne	r0, #1
   18686:	e7c4      	b.n	18612 <lv_draw_mask_line+0x36>
        if(y_at_x < abs_y) {
   18688:	4291      	cmp	r1, r2
   1868a:	dbf9      	blt.n	18680 <lv_draw_mask_line+0xa4>
    y_at_x = (int32_t)((int32_t)p->yx_steep * (abs_x + len)) >> 10;
   1868c:	1959      	adds	r1, r3, r5
   1868e:	4379      	muls	r1, r7
    if(p->yx_steep > 0) {
   18690:	2f00      	cmp	r7, #0
    y_at_x = (int32_t)((int32_t)p->yx_steep * (abs_x + len)) >> 10;
   18692:	ea4f 21a1 	mov.w	r1, r1, asr #10
    if(p->yx_steep > 0) {
   18696:	dd05      	ble.n	186a4 <lv_draw_mask_line+0xc8>
        if(y_at_x < abs_y) {
   18698:	4291      	cmp	r1, r2
   1869a:	da06      	bge.n	186aa <lv_draw_mask_line+0xce>
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
   1869c:	fab0 f080 	clz	r0, r0
   186a0:	0940      	lsrs	r0, r0, #5
   186a2:	e7b6      	b.n	18612 <lv_draw_mask_line+0x36>
        if(y_at_x > abs_y) {
   186a4:	4291      	cmp	r1, r2
   186a6:	dcf9      	bgt.n	1869c <lv_draw_mask_line+0xc0>
    else xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   186a8:	3201      	adds	r2, #1
   186aa:	69b1      	ldr	r1, [r6, #24]
   186ac:	0212      	lsls	r2, r2, #8
   186ae:	434a      	muls	r2, r1
   186b0:	1292      	asrs	r2, r2, #10
    int32_t xei = xe >> 8;
   186b2:	ea4f 2c22 	mov.w	ip, r2, asr #8
    if(xef == 0) px_h = 255;
   186b6:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    else px_h = 255 - (((255 - xef) * p->spx) >> 8);
   186ba:	bf1f      	itttt	ne
   186bc:	6a71      	ldrne	r1, [r6, #36]	; 0x24
   186be:	f1c2 07ff 	rsbne	r7, r2, #255	; 0xff
   186c2:	434f      	mulne	r7, r1
   186c4:	123f      	asrne	r7, r7, #8
    if(xef == 0) px_h = 255;
   186c6:	bf0c      	ite	eq
   186c8:	27ff      	moveq	r7, #255	; 0xff
    else px_h = 255 - (((255 - xef) * p->spx) >> 8);
   186ca:	f1c7 07ff 	rsbne	r7, r7, #255	; 0xff
    int32_t k = xei - abs_x;
   186ce:	ebac 0505 	sub.w	r5, ip, r5
    if(xef) {
   186d2:	2a00      	cmp	r2, #0
   186d4:	d050      	beq.n	18778 <lv_draw_mask_line+0x19c>
        if(k >= 0 && k < len) {
   186d6:	2d00      	cmp	r5, #0
   186d8:	db0f      	blt.n	186fa <lv_draw_mask_line+0x11e>
   186da:	42ab      	cmp	r3, r5
   186dc:	dd0d      	ble.n	186fa <lv_draw_mask_line+0x11e>
            m = 255 - (((255 - xef) * (255 - px_h)) >> 9);
   186de:	f1c7 01ff 	rsb	r1, r7, #255	; 0xff
   186e2:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
   186e6:	434a      	muls	r2, r1
   186e8:	f3c2 2147 	ubfx	r1, r2, #9, #8
            if(p->inv) m = 255 - m;
   186ec:	b908      	cbnz	r0, 186f2 <lv_draw_mask_line+0x116>
            m = 255 - (((255 - xef) * (255 - px_h)) >> 9);
   186ee:	43c9      	mvns	r1, r1
   186f0:	b2c9      	uxtb	r1, r1
            mask_buf[k] = mask_mix(mask_buf[k], m);
   186f2:	5d60      	ldrb	r0, [r4, r5]
   186f4:	f7ff ff60 	bl	185b8 <mask_mix>
   186f8:	5560      	strb	r0, [r4, r5]
        k++;
   186fa:	1c6a      	adds	r2, r5, #1
    while(px_h > p->spx) {
   186fc:	6a71      	ldr	r1, [r6, #36]	; 0x24
   186fe:	f896 0028 	ldrb.w	r0, [r6, #40]	; 0x28
   18702:	428f      	cmp	r7, r1
   18704:	f000 0002 	and.w	r0, r0, #2
   18708:	dc16      	bgt.n	18738 <lv_draw_mask_line+0x15c>
    if(k < len && k >= 0) {
   1870a:	4293      	cmp	r3, r2
   1870c:	dd28      	ble.n	18760 <lv_draw_mask_line+0x184>
   1870e:	2a00      	cmp	r2, #0
   18710:	db26      	blt.n	18760 <lv_draw_mask_line+0x184>
        int32_t x_inters = (px_h * p->xy_steep) >> 10;
   18712:	69b1      	ldr	r1, [r6, #24]
   18714:	4379      	muls	r1, r7
   18716:	1289      	asrs	r1, r1, #10
        m = (x_inters * px_h) >> 9;
   18718:	4379      	muls	r1, r7
        if(p->yx_steep < 0) m = 255 - m;
   1871a:	69f7      	ldr	r7, [r6, #28]
        m = (x_inters * px_h) >> 9;
   1871c:	f3c1 2147 	ubfx	r1, r1, #9, #8
        if(p->yx_steep < 0) m = 255 - m;
   18720:	2f00      	cmp	r7, #0
   18722:	bfbc      	itt	lt
   18724:	43c9      	mvnlt	r1, r1
   18726:	b2c9      	uxtblt	r1, r1
        if(p->inv) m = 255 - m;
   18728:	b108      	cbz	r0, 1872e <lv_draw_mask_line+0x152>
   1872a:	43c9      	mvns	r1, r1
   1872c:	b2c9      	uxtb	r1, r1
        mask_buf[k] = mask_mix(mask_buf[k], m);
   1872e:	5ca0      	ldrb	r0, [r4, r2]
   18730:	f7ff ff42 	bl	185b8 <mask_mix>
   18734:	54a0      	strb	r0, [r4, r2]
   18736:	e013      	b.n	18760 <lv_draw_mask_line+0x184>
        if(k >= 0 && k < len) {
   18738:	2a00      	cmp	r2, #0
   1873a:	db0b      	blt.n	18754 <lv_draw_mask_line+0x178>
   1873c:	4293      	cmp	r3, r2
   1873e:	dd09      	ble.n	18754 <lv_draw_mask_line+0x178>
            m = px_h - (p->spx >> 1);
   18740:	eba7 0161 	sub.w	r1, r7, r1, asr #1
   18744:	b2c9      	uxtb	r1, r1
            if(p->inv) m = 255 - m;
   18746:	b108      	cbz	r0, 1874c <lv_draw_mask_line+0x170>
   18748:	43c9      	mvns	r1, r1
   1874a:	b2c9      	uxtb	r1, r1
            mask_buf[k] = mask_mix(mask_buf[k], m);
   1874c:	5ca0      	ldrb	r0, [r4, r2]
   1874e:	f7ff ff33 	bl	185b8 <mask_mix>
   18752:	54a0      	strb	r0, [r4, r2]
        px_h -= p->spx;
   18754:	6a71      	ldr	r1, [r6, #36]	; 0x24
        k++;
   18756:	3201      	adds	r2, #1
        if(k >= len) break;
   18758:	4293      	cmp	r3, r2
        px_h -= p->spx;
   1875a:	eba7 0701 	sub.w	r7, r7, r1
        if(k >= len) break;
   1875e:	dccd      	bgt.n	186fc <lv_draw_mask_line+0x120>
    if(p->inv) {
   18760:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
   18764:	0788      	lsls	r0, r1, #30
   18766:	d509      	bpl.n	1877c <lv_draw_mask_line+0x1a0>
        if(k > len) {
   18768:	42ab      	cmp	r3, r5
   1876a:	f6ff af58 	blt.w	1861e <lv_draw_mask_line+0x42>
        if(k >= 0) {
   1876e:	2d00      	cmp	r5, #0
   18770:	f6ff af74 	blt.w	1865c <lv_draw_mask_line+0x80>
            _lv_memset_00(&mask_buf[0], k);
   18774:	4629      	mov	r1, r5
   18776:	e764      	b.n	18642 <lv_draw_mask_line+0x66>
    int32_t k = xei - abs_x;
   18778:	462a      	mov	r2, r5
   1877a:	e7bf      	b.n	186fc <lv_draw_mask_line+0x120>
        if(k < 0) {
   1877c:	1c50      	adds	r0, r2, #1
   1877e:	f53f af4e 	bmi.w	1861e <lv_draw_mask_line+0x42>
        if(k <= len) {
   18782:	4283      	cmp	r3, r0
                if(k >= 0) _lv_memset_00(&mask_buf[k],  len - k);
   18784:	f6ff af6a 	blt.w	1865c <lv_draw_mask_line+0x80>
   18788:	1a19      	subs	r1, r3, r0
   1878a:	4420      	add	r0, r4
                else if(k > 0) _lv_memset_00(&mask_buf[k],  len - k);
   1878c:	f7ff ff22 	bl	185d4 <_lv_memset_00>
   18790:	e764      	b.n	1865c <lv_draw_mask_line+0x80>
    x_at_y = (int32_t)((int32_t)p->xy_steep * abs_y) >> 10;
   18792:	69b1      	ldr	r1, [r6, #24]
   18794:	fa5f f08c 	uxtb.w	r0, ip
   18798:	fb02 f701 	mul.w	r7, r2, r1
    if(p->xy_steep > 0) x_at_y++;
   1879c:	2900      	cmp	r1, #0
    x_at_y = (int32_t)((int32_t)p->xy_steep * abs_y) >> 10;
   1879e:	ea4f 27a7 	mov.w	r7, r7, asr #10
   187a2:	bfd4      	ite	le
   187a4:	46be      	movle	lr, r7
    if(p->xy_steep > 0) x_at_y++;
   187a6:	f107 0e01 	addgt.w	lr, r7, #1
    if(x_at_y < abs_x) {
   187aa:	45ae      	cmp	lr, r5
   187ac:	f6ff af68 	blt.w	18680 <lv_draw_mask_line+0xa4>
    if(x_at_y > abs_x + len) {
   187b0:	eb03 0c05 	add.w	ip, r3, r5
   187b4:	4567      	cmp	r7, ip
   187b6:	f73f af71 	bgt.w	1869c <lv_draw_mask_line+0xc0>
    int32_t xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   187ba:	1c57      	adds	r7, r2, #1
   187bc:	023f      	lsls	r7, r7, #8
    int32_t xs = ((abs_y << 8) * p->xy_steep) >> 10;
   187be:	ea4f 2e02 	mov.w	lr, r2, lsl #8
    int32_t xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
   187c2:	434f      	muls	r7, r1
    int32_t xs = ((abs_y << 8) * p->xy_steep) >> 10;
   187c4:	fb01 fe0e 	mul.w	lr, r1, lr
    int32_t xei = xe >> 8;
   187c8:	ea4f 48a7 	mov.w	r8, r7, asr #18
    if(xsi != xei && (p->xy_steep < 0 && xsf == 0)) {
   187cc:	ebb8 4fae 	cmp.w	r8, lr, asr #18
    int32_t xsf = xs & 0xFF;
   187d0:	f3ce 2c87 	ubfx	ip, lr, #10, #8
    k = xsi - abs_x;
   187d4:	ebc5 42ae 	rsb	r2, r5, lr, asr #18
    if(xsi != xei && (p->xy_steep < 0 && xsf == 0)) {
   187d8:	f000 8096 	beq.w	18908 <lv_draw_mask_line+0x32c>
   187dc:	2900      	cmp	r1, #0
   187de:	da55      	bge.n	1888c <lv_draw_mask_line+0x2b0>
   187e0:	f102 39ff 	add.w	r9, r2, #4294967295
   187e4:	f1bc 0f00 	cmp.w	ip, #0
   187e8:	f000 808b 	beq.w	18902 <lv_draw_mask_line+0x326>
            y_inters = (xsf * (-p->yx_steep)) >> 10;
   187ec:	69f5      	ldr	r5, [r6, #28]
            if(k >= 0 && k < len) {
   187ee:	2a00      	cmp	r2, #0
            y_inters = (xsf * (-p->yx_steep)) >> 10;
   187f0:	fb05 f50c 	mul.w	r5, r5, ip
   187f4:	f1c5 0500 	rsb	r5, r5, #0
   187f8:	ea4f 25a5 	mov.w	r5, r5, asr #10
            if(k >= 0 && k < len) {
   187fc:	db0c      	blt.n	18818 <lv_draw_mask_line+0x23c>
   187fe:	4293      	cmp	r3, r2
   18800:	dd0a      	ble.n	18818 <lv_draw_mask_line+0x23c>
                m = (y_inters * xsf) >> 9;
   18802:	fb05 f10c 	mul.w	r1, r5, ip
   18806:	f3c1 2147 	ubfx	r1, r1, #9, #8
                if(p->inv) m = 255 - m;
   1880a:	b108      	cbz	r0, 18810 <lv_draw_mask_line+0x234>
   1880c:	43c9      	mvns	r1, r1
   1880e:	b2c9      	uxtb	r1, r1
                mask_buf[k] = mask_mix(mask_buf[k], m);
   18810:	5ca0      	ldrb	r0, [r4, r2]
   18812:	f7ff fed1 	bl	185b8 <mask_mix>
   18816:	54a0      	strb	r0, [r4, r2]
            if(k >= 0 && k < len) {
   18818:	f1b9 0f00 	cmp.w	r9, #0
   1881c:	db18      	blt.n	18850 <lv_draw_mask_line+0x274>
   1881e:	454b      	cmp	r3, r9
   18820:	dd16      	ble.n	18850 <lv_draw_mask_line+0x274>
            int32_t x_inters = ((255 - y_inters) * (-p->xy_steep)) >> 10;
   18822:	69b1      	ldr	r1, [r6, #24]
   18824:	f1a5 00ff 	sub.w	r0, r5, #255	; 0xff
   18828:	4341      	muls	r1, r0
   1882a:	1288      	asrs	r0, r1, #10
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
   1882c:	f1c5 01ff 	rsb	r1, r5, #255	; 0xff
   18830:	4341      	muls	r1, r0
                if(p->inv) m = 255 - m;
   18832:	f896 0028 	ldrb.w	r0, [r6, #40]	; 0x28
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
   18836:	f3c1 2147 	ubfx	r1, r1, #9, #8
                if(p->inv) m = 255 - m;
   1883a:	0787      	lsls	r7, r0, #30
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
   1883c:	bf58      	it	pl
   1883e:	43c9      	mvnpl	r1, r1
                mask_buf[k] = mask_mix(mask_buf[k], m);
   18840:	f814 0009 	ldrb.w	r0, [r4, r9]
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
   18844:	bf58      	it	pl
   18846:	b2c9      	uxtbpl	r1, r1
                mask_buf[k] = mask_mix(mask_buf[k], m);
   18848:	f7ff feb6 	bl	185b8 <mask_mix>
   1884c:	f804 0009 	strb.w	r0, [r4, r9]
            if(p->inv) {
   18850:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
   18854:	078d      	lsls	r5, r1, #30
   18856:	d514      	bpl.n	18882 <lv_draw_mask_line+0x2a6>
                if(k > len) k = len;
   18858:	454b      	cmp	r3, r9
   1885a:	f6ff aeff 	blt.w	1865c <lv_draw_mask_line+0x80>
                else if(k > 0) _lv_memset_00(&mask_buf[0],  k);
   1885e:	f1b9 0f00 	cmp.w	r9, #0
   18862:	f77f aefb 	ble.w	1865c <lv_draw_mask_line+0x80>
   18866:	4649      	mov	r1, r9
   18868:	e6eb      	b.n	18642 <lv_draw_mask_line+0x66>
        k++;
   1886a:	3201      	adds	r2, #1
   1886c:	429a      	cmp	r2, r3
   1886e:	bfa8      	it	ge
   18870:	461a      	movge	r2, r3
                if(k == 0) return LV_DRAW_MASK_RES_TRANSP;
   18872:	2a00      	cmp	r2, #0
   18874:	f43f aed3 	beq.w	1861e <lv_draw_mask_line+0x42>
                else if(k > 0) _lv_memset_00(&mask_buf[k],  len - k);
   18878:	f77f aef0 	ble.w	1865c <lv_draw_mask_line+0x80>
   1887c:	1a99      	subs	r1, r3, r2
   1887e:	18a0      	adds	r0, r4, r2
   18880:	e784      	b.n	1878c <lv_draw_mask_line+0x1b0>
            k += 2;
   18882:	1c50      	adds	r0, r2, #1
                if(k > len) return LV_DRAW_MASK_RES_FULL_COVER;
   18884:	4283      	cmp	r3, r0
   18886:	db3a      	blt.n	188fe <lv_draw_mask_line+0x322>
                if(k >= 0) _lv_memset_00(&mask_buf[k],  len - k);
   18888:	2800      	cmp	r0, #0
   1888a:	e77b      	b.n	18784 <lv_draw_mask_line+0x1a8>
            y_inters = ((255 - xsf) * p->yx_steep) >> 10;
   1888c:	69f5      	ldr	r5, [r6, #28]
   1888e:	f1cc 01ff 	rsb	r1, ip, #255	; 0xff
   18892:	434d      	muls	r5, r1
            if(k >= 0 && k < len) {
   18894:	2a00      	cmp	r2, #0
            y_inters = ((255 - xsf) * p->yx_steep) >> 10;
   18896:	ea4f 25a5 	mov.w	r5, r5, asr #10
            if(k >= 0 && k < len) {
   1889a:	db0b      	blt.n	188b4 <lv_draw_mask_line+0x2d8>
   1889c:	4293      	cmp	r3, r2
   1889e:	dd09      	ble.n	188b4 <lv_draw_mask_line+0x2d8>
                m = 255 - ((y_inters * (255 - xsf)) >> 9);
   188a0:	4369      	muls	r1, r5
   188a2:	f3c1 2147 	ubfx	r1, r1, #9, #8
                if(p->inv) m = 255 - m;
   188a6:	b908      	cbnz	r0, 188ac <lv_draw_mask_line+0x2d0>
                m = 255 - ((y_inters * (255 - xsf)) >> 9);
   188a8:	43c9      	mvns	r1, r1
   188aa:	b2c9      	uxtb	r1, r1
                mask_buf[k] = mask_mix(mask_buf[k], m);
   188ac:	5ca0      	ldrb	r0, [r4, r2]
   188ae:	f7ff fe83 	bl	185b8 <mask_mix>
   188b2:	54a0      	strb	r0, [r4, r2]
            if(k >= 0 && k < len) {
   188b4:	1c57      	adds	r7, r2, #1
   188b6:	d414      	bmi.n	188e2 <lv_draw_mask_line+0x306>
   188b8:	42bb      	cmp	r3, r7
   188ba:	dd12      	ble.n	188e2 <lv_draw_mask_line+0x306>
            int32_t x_inters = ((255 - y_inters) * p->xy_steep) >> 10;
   188bc:	69b1      	ldr	r1, [r6, #24]
   188be:	f1c5 05ff 	rsb	r5, r5, #255	; 0xff
   188c2:	4369      	muls	r1, r5
   188c4:	1289      	asrs	r1, r1, #10
                m = ((255 - y_inters) * x_inters) >> 9;
   188c6:	434d      	muls	r5, r1
                if(p->inv) m = 255 - m;
   188c8:	f896 0028 	ldrb.w	r0, [r6, #40]	; 0x28
                m = ((255 - y_inters) * x_inters) >> 9;
   188cc:	f3c5 2147 	ubfx	r1, r5, #9, #8
                if(p->inv) m = 255 - m;
   188d0:	0780      	lsls	r0, r0, #30
   188d2:	bf48      	it	mi
   188d4:	43c9      	mvnmi	r1, r1
                mask_buf[k] = mask_mix(mask_buf[k], m);
   188d6:	5de0      	ldrb	r0, [r4, r7]
                if(p->inv) m = 255 - m;
   188d8:	bf48      	it	mi
   188da:	b2c9      	uxtbmi	r1, r1
                mask_buf[k] = mask_mix(mask_buf[k], m);
   188dc:	f7ff fe6c 	bl	185b8 <mask_mix>
   188e0:	55e0      	strb	r0, [r4, r7]
            if(p->inv) {
   188e2:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
   188e6:	0789      	lsls	r1, r1, #30
   188e8:	d507      	bpl.n	188fa <lv_draw_mask_line+0x31e>
                if(k > len)  return LV_DRAW_MASK_RES_TRANSP;
   188ea:	4293      	cmp	r3, r2
   188ec:	f6ff ae97 	blt.w	1861e <lv_draw_mask_line+0x42>
                if(k >= 0) _lv_memset_00(&mask_buf[0],  k);
   188f0:	2a00      	cmp	r2, #0
   188f2:	f6ff aeb3 	blt.w	1865c <lv_draw_mask_line+0x80>
   188f6:	4611      	mov	r1, r2
   188f8:	e6a3      	b.n	18642 <lv_draw_mask_line+0x66>
            k++;
   188fa:	3202      	adds	r2, #2
   188fc:	e7b6      	b.n	1886c <lv_draw_mask_line+0x290>
                if(k > len) return LV_DRAW_MASK_RES_FULL_COVER;
   188fe:	2001      	movs	r0, #1
   18900:	e687      	b.n	18612 <lv_draw_mask_line+0x36>
   18902:	464a      	mov	r2, r9
        xsf = 0xFF;
   18904:	f04f 0cff 	mov.w	ip, #255	; 0xff
        if(k >= 0 && k < len) {
   18908:	2a00      	cmp	r2, #0
   1890a:	db0d      	blt.n	18928 <lv_draw_mask_line+0x34c>
   1890c:	4293      	cmp	r3, r2
   1890e:	dd0b      	ble.n	18928 <lv_draw_mask_line+0x34c>
    int32_t xef = xe & 0xFF;
   18910:	f3c7 2187 	ubfx	r1, r7, #10, #8
            m = (xsf + xef) >> 1;
   18914:	4461      	add	r1, ip
   18916:	f3c1 0147 	ubfx	r1, r1, #1, #8
            if(p->inv) m = 255 - m;
   1891a:	b108      	cbz	r0, 18920 <lv_draw_mask_line+0x344>
   1891c:	43c9      	mvns	r1, r1
   1891e:	b2c9      	uxtb	r1, r1
            mask_buf[k] = mask_mix(mask_buf[k], m);
   18920:	5ca0      	ldrb	r0, [r4, r2]
   18922:	f7ff fe49 	bl	185b8 <mask_mix>
   18926:	54a0      	strb	r0, [r4, r2]
        if(p->inv) {
   18928:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
   1892c:	0789      	lsls	r1, r1, #30
   1892e:	d59c      	bpl.n	1886a <lv_draw_mask_line+0x28e>
            k = xsi - abs_x;
   18930:	eba8 0105 	sub.w	r1, r8, r5
            if(k >= len) {
   18934:	428b      	cmp	r3, r1
   18936:	f77f ae72 	ble.w	1861e <lv_draw_mask_line+0x42>
            if(k >= 0) _lv_memset_00(&mask_buf[0], k);
   1893a:	2900      	cmp	r1, #0
   1893c:	f6ff ae8e 	blt.w	1865c <lv_draw_mask_line+0x80>
   18940:	e67f      	b.n	18642 <lv_draw_mask_line+0x66>

00018942 <_lv_memcpy_small.constprop.0>:
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   18942:	680a      	ldr	r2, [r1, #0]
   18944:	6002      	str	r2, [r0, #0]
   18946:	684a      	ldr	r2, [r1, #4]
   18948:	6042      	str	r2, [r0, #4]
}
   1894a:	4770      	bx	lr

0001894c <lv_draw_mask_radius>:
{
   1894c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18950:	b08d      	sub	sp, #52	; 0x34
   18952:	9f16      	ldr	r7, [sp, #88]	; 0x58
   18954:	4605      	mov	r5, r0
    bool outer = p->cfg.outer;
   18956:	f897 8012 	ldrb.w	r8, [r7, #18]
{
   1895a:	468b      	mov	fp, r1
   1895c:	461c      	mov	r4, r3
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
   1895e:	f107 0108 	add.w	r1, r7, #8
    bool outer = p->cfg.outer;
   18962:	f008 0301 	and.w	r3, r8, #1
   18966:	a80a      	add	r0, sp, #40	; 0x28
{
   18968:	4691      	mov	r9, r2
    bool outer = p->cfg.outer;
   1896a:	9301      	str	r3, [sp, #4]
    int32_t radius = p->cfg.radius;
   1896c:	f9b7 a010 	ldrsh.w	sl, [r7, #16]
   18970:	f7ff ffe7 	bl	18942 <_lv_memcpy_small.constprop.0>
    if(outer == false) {
   18974:	9b01      	ldr	r3, [sp, #4]
   18976:	f9bd 202a 	ldrsh.w	r2, [sp, #42]	; 0x2a
   1897a:	bbc3      	cbnz	r3, 189ee <lv_draw_mask_radius+0xa2>
        if(abs_y < rect.y1 || abs_y > rect.y2) {
   1897c:	454a      	cmp	r2, r9
   1897e:	dd01      	ble.n	18984 <lv_draw_mask_radius+0x38>
                    return LV_DRAW_MASK_RES_TRANSP;
   18980:	2000      	movs	r0, #0
   18982:	e037      	b.n	189f4 <lv_draw_mask_radius+0xa8>
        if(abs_y < rect.y1 || abs_y > rect.y2) {
   18984:	f9bd 302e 	ldrsh.w	r3, [sp, #46]	; 0x2e
   18988:	454b      	cmp	r3, r9
   1898a:	dbf9      	blt.n	18980 <lv_draw_mask_radius+0x34>
    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
   1898c:	f9bd 1028 	ldrsh.w	r1, [sp, #40]	; 0x28
   18990:	eb01 030a 	add.w	r3, r1, sl
   18994:	459b      	cmp	fp, r3
   18996:	eba1 060b 	sub.w	r6, r1, fp
   1899a:	db07      	blt.n	189ac <lv_draw_mask_radius+0x60>
   1899c:	f9bd 302c 	ldrsh.w	r3, [sp, #44]	; 0x2c
   189a0:	eb04 000b 	add.w	r0, r4, fp
   189a4:	eba3 030a 	sub.w	r3, r3, sl
   189a8:	4298      	cmp	r0, r3
   189aa:	dd09      	ble.n	189c0 <lv_draw_mask_radius+0x74>
       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {
   189ac:	eb02 030a 	add.w	r3, r2, sl
    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
   189b0:	4599      	cmp	r9, r3
   189b2:	f9bd 002e 	ldrsh.w	r0, [sp, #46]	; 0x2e
   189b6:	db3a      	blt.n	18a2e <lv_draw_mask_radius+0xe2>
       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {
   189b8:	eba0 030a 	sub.w	r3, r0, sl
   189bc:	4599      	cmp	r9, r3
   189be:	dc36      	bgt.n	18a2e <lv_draw_mask_radius+0xe2>
        if(outer == false) {
   189c0:	9b01      	ldr	r3, [sp, #4]
   189c2:	bb23      	cbnz	r3, 18a0e <lv_draw_mask_radius+0xc2>
            if(last > len) return LV_DRAW_MASK_RES_TRANSP;
   189c4:	42b4      	cmp	r4, r6
   189c6:	dbdb      	blt.n	18980 <lv_draw_mask_radius+0x34>
            if(last >= 0) {
   189c8:	2e00      	cmp	r6, #0
   189ca:	db03      	blt.n	189d4 <lv_draw_mask_radius+0x88>
                _lv_memset_00(&mask_buf[0], last);
   189cc:	4631      	mov	r1, r6
   189ce:	4628      	mov	r0, r5
   189d0:	f7ff fe00 	bl	185d4 <_lv_memset_00>
            int32_t first = rect.x2 - abs_x + 1;
   189d4:	f9bd 102c 	ldrsh.w	r1, [sp, #44]	; 0x2c
   189d8:	3101      	adds	r1, #1
   189da:	eba1 000b 	sub.w	r0, r1, fp
            if(first <= 0) return LV_DRAW_MASK_RES_TRANSP;
   189de:	2800      	cmp	r0, #0
   189e0:	ddce      	ble.n	18980 <lv_draw_mask_radius+0x34>
            else if(first < len) {
   189e2:	42a0      	cmp	r0, r4
   189e4:	da0e      	bge.n	18a04 <lv_draw_mask_radius+0xb8>
                _lv_memset_00(&mask_buf[first], len - first);
   189e6:	1a61      	subs	r1, r4, r1
   189e8:	4459      	add	r1, fp
                    _lv_memset_00(&mask_buf[first], len_tmp);
   189ea:	4428      	add	r0, r5
   189ec:	e0b8      	b.n	18b60 <lv_draw_mask_radius+0x214>
        if(abs_y < rect.y1 || abs_y > rect.y2) {
   189ee:	454a      	cmp	r2, r9
   189f0:	dd03      	ble.n	189fa <lv_draw_mask_radius+0xae>
            return LV_DRAW_MASK_RES_FULL_COVER;
   189f2:	2001      	movs	r0, #1
}
   189f4:	b00d      	add	sp, #52	; 0x34
   189f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(abs_y < rect.y1 || abs_y > rect.y2) {
   189fa:	f9bd 302e 	ldrsh.w	r3, [sp, #46]	; 0x2e
   189fe:	454b      	cmp	r3, r9
   18a00:	dac4      	bge.n	1898c <lv_draw_mask_radius+0x40>
   18a02:	e7f6      	b.n	189f2 <lv_draw_mask_radius+0xa6>
            if(last == 0 && first == len) return LV_DRAW_MASK_RES_FULL_COVER;
   18a04:	b90e      	cbnz	r6, 18a0a <lv_draw_mask_radius+0xbe>
   18a06:	42a0      	cmp	r0, r4
   18a08:	d0f3      	beq.n	189f2 <lv_draw_mask_radius+0xa6>
    return LV_DRAW_MASK_RES_CHANGED;
   18a0a:	2002      	movs	r0, #2
   18a0c:	e7f2      	b.n	189f4 <lv_draw_mask_radius+0xa8>
            if(first < 0) first = 0;
   18a0e:	ea26 70e6 	bic.w	r0, r6, r6, asr #31
            if(first <= len) {
   18a12:	42a0      	cmp	r0, r4
   18a14:	dcf9      	bgt.n	18a0a <lv_draw_mask_radius+0xbe>
                int32_t last =  rect.x2 - abs_x - first + 1;
   18a16:	f9bd 102c 	ldrsh.w	r1, [sp, #44]	; 0x2c
   18a1a:	3101      	adds	r1, #1
   18a1c:	eba1 010b 	sub.w	r1, r1, fp
                if(first + last > len) last = len - first;
   18a20:	42a1      	cmp	r1, r4
                int32_t last =  rect.x2 - abs_x - first + 1;
   18a22:	bfd4      	ite	le
   18a24:	1a09      	suble	r1, r1, r0
                if(first + last > len) last = len - first;
   18a26:	1a21      	subgt	r1, r4, r0
                if(first < len && len_tmp >= 0) {
   18a28:	2900      	cmp	r1, #0
   18a2a:	dbee      	blt.n	18a0a <lv_draw_mask_radius+0xbe>
   18a2c:	e7dd      	b.n	189ea <lv_draw_mask_radius+0x9e>
    uint32_t r2 = p->cfg.radius * p->cfg.radius;
   18a2e:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   18a32:	f8bd b02c 	ldrh.w	fp, [sp, #44]	; 0x2c
   18a36:	435b      	muls	r3, r3
    abs_y -= rect.y1;
   18a38:	eba9 0902 	sub.w	r9, r9, r2
   18a3c:	f10b 0b01 	add.w	fp, fp, #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   18a40:	3001      	adds	r0, #1
   18a42:	fa0f f989 	sxth.w	r9, r9
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   18a46:	ebab 0b01 	sub.w	fp, fp, r1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   18a4a:	1a80      	subs	r0, r0, r2
    if(abs_y < radius || abs_y > h - radius - 1) {
   18a4c:	45ca      	cmp	sl, r9
    int32_t w = lv_area_get_width(&rect);
   18a4e:	fa0f fb8b 	sxth.w	fp, fp
    int32_t h = lv_area_get_height(&rect);
   18a52:	b200      	sxth	r0, r0
    uint32_t r2 = p->cfg.radius * p->cfg.radius;
   18a54:	9302      	str	r3, [sp, #8]
    if(abs_y < radius || abs_y > h - radius - 1) {
   18a56:	f300 8193 	bgt.w	18d80 <lv_draw_mask_radius+0x434>
   18a5a:	1e43      	subs	r3, r0, #1
   18a5c:	eba3 030a 	sub.w	r3, r3, sl
   18a60:	4599      	cmp	r9, r3
   18a62:	ddd2      	ble.n	18a0a <lv_draw_mask_radius+0xbe>
            y = radius - (h - abs_y) + 1;
   18a64:	eba9 0900 	sub.w	r9, r9, r0
            if((y - 1) == p->y_prev) {
   18a68:	697b      	ldr	r3, [r7, #20]
        if(radius <= 256) sqrt_mask = 0x800;
   18a6a:	f5ba 7f80 	cmp.w	sl, #256	; 0x100
            y = radius - (h - abs_y) + 1;
   18a6e:	eb09 000a 	add.w	r0, r9, sl
        if(radius <= 256) sqrt_mask = 0x800;
   18a72:	bfd4      	ite	le
   18a74:	f44f 6800 	movle.w	r8, #2048	; 0x800
   18a78:	f44f 4800 	movgt.w	r8, #32768	; 0x8000
            if((y - 1) == p->y_prev) {
   18a7c:	4298      	cmp	r0, r3
            y = radius - (h - abs_y) + 1;
   18a7e:	f100 0901 	add.w	r9, r0, #1
            if((y - 1) == p->y_prev) {
   18a82:	d070      	beq.n	18b66 <lv_draw_mask_radius+0x21a>
                _lv_sqrt(r2 - ((y - 1) * (y - 1)), &x1, sqrt_mask);
   18a84:	9b02      	ldr	r3, [sp, #8]
   18a86:	4642      	mov	r2, r8
   18a88:	fb00 3010 	mls	r0, r0, r0, r3
   18a8c:	a907      	add	r1, sp, #28
   18a8e:	f002 fcbb 	bl	1b408 <_lv_sqrt>
   18a92:	e06a      	b.n	18b6a <lv_draw_mask_radius+0x21e>
                x0.i = p->y_prev_x.i;
   18a94:	69bb      	ldr	r3, [r7, #24]
   18a96:	9306      	str	r3, [sp, #24]
            _lv_sqrt(r2 - ((y - 1) * (y - 1)), &x1, sqrt_mask);
   18a98:	9802      	ldr	r0, [sp, #8]
   18a9a:	f109 33ff 	add.w	r3, r9, #4294967295
   18a9e:	fb03 0013 	mls	r0, r3, r3, r0
   18aa2:	4642      	mov	r2, r8
   18aa4:	a907      	add	r1, sp, #28
   18aa6:	9303      	str	r3, [sp, #12]
   18aa8:	f002 fcae 	bl	1b408 <_lv_sqrt>
            p->y_prev = y - 1;
   18aac:	9b03      	ldr	r3, [sp, #12]
   18aae:	617b      	str	r3, [r7, #20]
            p->y_prev_x.i = x1.i;
   18ab0:	9b07      	ldr	r3, [sp, #28]
            p->y_prev_x.i = x0.i;
   18ab2:	61bb      	str	r3, [r7, #24]
        if(x0.i == x1.i - 1 && x1.f == 0) {
   18ab4:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   18ab8:	f8bd 1018 	ldrh.w	r1, [sp, #24]
   18abc:	3b01      	subs	r3, #1
   18abe:	4299      	cmp	r1, r3
   18ac0:	d107      	bne.n	18ad2 <lv_draw_mask_radius+0x186>
   18ac2:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   18ac6:	b923      	cbnz	r3, 18ad2 <lv_draw_mask_radius+0x186>
            x1.f = 0xFF;
   18ac8:	23ff      	movs	r3, #255	; 0xff
            x1.i--;
   18aca:	f8ad 101c 	strh.w	r1, [sp, #28]
            x1.f = 0xFF;
   18ace:	f8ad 301e 	strh.w	r3, [sp, #30]
        if(x0.i == x1.i) {
   18ad2:	eb06 070b 	add.w	r7, r6, fp
   18ad6:	ea6f 0b01 	mvn.w	fp, r1
   18ada:	f8bd 001c 	ldrh.w	r0, [sp, #28]
   18ade:	44d3      	add	fp, sl
   18ae0:	eba7 030b 	sub.w	r3, r7, fp
   18ae4:	4288      	cmp	r0, r1
   18ae6:	eb06 0a0b 	add.w	sl, r6, fp
   18aea:	9303      	str	r3, [sp, #12]
   18aec:	f103 36ff 	add.w	r6, r3, #4294967295
   18af0:	d152      	bne.n	18b98 <lv_draw_mask_radius+0x24c>
            lv_opa_t m = (x0.f + x1.f) >> 1;
   18af2:	f8bd 201a 	ldrh.w	r2, [sp, #26]
   18af6:	f8bd 101e 	ldrh.w	r1, [sp, #30]
            if(outer) m = 255 - m;
   18afa:	9b01      	ldr	r3, [sp, #4]
            lv_opa_t m = (x0.f + x1.f) >> 1;
   18afc:	440a      	add	r2, r1
   18afe:	f3c2 0247 	ubfx	r2, r2, #1, #8
            if(outer) m = 255 - m;
   18b02:	b10b      	cbz	r3, 18b08 <lv_draw_mask_radius+0x1bc>
   18b04:	43d2      	mvns	r2, r2
   18b06:	b2d2      	uxtb	r2, r2
            if(kl >= 0 && kl < len) {
   18b08:	f1ba 0f00 	cmp.w	sl, #0
   18b0c:	db08      	blt.n	18b20 <lv_draw_mask_radius+0x1d4>
   18b0e:	4554      	cmp	r4, sl
   18b10:	dd06      	ble.n	18b20 <lv_draw_mask_radius+0x1d4>
                mask_buf[kl] = mask_mix(mask_buf[kl], m);
   18b12:	f815 000a 	ldrb.w	r0, [r5, sl]
   18b16:	4611      	mov	r1, r2
   18b18:	f7ff fd4e 	bl	185b8 <mask_mix>
   18b1c:	f805 000a 	strb.w	r0, [r5, sl]
            if(kr >= 0 && kr < len) {
   18b20:	2e00      	cmp	r6, #0
   18b22:	db06      	blt.n	18b32 <lv_draw_mask_radius+0x1e6>
   18b24:	42b4      	cmp	r4, r6
   18b26:	dd04      	ble.n	18b32 <lv_draw_mask_radius+0x1e6>
                mask_buf[kr] = mask_mix(mask_buf[kr], m);
   18b28:	5da8      	ldrb	r0, [r5, r6]
   18b2a:	4611      	mov	r1, r2
   18b2c:	f7ff fd44 	bl	185b8 <mask_mix>
   18b30:	55a8      	strb	r0, [r5, r6]
            if(outer == false) {
   18b32:	9b01      	ldr	r3, [sp, #4]
   18b34:	bb23      	cbnz	r3, 18b80 <lv_draw_mask_radius+0x234>
                if(kl > len)  {
   18b36:	4554      	cmp	r4, sl
   18b38:	f6ff af22 	blt.w	18980 <lv_draw_mask_radius+0x34>
                if(kl >= 0) {
   18b3c:	f1ba 0f00 	cmp.w	sl, #0
   18b40:	db03      	blt.n	18b4a <lv_draw_mask_radius+0x1fe>
                    _lv_memset_00(&mask_buf[0], kl);
   18b42:	4651      	mov	r1, sl
   18b44:	4628      	mov	r0, r5
   18b46:	f7ff fd45 	bl	185d4 <_lv_memset_00>
                if(kr < 0) {
   18b4a:	9b03      	ldr	r3, [sp, #12]
   18b4c:	2b00      	cmp	r3, #0
   18b4e:	f6ff af17 	blt.w	18980 <lv_draw_mask_radius+0x34>
                if(kr <= len) {
   18b52:	429c      	cmp	r4, r3
   18b54:	f6ff af59 	blt.w	18a0a <lv_draw_mask_radius+0xbe>
                    _lv_memset_00(&mask_buf[kr], len - kr);
   18b58:	442b      	add	r3, r5
   18b5a:	4618      	mov	r0, r3
   18b5c:	1be1      	subs	r1, r4, r7
   18b5e:	4459      	add	r1, fp
                if(kr < len) _lv_memset_00(&mask_buf[kr], len - kr);
   18b60:	f7ff fd38 	bl	185d4 <_lv_memset_00>
   18b64:	e751      	b.n	18a0a <lv_draw_mask_radius+0xbe>
                x1.i = p->y_prev_x.i;
   18b66:	69bb      	ldr	r3, [r7, #24]
   18b68:	9307      	str	r3, [sp, #28]
            _lv_sqrt(r2 - (y * y), &x0, sqrt_mask);
   18b6a:	9b02      	ldr	r3, [sp, #8]
   18b6c:	4642      	mov	r2, r8
   18b6e:	fb09 3019 	mls	r0, r9, r9, r3
   18b72:	a906      	add	r1, sp, #24
   18b74:	f002 fc48 	bl	1b408 <_lv_sqrt>
            p->y_prev_x.i = x0.i;
   18b78:	9b06      	ldr	r3, [sp, #24]
            p->y_prev = y;
   18b7a:	f8c7 9014 	str.w	r9, [r7, #20]
            p->y_prev_x.i = x0.i;
   18b7e:	e798      	b.n	18ab2 <lv_draw_mask_radius+0x166>
                kl++;
   18b80:	f10a 0001 	add.w	r0, sl, #1
   18b84:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
                if(len_tmp + first > len) len_tmp = len - first;
   18b88:	42b4      	cmp	r4, r6
                int32_t len_tmp = kr - first;
   18b8a:	bfac      	ite	ge
   18b8c:	1a31      	subge	r1, r6, r0
                if(len_tmp + first > len) len_tmp = len - first;
   18b8e:	1a21      	sublt	r1, r4, r0
                if(first < len && len_tmp >= 0) {
   18b90:	42a0      	cmp	r0, r4
   18b92:	f6bf af3a 	bge.w	18a0a <lv_draw_mask_radius+0xbe>
   18b96:	e747      	b.n	18a28 <lv_draw_mask_radius+0xdc>
            if(outer) {
   18b98:	9b01      	ldr	r3, [sp, #4]
   18b9a:	b173      	cbz	r3, 18bba <lv_draw_mask_radius+0x26e>
                int32_t first = kl + 1;
   18b9c:	f10a 0001 	add.w	r0, sl, #1
                if(first < 0) first = 0;
   18ba0:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
                if(len_tmp + first > len) len_tmp = len - first;
   18ba4:	42b4      	cmp	r4, r6
                int32_t len_tmp = kr - first;
   18ba6:	bfac      	ite	ge
   18ba8:	1a31      	subge	r1, r6, r0
                if(len_tmp + first > len) len_tmp = len - first;
   18baa:	1a21      	sublt	r1, r4, r0
                if(first < len && len_tmp >= 0) {
   18bac:	42a0      	cmp	r0, r4
   18bae:	da04      	bge.n	18bba <lv_draw_mask_radius+0x26e>
   18bb0:	2900      	cmp	r1, #0
   18bb2:	db02      	blt.n	18bba <lv_draw_mask_radius+0x26e>
                    _lv_memset_00(&mask_buf[first], len_tmp);
   18bb4:	4428      	add	r0, r5
   18bb6:	f7ff fd0d 	bl	185d4 <_lv_memset_00>
            uint32_t i = x0.i + 1;
   18bba:	f8bd 7018 	ldrh.w	r7, [sp, #24]
            _lv_sqrt(r2 - (x0.i * x0.i), &y_prev, sqrt_mask);
   18bbe:	9b02      	ldr	r3, [sp, #8]
   18bc0:	a908      	add	r1, sp, #32
   18bc2:	4642      	mov	r2, r8
   18bc4:	fb07 3017 	mls	r0, r7, r7, r3
   18bc8:	f002 fc1e 	bl	1b408 <_lv_sqrt>
            if(y_prev.f == 0) {
   18bcc:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
            uint32_t i = x0.i + 1;
   18bd0:	f107 0b01 	add.w	fp, r7, #1
            if(y_prev.f == 0) {
   18bd4:	b939      	cbnz	r1, 18be6 <lv_draw_mask_radius+0x29a>
                y_prev.i--;
   18bd6:	f8bd 1020 	ldrh.w	r1, [sp, #32]
   18bda:	3901      	subs	r1, #1
   18bdc:	f8ad 1020 	strh.w	r1, [sp, #32]
                y_prev.f = 0xFF;
   18be0:	21ff      	movs	r1, #255	; 0xff
   18be2:	f8ad 1022 	strh.w	r1, [sp, #34]	; 0x22
            if(y_prev.i >= y) {
   18be6:	f8bd 1020 	ldrh.w	r1, [sp, #32]
   18bea:	4549      	cmp	r1, r9
   18bec:	db31      	blt.n	18c52 <lv_draw_mask_radius+0x306>
                _lv_sqrt(r2 - (i * i), &y_next, sqrt_mask);
   18bee:	9b02      	ldr	r3, [sp, #8]
   18bf0:	4642      	mov	r2, r8
   18bf2:	fb0b 301b 	mls	r0, fp, fp, r3
   18bf6:	a909      	add	r1, sp, #36	; 0x24
   18bf8:	f002 fc06 	bl	1b408 <_lv_sqrt>
                m = 255 - (((255 - x0.f) * (255 - y_next.f)) >> 9);
   18bfc:	f8bd 201a 	ldrh.w	r2, [sp, #26]
   18c00:	f8bd 9026 	ldrh.w	r9, [sp, #38]	; 0x26
   18c04:	f1c2 01ff 	rsb	r1, r2, #255	; 0xff
   18c08:	f1c9 02ff 	rsb	r2, r9, #255	; 0xff
   18c0c:	434a      	muls	r2, r1
                if(outer) m = 255 - m;
   18c0e:	9b01      	ldr	r3, [sp, #4]
                m = 255 - (((255 - x0.f) * (255 - y_next.f)) >> 9);
   18c10:	f3c2 2247 	ubfx	r2, r2, #9, #8
                if(outer) m = 255 - m;
   18c14:	b90b      	cbnz	r3, 18c1a <lv_draw_mask_radius+0x2ce>
                m = 255 - (((255 - x0.f) * (255 - y_next.f)) >> 9);
   18c16:	43d2      	mvns	r2, r2
   18c18:	b2d2      	uxtb	r2, r2
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
   18c1a:	f1ba 0f00 	cmp.w	sl, #0
   18c1e:	db08      	blt.n	18c32 <lv_draw_mask_radius+0x2e6>
   18c20:	4554      	cmp	r4, sl
   18c22:	dd06      	ble.n	18c32 <lv_draw_mask_radius+0x2e6>
   18c24:	f815 000a 	ldrb.w	r0, [r5, sl]
   18c28:	4611      	mov	r1, r2
   18c2a:	f7ff fcc5 	bl	185b8 <mask_mix>
   18c2e:	f805 000a 	strb.w	r0, [r5, sl]
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
   18c32:	2e00      	cmp	r6, #0
   18c34:	db06      	blt.n	18c44 <lv_draw_mask_radius+0x2f8>
   18c36:	42b4      	cmp	r4, r6
   18c38:	dd04      	ble.n	18c44 <lv_draw_mask_radius+0x2f8>
   18c3a:	5da8      	ldrb	r0, [r5, r6]
   18c3c:	4611      	mov	r1, r2
   18c3e:	f7ff fcbb 	bl	185b8 <mask_mix>
   18c42:	55a8      	strb	r0, [r5, r6]
                i++;
   18c44:	9e03      	ldr	r6, [sp, #12]
                kl--;
   18c46:	f10a 3aff 	add.w	sl, sl, #4294967295
                y_prev.f = y_next.f;
   18c4a:	f8ad 9022 	strh.w	r9, [sp, #34]	; 0x22
                i++;
   18c4e:	f107 0b02 	add.w	fp, r7, #2
            for(; i <= x1.i; i++) {
   18c52:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 */
LV_ATTRIBUTE_FAST_MEM static inline void sqrt_approx(lv_sqrt_res_t * q, lv_sqrt_res_t * ref, uint32_t x)
{
    x = x << 8; /*Upscale for extra precision*/

    uint32_t raw = (ref->i << 4) + (ref->f >> 4);
   18c56:	f8bd 2020 	ldrh.w	r2, [sp, #32]
            for(; i <= x1.i; i++) {
   18c5a:	9303      	str	r3, [sp, #12]
    uint32_t raw = (ref->i << 4) + (ref->f >> 4);
   18c5c:	0113      	lsls	r3, r2, #4
   18c5e:	9304      	str	r3, [sp, #16]
   18c60:	46b1      	mov	r9, r6
   18c62:	465b      	mov	r3, fp
   18c64:	4657      	mov	r7, sl
   18c66:	2000      	movs	r0, #0
   18c68:	f8bd c022 	ldrh.w	ip, [sp, #34]	; 0x22
   18c6c:	f8bd 8024 	ldrh.w	r8, [sp, #36]	; 0x24
   18c70:	f8bd 2026 	ldrh.w	r2, [sp, #38]	; 0x26
            for(; i <= x1.i; i++) {
   18c74:	9903      	ldr	r1, [sp, #12]
   18c76:	4299      	cmp	r1, r3
   18c78:	d24a      	bcs.n	18d10 <lv_draw_mask_radius+0x3c4>
   18c7a:	460f      	mov	r7, r1
   18c7c:	3701      	adds	r7, #1
   18c7e:	45bb      	cmp	fp, r7
   18c80:	eba7 010b 	sub.w	r1, r7, fp
   18c84:	ebab 0e07 	sub.w	lr, fp, r7
   18c88:	bf84      	itt	hi
   18c8a:	2100      	movhi	r1, #0
   18c8c:	f04f 0e00 	movhi.w	lr, #0
   18c90:	440e      	add	r6, r1
   18c92:	eb0e 030a 	add.w	r3, lr, sl
   18c96:	b128      	cbz	r0, 18ca4 <lv_draw_mask_radius+0x358>
   18c98:	f8ad c022 	strh.w	ip, [sp, #34]	; 0x22
   18c9c:	f8ad 8024 	strh.w	r8, [sp, #36]	; 0x24
   18ca0:	f8ad 2026 	strh.w	r2, [sp, #38]	; 0x26
            if(y_prev.f) {
   18ca4:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
   18ca8:	b1e2      	cbz	r2, 18ce4 <lv_draw_mask_radius+0x398>
                m = (y_prev.f * x1.f) >> 9;
   18caa:	f8bd 101e 	ldrh.w	r1, [sp, #30]
   18cae:	434a      	muls	r2, r1
                if(outer) m = 255 - m;
   18cb0:	9901      	ldr	r1, [sp, #4]
                m = (y_prev.f * x1.f) >> 9;
   18cb2:	f3c2 2247 	ubfx	r2, r2, #9, #8
                if(outer) m = 255 - m;
   18cb6:	b109      	cbz	r1, 18cbc <lv_draw_mask_radius+0x370>
   18cb8:	43d2      	mvns	r2, r2
   18cba:	b2d2      	uxtb	r2, r2
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
   18cbc:	2b00      	cmp	r3, #0
   18cbe:	db06      	blt.n	18cce <lv_draw_mask_radius+0x382>
   18cc0:	429c      	cmp	r4, r3
   18cc2:	dd04      	ble.n	18cce <lv_draw_mask_radius+0x382>
   18cc4:	5ce8      	ldrb	r0, [r5, r3]
   18cc6:	4611      	mov	r1, r2
   18cc8:	f7ff fc76 	bl	185b8 <mask_mix>
   18ccc:	54e8      	strb	r0, [r5, r3]
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
   18cce:	2e00      	cmp	r6, #0
   18cd0:	db06      	blt.n	18ce0 <lv_draw_mask_radius+0x394>
   18cd2:	42b4      	cmp	r4, r6
   18cd4:	dd04      	ble.n	18ce0 <lv_draw_mask_radius+0x394>
   18cd6:	5da8      	ldrb	r0, [r5, r6]
   18cd8:	4611      	mov	r1, r2
   18cda:	f7ff fc6d 	bl	185b8 <mask_mix>
   18cde:	55a8      	strb	r0, [r5, r6]
                kl--;
   18ce0:	3b01      	subs	r3, #1
                kr++;
   18ce2:	3601      	adds	r6, #1
            if(outer == 0) {
   18ce4:	9a01      	ldr	r2, [sp, #4]
   18ce6:	2a00      	cmp	r2, #0
   18ce8:	f47f ae8f 	bne.w	18a0a <lv_draw_mask_radius+0xbe>
                kl++;
   18cec:	1c59      	adds	r1, r3, #1
                if(kl > len) {
   18cee:	428c      	cmp	r4, r1
   18cf0:	f6ff ae46 	blt.w	18980 <lv_draw_mask_radius+0x34>
                if(kl >= 0) _lv_memset_00(&mask_buf[0], kl);
   18cf4:	2900      	cmp	r1, #0
   18cf6:	db02      	blt.n	18cfe <lv_draw_mask_radius+0x3b2>
   18cf8:	4628      	mov	r0, r5
   18cfa:	f7ff fc6b 	bl	185d4 <_lv_memset_00>
                if(kr < 0) {
   18cfe:	2e00      	cmp	r6, #0
   18d00:	f6ff ae3e 	blt.w	18980 <lv_draw_mask_radius+0x34>
                if(kr < len) _lv_memset_00(&mask_buf[kr], len - kr);
   18d04:	42b4      	cmp	r4, r6
   18d06:	f77f ae80 	ble.w	18a0a <lv_draw_mask_radius+0xbe>
   18d0a:	1ba1      	subs	r1, r4, r6
   18d0c:	19a8      	adds	r0, r5, r6
   18d0e:	e727      	b.n	18b60 <lv_draw_mask_radius+0x214>
    uint32_t raw = (ref->i << 4) + (ref->f >> 4);
   18d10:	9904      	ldr	r1, [sp, #16]
   18d12:	f3cc 120f 	ubfx	r2, ip, #4, #16
   18d16:	1851      	adds	r1, r2, r1
                sqrt_approx(&y_next, &y_prev, r2 - (i * i));
   18d18:	9a02      	ldr	r2, [sp, #8]
    uint32_t raw2 = raw * raw;
   18d1a:	fb01 f001 	mul.w	r0, r1, r1
                sqrt_approx(&y_next, &y_prev, r2 - (i * i));
   18d1e:	fb03 2213 	mls	r2, r3, r3, r2

    int32_t d = x - raw2;
   18d22:	ebc0 2202 	rsb	r2, r0, r2, lsl #8
    d = (int32_t)d / (int32_t)(2 * raw) + raw;
   18d26:	0048      	lsls	r0, r1, #1
   18d28:	fb92 f2f0 	sdiv	r2, r2, r0
   18d2c:	440a      	add	r2, r1

    q->i = d >> 4;
   18d2e:	f3c2 180f 	ubfx	r8, r2, #4, #16
    q->f = (d & 0xF) << 4;
   18d32:	0112      	lsls	r2, r2, #4
   18d34:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
                if(outer) m = 255 - m;
   18d38:	9801      	ldr	r0, [sp, #4]
                m = (y_prev.f + y_next.f) >> 1;
   18d3a:	eb0c 0102 	add.w	r1, ip, r2
   18d3e:	f3c1 0147 	ubfx	r1, r1, #1, #8
                if(outer) m = 255 - m;
   18d42:	b108      	cbz	r0, 18d48 <lv_draw_mask_radius+0x3fc>
   18d44:	43c9      	mvns	r1, r1
   18d46:	b2c9      	uxtb	r1, r1
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
   18d48:	2f00      	cmp	r7, #0
   18d4a:	db07      	blt.n	18d5c <lv_draw_mask_radius+0x410>
   18d4c:	42bc      	cmp	r4, r7
   18d4e:	dd05      	ble.n	18d5c <lv_draw_mask_radius+0x410>
   18d50:	5de8      	ldrb	r0, [r5, r7]
   18d52:	9105      	str	r1, [sp, #20]
   18d54:	f7ff fc30 	bl	185b8 <mask_mix>
   18d58:	9905      	ldr	r1, [sp, #20]
   18d5a:	55e8      	strb	r0, [r5, r7]
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
   18d5c:	f1b9 0f00 	cmp.w	r9, #0
   18d60:	db07      	blt.n	18d72 <lv_draw_mask_radius+0x426>
   18d62:	454c      	cmp	r4, r9
   18d64:	dd05      	ble.n	18d72 <lv_draw_mask_radius+0x426>
   18d66:	f815 0009 	ldrb.w	r0, [r5, r9]
   18d6a:	f7ff fc25 	bl	185b8 <mask_mix>
   18d6e:	f805 0009 	strb.w	r0, [r5, r9]
                y_prev.f = y_next.f;
   18d72:	4694      	mov	ip, r2
            for(; i <= x1.i; i++) {
   18d74:	2001      	movs	r0, #1
                kl--;
   18d76:	3f01      	subs	r7, #1
                kr++;
   18d78:	f109 0901 	add.w	r9, r9, #1
            for(; i <= x1.i; i++) {
   18d7c:	3301      	adds	r3, #1
   18d7e:	e779      	b.n	18c74 <lv_draw_mask_radius+0x328>
            if(y == p->y_prev) {
   18d80:	697b      	ldr	r3, [r7, #20]
        if(radius <= 256) sqrt_mask = 0x800;
   18d82:	f5ba 7f80 	cmp.w	sl, #256	; 0x100
            y = radius - abs_y;
   18d86:	ebaa 0909 	sub.w	r9, sl, r9
        if(radius <= 256) sqrt_mask = 0x800;
   18d8a:	bfd4      	ite	le
   18d8c:	f44f 6800 	movle.w	r8, #2048	; 0x800
   18d90:	f44f 4800 	movgt.w	r8, #32768	; 0x8000
            if(y == p->y_prev) {
   18d94:	454b      	cmp	r3, r9
   18d96:	f43f ae7d 	beq.w	18a94 <lv_draw_mask_radius+0x148>
                _lv_sqrt(r2 - (y * y), &x0, sqrt_mask);
   18d9a:	9b02      	ldr	r3, [sp, #8]
   18d9c:	4642      	mov	r2, r8
   18d9e:	fb09 3019 	mls	r0, r9, r9, r3
   18da2:	a906      	add	r1, sp, #24
   18da4:	f002 fb30 	bl	1b408 <_lv_sqrt>
   18da8:	e676      	b.n	18a98 <lv_draw_mask_radius+0x14c>

00018daa <grad_get>:
        _lv_mem_buf_release(mask_buf);
    }
}

LV_ATTRIBUTE_FAST_MEM static inline lv_color_t grad_get(const lv_draw_rect_dsc_t * dsc, lv_coord_t s, lv_coord_t i)
{
   18daa:	b570      	push	{r4, r5, r6, lr}
    int32_t min = (dsc->bg_main_color_stop * s) >> 8;
   18dac:	f9b0 400e 	ldrsh.w	r4, [r0, #14]
   18db0:	fb04 f301 	mul.w	r3, r4, r1
    if(i <= min) return dsc->bg_color;
   18db4:	ebb2 2f23 	cmp.w	r2, r3, asr #8
    int32_t min = (dsc->bg_main_color_stop * s) >> 8;
   18db8:	ea4f 2523 	mov.w	r5, r3, asr #8
    if(i <= min) return dsc->bg_color;
   18dbc:	dc01      	bgt.n	18dc2 <grad_get+0x18>
   18dbe:	6840      	ldr	r0, [r0, #4]
    int32_t d = dsc->bg_grad_color_stop - dsc->bg_main_color_stop;
    d = (s * d) >> 8;
    i -= min;
    lv_opa_t mix = (i * 255) / d;
    return lv_color_mix(dsc->bg_grad_color, dsc->bg_color, mix);
}
   18dc0:	bd70      	pop	{r4, r5, r6, pc}
    int32_t max = (dsc->bg_grad_color_stop * s) >> 8;
   18dc2:	f9b0 3010 	ldrsh.w	r3, [r0, #16]
   18dc6:	fb01 f603 	mul.w	r6, r1, r3
    if(i >= max) return dsc->bg_grad_color;
   18dca:	ebb2 2f26 	cmp.w	r2, r6, asr #8
   18dce:	db01      	blt.n	18dd4 <grad_get+0x2a>
   18dd0:	6880      	ldr	r0, [r0, #8]
   18dd2:	e7f5      	b.n	18dc0 <grad_get+0x16>
    int32_t d = dsc->bg_grad_color_stop - dsc->bg_main_color_stop;
   18dd4:	1b1b      	subs	r3, r3, r4
    d = (s * d) >> 8;
   18dd6:	434b      	muls	r3, r1
    i -= min;
   18dd8:	1b52      	subs	r2, r2, r5
    lv_opa_t mix = (i * 255) / d;
   18dda:	b212      	sxth	r2, r2
   18ddc:	ebc2 2202 	rsb	r2, r2, r2, lsl #8
    d = (s * d) >> 8;
   18de0:	121b      	asrs	r3, r3, #8
    lv_opa_t mix = (i * 255) / d;
   18de2:	fb92 f3f3 	sdiv	r3, r2, r3
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   18de6:	7981      	ldrb	r1, [r0, #6]
   18de8:	b2db      	uxtb	r3, r3
   18dea:	f1c3 05ff 	rsb	r5, r3, #255	; 0xff
   18dee:	4369      	muls	r1, r5
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   18df0:	7946      	ldrb	r6, [r0, #5]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   18df2:	7a82      	ldrb	r2, [r0, #10]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   18df4:	436e      	muls	r6, r5
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   18df6:	f248 0481 	movw	r4, #32897	; 0x8081
   18dfa:	fb03 1202 	mla	r2, r3, r2, r1
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   18dfe:	7a41      	ldrb	r1, [r0, #9]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   18e00:	4362      	muls	r2, r4
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   18e02:	fb03 6101 	mla	r1, r3, r1, r6
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   18e06:	7a06      	ldrb	r6, [r0, #8]
   18e08:	7900      	ldrb	r0, [r0, #4]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   18e0a:	4361      	muls	r1, r4
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   18e0c:	4345      	muls	r5, r0
   18e0e:	2000      	movs	r0, #0
   18e10:	fb03 5506 	mla	r5, r3, r6, r5
   18e14:	436c      	muls	r4, r5
   18e16:	0de4      	lsrs	r4, r4, #23
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   18e18:	f3c1 51c7 	ubfx	r1, r1, #23, #8
   18e1c:	f364 0007 	bfi	r0, r4, #0, #8
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   18e20:	f3c2 52c7 	ubfx	r2, r2, #23, #8
    return ret;
   18e24:	f361 200f 	bfi	r0, r1, #8, #8
   18e28:	f362 4017 	bfi	r0, r2, #16, #8
   18e2c:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
   18e30:	e7c6      	b.n	18dc0 <grad_get+0x16>

00018e32 <_lv_memset_00>:
{
   18e32:	460a      	mov	r2, r1
__ssp_bos_icheck3(memset, void *, int)
   18e34:	2100      	movs	r1, #0
   18e36:	f004 bda1 	b.w	1d97c <memset>

00018e3a <_lv_memset_ff>:
{
   18e3a:	460a      	mov	r2, r1
   18e3c:	21ff      	movs	r1, #255	; 0xff
   18e3e:	f004 bd9d 	b.w	1d97c <memset>

00018e42 <_lv_memset>:
   18e42:	f004 bd9b 	b.w	1d97c <memset>

00018e46 <_lv_memcpy>:
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   18e46:	f004 bd8c 	b.w	1d962 <memcpy>

00018e4a <lv_area_copy>:
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
   18e4a:	2208      	movs	r2, #8
   18e4c:	f7ff bffb 	b.w	18e46 <_lv_memcpy>

00018e50 <shadow_blur_corner>:

}

LV_ATTRIBUTE_FAST_MEM static void shadow_blur_corner(lv_coord_t size, lv_coord_t sw, uint16_t * sh_ups_buf)
{
    int32_t s_left = sw >> 1;
   18e50:	460b      	mov	r3, r1
{
   18e52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18e56:	4615      	mov	r5, r2
    int32_t s_right = (sw >> 1);
    if((sw & 1) == 0) s_left--;

    /*Horizontal blur*/
    uint16_t * sh_ups_blur_buf = _lv_mem_buf_get(size * sizeof(uint16_t));
   18e58:	0042      	lsls	r2, r0, #1
{
   18e5a:	b089      	sub	sp, #36	; 0x24
    int32_t s_left = sw >> 1;
   18e5c:	ea4f 0961 	mov.w	r9, r1, asr #1
    if((sw & 1) == 0) s_left--;
   18e60:	07db      	lsls	r3, r3, #31
{
   18e62:	4604      	mov	r4, r0
    uint16_t * sh_ups_blur_buf = _lv_mem_buf_get(size * sizeof(uint16_t));
   18e64:	4610      	mov	r0, r2
    int32_t s_left = sw >> 1;
   18e66:	464f      	mov	r7, r9
{
   18e68:	9101      	str	r1, [sp, #4]
    if((sw & 1) == 0) s_left--;
   18e6a:	bf58      	it	pl
   18e6c:	f109 37ff 	addpl.w	r7, r9, #4294967295
    uint16_t * sh_ups_blur_buf = _lv_mem_buf_get(size * sizeof(uint16_t));
   18e70:	9202      	str	r2, [sp, #8]
   18e72:	f7f3 fe43 	bl	cafc <_lv_mem_buf_get>
   18e76:	f06f 0801 	mvn.w	r8, #1
   18e7a:	4601      	mov	r1, r0
            if(x + s_right < size) right_val = sh_ups_tmp_buf[x + s_right];
            v -= right_val;

            /*Add the left pixel*/
            uint32_t left_val;
            if(x - s_left - 1 < 0) left_val = sh_ups_tmp_buf[0];
   18e7c:	43f8      	mvns	r0, r7
    for(y = 0; y < size; y++) {
   18e7e:	46aa      	mov	sl, r5
   18e80:	f04f 0b00 	mov.w	fp, #0
        int32_t v = sh_ups_tmp_buf[size - 1] * sw;
   18e84:	9a02      	ldr	r2, [sp, #8]
   18e86:	fb07 8808 	mla	r8, r7, r8, r8
   18e8a:	1e93      	subs	r3, r2, #2
   18e8c:	9302      	str	r3, [sp, #8]
   18e8e:	1c7b      	adds	r3, r7, #1
   18e90:	9306      	str	r3, [sp, #24]
   18e92:	44a8      	add	r8, r5
   18e94:	eb05 0349 	add.w	r3, r5, r9, lsl #1
            if(x - s_left - 1 < 0) left_val = sh_ups_tmp_buf[0];
   18e98:	9003      	str	r0, [sp, #12]
    for(y = 0; y < size; y++) {
   18e9a:	455c      	cmp	r4, fp
   18e9c:	f104 30ff 	add.w	r0, r4, #4294967295
   18ea0:	dc25      	bgt.n	18eee <shadow_blur_corner+0x9e>
        sh_ups_tmp_buf += size;
    }

    /*Vertical blur*/
    uint32_t i;
    sh_ups_buf[0] = sh_ups_buf[0] / sw;
   18ea2:	882b      	ldrh	r3, [r5, #0]
   18ea4:	9e01      	ldr	r6, [sp, #4]
    for(i = 1; i < (uint32_t)size * size; i++) {
   18ea6:	f04f 0e01 	mov.w	lr, #1
    sh_ups_buf[0] = sh_ups_buf[0] / sw;
   18eaa:	fb93 f3f6 	sdiv	r3, r3, r6
   18eae:	802b      	strh	r3, [r5, #0]
    for(i = 1; i < (uint32_t)size * size; i++) {
   18eb0:	462b      	mov	r3, r5
   18eb2:	fb04 f804 	mul.w	r8, r4, r4
   18eb6:	45f0      	cmp	r8, lr
   18eb8:	d845      	bhi.n	18f46 <shadow_blur_corner+0xf6>
        if(sh_ups_buf[i] == sh_ups_buf[i - 1]) sh_ups_buf[i] = sh_ups_buf[i - 1];
        else  sh_ups_buf[i] = sh_ups_buf[i] / sw;
    }

    for(x = 0; x < size; x++) {
   18eba:	f04f 0c00 	mov.w	ip, #0
            v -= top_val;

            /*Add the bottom pixel*/
            uint32_t bottom_val;
            if(y + s_left + 1 < size) bottom_val = sh_ups_buf[(y + s_left + 1) * size + x];
            else bottom_val = sh_ups_buf[(size - 1) * size + x];
   18ebe:	fb00 f304 	mul.w	r3, r0, r4
   18ec2:	0060      	lsls	r0, r4, #1
   18ec4:	9004      	str	r0, [sp, #16]
   18ec6:	fb04 f009 	mul.w	r0, r4, r9
   18eca:	fb07 4704 	mla	r7, r7, r4, r4
   18ece:	4240      	negs	r0, r0
   18ed0:	eb05 0e47 	add.w	lr, r5, r7, lsl #1
   18ed4:	1bc7      	subs	r7, r0, r7
   18ed6:	0078      	lsls	r0, r7, #1
   18ed8:	eb05 0343 	add.w	r3, r5, r3, lsl #1
   18edc:	9005      	str	r0, [sp, #20]
    for(x = 0; x < size; x++) {
   18ede:	4564      	cmp	r4, ip
   18ee0:	dc41      	bgt.n	18f66 <shadow_blur_corner+0x116>
        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {
            (*sh_ups_tmp_buf) = sh_ups_blur_buf[y];
        }
    }

    _lv_mem_buf_release(sh_ups_blur_buf);
   18ee2:	4608      	mov	r0, r1
}
   18ee4:	b009      	add	sp, #36	; 0x24
   18ee6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _lv_mem_buf_release(sh_ups_blur_buf);
   18eea:	f7f3 be69 	b.w	cbc0 <_lv_mem_buf_release>
        int32_t v = sh_ups_tmp_buf[size - 1] * sw;
   18eee:	9e02      	ldr	r6, [sp, #8]
   18ef0:	f83a c006 	ldrh.w	ip, [sl, r6]
   18ef4:	9e01      	ldr	r6, [sp, #4]
   18ef6:	fb06 fc0c 	mul.w	ip, r6, ip
            if(x + s_right < size) right_val = sh_ups_tmp_buf[x + s_right];
   18efa:	eb00 0e09 	add.w	lr, r0, r9
   18efe:	4574      	cmp	r4, lr
            uint32_t right_val = 0;
   18f00:	bfd8      	it	le
   18f02:	f04f 0e00 	movle.w	lr, #0
            sh_ups_blur_buf[x] = v;
   18f06:	f821 c010 	strh.w	ip, [r1, r0, lsl #1]
            if(x - s_left - 1 < 0) left_val = sh_ups_tmp_buf[0];
   18f0a:	9e03      	ldr	r6, [sp, #12]
            if(x + s_right < size) right_val = sh_ups_tmp_buf[x + s_right];
   18f0c:	bfc8      	it	gt
   18f0e:	f833 e010 	ldrhgt.w	lr, [r3, r0, lsl #1]
            if(x - s_left - 1 < 0) left_val = sh_ups_tmp_buf[0];
   18f12:	42c6      	cmn	r6, r0
            v -= right_val;
   18f14:	ebac 0c0e 	sub.w	ip, ip, lr
            if(x - s_left - 1 < 0) left_val = sh_ups_tmp_buf[0];
   18f18:	bf4c      	ite	mi
   18f1a:	f8ba e000 	ldrhmi.w	lr, [sl]
            else left_val = sh_ups_tmp_buf[x - s_left - 1];
   18f1e:	f838 e010 	ldrhpl.w	lr, [r8, r0, lsl #1]
        for(x = size - 1; x >= 0; x--) {
   18f22:	3801      	subs	r0, #1
            v += left_val;
   18f24:	44f4      	add	ip, lr
        for(x = size - 1; x >= 0; x--) {
   18f26:	d2e8      	bcs.n	18efa <shadow_blur_corner+0xaa>
        _lv_memcpy(sh_ups_tmp_buf, sh_ups_blur_buf, size * sizeof(uint16_t));
   18f28:	4650      	mov	r0, sl
   18f2a:	e9cd 1204 	strd	r1, r2, [sp, #16]
   18f2e:	9307      	str	r3, [sp, #28]
   18f30:	f7ff ff89 	bl	18e46 <_lv_memcpy>
        sh_ups_tmp_buf += size;
   18f34:	9a05      	ldr	r2, [sp, #20]
   18f36:	9b07      	ldr	r3, [sp, #28]
   18f38:	9904      	ldr	r1, [sp, #16]
   18f3a:	4492      	add	sl, r2
    for(y = 0; y < size; y++) {
   18f3c:	f10b 0b01 	add.w	fp, fp, #1
   18f40:	4490      	add	r8, r2
   18f42:	4413      	add	r3, r2
   18f44:	e7a9      	b.n	18e9a <shadow_blur_corner+0x4a>
        if(sh_ups_buf[i] == sh_ups_buf[i - 1]) sh_ups_buf[i] = sh_ups_buf[i - 1];
   18f46:	f8b3 c002 	ldrh.w	ip, [r3, #2]
   18f4a:	f833 ab02 	ldrh.w	sl, [r3], #2
    for(i = 1; i < (uint32_t)size * size; i++) {
   18f4e:	f10e 0e01 	add.w	lr, lr, #1
        if(sh_ups_buf[i] == sh_ups_buf[i - 1]) sh_ups_buf[i] = sh_ups_buf[i - 1];
   18f52:	45d4      	cmp	ip, sl
        else  sh_ups_buf[i] = sh_ups_buf[i] / sw;
   18f54:	bf1e      	ittt	ne
   18f56:	9e01      	ldrne	r6, [sp, #4]
   18f58:	fb9c fcf6 	sdivne	ip, ip, r6
   18f5c:	fa1f fa8c 	uxthne.w	sl, ip
   18f60:	f8a3 a000 	strh.w	sl, [r3]
    for(i = 1; i < (uint32_t)size * size; i++) {
   18f64:	e7a7      	b.n	18eb6 <shadow_blur_corner+0x66>
        sh_ups_tmp_buf = &sh_ups_buf[x];
   18f66:	eb05 084c 	add.w	r8, r5, ip, lsl #1
        int32_t v = sh_ups_tmp_buf[0] * sw;
   18f6a:	46c2      	mov	sl, r8
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
   18f6c:	2700      	movs	r7, #0
        int32_t v = sh_ups_tmp_buf[0] * sw;
   18f6e:	9e01      	ldr	r6, [sp, #4]
   18f70:	f835 001c 	ldrh.w	r0, [r5, ip, lsl #1]
   18f74:	4370      	muls	r0, r6
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
   18f76:	9e05      	ldr	r6, [sp, #20]
   18f78:	4476      	add	r6, lr
        int32_t v = sh_ups_tmp_buf[0] * sw;
   18f7a:	e9cd 6e02 	strd	r6, lr, [sp, #8]
            sh_ups_blur_buf[y] = v < 0 ? 0 : (v >> SHADOW_UPSACALE_SHIFT);
   18f7e:	2800      	cmp	r0, #0
   18f80:	bfb4      	ite	lt
   18f82:	f04f 0b00 	movlt.w	fp, #0
   18f86:	f3c0 1b8f 	ubfxge	fp, r0, #6, #16
   18f8a:	f821 b017 	strh.w	fp, [r1, r7, lsl #1]
            if(y - s_right <= 0) top_val = sh_ups_tmp_buf[0];
   18f8e:	eba7 0b09 	sub.w	fp, r7, r9
   18f92:	f1bb 0f00 	cmp.w	fp, #0
            else top_val = sh_ups_buf[(y - s_right) * size + x];
   18f96:	bfca      	itet	gt
   18f98:	9e02      	ldrgt	r6, [sp, #8]
            if(y - s_right <= 0) top_val = sh_ups_tmp_buf[0];
   18f9a:	f8ba b000 	ldrhle.w	fp, [sl]
            else top_val = sh_ups_buf[(y - s_right) * size + x];
   18f9e:	f8b6 b000 	ldrhgt.w	fp, [r6]
            v -= top_val;
   18fa2:	9e03      	ldr	r6, [sp, #12]
   18fa4:	eba0 0b0b 	sub.w	fp, r0, fp
            if(y + s_left + 1 < size) bottom_val = sh_ups_buf[(y + s_left + 1) * size + x];
   18fa8:	9806      	ldr	r0, [sp, #24]
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
   18faa:	4492      	add	sl, r2
            if(y + s_left + 1 < size) bottom_val = sh_ups_buf[(y + s_left + 1) * size + x];
   18fac:	1838      	adds	r0, r7, r0
   18fae:	4284      	cmp	r4, r0
   18fb0:	bfca      	itet	gt
   18fb2:	9803      	ldrgt	r0, [sp, #12]
            else bottom_val = sh_ups_buf[(size - 1) * size + x];
   18fb4:	8818      	ldrhle	r0, [r3, #0]
            if(y + s_left + 1 < size) bottom_val = sh_ups_buf[(y + s_left + 1) * size + x];
   18fb6:	8800      	ldrhgt	r0, [r0, #0]
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
   18fb8:	3701      	adds	r7, #1
            v += bottom_val;
   18fba:	4458      	add	r0, fp
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
   18fbc:	46b3      	mov	fp, r6
   18fbe:	9e04      	ldr	r6, [sp, #16]
   18fc0:	42bc      	cmp	r4, r7
   18fc2:	44b3      	add	fp, r6
   18fc4:	9e02      	ldr	r6, [sp, #8]
   18fc6:	f8cd b00c 	str.w	fp, [sp, #12]
   18fca:	46b3      	mov	fp, r6
   18fcc:	9e04      	ldr	r6, [sp, #16]
   18fce:	44b3      	add	fp, r6
   18fd0:	465e      	mov	r6, fp
   18fd2:	f8cd b008 	str.w	fp, [sp, #8]
   18fd6:	dcd2      	bgt.n	18f7e <shadow_blur_corner+0x12e>
        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {
   18fd8:	2000      	movs	r0, #0
            (*sh_ups_tmp_buf) = sh_ups_blur_buf[y];
   18fda:	f831 7010 	ldrh.w	r7, [r1, r0, lsl #1]
        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {
   18fde:	3001      	adds	r0, #1
   18fe0:	4284      	cmp	r4, r0
            (*sh_ups_tmp_buf) = sh_ups_blur_buf[y];
   18fe2:	f8a8 7000 	strh.w	r7, [r8]
        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {
   18fe6:	4490      	add	r8, r2
   18fe8:	dcf7      	bgt.n	18fda <shadow_blur_corner+0x18a>
    for(x = 0; x < size; x++) {
   18fea:	f10c 0c01 	add.w	ip, ip, #1
   18fee:	3302      	adds	r3, #2
   18ff0:	f10e 0e02 	add.w	lr, lr, #2
   18ff4:	e773      	b.n	18ede <shadow_blur_corner+0x8e>

00018ff6 <lv_draw_rect>:
{
   18ff6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   18ffa:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
   18ffe:	4614      	mov	r4, r2
   19000:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
   19004:	468a      	mov	sl, r1
   19006:	1c59      	adds	r1, r3, #1
   19008:	1a89      	subs	r1, r1, r2
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
   1900a:	b209      	sxth	r1, r1
{
   1900c:	b0ad      	sub	sp, #180	; 0xb4
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
   1900e:	2900      	cmp	r1, #0
{
   19010:	9005      	str	r0, [sp, #20]
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
   19012:	f340 87b8 	ble.w	19f86 <lv_draw_rect+0xf90>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19016:	f9b0 1004 	ldrsh.w	r1, [r0, #4]
   1901a:	f9b0 0000 	ldrsh.w	r0, [r0]
   1901e:	1c4d      	adds	r5, r1, #1
   19020:	1a2d      	subs	r5, r5, r0
   19022:	b22d      	sxth	r5, r5
   19024:	2d00      	cmp	r5, #0
   19026:	f340 87ae 	ble.w	19f86 <lv_draw_rect+0xf90>
    if(dsc->shadow_width == 0) return;
   1902a:	f9b4 6030 	ldrsh.w	r6, [r4, #48]	; 0x30
   1902e:	2e00      	cmp	r6, #0
   19030:	f000 857e 	beq.w	19b30 <lv_draw_rect+0xb3a>
    if(dsc->shadow_opa <= LV_OPA_MIN) return;
   19034:	f894 5038 	ldrb.w	r5, [r4, #56]	; 0x38
   19038:	2d02      	cmp	r5, #2
   1903a:	950a      	str	r5, [sp, #40]	; 0x28
   1903c:	f240 8578 	bls.w	19b30 <lv_draw_rect+0xb3a>
    if(dsc->shadow_width == 1 && dsc->shadow_ofs_x == 0 &&
   19040:	6b27      	ldr	r7, [r4, #48]	; 0x30
   19042:	f9b4 5034 	ldrsh.w	r5, [r4, #52]	; 0x34
   19046:	2f01      	cmp	r7, #1
   19048:	f9b4 c036 	ldrsh.w	ip, [r4, #54]	; 0x36
   1904c:	d104      	bne.n	19058 <lv_draw_rect+0x62>
   1904e:	b91d      	cbnz	r5, 19058 <lv_draw_rect+0x62>
       dsc->shadow_ofs_y == 0 && dsc->shadow_spread <= 0) {
   19050:	f1bc 0f00 	cmp.w	ip, #0
   19054:	f340 856c 	ble.w	19b30 <lv_draw_rect+0xb3a>
    sh_rect_area.x1 = coords->x1  + dsc->shadow_ofs_x - dsc->shadow_spread;
   19058:	f9b4 7032 	ldrsh.w	r7, [r4, #50]	; 0x32
   1905c:	eba7 0e0c 	sub.w	lr, r7, ip
    sh_rect_area.x2 = coords->x2  + dsc->shadow_ofs_x + dsc->shadow_spread;
   19060:	4467      	add	r7, ip
   19062:	4439      	add	r1, r7
    sh_rect_area.y1 = coords->y1  + dsc->shadow_ofs_y - dsc->shadow_spread;
   19064:	eba5 070c 	sub.w	r7, r5, ip
    sh_rect_area.y2 = coords->y2  + dsc->shadow_ofs_y + dsc->shadow_spread;
   19068:	4465      	add	r5, ip
   1906a:	441d      	add	r5, r3
    sh_area.x1 = sh_rect_area.x1 - sw / 2 - 1;
   1906c:	eb06 73d6 	add.w	r3, r6, r6, lsr #31
    sh_rect_area.y1 = coords->y1  + dsc->shadow_ofs_y - dsc->shadow_spread;
   19070:	443a      	add	r2, r7
   19072:	ea6f 0763 	mvn.w	r7, r3, asr #1
    sh_area.x2 = sh_rect_area.x2 + sw / 2 + 1;
   19076:	105b      	asrs	r3, r3, #1
    sh_rect_area.y2 = coords->y2  + dsc->shadow_ofs_y + dsc->shadow_spread;
   19078:	b22d      	sxth	r5, r5
    sh_rect_area.x2 = coords->x2  + dsc->shadow_ofs_x + dsc->shadow_spread;
   1907a:	b209      	sxth	r1, r1
   1907c:	3301      	adds	r3, #1
   1907e:	f8ad 104c 	strh.w	r1, [sp, #76]	; 0x4c
    sh_area.x2 = sh_rect_area.x2 + sw / 2 + 1;
   19082:	fa01 f183 	sxtah	r1, r1, r3
    sh_area.y2 = sh_rect_area.y2 + sw / 2 + 1;
   19086:	fa05 f383 	sxtah	r3, r5, r3
   1908a:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   1908e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    sh_rect_area.x1 = coords->x1  + dsc->shadow_ofs_x - dsc->shadow_spread;
   19090:	4470      	add	r0, lr
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   19092:	2bfe      	cmp	r3, #254	; 0xfe
   19094:	bf28      	it	cs
   19096:	23ff      	movcs	r3, #255	; 0xff
    sh_rect_area.x1 = coords->x1  + dsc->shadow_ofs_x - dsc->shadow_spread;
   19098:	b200      	sxth	r0, r0
    sh_rect_area.y1 = coords->y1  + dsc->shadow_ofs_y - dsc->shadow_spread;
   1909a:	b212      	sxth	r2, r2
    sh_rect_area.x1 = coords->x1  + dsc->shadow_ofs_x - dsc->shadow_spread;
   1909c:	f8ad 0048 	strh.w	r0, [sp, #72]	; 0x48
    sh_rect_area.y1 = coords->y1  + dsc->shadow_ofs_y - dsc->shadow_spread;
   190a0:	f8ad 204a 	strh.w	r2, [sp, #74]	; 0x4a
    sh_area.x1 = sh_rect_area.x1 - sw / 2 - 1;
   190a4:	4438      	add	r0, r7
    sh_area.y1 = sh_rect_area.y1 - sw / 2 - 1;
   190a6:	443a      	add	r2, r7
    sh_area.x2 = sh_rect_area.x2 + sw / 2 + 1;
   190a8:	f8ad 1054 	strh.w	r1, [sp, #84]	; 0x54
    sh_area.y1 = sh_rect_area.y1 - sw / 2 - 1;
   190ac:	f8ad 2052 	strh.w	r2, [sp, #82]	; 0x52
    sh_rect_area.y2 = coords->y2  + dsc->shadow_ofs_y + dsc->shadow_spread;
   190b0:	f8ad 504e 	strh.w	r5, [sp, #78]	; 0x4e
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   190b4:	930a      	str	r3, [sp, #40]	; 0x28
    sh_area.x1 = sh_rect_area.x1 - sw / 2 - 1;
   190b6:	f8ad 0050 	strh.w	r0, [sp, #80]	; 0x50
    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   190ba:	f7f1 fab1 	bl	a620 <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   190be:	f001 fd01 	bl	1aac4 <lv_disp_get_buf>
    is_common = _lv_area_intersect(&draw_area, &sh_area, clip);
   190c2:	4652      	mov	r2, sl
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   190c4:	4605      	mov	r5, r0
    is_common = _lv_area_intersect(&draw_area, &sh_area, clip);
   190c6:	a914      	add	r1, sp, #80	; 0x50
   190c8:	a816      	add	r0, sp, #88	; 0x58
   190ca:	f001 fde7 	bl	1ac9c <_lv_area_intersect>
    if(is_common == false) return;
   190ce:	2800      	cmp	r0, #0
   190d0:	f000 852e 	beq.w	19b30 <lv_draw_rect+0xb3a>
    draw_area.x1 -= disp_area->x1;
   190d4:	f9b5 7010 	ldrsh.w	r7, [r5, #16]
   190d8:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    draw_area.y1 -= disp_area->y1;
   190dc:	f9b5 0012 	ldrsh.w	r0, [r5, #18]
    draw_area.x1 -= disp_area->x1;
   190e0:	1bdb      	subs	r3, r3, r7
    draw_area.y1 -= disp_area->y1;
   190e2:	f8bd 105a 	ldrh.w	r1, [sp, #90]	; 0x5a
    draw_area.x2 -= disp_area->x1;
   190e6:	f8bd 205c 	ldrh.w	r2, [sp, #92]	; 0x5c
    draw_area.x1 -= disp_area->x1;
   190ea:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
    draw_area.y2 -= disp_area->y1;
   190ee:	f8bd 305e 	ldrh.w	r3, [sp, #94]	; 0x5e
    draw_area.y1 -= disp_area->y1;
   190f2:	1a09      	subs	r1, r1, r0
    draw_area.x2 -= disp_area->x1;
   190f4:	1bd2      	subs	r2, r2, r7
    draw_area.y2 -= disp_area->y1;
   190f6:	1a1b      	subs	r3, r3, r0
    draw_area.y1 -= disp_area->y1;
   190f8:	f8ad 105a 	strh.w	r1, [sp, #90]	; 0x5a
    lv_area_copy(&bg_coords, coords);
   190fc:	a818      	add	r0, sp, #96	; 0x60
   190fe:	9905      	ldr	r1, [sp, #20]
    draw_area.x2 -= disp_area->x1;
   19100:	f8ad 205c 	strh.w	r2, [sp, #92]	; 0x5c
    draw_area.y2 -= disp_area->y1;
   19104:	f8ad 305e 	strh.w	r3, [sp, #94]	; 0x5e
    lv_area_copy(&bg_coords, coords);
   19108:	f7ff fe9f 	bl	18e4a <lv_area_copy>
    bg_coords.x1 += 1;
   1910c:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
    bg_coords.y1 += 1;
   19110:	f8bd 1062 	ldrh.w	r1, [sp, #98]	; 0x62
    bg_coords.x1 += 1;
   19114:	3301      	adds	r3, #1
   19116:	b21d      	sxth	r5, r3
    bg_coords.y1 += 1;
   19118:	3101      	adds	r1, #1
    bg_coords.x2 -= 1;
   1911a:	f9bd 3064 	ldrsh.w	r3, [sp, #100]	; 0x64
    bg_coords.y1 += 1;
   1911e:	b208      	sxth	r0, r1
    bg_coords.y2 -= 1;
   19120:	f9bd 1066 	ldrsh.w	r1, [sp, #102]	; 0x66
    bg_coords.x2 -= 1;
   19124:	1e5a      	subs	r2, r3, #1
   19126:	f8ad 2064 	strh.w	r2, [sp, #100]	; 0x64
   1912a:	1b5b      	subs	r3, r3, r5
    bg_coords.y2 -= 1;
   1912c:	1e4a      	subs	r2, r1, #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1912e:	1a09      	subs	r1, r1, r0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19130:	b21b      	sxth	r3, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19132:	b209      	sxth	r1, r1
    int32_t short_side = LV_MATH_MIN(lv_area_get_width(&bg_coords), lv_area_get_height(&bg_coords));
   19134:	428b      	cmp	r3, r1
   19136:	bfa8      	it	ge
   19138:	460b      	movge	r3, r1
    bg_coords.y2 -= 1;
   1913a:	f8ad 2066 	strh.w	r2, [sp, #102]	; 0x66
    int32_t r_bg = dsc->radius;
   1913e:	f9b4 2000 	ldrsh.w	r2, [r4]
    if(r_bg > short_side >> 1) r_bg = short_side >> 1;
   19142:	105b      	asrs	r3, r3, #1
   19144:	4293      	cmp	r3, r2
   19146:	bfa8      	it	ge
   19148:	4613      	movge	r3, r2
   1914a:	930e      	str	r3, [sp, #56]	; 0x38
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1914c:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
    bg_coords.x1 += 1;
   19150:	f8ad 5060 	strh.w	r5, [sp, #96]	; 0x60
   19154:	f8bd 5048 	ldrh.w	r5, [sp, #72]	; 0x48
   19158:	3301      	adds	r3, #1
   1915a:	1b5b      	subs	r3, r3, r5
   1915c:	b21d      	sxth	r5, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1915e:	f8bd 304e 	ldrh.w	r3, [sp, #78]	; 0x4e
   19162:	f8bd 104a 	ldrh.w	r1, [sp, #74]	; 0x4a
   19166:	3301      	adds	r3, #1
   19168:	1a5b      	subs	r3, r3, r1
   1916a:	b21b      	sxth	r3, r3
    short_side = LV_MATH_MIN(lv_area_get_width(&sh_rect_area), lv_area_get_height(&sh_rect_area));
   1916c:	42ab      	cmp	r3, r5
   1916e:	bfa8      	it	ge
   19170:	462b      	movge	r3, r5
    if(r_sh > short_side >> 1) r_sh = short_side >> 1;
   19172:	105d      	asrs	r5, r3, #1
   19174:	4295      	cmp	r5, r2
   19176:	bfa8      	it	ge
   19178:	4615      	movge	r5, r2
    int32_t corner_size = sw  + r_sh;
   1917a:	1973      	adds	r3, r6, r5
    bg_coords.y1 += 1;
   1917c:	f8ad 0062 	strh.w	r0, [sp, #98]	; 0x62
    sh_buf = _lv_mem_buf_get(corner_size * corner_size * sizeof(uint16_t));
   19180:	fb03 f003 	mul.w	r0, r3, r3
   19184:	0040      	lsls	r0, r0, #1
    int32_t corner_size = sw  + r_sh;
   19186:	9306      	str	r3, [sp, #24]
    sh_buf = _lv_mem_buf_get(corner_size * corner_size * sizeof(uint16_t));
   19188:	f7f3 fcb8 	bl	cafc <_lv_mem_buf_get>
    shadow_draw_corner_buf(&sh_rect_area, (uint16_t *)sh_buf, dsc->shadow_width, r_sh);
   1918c:	f9b4 6030 	ldrsh.w	r6, [r4, #48]	; 0x30
    sh_buf = _lv_mem_buf_get(corner_size * corner_size * sizeof(uint16_t));
   19190:	9008      	str	r0, [sp, #32]
    int32_t size = sw_ori  + r;
   19192:	19ab      	adds	r3, r5, r6
    lv_area_copy(&sh_area, coords);
   19194:	a912      	add	r1, sp, #72	; 0x48
   19196:	a81e      	add	r0, sp, #120	; 0x78
    int32_t size = sw_ori  + r;
   19198:	9307      	str	r3, [sp, #28]
    lv_area_copy(&sh_area, coords);
   1919a:	f7ff fe56 	bl	18e4a <lv_area_copy>
    sh_area.x2 = sw / 2 + r - 1  - ((sw & 1) ? 0 : 1);
   1919e:	eb06 71d6 	add.w	r1, r6, r6, lsr #31
   191a2:	f066 0301 	orn	r3, r6, #1
   191a6:	104a      	asrs	r2, r1, #1
   191a8:	eb03 0361 	add.w	r3, r3, r1, asr #1
    sh_area.x1 = sh_area.x2 - lv_area_get_width(coords);
   191ac:	f8bd 104c 	ldrh.w	r1, [sp, #76]	; 0x4c
   191b0:	f8bd 0048 	ldrh.w	r0, [sp, #72]	; 0x48
   191b4:	43c9      	mvns	r1, r1
    shadow_draw_corner_buf(&sh_rect_area, (uint16_t *)sh_buf, dsc->shadow_width, r_sh);
   191b6:	fa0f f885 	sxth.w	r8, r5
    sh_area.x2 = sw / 2 + r - 1  - ((sw & 1) ? 0 : 1);
   191ba:	4443      	add	r3, r8
    sh_area.x1 = sh_area.x2 - lv_area_get_width(coords);
   191bc:	4401      	add	r1, r0
    sh_area.x2 = sw / 2 + r - 1  - ((sw & 1) ? 0 : 1);
   191be:	b21b      	sxth	r3, r3
   191c0:	f8ad 307c 	strh.w	r3, [sp, #124]	; 0x7c
    sh_area.x1 = sh_area.x2 - lv_area_get_width(coords);
   191c4:	440b      	add	r3, r1
   191c6:	f8ad 3078 	strh.w	r3, [sp, #120]	; 0x78
   191ca:	f8bd 304e 	ldrh.w	r3, [sp, #78]	; 0x4e
   191ce:	f8bd 104a 	ldrh.w	r1, [sp, #74]	; 0x4a
    sh_area.y1 = sw / 2 + 1;
   191d2:	3201      	adds	r2, #1
   191d4:	3301      	adds	r3, #1
   191d6:	1a5b      	subs	r3, r3, r1
   191d8:	b212      	sxth	r2, r2
   191da:	f8ad 207a 	strh.w	r2, [sp, #122]	; 0x7a
    sh_area.y2 = sh_area.y1 + lv_area_get_height(coords);
   191de:	441a      	add	r2, r3
   191e0:	f8ad 207e 	strh.w	r2, [sp, #126]	; 0x7e
    lv_draw_mask_radius_init(&mask_param, &sh_area, r, false);
   191e4:	2300      	movs	r3, #0
   191e6:	4642      	mov	r2, r8
   191e8:	a91e      	add	r1, sp, #120	; 0x78
   191ea:	a825      	add	r0, sp, #148	; 0x94
   191ec:	f7f2 fe6c 	bl	bec8 <lv_draw_mask_radius_init>
    if(sw_ori == 1) sw = 1;
   191f0:	2e01      	cmp	r6, #1
    lv_opa_t * mask_line = _lv_mem_buf_get(size);
   191f2:	9807      	ldr	r0, [sp, #28]
    if(sw_ori == 1) sw = 1;
   191f4:	bf0c      	ite	eq
   191f6:	4637      	moveq	r7, r6
    else sw = sw_ori >> 1;
   191f8:	1077      	asrne	r7, r6, #1
    lv_opa_t * mask_line = _lv_mem_buf_get(size);
   191fa:	f7f3 fc7f 	bl	cafc <_lv_mem_buf_get>
            _lv_memset_00(sh_ups_tmp_buf, size * sizeof(sh_ups_tmp_buf[0]));
   191fe:	9b07      	ldr	r3, [sp, #28]
    lv_opa_t * mask_line = _lv_mem_buf_get(size);
   19200:	4681      	mov	r9, r0
            _lv_memset_00(sh_ups_tmp_buf, size * sizeof(sh_ups_tmp_buf[0]));
   19202:	005b      	lsls	r3, r3, #1
   19204:	930b      	str	r3, [sp, #44]	; 0x2c
    for(y = 0; y < size; y++) {
   19206:	2300      	movs	r3, #0
   19208:	9309      	str	r3, [sp, #36]	; 0x24
        lv_draw_mask_res_t mask_res = mask_param.dsc.cb(mask_line, 0, y, size, &mask_param);
   1920a:	eb06 0308 	add.w	r3, r6, r8
   1920e:	b21b      	sxth	r3, r3
    sh_buf = _lv_mem_buf_get(corner_size * corner_size * sizeof(uint16_t));
   19210:	f8dd b020 	ldr.w	fp, [sp, #32]
        lv_draw_mask_res_t mask_res = mask_param.dsc.cb(mask_line, 0, y, size, &mask_param);
   19214:	930c      	str	r3, [sp, #48]	; 0x30
    for(y = 0; y < size; y++) {
   19216:	9b09      	ldr	r3, [sp, #36]	; 0x24
   19218:	9a07      	ldr	r2, [sp, #28]
   1921a:	429a      	cmp	r2, r3
   1921c:	dc0a      	bgt.n	19234 <lv_draw_rect+0x23e>
    _lv_mem_buf_release(mask_line);
   1921e:	4648      	mov	r0, r9
   19220:	f7f3 fcce 	bl	cbc0 <_lv_mem_buf_release>
    if(sw == 1) {
   19224:	9d07      	ldr	r5, [sp, #28]
   19226:	2f01      	cmp	r7, #1
   19228:	fb05 f505 	mul.w	r5, r5, r5
   1922c:	f040 81a8 	bne.w	19580 <lv_draw_rect+0x58a>
        for(i = 0; i < size * size; i++) {
   19230:	2300      	movs	r3, #0
   19232:	e03c      	b.n	192ae <lv_draw_rect+0x2b8>
        _lv_memset_ff(mask_line, size);
   19234:	4648      	mov	r0, r9
   19236:	9907      	ldr	r1, [sp, #28]
   19238:	f7ff fdff 	bl	18e3a <_lv_memset_ff>
        lv_draw_mask_res_t mask_res = mask_param.dsc.cb(mask_line, 0, y, size, &mask_param);
   1923c:	ab25      	add	r3, sp, #148	; 0x94
   1923e:	9300      	str	r3, [sp, #0]
   19240:	2100      	movs	r1, #0
   19242:	4648      	mov	r0, r9
   19244:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   19246:	f9bd 2024 	ldrsh.w	r2, [sp, #36]	; 0x24
   1924a:	9d25      	ldr	r5, [sp, #148]	; 0x94
   1924c:	47a8      	blx	r5
        if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
   1924e:	b948      	cbnz	r0, 19264 <lv_draw_rect+0x26e>
            _lv_memset_00(sh_ups_tmp_buf, size * sizeof(sh_ups_tmp_buf[0]));
   19250:	4658      	mov	r0, fp
   19252:	990b      	ldr	r1, [sp, #44]	; 0x2c
   19254:	f7ff fded 	bl	18e32 <_lv_memset_00>
        sh_ups_tmp_buf += size;
   19258:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1925a:	449b      	add	fp, r3
    for(y = 0; y < size; y++) {
   1925c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1925e:	3301      	adds	r3, #1
   19260:	9309      	str	r3, [sp, #36]	; 0x24
   19262:	e7d8      	b.n	19216 <lv_draw_rect+0x220>
            sh_ups_tmp_buf[0] = (mask_line[0] << SHADOW_UPSACALE_SHIFT) / sw;
   19264:	f899 2000 	ldrb.w	r2, [r9]
   19268:	465b      	mov	r3, fp
   1926a:	0192      	lsls	r2, r2, #6
   1926c:	fb92 f2f7 	sdiv	r2, r2, r7
   19270:	4649      	mov	r1, r9
   19272:	f823 2b02 	strh.w	r2, [r3], #2
            for(i = 1; i < size; i++) {
   19276:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   19278:	eb02 000b 	add.w	r0, r2, fp
   1927c:	4298      	cmp	r0, r3
   1927e:	d0eb      	beq.n	19258 <lv_draw_rect+0x262>
                if(mask_line[i] == mask_line[i - 1]) sh_ups_tmp_buf[i] = sh_ups_tmp_buf[i - 1];
   19280:	468c      	mov	ip, r1
   19282:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   19286:	f89c c000 	ldrb.w	ip, [ip]
   1928a:	3302      	adds	r3, #2
   1928c:	4594      	cmp	ip, r2
                else  sh_ups_tmp_buf[i] = (mask_line[i] << SHADOW_UPSACALE_SHIFT) / sw;
   1928e:	bf1a      	itte	ne
   19290:	0192      	lslne	r2, r2, #6
   19292:	fb92 f2f7 	sdivne	r2, r2, r7
                if(mask_line[i] == mask_line[i - 1]) sh_ups_tmp_buf[i] = sh_ups_tmp_buf[i - 1];
   19296:	f833 2c04 	ldrheq.w	r2, [r3, #-4]
                else  sh_ups_tmp_buf[i] = (mask_line[i] << SHADOW_UPSACALE_SHIFT) / sw;
   1929a:	f823 2c02 	strh.w	r2, [r3, #-2]
            for(i = 1; i < size; i++) {
   1929e:	e7ed      	b.n	1927c <lv_draw_rect+0x286>
            res_buf[i] = (sh_buf[i] >> SHADOW_UPSACALE_SHIFT);
   192a0:	9a08      	ldr	r2, [sp, #32]
   192a2:	9908      	ldr	r1, [sp, #32]
   192a4:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
   192a8:	0992      	lsrs	r2, r2, #6
   192aa:	54ca      	strb	r2, [r1, r3]
        for(i = 0; i < size * size; i++) {
   192ac:	3301      	adds	r3, #1
   192ae:	42ab      	cmp	r3, r5
   192b0:	dbf6      	blt.n	192a0 <lv_draw_rect+0x2aa>
   192b2:	f8bd 3056 	ldrh.w	r3, [sp, #86]	; 0x56
    lv_coord_t h_half = sh_area.y1 + lv_area_get_height(&sh_area) / 2;
   192b6:	f9bd 2052 	ldrsh.w	r2, [sp, #82]	; 0x52
   192ba:	3301      	adds	r3, #1
   192bc:	1a9b      	subs	r3, r3, r2
   192be:	f3c3 31c0 	ubfx	r1, r3, #15, #1
   192c2:	fa01 f383 	sxtah	r3, r1, r3
   192c6:	eb02 0363 	add.w	r3, r2, r3, asr #1
   192ca:	b21b      	sxth	r3, r3
   192cc:	930c      	str	r3, [sp, #48]	; 0x30
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   192ce:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    lv_coord_t w_half = sh_area.x1 + lv_area_get_width(&sh_area) / 2;
   192d2:	f9bd 2050 	ldrsh.w	r2, [sp, #80]	; 0x50
   192d6:	3301      	adds	r3, #1
   192d8:	1a9b      	subs	r3, r3, r2
   192da:	f3c3 31c0 	ubfx	r1, r3, #15, #1
   192de:	fa01 f383 	sxtah	r3, r1, r3
   192e2:	eb02 0363 	add.w	r3, r2, r3, asr #1
   192e6:	b21b      	sxth	r3, r3
   192e8:	930d      	str	r3, [sp, #52]	; 0x34
    if(lv_draw_mask_get_cnt() > 0) simple_mode = false;
   192ea:	f7f2 fd5b 	bl	bda4 <lv_draw_mask_get_cnt>
   192ee:	4606      	mov	r6, r0
   192f0:	2800      	cmp	r0, #0
   192f2:	f040 8177 	bne.w	195e4 <lv_draw_rect+0x5ee>
    else if(dsc->shadow_ofs_x != 0 || dsc->shadow_ofs_y != 0) simple_mode = false;
   192f6:	f9b4 0032 	ldrsh.w	r0, [r4, #50]	; 0x32
   192fa:	2800      	cmp	r0, #0
   192fc:	f040 8174 	bne.w	195e8 <lv_draw_rect+0x5f2>
   19300:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
   19304:	2b00      	cmp	r3, #0
   19306:	f040 8171 	bne.w	195ec <lv_draw_rect+0x5f6>
    else if(dsc->shadow_spread != 0) simple_mode = false;
   1930a:	f9b4 6036 	ldrsh.w	r6, [r4, #54]	; 0x36
   1930e:	fab6 f386 	clz	r3, r6
   19312:	095b      	lsrs	r3, r3, #5
    if(lv_draw_mask_get_cnt() > 0) simple_mode = false;
   19314:	9309      	str	r3, [sp, #36]	; 0x24
   19316:	f8bd 0054 	ldrh.w	r0, [sp, #84]	; 0x54
   1931a:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   1931e:	3001      	adds	r0, #1
   19320:	1ac0      	subs	r0, r0, r3
    lv_opa_t * mask_buf = _lv_mem_buf_get(lv_area_get_width(&sh_area));
   19322:	b200      	sxth	r0, r0
   19324:	f7f3 fbea 	bl	cafc <_lv_mem_buf_get>
    lv_draw_mask_radius_init(&mask_rout_param, &bg_coords, r_bg, true);
   19328:	f9bd 3038 	ldrsh.w	r3, [sp, #56]	; 0x38
   1932c:	a918      	add	r1, sp, #96	; 0x60
   1932e:	930b      	str	r3, [sp, #44]	; 0x2c
   19330:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   19332:	2301      	movs	r3, #1
    lv_opa_t * mask_buf = _lv_mem_buf_get(lv_area_get_width(&sh_area));
   19334:	4605      	mov	r5, r0
    lv_draw_mask_radius_init(&mask_rout_param, &bg_coords, r_bg, true);
   19336:	a825      	add	r0, sp, #148	; 0x94
   19338:	f7f2 fdc6 	bl	bec8 <lv_draw_mask_radius_init>
    int16_t mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   1933c:	2100      	movs	r1, #0
   1933e:	a825      	add	r0, sp, #148	; 0x94
   19340:	f7f2 fcd2 	bl	bce8 <lv_draw_mask_add>
    a.x2 = sh_area.x2;
   19344:	f9bd 3054 	ldrsh.w	r3, [sp, #84]	; 0x54
    a.x1 = a.x2 - corner_size + 1;
   19348:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
    a.x2 = sh_area.x2;
   1934c:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.x1 = a.x2 - corner_size + 1;
   19350:	3301      	adds	r3, #1
   19352:	1a9b      	subs	r3, r3, r2
   19354:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.y1 = sh_area.y1;
   19358:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
    int16_t mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   1935c:	900e      	str	r0, [sp, #56]	; 0x38
    a.y1 = sh_area.y1;
   1935e:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    a.y2 = a.y1 + corner_size - 1;
   19362:	3b01      	subs	r3, #1
   19364:	4413      	add	r3, r2
    a.x1 = a.x2 - corner_size + 1;
   19366:	9207      	str	r2, [sp, #28]
    bool has_com = _lv_area_intersect(&ca, &a, clip);
   19368:	a91a      	add	r1, sp, #104	; 0x68
   1936a:	4652      	mov	r2, sl
   1936c:	a81c      	add	r0, sp, #112	; 0x70
    a.y2 = a.y1 + corner_size - 1;
   1936e:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
    bool has_com = _lv_area_intersect(&ca, &a, clip);
   19372:	f001 fc93 	bl	1ac9c <_lv_area_intersect>
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   19376:	2800      	cmp	r0, #0
   19378:	d045      	beq.n	19406 <lv_draw_rect+0x410>
   1937a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1937c:	a918      	add	r1, sp, #96	; 0x60
   1937e:	a81a      	add	r0, sp, #104	; 0x68
   19380:	f001 fd7f 	bl	1ae82 <_lv_area_is_in>
   19384:	2800      	cmp	r0, #0
   19386:	d13e      	bne.n	19406 <lv_draw_rect+0x410>
        if(ca.y2 > h_half) ca.y2 = h_half;
   19388:	f9bd 3076 	ldrsh.w	r3, [sp, #118]	; 0x76
   1938c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1938e:	f8bd 7074 	ldrh.w	r7, [sp, #116]	; 0x74
   19392:	4293      	cmp	r3, r2
   19394:	bfc8      	it	gt
   19396:	4613      	movgt	r3, r2
        if(ca.x1 <= w_half) ca.x1 = w_half + 1;
   19398:	9a0d      	ldr	r2, [sp, #52]	; 0x34
        if(ca.y2 > h_half) ca.y2 = h_half;
   1939a:	bfc8      	it	gt
   1939c:	f8ad 3076 	strhgt.w	r3, [sp, #118]	; 0x76
        if(ca.x1 <= w_half) ca.x1 = w_half + 1;
   193a0:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
   193a4:	3701      	adds	r7, #1
   193a6:	4293      	cmp	r3, r2
   193a8:	bfde      	ittt	le
   193aa:	4613      	movle	r3, r2
   193ac:	3301      	addle	r3, #1
   193ae:	f8ad 3070 	strhle.w	r3, [sp, #112]	; 0x70
   193b2:	f9bd 2070 	ldrsh.w	r2, [sp, #112]	; 0x70
   193b6:	1abf      	subs	r7, r7, r2
   193b8:	b23f      	sxth	r7, r7
        if(w > 0) {
   193ba:	2f00      	cmp	r7, #0
   193bc:	dd23      	ble.n	19406 <lv_draw_rect+0x410>
            for(y = 0; y < h; y++) {
   193be:	f04f 0900 	mov.w	r9, #0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   193c2:	f8bd b076 	ldrh.w	fp, [sp, #118]	; 0x76
   193c6:	f9bd 3072 	ldrsh.w	r3, [sp, #114]	; 0x72
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   193ca:	f9bd 606a 	ldrsh.w	r6, [sp, #106]	; 0x6a
   193ce:	f10b 0b01 	add.w	fp, fp, #1
   193d2:	ebab 0b03 	sub.w	fp, fp, r3
   193d6:	1b9e      	subs	r6, r3, r6
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
   193d8:	f9bd 3068 	ldrsh.w	r3, [sp, #104]	; 0x68
            lv_area_copy(&fa, &ca);
   193dc:	f10d 0878 	add.w	r8, sp, #120	; 0x78
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
   193e0:	1ad2      	subs	r2, r2, r3
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   193e2:	9b06      	ldr	r3, [sp, #24]
            lv_area_copy(&fa, &ca);
   193e4:	4640      	mov	r0, r8
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   193e6:	fb03 2606 	mla	r6, r3, r6, r2
   193ea:	9b08      	ldr	r3, [sp, #32]
            lv_area_copy(&fa, &ca);
   193ec:	a91c      	add	r1, sp, #112	; 0x70
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   193ee:	441e      	add	r6, r3
            lv_area_copy(&fa, &ca);
   193f0:	f7ff fd2b 	bl	18e4a <lv_area_copy>
            fa.y2 = fa.y1;
   193f4:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   193f8:	fa0f fb8b 	sxth.w	fp, fp
   193fc:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
            for(y = 0; y < h; y++) {
   19400:	45d9      	cmp	r9, fp
   19402:	f2c0 80f5 	blt.w	195f0 <lv_draw_rect+0x5fa>
    a.x2 = sh_area.x2;
   19406:	f9bd 3054 	ldrsh.w	r3, [sp, #84]	; 0x54
    a.x1 = a.x2 - corner_size + 1;
   1940a:	9a07      	ldr	r2, [sp, #28]
    a.x2 = sh_area.x2;
   1940c:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.x1 = a.x2 - corner_size + 1;
   19410:	3301      	adds	r3, #1
   19412:	1a9b      	subs	r3, r3, r2
    a.y1 = sh_area.y2 - corner_size + 1;
   19414:	f9bd 2056 	ldrsh.w	r2, [sp, #86]	; 0x56
   19418:	9907      	ldr	r1, [sp, #28]
    a.x1 = a.x2 - corner_size + 1;
   1941a:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.y1 = sh_area.y2 - corner_size + 1;
   1941e:	1c53      	adds	r3, r2, #1
   19420:	1a5b      	subs	r3, r3, r1
    a.y2 = sh_area.y2;
   19422:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
    has_com = _lv_area_intersect(&ca, &a, clip);
   19426:	a91a      	add	r1, sp, #104	; 0x68
   19428:	4652      	mov	r2, sl
   1942a:	a81c      	add	r0, sp, #112	; 0x70
    a.y1 = sh_area.y2 - corner_size + 1;
   1942c:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    has_com = _lv_area_intersect(&ca, &a, clip);
   19430:	f001 fc34 	bl	1ac9c <_lv_area_intersect>
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   19434:	2800      	cmp	r0, #0
   19436:	d046      	beq.n	194c6 <lv_draw_rect+0x4d0>
   19438:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1943a:	a918      	add	r1, sp, #96	; 0x60
   1943c:	a81a      	add	r0, sp, #104	; 0x68
   1943e:	f001 fd20 	bl	1ae82 <_lv_area_is_in>
   19442:	2800      	cmp	r0, #0
   19444:	d13f      	bne.n	194c6 <lv_draw_rect+0x4d0>
        if(ca.y1 <= h_half) ca.y1 = h_half + 1;
   19446:	f9bd 3072 	ldrsh.w	r3, [sp, #114]	; 0x72
   1944a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1944c:	f8bd 6074 	ldrh.w	r6, [sp, #116]	; 0x74
   19450:	4293      	cmp	r3, r2
   19452:	bfdc      	itt	le
   19454:	4613      	movle	r3, r2
   19456:	3301      	addle	r3, #1
        if(ca.x1 <= w_half) ca.x1 = w_half + 1;
   19458:	9a0d      	ldr	r2, [sp, #52]	; 0x34
        if(ca.y1 <= h_half) ca.y1 = h_half + 1;
   1945a:	bfd8      	it	le
   1945c:	f8ad 3072 	strhle.w	r3, [sp, #114]	; 0x72
        if(ca.x1 <= w_half) ca.x1 = w_half + 1;
   19460:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
   19464:	3601      	adds	r6, #1
   19466:	4293      	cmp	r3, r2
   19468:	bfde      	ittt	le
   1946a:	4613      	movle	r3, r2
   1946c:	3301      	addle	r3, #1
   1946e:	f8ad 3070 	strhle.w	r3, [sp, #112]	; 0x70
   19472:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
   19476:	1af6      	subs	r6, r6, r3
   19478:	b236      	sxth	r6, r6
        if(w > 0) {
   1947a:	2e00      	cmp	r6, #0
   1947c:	dd23      	ble.n	194c6 <lv_draw_rect+0x4d0>
            for(y = 0; y < h; y++) {
   1947e:	f04f 0900 	mov.w	r9, #0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19482:	f9bd 2076 	ldrsh.w	r2, [sp, #118]	; 0x76
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19486:	f9bd 706e 	ldrsh.w	r7, [sp, #110]	; 0x6e
   1948a:	f102 0b01 	add.w	fp, r2, #1
   1948e:	1abf      	subs	r7, r7, r2
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
   19490:	f9bd 2068 	ldrsh.w	r2, [sp, #104]	; 0x68
   19494:	f8bd 1072 	ldrh.w	r1, [sp, #114]	; 0x72
   19498:	1a9b      	subs	r3, r3, r2
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   1949a:	9a06      	ldr	r2, [sp, #24]
            lv_area_copy(&fa, &ca);
   1949c:	f10d 0878 	add.w	r8, sp, #120	; 0x78
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   194a0:	fb02 3707 	mla	r7, r2, r7, r3
   194a4:	9b08      	ldr	r3, [sp, #32]
   194a6:	ebab 0b01 	sub.w	fp, fp, r1
            lv_area_copy(&fa, &ca);
   194aa:	4640      	mov	r0, r8
   194ac:	a91c      	add	r1, sp, #112	; 0x70
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   194ae:	441f      	add	r7, r3
            lv_area_copy(&fa, &ca);
   194b0:	f7ff fccb 	bl	18e4a <lv_area_copy>
            fa.y1 = fa.y2;    /*Fill from bottom to top*/
   194b4:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   194b8:	fa0f fb8b 	sxth.w	fp, fp
   194bc:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
            for(y = 0; y < h; y++) {
   194c0:	45d9      	cmp	r9, fp
   194c2:	f2c0 80c0 	blt.w	19646 <lv_draw_rect+0x650>
    a.x2 = sh_area.x2;
   194c6:	f9bd 3054 	ldrsh.w	r3, [sp, #84]	; 0x54
    a.x1 = a.x2 - corner_size + 1;
   194ca:	9a07      	ldr	r2, [sp, #28]
    a.x2 = sh_area.x2;
   194cc:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.x1 = a.x2 - corner_size + 1;
   194d0:	3301      	adds	r3, #1
   194d2:	1a9b      	subs	r3, r3, r2
   194d4:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.y1 = sh_area.y1 + corner_size;
   194d8:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
    has_com = _lv_area_intersect(&ca, &a, clip);
   194dc:	a91a      	add	r1, sp, #104	; 0x68
    a.y1 = sh_area.y1 + corner_size;
   194de:	4413      	add	r3, r2
   194e0:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    a.y2 = sh_area.y2 - corner_size;
   194e4:	f8bd 3056 	ldrh.w	r3, [sp, #86]	; 0x56
    has_com = _lv_area_intersect(&ca, &a, clip);
   194e8:	a81c      	add	r0, sp, #112	; 0x70
    a.y2 = sh_area.y2 - corner_size;
   194ea:	1a9b      	subs	r3, r3, r2
    has_com = _lv_area_intersect(&ca, &a, clip);
   194ec:	4652      	mov	r2, sl
    a.y2 = sh_area.y2 - corner_size;
   194ee:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
    has_com = _lv_area_intersect(&ca, &a, clip);
   194f2:	f001 fbd3 	bl	1ac9c <_lv_area_intersect>
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   194f6:	2800      	cmp	r0, #0
   194f8:	d03d      	beq.n	19576 <lv_draw_rect+0x580>
   194fa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   194fc:	a918      	add	r1, sp, #96	; 0x60
   194fe:	a81a      	add	r0, sp, #104	; 0x68
   19500:	f001 fcbf 	bl	1ae82 <_lv_area_is_in>
   19504:	bbb8      	cbnz	r0, 19576 <lv_draw_rect+0x580>
        if(simple_mode) ca.x1 = LV_MATH_MAX(ca.x1, coords->x2);
   19506:	9b09      	ldr	r3, [sp, #36]	; 0x24
   19508:	b14b      	cbz	r3, 1951e <lv_draw_rect+0x528>
   1950a:	9b05      	ldr	r3, [sp, #20]
   1950c:	f9bd 2070 	ldrsh.w	r2, [sp, #112]	; 0x70
   19510:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
   19514:	4293      	cmp	r3, r2
   19516:	bfb8      	it	lt
   19518:	4613      	movlt	r3, r2
   1951a:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1951e:	f8bd 6074 	ldrh.w	r6, [sp, #116]	; 0x74
   19522:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
   19526:	3601      	adds	r6, #1
   19528:	1af6      	subs	r6, r6, r3
   1952a:	b236      	sxth	r6, r6
        if(w > 0) {
   1952c:	2e00      	cmp	r6, #0
   1952e:	dd22      	ble.n	19576 <lv_draw_rect+0x580>
            for(y = 0; y < h; y++) {
   19530:	f04f 0900 	mov.w	r9, #0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19534:	f8bd b076 	ldrh.w	fp, [sp, #118]	; 0x76
   19538:	f8bd 2072 	ldrh.w	r2, [sp, #114]	; 0x72
   1953c:	f10b 0b01 	add.w	fp, fp, #1
   19540:	ebab 0b02 	sub.w	fp, fp, r2
            sh_buf_tmp = sh_buf + corner_size * (corner_size - 1);
   19544:	9a06      	ldr	r2, [sp, #24]
            lv_area_copy(&fa, &ca);
   19546:	f10d 0878 	add.w	r8, sp, #120	; 0x78
            sh_buf_tmp = sh_buf + corner_size * (corner_size - 1);
   1954a:	1e57      	subs	r7, r2, #1
            sh_buf_tmp += ca.x1 - a.x1;
   1954c:	f9bd 2068 	ldrsh.w	r2, [sp, #104]	; 0x68
            lv_area_copy(&fa, &ca);
   19550:	4640      	mov	r0, r8
            sh_buf_tmp += ca.x1 - a.x1;
   19552:	1a9b      	subs	r3, r3, r2
   19554:	9a06      	ldr	r2, [sp, #24]
            lv_area_copy(&fa, &ca);
   19556:	a91c      	add	r1, sp, #112	; 0x70
            sh_buf_tmp += ca.x1 - a.x1;
   19558:	fb02 3707 	mla	r7, r2, r7, r3
   1955c:	9b08      	ldr	r3, [sp, #32]
   1955e:	fa0f fb8b 	sxth.w	fp, fp
   19562:	441f      	add	r7, r3
            lv_area_copy(&fa, &ca);
   19564:	f7ff fc71 	bl	18e4a <lv_area_copy>
            fa.y2 = fa.y1;
   19568:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   1956c:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
            for(y = 0; y < h; y++) {
   19570:	45d9      	cmp	r9, fp
   19572:	f2c0 8093 	blt.w	1969c <lv_draw_rect+0x6a6>
        for(x = 0; x < corner_size / 2; x++) {
   19576:	9b06      	ldr	r3, [sp, #24]
   19578:	2000      	movs	r0, #0
    sh_buf = _lv_mem_buf_get(corner_size * corner_size * sizeof(uint16_t));
   1957a:	9a08      	ldr	r2, [sp, #32]
        for(x = 0; x < corner_size / 2; x++) {
   1957c:	105f      	asrs	r7, r3, #1
   1957e:	e0c8      	b.n	19712 <lv_draw_rect+0x71c>
    shadow_blur_corner(size, sw, sh_buf);
   19580:	44b0      	add	r8, r6
   19582:	fa0f f888 	sxth.w	r8, r8
   19586:	4639      	mov	r1, r7
   19588:	4640      	mov	r0, r8
   1958a:	9a08      	ldr	r2, [sp, #32]
   1958c:	f7ff fc60 	bl	18e50 <shadow_blur_corner>
    sw += sw_ori & 1;
   19590:	f006 0101 	and.w	r1, r6, #1
   19594:	4439      	add	r1, r7
    if(sw > 1) {
   19596:	2901      	cmp	r1, #1
   19598:	dd0d      	ble.n	195b6 <lv_draw_rect+0x5c0>
        sh_buf[0] = (sh_buf[0] << SHADOW_UPSACALE_SHIFT) / sw;
   1959a:	9b08      	ldr	r3, [sp, #32]
        for(i = 1; i < (uint32_t) size * size; i++) {
   1959c:	2001      	movs	r0, #1
        sh_buf[0] = (sh_buf[0] << SHADOW_UPSACALE_SHIFT) / sw;
   1959e:	881b      	ldrh	r3, [r3, #0]
   195a0:	9a08      	ldr	r2, [sp, #32]
   195a2:	019b      	lsls	r3, r3, #6
   195a4:	fbb3 f3f1 	udiv	r3, r3, r1
   195a8:	8013      	strh	r3, [r2, #0]
        for(i = 1; i < (uint32_t) size * size; i++) {
   195aa:	42a8      	cmp	r0, r5
   195ac:	d305      	bcc.n	195ba <lv_draw_rect+0x5c4>
        shadow_blur_corner(size, sw, sh_buf);
   195ae:	4640      	mov	r0, r8
   195b0:	9a08      	ldr	r2, [sp, #32]
   195b2:	f7ff fc4d 	bl	18e50 <shadow_blur_corner>
        for(i = 1; i < (uint32_t) size * size; i++) {
   195b6:	2300      	movs	r3, #0
   195b8:	e011      	b.n	195de <lv_draw_rect+0x5e8>
            if(sh_buf[i] == sh_buf[i - 1]) sh_buf[i] = sh_buf[i - 1];
   195ba:	8853      	ldrh	r3, [r2, #2]
   195bc:	f832 6b02 	ldrh.w	r6, [r2], #2
        for(i = 1; i < (uint32_t) size * size; i++) {
   195c0:	3001      	adds	r0, #1
            if(sh_buf[i] == sh_buf[i - 1]) sh_buf[i] = sh_buf[i - 1];
   195c2:	42b3      	cmp	r3, r6
            else  sh_buf[i] = (sh_buf[i] << SHADOW_UPSACALE_SHIFT) / sw;
   195c4:	bf1e      	ittt	ne
   195c6:	019b      	lslne	r3, r3, #6
   195c8:	fbb3 f3f1 	udivne	r3, r3, r1
   195cc:	b29e      	uxthne	r6, r3
   195ce:	8016      	strh	r6, [r2, #0]
        for(i = 1; i < (uint32_t) size * size; i++) {
   195d0:	e7eb      	b.n	195aa <lv_draw_rect+0x5b4>
        res_buf[x] = sh_buf[x];
   195d2:	9a08      	ldr	r2, [sp, #32]
   195d4:	9908      	ldr	r1, [sp, #32]
   195d6:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
   195da:	54ca      	strb	r2, [r1, r3]
    for(x = 0; x < size * size; x++) {
   195dc:	3301      	adds	r3, #1
   195de:	42ab      	cmp	r3, r5
   195e0:	dbf7      	blt.n	195d2 <lv_draw_rect+0x5dc>
   195e2:	e666      	b.n	192b2 <lv_draw_rect+0x2bc>
    if(lv_draw_mask_get_cnt() > 0) simple_mode = false;
   195e4:	2300      	movs	r3, #0
   195e6:	e695      	b.n	19314 <lv_draw_rect+0x31e>
   195e8:	9609      	str	r6, [sp, #36]	; 0x24
   195ea:	e694      	b.n	19316 <lv_draw_rect+0x320>
   195ec:	9009      	str	r0, [sp, #36]	; 0x24
   195ee:	e692      	b.n	19316 <lv_draw_rect+0x320>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
   195f0:	4631      	mov	r1, r6
   195f2:	463a      	mov	r2, r7
   195f4:	4628      	mov	r0, r5
   195f6:	f7ff fc26 	bl	18e46 <_lv_memcpy>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   195fa:	463b      	mov	r3, r7
   195fc:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   19600:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   19604:	4628      	mov	r0, r5
   19606:	f7f2 fb85 	bl	bd14 <lv_draw_mask_apply>
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   1960a:	2801      	cmp	r0, #1
   1960c:	bf08      	it	eq
   1960e:	2002      	moveq	r0, #2
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   19610:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   19614:	4641      	mov	r1, r8
   19616:	9302      	str	r3, [sp, #8]
   19618:	9b0a      	ldr	r3, [sp, #40]	; 0x28
            for(y = 0; y < h; y++) {
   1961a:	f109 0901 	add.w	r9, r9, #1
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   1961e:	e9cd 0300 	strd	r0, r3, [sp]
   19622:	462b      	mov	r3, r5
   19624:	4650      	mov	r0, sl
   19626:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   19628:	f7fd ffd8 	bl	175dc <_lv_blend_fill>
                fa.y1++;
   1962c:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   19630:	3301      	adds	r3, #1
   19632:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
                fa.y2++;
   19636:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   1963a:	3301      	adds	r3, #1
   1963c:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
                sh_buf_tmp += corner_size;
   19640:	9b06      	ldr	r3, [sp, #24]
   19642:	441e      	add	r6, r3
            for(y = 0; y < h; y++) {
   19644:	e6dc      	b.n	19400 <lv_draw_rect+0x40a>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
   19646:	4639      	mov	r1, r7
   19648:	4632      	mov	r2, r6
   1964a:	4628      	mov	r0, r5
   1964c:	f7ff fbfb 	bl	18e46 <_lv_memcpy>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   19650:	4633      	mov	r3, r6
   19652:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   19656:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   1965a:	4628      	mov	r0, r5
   1965c:	f7f2 fb5a 	bl	bd14 <lv_draw_mask_apply>
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   19660:	2801      	cmp	r0, #1
   19662:	bf08      	it	eq
   19664:	2002      	moveq	r0, #2
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   19666:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   1966a:	4641      	mov	r1, r8
   1966c:	9302      	str	r3, [sp, #8]
   1966e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
            for(y = 0; y < h; y++) {
   19670:	f109 0901 	add.w	r9, r9, #1
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   19674:	e9cd 0300 	strd	r0, r3, [sp]
   19678:	462b      	mov	r3, r5
   1967a:	4650      	mov	r0, sl
   1967c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1967e:	f7fd ffad 	bl	175dc <_lv_blend_fill>
                fa.y1--;
   19682:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   19686:	3b01      	subs	r3, #1
   19688:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
                fa.y2--;
   1968c:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   19690:	3b01      	subs	r3, #1
   19692:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
                sh_buf_tmp += corner_size;
   19696:	9b06      	ldr	r3, [sp, #24]
   19698:	441f      	add	r7, r3
            for(y = 0; y < h; y++) {
   1969a:	e711      	b.n	194c0 <lv_draw_rect+0x4ca>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
   1969c:	4632      	mov	r2, r6
   1969e:	4639      	mov	r1, r7
   196a0:	4628      	mov	r0, r5
   196a2:	f7ff fbd0 	bl	18e46 <_lv_memcpy>
                if(simple_mode) {
   196a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   196a8:	b94b      	cbnz	r3, 196be <lv_draw_rect+0x6c8>
                    mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   196aa:	4633      	mov	r3, r6
   196ac:	4628      	mov	r0, r5
   196ae:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   196b2:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   196b6:	f7f2 fb2d 	bl	bd14 <lv_draw_mask_apply>
                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   196ba:	2801      	cmp	r0, #1
   196bc:	d100      	bne.n	196c0 <lv_draw_rect+0x6ca>
   196be:	2002      	movs	r0, #2
                _lv_blend_fill(clip, &fa,
   196c0:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   196c4:	4641      	mov	r1, r8
   196c6:	9302      	str	r3, [sp, #8]
   196c8:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
            for(y = 0; y < h; y++) {
   196cc:	f109 0901 	add.w	r9, r9, #1
                _lv_blend_fill(clip, &fa,
   196d0:	e9cd 0300 	strd	r0, r3, [sp]
   196d4:	462b      	mov	r3, r5
   196d6:	4650      	mov	r0, sl
   196d8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   196da:	f7fd ff7f 	bl	175dc <_lv_blend_fill>
                fa.y1++;
   196de:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   196e2:	3301      	adds	r3, #1
   196e4:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
                fa.y2++;
   196e8:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   196ec:	3301      	adds	r3, #1
   196ee:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
            for(y = 0; y < h; y++) {
   196f2:	e73d      	b.n	19570 <lv_draw_rect+0x57a>
            lv_opa_t tmp = sh_buf_tmp[x];
   196f4:	f811 cf01 	ldrb.w	ip, [r1, #1]!
            sh_buf_tmp[x] = sh_buf_tmp[corner_size - x - 1];
   196f8:	f813 ed01 	ldrb.w	lr, [r3, #-1]!
   196fc:	f881 e000 	strb.w	lr, [r1]
            sh_buf_tmp[corner_size - x - 1] = tmp;
   19700:	f883 c000 	strb.w	ip, [r3]
        for(x = 0; x < corner_size / 2; x++) {
   19704:	eba6 0c03 	sub.w	ip, r6, r3
   19708:	4567      	cmp	r7, ip
   1970a:	dcf3      	bgt.n	196f4 <lv_draw_rect+0x6fe>
        sh_buf_tmp += corner_size;
   1970c:	9b06      	ldr	r3, [sp, #24]
    for(y = 0; y < corner_size; y++) {
   1970e:	3001      	adds	r0, #1
        sh_buf_tmp += corner_size;
   19710:	441a      	add	r2, r3
    for(y = 0; y < corner_size; y++) {
   19712:	9b06      	ldr	r3, [sp, #24]
   19714:	4283      	cmp	r3, r0
   19716:	dd03      	ble.n	19720 <lv_draw_rect+0x72a>
   19718:	18d6      	adds	r6, r2, r3
   1971a:	4633      	mov	r3, r6
   1971c:	1e51      	subs	r1, r2, #1
   1971e:	e7f1      	b.n	19704 <lv_draw_rect+0x70e>
    a.x1 = sh_area.x1;
   19720:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
    a.x2 = a.x1 + corner_size - 1;
   19724:	9a07      	ldr	r2, [sp, #28]
    a.x1 = sh_area.x1;
   19726:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.x2 = a.x1 + corner_size - 1;
   1972a:	3b01      	subs	r3, #1
   1972c:	4413      	add	r3, r2
   1972e:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.y1 = sh_area.y1;
   19732:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
    has_com = _lv_area_intersect(&ca, &a, clip);
   19736:	a91a      	add	r1, sp, #104	; 0x68
    a.y1 = sh_area.y1;
   19738:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    a.y2 = a.y1 + corner_size - 1;
   1973c:	3b01      	subs	r3, #1
   1973e:	4413      	add	r3, r2
    has_com = _lv_area_intersect(&ca, &a, clip);
   19740:	a81c      	add	r0, sp, #112	; 0x70
   19742:	4652      	mov	r2, sl
    a.y2 = a.y1 + corner_size - 1;
   19744:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
    has_com = _lv_area_intersect(&ca, &a, clip);
   19748:	f001 faa8 	bl	1ac9c <_lv_area_intersect>
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   1974c:	2800      	cmp	r0, #0
   1974e:	d044      	beq.n	197da <lv_draw_rect+0x7e4>
   19750:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   19752:	a918      	add	r1, sp, #96	; 0x60
   19754:	a81a      	add	r0, sp, #104	; 0x68
   19756:	f001 fb94 	bl	1ae82 <_lv_area_is_in>
   1975a:	2800      	cmp	r0, #0
   1975c:	d13d      	bne.n	197da <lv_draw_rect+0x7e4>
        if(ca.y2 > h_half) ca.y2 = h_half;
   1975e:	f9bd 3076 	ldrsh.w	r3, [sp, #118]	; 0x76
   19762:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   19764:	4293      	cmp	r3, r2
   19766:	bfc8      	it	gt
   19768:	4613      	movgt	r3, r2
        if(ca.x2 > w_half) ca.x2 = w_half;
   1976a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
        if(ca.y2 > h_half) ca.y2 = h_half;
   1976c:	bfc8      	it	gt
   1976e:	f8ad 3076 	strhgt.w	r3, [sp, #118]	; 0x76
        if(ca.x2 > w_half) ca.x2 = w_half;
   19772:	f9bd 3074 	ldrsh.w	r3, [sp, #116]	; 0x74
   19776:	4293      	cmp	r3, r2
   19778:	bfc4      	itt	gt
   1977a:	4613      	movgt	r3, r2
   1977c:	f8ad 3074 	strhgt.w	r3, [sp, #116]	; 0x74
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19780:	f8bd 7074 	ldrh.w	r7, [sp, #116]	; 0x74
   19784:	f9bd 2070 	ldrsh.w	r2, [sp, #112]	; 0x70
   19788:	3701      	adds	r7, #1
   1978a:	1abf      	subs	r7, r7, r2
   1978c:	b23f      	sxth	r7, r7
        if(w > 0) {
   1978e:	2f00      	cmp	r7, #0
   19790:	dd23      	ble.n	197da <lv_draw_rect+0x7e4>
            for(y = 0; y < h; y++) {
   19792:	f04f 0900 	mov.w	r9, #0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19796:	f8bd b076 	ldrh.w	fp, [sp, #118]	; 0x76
   1979a:	f9bd 3072 	ldrsh.w	r3, [sp, #114]	; 0x72
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   1979e:	f9bd 606a 	ldrsh.w	r6, [sp, #106]	; 0x6a
   197a2:	f10b 0b01 	add.w	fp, fp, #1
   197a6:	ebab 0b03 	sub.w	fp, fp, r3
   197aa:	1b9e      	subs	r6, r3, r6
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
   197ac:	f9bd 3068 	ldrsh.w	r3, [sp, #104]	; 0x68
            lv_area_copy(&fa, &ca);
   197b0:	f10d 0878 	add.w	r8, sp, #120	; 0x78
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
   197b4:	1ad2      	subs	r2, r2, r3
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   197b6:	9b06      	ldr	r3, [sp, #24]
            lv_area_copy(&fa, &ca);
   197b8:	4640      	mov	r0, r8
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   197ba:	fb03 2606 	mla	r6, r3, r6, r2
   197be:	9b08      	ldr	r3, [sp, #32]
            lv_area_copy(&fa, &ca);
   197c0:	a91c      	add	r1, sp, #112	; 0x70
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   197c2:	441e      	add	r6, r3
            lv_area_copy(&fa, &ca);
   197c4:	f7ff fb41 	bl	18e4a <lv_area_copy>
            fa.y2 = fa.y1;
   197c8:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   197cc:	fa0f fb8b 	sxth.w	fp, fp
   197d0:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
            for(y = 0; y < h; y++) {
   197d4:	45d9      	cmp	r9, fp
   197d6:	f2c0 83d9 	blt.w	19f8c <lv_draw_rect+0xf96>
    a.x1 = sh_area.x1;
   197da:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
    a.x2 = a.x1 + corner_size - 1;
   197de:	9a07      	ldr	r2, [sp, #28]
    a.x1 = sh_area.x1;
   197e0:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.x2 = a.x1 + corner_size - 1;
   197e4:	3b01      	subs	r3, #1
   197e6:	4413      	add	r3, r2
    a.y1 = sh_area.y2 - corner_size + 1;
   197e8:	f9bd 2056 	ldrsh.w	r2, [sp, #86]	; 0x56
   197ec:	9907      	ldr	r1, [sp, #28]
    a.x2 = a.x1 + corner_size - 1;
   197ee:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.y1 = sh_area.y2 - corner_size + 1;
   197f2:	1c53      	adds	r3, r2, #1
   197f4:	1a5b      	subs	r3, r3, r1
    a.y2 = sh_area.y2;
   197f6:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
    has_com = _lv_area_intersect(&ca, &a, clip);
   197fa:	a91a      	add	r1, sp, #104	; 0x68
   197fc:	4652      	mov	r2, sl
   197fe:	a81c      	add	r0, sp, #112	; 0x70
    a.y1 = sh_area.y2 - corner_size + 1;
   19800:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    has_com = _lv_area_intersect(&ca, &a, clip);
   19804:	f001 fa4a 	bl	1ac9c <_lv_area_intersect>
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   19808:	2800      	cmp	r0, #0
   1980a:	d045      	beq.n	19898 <lv_draw_rect+0x8a2>
   1980c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1980e:	a918      	add	r1, sp, #96	; 0x60
   19810:	a81a      	add	r0, sp, #104	; 0x68
   19812:	f001 fb36 	bl	1ae82 <_lv_area_is_in>
   19816:	2800      	cmp	r0, #0
   19818:	d13e      	bne.n	19898 <lv_draw_rect+0x8a2>
        if(ca.y1 <= h_half) ca.y1 = h_half + 1;
   1981a:	f9bd 3072 	ldrsh.w	r3, [sp, #114]	; 0x72
   1981e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   19820:	4293      	cmp	r3, r2
   19822:	bfdc      	itt	le
   19824:	4613      	movle	r3, r2
   19826:	3301      	addle	r3, #1
        if(ca.x2 > w_half) ca.x2 = w_half;
   19828:	9a0d      	ldr	r2, [sp, #52]	; 0x34
        if(ca.y1 <= h_half) ca.y1 = h_half + 1;
   1982a:	bfd8      	it	le
   1982c:	f8ad 3072 	strhle.w	r3, [sp, #114]	; 0x72
        if(ca.x2 > w_half) ca.x2 = w_half;
   19830:	f9bd 3074 	ldrsh.w	r3, [sp, #116]	; 0x74
   19834:	4293      	cmp	r3, r2
   19836:	bfc4      	itt	gt
   19838:	4613      	movgt	r3, r2
   1983a:	f8ad 3074 	strhgt.w	r3, [sp, #116]	; 0x74
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1983e:	f8bd 6074 	ldrh.w	r6, [sp, #116]	; 0x74
   19842:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
   19846:	3601      	adds	r6, #1
   19848:	1af6      	subs	r6, r6, r3
   1984a:	b236      	sxth	r6, r6
        if(w > 0) {
   1984c:	2e00      	cmp	r6, #0
   1984e:	dd23      	ble.n	19898 <lv_draw_rect+0x8a2>
            for(y = 0; y < h; y++) {
   19850:	f04f 0900 	mov.w	r9, #0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19854:	f9bd 2076 	ldrsh.w	r2, [sp, #118]	; 0x76
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19858:	f9bd 706e 	ldrsh.w	r7, [sp, #110]	; 0x6e
   1985c:	f102 0b01 	add.w	fp, r2, #1
   19860:	1abf      	subs	r7, r7, r2
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
   19862:	f9bd 2068 	ldrsh.w	r2, [sp, #104]	; 0x68
   19866:	f8bd 1072 	ldrh.w	r1, [sp, #114]	; 0x72
   1986a:	1a9b      	subs	r3, r3, r2
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   1986c:	9a06      	ldr	r2, [sp, #24]
            lv_area_copy(&fa, &ca);
   1986e:	f10d 0878 	add.w	r8, sp, #120	; 0x78
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19872:	fb02 3707 	mla	r7, r2, r7, r3
   19876:	9b08      	ldr	r3, [sp, #32]
   19878:	ebab 0b01 	sub.w	fp, fp, r1
            lv_area_copy(&fa, &ca);
   1987c:	4640      	mov	r0, r8
   1987e:	a91c      	add	r1, sp, #112	; 0x70
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19880:	441f      	add	r7, r3
            lv_area_copy(&fa, &ca);
   19882:	f7ff fae2 	bl	18e4a <lv_area_copy>
            fa.y1 = fa.y2;    /*Fill from bottom to top*/
   19886:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   1988a:	fa0f fb8b 	sxth.w	fp, fp
   1988e:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
            for(y = 0; y < h; y++) {
   19892:	45d9      	cmp	r9, fp
   19894:	f2c0 83a6 	blt.w	19fe4 <lv_draw_rect+0xfee>
    a.x1 = sh_area.x1;
   19898:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
    a.x2 = a.x1 + corner_size - 1;
   1989c:	9a07      	ldr	r2, [sp, #28]
    a.x1 = sh_area.x1;
   1989e:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.x2 = a.x1 + corner_size - 1;
   198a2:	3b01      	subs	r3, #1
   198a4:	4413      	add	r3, r2
   198a6:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.y1 = sh_area.y1 + corner_size;
   198aa:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
    has_com = _lv_area_intersect(&ca, &a, clip);
   198ae:	a91a      	add	r1, sp, #104	; 0x68
    a.y1 = sh_area.y1 + corner_size;
   198b0:	4413      	add	r3, r2
   198b2:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    a.y2 = sh_area.y2 - corner_size;
   198b6:	f8bd 3056 	ldrh.w	r3, [sp, #86]	; 0x56
    has_com = _lv_area_intersect(&ca, &a, clip);
   198ba:	a81c      	add	r0, sp, #112	; 0x70
    a.y2 = sh_area.y2 - corner_size;
   198bc:	1a9b      	subs	r3, r3, r2
    has_com = _lv_area_intersect(&ca, &a, clip);
   198be:	4652      	mov	r2, sl
    a.y2 = sh_area.y2 - corner_size;
   198c0:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
    has_com = _lv_area_intersect(&ca, &a, clip);
   198c4:	f001 f9ea 	bl	1ac9c <_lv_area_intersect>
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   198c8:	2800      	cmp	r0, #0
   198ca:	d03d      	beq.n	19948 <lv_draw_rect+0x952>
   198cc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   198ce:	a918      	add	r1, sp, #96	; 0x60
   198d0:	a81a      	add	r0, sp, #104	; 0x68
   198d2:	f001 fad6 	bl	1ae82 <_lv_area_is_in>
   198d6:	bbb8      	cbnz	r0, 19948 <lv_draw_rect+0x952>
        if(simple_mode) ca.x2 = LV_MATH_MIN(coords->x1, ca.x2);
   198d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   198da:	b14b      	cbz	r3, 198f0 <lv_draw_rect+0x8fa>
   198dc:	9b05      	ldr	r3, [sp, #20]
   198de:	f9bd 2074 	ldrsh.w	r2, [sp, #116]	; 0x74
   198e2:	f9b3 3000 	ldrsh.w	r3, [r3]
   198e6:	4293      	cmp	r3, r2
   198e8:	bfa8      	it	ge
   198ea:	4613      	movge	r3, r2
   198ec:	f8ad 3074 	strh.w	r3, [sp, #116]	; 0x74
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   198f0:	f8bd 6074 	ldrh.w	r6, [sp, #116]	; 0x74
   198f4:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
   198f8:	3601      	adds	r6, #1
   198fa:	1af6      	subs	r6, r6, r3
   198fc:	b236      	sxth	r6, r6
        if(w > 0) {
   198fe:	2e00      	cmp	r6, #0
   19900:	dd22      	ble.n	19948 <lv_draw_rect+0x952>
            for(y = 0; y < h; y++) {
   19902:	f04f 0900 	mov.w	r9, #0
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19906:	f8bd b076 	ldrh.w	fp, [sp, #118]	; 0x76
   1990a:	f8bd 2072 	ldrh.w	r2, [sp, #114]	; 0x72
   1990e:	f10b 0b01 	add.w	fp, fp, #1
   19912:	ebab 0b02 	sub.w	fp, fp, r2
            sh_buf_tmp = sh_buf + corner_size * (corner_size - 1);
   19916:	9a06      	ldr	r2, [sp, #24]
            lv_area_copy(&fa, &ca);
   19918:	f10d 0878 	add.w	r8, sp, #120	; 0x78
            sh_buf_tmp = sh_buf + corner_size * (corner_size - 1);
   1991c:	1e57      	subs	r7, r2, #1
            sh_buf_tmp += ca.x1 - a.x1;
   1991e:	f9bd 2068 	ldrsh.w	r2, [sp, #104]	; 0x68
            lv_area_copy(&fa, &ca);
   19922:	4640      	mov	r0, r8
            sh_buf_tmp += ca.x1 - a.x1;
   19924:	1a9b      	subs	r3, r3, r2
   19926:	9a06      	ldr	r2, [sp, #24]
            lv_area_copy(&fa, &ca);
   19928:	a91c      	add	r1, sp, #112	; 0x70
            sh_buf_tmp += ca.x1 - a.x1;
   1992a:	fb02 3707 	mla	r7, r2, r7, r3
   1992e:	9b08      	ldr	r3, [sp, #32]
   19930:	fa0f fb8b 	sxth.w	fp, fp
   19934:	441f      	add	r7, r3
            lv_area_copy(&fa, &ca);
   19936:	f7ff fa88 	bl	18e4a <lv_area_copy>
            fa.y2 = fa.y1;
   1993a:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   1993e:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
            for(y = 0; y < h; y++) {
   19942:	45d9      	cmp	r9, fp
   19944:	f2c0 8379 	blt.w	1a03a <lv_draw_rect+0x1044>
    a.x1 = sh_area.x1 + corner_size;
   19948:	9a07      	ldr	r2, [sp, #28]
   1994a:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    has_com = _lv_area_intersect(&ca, &a, clip);
   1994e:	a91a      	add	r1, sp, #104	; 0x68
    a.x1 = sh_area.x1 + corner_size;
   19950:	4413      	add	r3, r2
   19952:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.x2 = sh_area.x2 - corner_size;
   19956:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    has_com = _lv_area_intersect(&ca, &a, clip);
   1995a:	a81c      	add	r0, sp, #112	; 0x70
    a.x2 = sh_area.x2 - corner_size;
   1995c:	1a9b      	subs	r3, r3, r2
   1995e:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.y1 = sh_area.y1;
   19962:	f9bd 3052 	ldrsh.w	r3, [sp, #82]	; 0x52
   19966:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    a.y2 = sh_area.y1 + corner_size - 1;
   1996a:	3b01      	subs	r3, #1
   1996c:	4413      	add	r3, r2
    has_com = _lv_area_intersect(&ca, &a, clip);
   1996e:	4652      	mov	r2, sl
    a.y2 = sh_area.y1 + corner_size - 1;
   19970:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
    has_com = _lv_area_intersect(&ca, &a, clip);
   19974:	f001 f992 	bl	1ac9c <_lv_area_intersect>
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   19978:	2800      	cmp	r0, #0
   1997a:	d039      	beq.n	199f0 <lv_draw_rect+0x9fa>
   1997c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1997e:	a918      	add	r1, sp, #96	; 0x60
   19980:	a81a      	add	r0, sp, #104	; 0x68
   19982:	f001 fa7e 	bl	1ae82 <_lv_area_is_in>
   19986:	bb98      	cbnz	r0, 199f0 <lv_draw_rect+0x9fa>
        if(simple_mode) ca.y2 = LV_MATH_MIN(ca.y2, coords->y1);
   19988:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1998a:	b14b      	cbz	r3, 199a0 <lv_draw_rect+0x9aa>
   1998c:	9b05      	ldr	r3, [sp, #20]
   1998e:	f9bd 2076 	ldrsh.w	r2, [sp, #118]	; 0x76
   19992:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
   19996:	4293      	cmp	r3, r2
   19998:	bfa8      	it	ge
   1999a:	4613      	movge	r3, r2
   1999c:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
        for(y = 0; y < h; y++) {
   199a0:	f04f 0900 	mov.w	r9, #0
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   199a4:	f8bd 7074 	ldrh.w	r7, [sp, #116]	; 0x74
   199a8:	f8bd 3070 	ldrh.w	r3, [sp, #112]	; 0x70
   199ac:	3701      	adds	r7, #1
   199ae:	1aff      	subs	r7, r7, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   199b0:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   199b4:	f9bd 6072 	ldrsh.w	r6, [sp, #114]	; 0x72
   199b8:	3301      	adds	r3, #1
   199ba:	1b9b      	subs	r3, r3, r6
   199bc:	fa0f fb83 	sxth.w	fp, r3
        sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   199c0:	f9bd 306a 	ldrsh.w	r3, [sp, #106]	; 0x6a
   199c4:	9a06      	ldr	r2, [sp, #24]
   199c6:	1af6      	subs	r6, r6, r3
        sh_buf_tmp = sh_buf + corner_size - 1;
   199c8:	9b06      	ldr	r3, [sp, #24]
        lv_area_copy(&fa, &ca);
   199ca:	f10d 0878 	add.w	r8, sp, #120	; 0x78
        sh_buf_tmp = sh_buf + corner_size - 1;
   199ce:	3b01      	subs	r3, #1
        sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   199d0:	fb02 3606 	mla	r6, r2, r6, r3
   199d4:	9b08      	ldr	r3, [sp, #32]
        lv_area_copy(&fa, &ca);
   199d6:	4640      	mov	r0, r8
   199d8:	a91c      	add	r1, sp, #112	; 0x70
        sh_buf_tmp += corner_size * (ca.y1 - a.y1);
   199da:	441e      	add	r6, r3
        lv_area_copy(&fa, &ca);
   199dc:	f7ff fa35 	bl	18e4a <lv_area_copy>
        fa.y2 = fa.y1;
   199e0:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   199e4:	b23f      	sxth	r7, r7
   199e6:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
        for(y = 0; y < h; y++) {
   199ea:	45d9      	cmp	r9, fp
   199ec:	f2c0 8351 	blt.w	1a092 <lv_draw_rect+0x109c>
    a.x1 = sh_area.x1 + corner_size;
   199f0:	9a07      	ldr	r2, [sp, #28]
   199f2:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    a.y1 = sh_area.y2 - corner_size + 1;
   199f6:	9907      	ldr	r1, [sp, #28]
    a.x1 = sh_area.x1 + corner_size;
   199f8:	4413      	add	r3, r2
   199fa:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.x2 = sh_area.x2 - corner_size;
   199fe:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    has_com = _lv_area_intersect(&ca, &a, clip);
   19a02:	a81c      	add	r0, sp, #112	; 0x70
    a.x2 = sh_area.x2 - corner_size;
   19a04:	1a9b      	subs	r3, r3, r2
    a.y1 = sh_area.y2 - corner_size + 1;
   19a06:	f9bd 2056 	ldrsh.w	r2, [sp, #86]	; 0x56
    a.x2 = sh_area.x2 - corner_size;
   19a0a:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.y1 = sh_area.y2 - corner_size + 1;
   19a0e:	1c53      	adds	r3, r2, #1
   19a10:	1a5b      	subs	r3, r3, r1
    a.y2 = sh_area.y2;
   19a12:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
    has_com = _lv_area_intersect(&ca, &a, clip);
   19a16:	a91a      	add	r1, sp, #104	; 0x68
   19a18:	4652      	mov	r2, sl
    a.y1 = sh_area.y2 - corner_size + 1;
   19a1a:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    has_com = _lv_area_intersect(&ca, &a, clip);
   19a1e:	f001 f93d 	bl	1ac9c <_lv_area_intersect>
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   19a22:	2800      	cmp	r0, #0
   19a24:	d039      	beq.n	19a9a <lv_draw_rect+0xaa4>
   19a26:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   19a28:	a918      	add	r1, sp, #96	; 0x60
   19a2a:	a81a      	add	r0, sp, #104	; 0x68
   19a2c:	f001 fa29 	bl	1ae82 <_lv_area_is_in>
   19a30:	bb98      	cbnz	r0, 19a9a <lv_draw_rect+0xaa4>
        if(simple_mode) ca.y1 = LV_MATH_MAX(ca.y1, coords->y2);
   19a32:	9b09      	ldr	r3, [sp, #36]	; 0x24
   19a34:	b14b      	cbz	r3, 19a4a <lv_draw_rect+0xa54>
   19a36:	9b05      	ldr	r3, [sp, #20]
   19a38:	f9bd 2072 	ldrsh.w	r2, [sp, #114]	; 0x72
   19a3c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
   19a40:	4293      	cmp	r3, r2
   19a42:	bfb8      	it	lt
   19a44:	4613      	movlt	r3, r2
   19a46:	f8ad 3072 	strh.w	r3, [sp, #114]	; 0x72
        for(y = 0; y < h; y++) {
   19a4a:	f04f 0900 	mov.w	r9, #0
   19a4e:	f8bd 7074 	ldrh.w	r7, [sp, #116]	; 0x74
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19a52:	f9bd 2076 	ldrsh.w	r2, [sp, #118]	; 0x76
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19a56:	f8bd 3070 	ldrh.w	r3, [sp, #112]	; 0x70
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19a5a:	f8bd 1072 	ldrh.w	r1, [sp, #114]	; 0x72
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19a5e:	3701      	adds	r7, #1
   19a60:	1aff      	subs	r7, r7, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19a62:	1c53      	adds	r3, r2, #1
   19a64:	1a5b      	subs	r3, r3, r1
        sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19a66:	f9bd 606e 	ldrsh.w	r6, [sp, #110]	; 0x6e
   19a6a:	fa0f fb83 	sxth.w	fp, r3
        sh_buf_tmp = sh_buf + corner_size - 1;
   19a6e:	9b06      	ldr	r3, [sp, #24]
        sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19a70:	1ab6      	subs	r6, r6, r2
   19a72:	9a06      	ldr	r2, [sp, #24]
        sh_buf_tmp = sh_buf + corner_size - 1;
   19a74:	3b01      	subs	r3, #1
        sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19a76:	fb02 3606 	mla	r6, r2, r6, r3
        lv_area_copy(&fa, &ca);
   19a7a:	f10d 0878 	add.w	r8, sp, #120	; 0x78
        sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19a7e:	9b08      	ldr	r3, [sp, #32]
        lv_area_copy(&fa, &ca);
   19a80:	4640      	mov	r0, r8
   19a82:	a91c      	add	r1, sp, #112	; 0x70
        sh_buf_tmp += corner_size * (a.y2 - ca.y2);
   19a84:	441e      	add	r6, r3
        lv_area_copy(&fa, &ca);
   19a86:	f7ff f9e0 	bl	18e4a <lv_area_copy>
        fa.y1 = fa.y2;
   19a8a:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19a8e:	b23f      	sxth	r7, r7
   19a90:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
        for(y = 0; y < h; y++) {
   19a94:	45d9      	cmp	r9, fp
   19a96:	f2c0 8333 	blt.w	1a100 <lv_draw_rect+0x110a>
    a.x1 = sh_area.x1 + corner_size;
   19a9a:	9a07      	ldr	r2, [sp, #28]
   19a9c:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
    has_com = _lv_area_intersect(&ca, &a, clip);
   19aa0:	a91a      	add	r1, sp, #104	; 0x68
    a.x1 = sh_area.x1 + corner_size;
   19aa2:	4413      	add	r3, r2
   19aa4:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    a.x2 = sh_area.x2 - corner_size;
   19aa8:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
    has_com = _lv_area_intersect(&ca, &a, clip);
   19aac:	a81c      	add	r0, sp, #112	; 0x70
    a.x2 = sh_area.x2 - corner_size;
   19aae:	1a9b      	subs	r3, r3, r2
   19ab0:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
    a.y1 = sh_area.y1 + corner_size;
   19ab4:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
   19ab8:	4413      	add	r3, r2
   19aba:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
    a.y2 = sh_area.y2 - corner_size;
   19abe:	f8bd 3056 	ldrh.w	r3, [sp, #86]	; 0x56
   19ac2:	1a9b      	subs	r3, r3, r2
    has_com = _lv_area_intersect(&ca, &a, clip);
   19ac4:	4652      	mov	r2, sl
    a.y2 = sh_area.y2 - corner_size;
   19ac6:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
    has_com = _lv_area_intersect(&ca, &a, clip);
   19aca:	f001 f8e7 	bl	1ac9c <_lv_area_intersect>
    if(has_com && simple_mode == false &&  _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
   19ace:	b330      	cbz	r0, 19b1e <lv_draw_rect+0xb28>
   19ad0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   19ad2:	bb23      	cbnz	r3, 19b1e <lv_draw_rect+0xb28>
   19ad4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   19ad6:	a918      	add	r1, sp, #96	; 0x60
   19ad8:	a81a      	add	r0, sp, #104	; 0x68
   19ada:	f001 f9d2 	bl	1ae82 <_lv_area_is_in>
   19ade:	b9f0      	cbnz	r0, 19b1e <lv_draw_rect+0xb28>
            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   19ae0:	f04f 09ff 	mov.w	r9, #255	; 0xff
   19ae4:	f8bd 7074 	ldrh.w	r7, [sp, #116]	; 0x74
   19ae8:	f8bd 3070 	ldrh.w	r3, [sp, #112]	; 0x70
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19aec:	f8bd 8076 	ldrh.w	r8, [sp, #118]	; 0x76
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19af0:	3701      	adds	r7, #1
   19af2:	1aff      	subs	r7, r7, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19af4:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
   19af8:	f108 0801 	add.w	r8, r8, #1
        lv_area_copy(&fa, &ca);
   19afc:	a91c      	add	r1, sp, #112	; 0x70
   19afe:	a81e      	add	r0, sp, #120	; 0x78
   19b00:	eba8 0803 	sub.w	r8, r8, r3
   19b04:	f7ff f9a1 	bl	18e4a <lv_area_copy>
        fa.y2 = fa.y1;
   19b08:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
        for(y = 0; y < h; y++) {
   19b0c:	9e09      	ldr	r6, [sp, #36]	; 0x24
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19b0e:	b23f      	sxth	r7, r7
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19b10:	fa0f f888 	sxth.w	r8, r8
        fa.y2 = fa.y1;
   19b14:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
        for(y = 0; y < h; y++) {
   19b18:	4546      	cmp	r6, r8
   19b1a:	f2c0 8328 	blt.w	1a16e <lv_draw_rect+0x1178>
    lv_draw_mask_remove_id(mask_rout_id);
   19b1e:	980e      	ldr	r0, [sp, #56]	; 0x38
   19b20:	f7f2 f91a 	bl	bd58 <lv_draw_mask_remove_id>
    _lv_mem_buf_release(mask_buf);
   19b24:	4628      	mov	r0, r5
   19b26:	f7f3 f84b 	bl	cbc0 <_lv_mem_buf_release>
    _lv_mem_buf_release(sh_buf);
   19b2a:	9808      	ldr	r0, [sp, #32]
   19b2c:	f7f3 f848 	bl	cbc0 <_lv_mem_buf_release>
    if(dsc->bg_opa <= LV_OPA_MIN) return;
   19b30:	7ca3      	ldrb	r3, [r4, #18]
   19b32:	2b02      	cmp	r3, #2
   19b34:	f240 80aa 	bls.w	19c8c <lv_draw_rect+0xc96>
    lv_area_copy(&coords_bg, coords);
   19b38:	9905      	ldr	r1, [sp, #20]
   19b3a:	a818      	add	r0, sp, #96	; 0x60
   19b3c:	f7ff f985 	bl	18e4a <lv_area_copy>
    if(dsc->border_width > 1 && dsc->border_opa >= LV_OPA_MAX && dsc->radius != 0) {
   19b40:	f9b4 3018 	ldrsh.w	r3, [r4, #24]
   19b44:	2b01      	cmp	r3, #1
   19b46:	dd24      	ble.n	19b92 <lv_draw_rect+0xb9c>
   19b48:	7f23      	ldrb	r3, [r4, #28]
   19b4a:	2bfc      	cmp	r3, #252	; 0xfc
   19b4c:	d921      	bls.n	19b92 <lv_draw_rect+0xb9c>
   19b4e:	f9b4 3000 	ldrsh.w	r3, [r4]
   19b52:	b1f3      	cbz	r3, 19b92 <lv_draw_rect+0xb9c>
        coords_bg.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;
   19b54:	8b63      	ldrh	r3, [r4, #26]
   19b56:	f8bd 0060 	ldrh.w	r0, [sp, #96]	; 0x60
   19b5a:	f3c3 0180 	ubfx	r1, r3, #2, #1
   19b5e:	4401      	add	r1, r0
        coords_bg.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;
   19b60:	f8bd 0062 	ldrh.w	r0, [sp, #98]	; 0x62
        coords_bg.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;
   19b64:	f8ad 1060 	strh.w	r1, [sp, #96]	; 0x60
        coords_bg.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;
   19b68:	f3c3 0140 	ubfx	r1, r3, #1, #1
   19b6c:	4401      	add	r1, r0
   19b6e:	f8ad 1062 	strh.w	r1, [sp, #98]	; 0x62
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
   19b72:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
   19b76:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   19b7a:	1acb      	subs	r3, r1, r3
        coords_bg.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;
   19b7c:	f9b4 201a 	ldrsh.w	r2, [r4, #26]
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
   19b80:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
        coords_bg.y2 -= (dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? 1 : 0;
   19b84:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
   19b88:	f002 0201 	and.w	r2, r2, #1
   19b8c:	1a9b      	subs	r3, r3, r2
   19b8e:	f8ad 3066 	strh.w	r3, [sp, #102]	; 0x66
    lv_opa_t opa = dsc->bg_opa;
   19b92:	f894 b012 	ldrb.w	fp, [r4, #18]
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   19b96:	f1bb 0ffe 	cmp.w	fp, #254	; 0xfe
   19b9a:	bf28      	it	cs
   19b9c:	f04f 0bff 	movcs.w	fp, #255	; 0xff
    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   19ba0:	f7f0 fd3e 	bl	a620 <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   19ba4:	f000 ff8e 	bl	1aac4 <lv_disp_get_buf>
    is_common = _lv_area_intersect(&draw_area, &coords_bg, clip);
   19ba8:	4652      	mov	r2, sl
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   19baa:	9006      	str	r0, [sp, #24]
    is_common = _lv_area_intersect(&draw_area, &coords_bg, clip);
   19bac:	a918      	add	r1, sp, #96	; 0x60
   19bae:	a81a      	add	r0, sp, #104	; 0x68
   19bb0:	f001 f874 	bl	1ac9c <_lv_area_intersect>
    if(is_common == false) return;
   19bb4:	2800      	cmp	r0, #0
   19bb6:	d069      	beq.n	19c8c <lv_draw_rect+0xc96>
    draw_area.x1 -= disp_area->x1;
   19bb8:	9b06      	ldr	r3, [sp, #24]
   19bba:	f9bd 0068 	ldrsh.w	r0, [sp, #104]	; 0x68
   19bbe:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
    draw_area.y1 -= disp_area->y1;
   19bc2:	f8bd 106a 	ldrh.w	r1, [sp, #106]	; 0x6a
    draw_area.x1 -= disp_area->x1;
   19bc6:	1a83      	subs	r3, r0, r2
   19bc8:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
    draw_area.y1 -= disp_area->y1;
   19bcc:	9b06      	ldr	r3, [sp, #24]
   19bce:	f9b3 5012 	ldrsh.w	r5, [r3, #18]
    draw_area.x2 -= disp_area->x1;
   19bd2:	f9bd 306c 	ldrsh.w	r3, [sp, #108]	; 0x6c
    draw_area.y1 -= disp_area->y1;
   19bd6:	1b49      	subs	r1, r1, r5
    draw_area.x2 -= disp_area->x1;
   19bd8:	1a9a      	subs	r2, r3, r2
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19bda:	3301      	adds	r3, #1
   19bdc:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
   19be0:	1a1b      	subs	r3, r3, r0
    draw_area.y2 -= disp_area->y1;
   19be2:	f8bd 206e 	ldrh.w	r2, [sp, #110]	; 0x6e
   19be6:	b21b      	sxth	r3, r3
   19be8:	1b52      	subs	r2, r2, r5
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   19bea:	4618      	mov	r0, r3
    draw_area.y1 -= disp_area->y1;
   19bec:	f8ad 106a 	strh.w	r1, [sp, #106]	; 0x6a
    draw_area.y2 -= disp_area->y1;
   19bf0:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
   19bf4:	9309      	str	r3, [sp, #36]	; 0x24
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   19bf6:	f7f2 ff81 	bl	cafc <_lv_mem_buf_get>
    if(dsc->bg_color.full == dsc->bg_grad_color.full) grad_dir = LV_GRAD_DIR_NONE;
   19bfa:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
    lv_grad_dir_t grad_dir = dsc->bg_grad_dir;
   19bfe:	7b26      	ldrb	r6, [r4, #12]
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   19c00:	4680      	mov	r8, r0
    if(dsc->bg_color.full == dsc->bg_grad_color.full) grad_dir = LV_GRAD_DIR_NONE;
   19c02:	429a      	cmp	r2, r3
   19c04:	bf08      	it	eq
   19c06:	2600      	moveq	r6, #0
    uint16_t other_mask_cnt = lv_draw_mask_get_cnt();
   19c08:	f7f2 f8cc 	bl	bda4 <lv_draw_mask_get_cnt>
   19c0c:	9010      	str	r0, [sp, #64]	; 0x40
   19c0e:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
   19c12:	9311      	str	r3, [sp, #68]	; 0x44
    if(other_mask_cnt) simple_mode = false;
   19c14:	2b00      	cmp	r3, #0
   19c16:	f040 82d2 	bne.w	1a1be <lv_draw_rect+0x11c8>
    else if(grad_dir == LV_GRAD_DIR_HOR) simple_mode = false;
   19c1a:	1eb3      	subs	r3, r6, #2
   19c1c:	bf18      	it	ne
   19c1e:	2301      	movne	r3, #1
   19c20:	f8bd 7064 	ldrh.w	r7, [sp, #100]	; 0x64
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19c24:	f8bd 5066 	ldrh.w	r5, [sp, #102]	; 0x66
    if(other_mask_cnt) simple_mode = false;
   19c28:	930a      	str	r3, [sp, #40]	; 0x28
   19c2a:	f8bd 2062 	ldrh.w	r2, [sp, #98]	; 0x62
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19c2e:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
   19c32:	3701      	adds	r7, #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19c34:	3501      	adds	r5, #1
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19c36:	1aff      	subs	r7, r7, r3
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19c38:	1aad      	subs	r5, r5, r2
    int32_t coords_h = lv_area_get_height(&coords_bg);
   19c3a:	b22d      	sxth	r5, r5
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19c3c:	b23f      	sxth	r7, r7
    int32_t short_side = LV_MATH_MIN(coords_w, coords_h);
   19c3e:	42bd      	cmp	r5, r7
   19c40:	bfa8      	it	ge
   19c42:	463d      	movge	r5, r7
    int32_t rout = dsc->radius;
   19c44:	f9b4 3000 	ldrsh.w	r3, [r4]
    if(rout > short_side >> 1) rout = short_side >> 1;
   19c48:	106d      	asrs	r5, r5, #1
   19c4a:	429d      	cmp	r5, r3
   19c4c:	bfa8      	it	ge
   19c4e:	461d      	movge	r5, r3
    if(simple_mode && rout == 0 && (grad_dir == LV_GRAD_DIR_NONE)) {
   19c50:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   19c52:	2b00      	cmp	r3, #0
   19c54:	f000 82b5 	beq.w	1a1c2 <lv_draw_rect+0x11cc>
   19c58:	2d00      	cmp	r5, #0
   19c5a:	f040 82b2 	bne.w	1a1c2 <lv_draw_rect+0x11cc>
   19c5e:	2e00      	cmp	r6, #0
   19c60:	f040 8352 	bne.w	1a308 <lv_draw_rect+0x1312>
        _lv_blend_fill(clip, &coords_bg,
   19c64:	7ce3      	ldrb	r3, [r4, #19]
   19c66:	4650      	mov	r0, sl
   19c68:	e9cd b301 	strd	fp, r3, [sp, #4]
   19c6c:	2301      	movs	r3, #1
   19c6e:	9300      	str	r3, [sp, #0]
   19c70:	6862      	ldr	r2, [r4, #4]
   19c72:	4633      	mov	r3, r6
   19c74:	a918      	add	r1, sp, #96	; 0x60
   19c76:	f7fd fcb1 	bl	175dc <_lv_blend_fill>
    int16_t mask_rout_id = LV_MASK_ID_INV;
   19c7a:	f04f 33ff 	mov.w	r3, #4294967295
   19c7e:	930d      	str	r3, [sp, #52]	; 0x34
    lv_draw_mask_remove_id(mask_rout_id);
   19c80:	980d      	ldr	r0, [sp, #52]	; 0x34
   19c82:	f7f2 f869 	bl	bd58 <lv_draw_mask_remove_id>
    _lv_mem_buf_release(mask_buf);
   19c86:	4640      	mov	r0, r8
   19c88:	f7f2 ff9a 	bl	cbc0 <_lv_mem_buf_release>
    if(dsc->border_opa <= LV_OPA_MIN) return;
   19c8c:	7f23      	ldrb	r3, [r4, #28]
   19c8e:	2b02      	cmp	r3, #2
   19c90:	f240 8179 	bls.w	19f86 <lv_draw_rect+0xf90>
    if(dsc->border_width == 0) return;
   19c94:	f9b4 3018 	ldrsh.w	r3, [r4, #24]
   19c98:	2b00      	cmp	r3, #0
   19c9a:	f000 8174 	beq.w	19f86 <lv_draw_rect+0xf90>
    if(dsc->border_side == LV_BORDER_SIDE_NONE) return;
   19c9e:	f9b4 301a 	ldrsh.w	r3, [r4, #26]
   19ca2:	2b00      	cmp	r3, #0
   19ca4:	f000 816f 	beq.w	19f86 <lv_draw_rect+0xf90>
    if(dsc->border_post) return;
   19ca8:	7fa3      	ldrb	r3, [r4, #30]
   19caa:	07d9      	lsls	r1, r3, #31
   19cac:	f100 816b 	bmi.w	19f86 <lv_draw_rect+0xf90>
   19cb0:	9b05      	ldr	r3, [sp, #20]
   19cb2:	9a05      	ldr	r2, [sp, #20]
   19cb4:	889b      	ldrh	r3, [r3, #4]
   19cb6:	8816      	ldrh	r6, [r2, #0]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19cb8:	9905      	ldr	r1, [sp, #20]
   19cba:	88d2      	ldrh	r2, [r2, #6]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19cbc:	3301      	adds	r3, #1
   19cbe:	1b9b      	subs	r3, r3, r6
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19cc0:	884e      	ldrh	r6, [r1, #2]
   19cc2:	3201      	adds	r2, #1
   19cc4:	1b92      	subs	r2, r2, r6
    int32_t coords_h = lv_area_get_height(coords);
   19cc6:	b216      	sxth	r6, r2
    int32_t coords_w = lv_area_get_width(coords);
   19cc8:	b21b      	sxth	r3, r3
    int32_t short_side = LV_MATH_MIN(coords_w, coords_h);
   19cca:	42b3      	cmp	r3, r6
   19ccc:	bfa8      	it	ge
   19cce:	4633      	movge	r3, r6
    int32_t rout = dsc->radius;
   19cd0:	f9b4 b000 	ldrsh.w	fp, [r4]
    if(rout > short_side >> 1) rout = short_side >> 1;
   19cd4:	105e      	asrs	r6, r3, #1
   19cd6:	45b3      	cmp	fp, r6
    lv_area_copy(&area_inner, coords);
   19cd8:	a816      	add	r0, sp, #88	; 0x58
   19cda:	bfa8      	it	ge
   19cdc:	46b3      	movge	fp, r6
   19cde:	f7ff f8b4 	bl	18e4a <lv_area_copy>
    area_inner.x1 += ((dsc->border_side & LV_BORDER_SIDE_LEFT) ? dsc->border_width : - (dsc->border_width + rout));
   19ce2:	8b60      	ldrh	r0, [r4, #26]
   19ce4:	f9b4 3018 	ldrsh.w	r3, [r4, #24]
   19ce8:	f010 0f04 	tst.w	r0, #4
   19cec:	bf14      	ite	ne
   19cee:	461a      	movne	r2, r3
   19cf0:	8b22      	ldrheq	r2, [r4, #24]
   19cf2:	f9bd 5058 	ldrsh.w	r5, [sp, #88]	; 0x58
   19cf6:	bf02      	ittt	eq
   19cf8:	445a      	addeq	r2, fp
   19cfa:	4252      	negeq	r2, r2
   19cfc:	b212      	sxtheq	r2, r2
   19cfe:	442a      	add	r2, r5
   19d00:	f8ad 2058 	strh.w	r2, [sp, #88]	; 0x58
    area_inner.x2 -= ((dsc->border_side & LV_BORDER_SIDE_RIGHT) ? dsc->border_width : - (dsc->border_width + rout));
   19d04:	0702      	lsls	r2, r0, #28
   19d06:	bf4c      	ite	mi
   19d08:	461a      	movmi	r2, r3
   19d0a:	eb03 020b 	addpl.w	r2, r3, fp
   19d0e:	f9bd 605c 	ldrsh.w	r6, [sp, #92]	; 0x5c
   19d12:	bf5c      	itt	pl
   19d14:	4252      	negpl	r2, r2
   19d16:	b212      	sxthpl	r2, r2
   19d18:	1ab2      	subs	r2, r6, r2
    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));
   19d1a:	0787      	lsls	r7, r0, #30
    area_inner.x2 -= ((dsc->border_side & LV_BORDER_SIDE_RIGHT) ? dsc->border_width : - (dsc->border_width + rout));
   19d1c:	f8ad 205c 	strh.w	r2, [sp, #92]	; 0x5c
    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));
   19d20:	bf48      	it	mi
   19d22:	461a      	movmi	r2, r3
   19d24:	461d      	mov	r5, r3
   19d26:	bf5c      	itt	pl
   19d28:	eb03 020b 	addpl.w	r2, r3, fp
   19d2c:	4252      	negpl	r2, r2
   19d2e:	f9bd 605a 	ldrsh.w	r6, [sp, #90]	; 0x5a
   19d32:	bf58      	it	pl
   19d34:	b212      	sxthpl	r2, r2
    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));
   19d36:	07c0      	lsls	r0, r0, #31
   19d38:	bf58      	it	pl
   19d3a:	445b      	addpl	r3, fp
    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));
   19d3c:	4432      	add	r2, r6
    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));
   19d3e:	bf58      	it	pl
   19d40:	425b      	negpl	r3, r3
    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));
   19d42:	f8ad 205a 	strh.w	r2, [sp, #90]	; 0x5a
    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));
   19d46:	f9bd 205e 	ldrsh.w	r2, [sp, #94]	; 0x5e
   19d4a:	bf58      	it	pl
   19d4c:	b21d      	sxthpl	r5, r3
   19d4e:	1b53      	subs	r3, r2, r5
    area_inner.x1 += ((dsc->border_side & LV_BORDER_SIDE_LEFT) ? dsc->border_width : - (dsc->border_width + rout));
   19d50:	f9b4 101a 	ldrsh.w	r1, [r4, #26]
    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));
   19d54:	f8ad 305e 	strh.w	r3, [sp, #94]	; 0x5e
    if(dsc->border_side == LV_BORDER_SIDE_FULL) {
   19d58:	7f23      	ldrb	r3, [r4, #28]
   19d5a:	290f      	cmp	r1, #15
   19d5c:	9306      	str	r3, [sp, #24]
   19d5e:	f040 84f9 	bne.w	1a754 <lv_draw_rect+0x175e>
        draw_full_border(&area_inner, coords, clip, dsc->radius, dsc->border_color, dsc->border_opa, dsc->border_blend_mode);
   19d62:	f9b4 3000 	ldrsh.w	r3, [r4]
   19d66:	6965      	ldr	r5, [r4, #20]
   19d68:	9309      	str	r3, [sp, #36]	; 0x24
   19d6a:	7f63      	ldrb	r3, [r4, #29]
   19d6c:	9307      	str	r3, [sp, #28]
#endif

static void draw_full_border(const lv_area_t * area_inner, const lv_area_t * area_outer, const lv_area_t * clip,
                             lv_coord_t radius, lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)
{
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
   19d6e:	f7f2 f819 	bl	bda4 <lv_draw_mask_get_cnt>
   19d72:	f9bd 305a 	ldrsh.w	r3, [sp, #90]	; 0x5a
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19d76:	f9bd 605c 	ldrsh.w	r6, [sp, #92]	; 0x5c
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19d7a:	930a      	str	r3, [sp, #40]	; 0x28
    bool simple_mode = true;
    if(other_mask_cnt) simple_mode = false;

    int32_t inner_w = lv_area_get_width(area_inner);
    int32_t inner_h = lv_area_get_height(area_inner);
    lv_coord_t border_width = area_outer->x2 - area_inner->x2;
   19d7c:	9b05      	ldr	r3, [sp, #20]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19d7e:	f9bd 8058 	ldrsh.w	r8, [sp, #88]	; 0x58
   19d82:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19d86:	f9bd 405e 	ldrsh.w	r4, [sp, #94]	; 0x5e
   19d8a:	930b      	str	r3, [sp, #44]	; 0x2c
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19d8c:	9b05      	ldr	r3, [sp, #20]
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
   19d8e:	900c      	str	r0, [sp, #48]	; 0x30
   19d90:	f9b3 9000 	ldrsh.w	r9, [r3]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19d94:	f9b3 7006 	ldrsh.w	r7, [r3, #6]
   19d98:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
   19d9c:	930e      	str	r3, [sp, #56]	; 0x38
    int32_t coords_out_w = lv_area_get_width(area_outer);
    int32_t coords_out_h = lv_area_get_height(area_outer);
    short_side = LV_MATH_MIN(coords_out_w, coords_out_h);
    if(rout > short_side >> 1) rout = short_side >> 1;

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   19d9e:	f7f0 fc3f 	bl	a620 <_lv_refr_get_disp_refreshing>
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   19da2:	f000 fe8f 	bl	1aac4 <lv_disp_get_buf>

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, area_outer, clip);
   19da6:	4652      	mov	r2, sl
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   19da8:	4683      	mov	fp, r0
    is_common = _lv_area_intersect(&draw_area, area_outer, clip);
   19daa:	9905      	ldr	r1, [sp, #20]
   19dac:	a818      	add	r0, sp, #96	; 0x60
   19dae:	f000 ff75 	bl	1ac9c <_lv_area_intersect>
    if(is_common == false) return;
   19db2:	2800      	cmp	r0, #0
   19db4:	f000 80e7 	beq.w	19f86 <lv_draw_rect+0xf90>
   19db8:	1c72      	adds	r2, r6, #1
   19dba:	b213      	sxth	r3, r2
   19dbc:	930d      	str	r3, [sp, #52]	; 0x34
    lv_coord_t border_width = area_outer->x2 - area_inner->x2;
   19dbe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   19dc0:	1c62      	adds	r2, r4, #1
   19dc2:	1b9e      	subs	r6, r3, r6
   19dc4:	b233      	sxth	r3, r6
   19dc6:	9308      	str	r3, [sp, #32]
   19dc8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   19dca:	3701      	adds	r7, #1
   19dcc:	1ad2      	subs	r2, r2, r3
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19dce:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    int32_t inner_h = lv_area_get_height(area_inner);
   19dd0:	b212      	sxth	r2, r2
   19dd2:	eba3 0808 	sub.w	r8, r3, r8
    int32_t inner_w = lv_area_get_width(area_inner);
   19dd6:	fa0f f888 	sxth.w	r8, r8
    int32_t short_side = LV_MATH_MIN(inner_w, inner_h);
   19dda:	4542      	cmp	r2, r8
   19ddc:	bfa8      	it	ge
   19dde:	4642      	movge	r2, r8
   19de0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    if(rin > short_side >> 1) rin = short_side >> 1;
   19de2:	1052      	asrs	r2, r2, #1
   19de4:	429a      	cmp	r2, r3
   19de6:	bfa8      	it	ge
   19de8:	461a      	movge	r2, r3
   19dea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    int32_t rout = rin + border_width;
   19dec:	fa02 f686 	sxtah	r6, r2, r6
   19df0:	1c59      	adds	r1, r3, #1
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19df2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19df4:	eba1 0909 	sub.w	r9, r1, r9
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   19df8:	1afb      	subs	r3, r7, r3
    int32_t coords_out_w = lv_area_get_width(area_outer);
   19dfa:	fa0f f989 	sxth.w	r9, r9
    int32_t coords_out_h = lv_area_get_height(area_outer);
   19dfe:	b21b      	sxth	r3, r3
    short_side = LV_MATH_MIN(coords_out_w, coords_out_h);
   19e00:	4599      	cmp	r9, r3
   19e02:	bfa8      	it	ge
   19e04:	4699      	movge	r9, r3
    if(rout > short_side >> 1) rout = short_side >> 1;
   19e06:	ea4f 0969 	mov.w	r9, r9, asr #1
   19e0a:	45b1      	cmp	r9, r6
   19e0c:	464b      	mov	r3, r9
   19e0e:	bfa8      	it	ge
   19e10:	4633      	movge	r3, r6

    const lv_area_t * disp_area = &vdb->area;

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
   19e12:	f9bd 1060 	ldrsh.w	r1, [sp, #96]	; 0x60
    draw_area.y1 -= disp_area->y1;
    draw_area.x2 -= disp_area->x1;
   19e16:	f9bd 6064 	ldrsh.w	r6, [sp, #100]	; 0x64
   19e1a:	9309      	str	r3, [sp, #36]	; 0x24
    draw_area.x1 -= disp_area->x1;
   19e1c:	f9bb 3010 	ldrsh.w	r3, [fp, #16]
    draw_area.y1 -= disp_area->y1;
   19e20:	f8bd 4062 	ldrh.w	r4, [sp, #98]	; 0x62
    draw_area.x1 -= disp_area->x1;
   19e24:	1ac8      	subs	r0, r1, r3
    draw_area.x2 -= disp_area->x1;
   19e26:	1af3      	subs	r3, r6, r3
    draw_area.x1 -= disp_area->x1;
   19e28:	f8ad 0060 	strh.w	r0, [sp, #96]	; 0x60
    draw_area.y1 -= disp_area->y1;
   19e2c:	f9bb 0012 	ldrsh.w	r0, [fp, #18]
    draw_area.x2 -= disp_area->x1;
   19e30:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
    draw_area.y2 -= disp_area->y1;
   19e34:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   19e38:	3601      	adds	r6, #1
   19e3a:	1a1b      	subs	r3, r3, r0
    draw_area.y1 -= disp_area->y1;
   19e3c:	1a24      	subs	r4, r4, r0

    int32_t draw_area_w = lv_area_get_width(&draw_area);

    /*Create inner the mask*/
    lv_draw_mask_radius_param_t mask_rin_param;
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
   19e3e:	b212      	sxth	r2, r2
    draw_area.y2 -= disp_area->y1;
   19e40:	f8ad 3066 	strh.w	r3, [sp, #102]	; 0x66
   19e44:	1a76      	subs	r6, r6, r1
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
   19e46:	2301      	movs	r3, #1
   19e48:	a916      	add	r1, sp, #88	; 0x58
   19e4a:	a81e      	add	r0, sp, #120	; 0x78
    draw_area.y1 -= disp_area->y1;
   19e4c:	f8ad 4062 	strh.w	r4, [sp, #98]	; 0x62
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
   19e50:	f7f2 f83a 	bl	bec8 <lv_draw_mask_radius_init>
    int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   19e54:	2100      	movs	r1, #0
   19e56:	a81e      	add	r0, sp, #120	; 0x78
   19e58:	f7f1 ff46 	bl	bce8 <lv_draw_mask_add>

    lv_draw_mask_radius_param_t mask_rout_param;
    lv_draw_mask_radius_init(&mask_rout_param, area_outer, rout, false);
   19e5c:	f9bd 9024 	ldrsh.w	r9, [sp, #36]	; 0x24
   19e60:	2300      	movs	r3, #0
   19e62:	464a      	mov	r2, r9
   19e64:	9905      	ldr	r1, [sp, #20]
    int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   19e66:	900e      	str	r0, [sp, #56]	; 0x38
    lv_draw_mask_radius_init(&mask_rout_param, area_outer, rout, false);
   19e68:	a825      	add	r0, sp, #148	; 0x94
   19e6a:	f7f2 f82d 	bl	bec8 <lv_draw_mask_radius_init>
    int16_t mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   19e6e:	2100      	movs	r1, #0
   19e70:	a825      	add	r0, sp, #148	; 0x94
   19e72:	f7f1 ff39 	bl	bce8 <lv_draw_mask_add>
   19e76:	b236      	sxth	r6, r6
   19e78:	900f      	str	r0, [sp, #60]	; 0x3c

    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   19e7a:	4630      	mov	r0, r6
   19e7c:	f7f2 fe3e 	bl	cafc <_lv_mem_buf_get>
    int32_t h;
    lv_draw_mask_res_t mask_res;
    lv_area_t fill_area;

    /*Apply some optimization if there is no other mask*/
    if(simple_mode) {
   19e80:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   19e82:	4604      	mov	r4, r0
    if(simple_mode) {
   19e84:	2b00      	cmp	r3, #0
   19e86:	f040 8425 	bne.w	1a6d4 <lv_draw_rect+0x16de>
    int32_t corner_size = LV_MATH_MAX(rout, border_width - 1);
   19e8a:	9b08      	ldr	r3, [sp, #32]
   19e8c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   19e8e:	3b01      	subs	r3, #1
   19e90:	4293      	cmp	r3, r2
   19e92:	bfb8      	it	lt
   19e94:	4613      	movlt	r3, r2
        /*Draw the upper corner area*/
        int32_t upper_corner_end = area_outer->y1 - disp_area->y1 + corner_size;
   19e96:	9a05      	ldr	r2, [sp, #20]
    int32_t corner_size = LV_MATH_MAX(rout, border_width - 1);
   19e98:	930a      	str	r3, [sp, #40]	; 0x28
        int32_t upper_corner_end = area_outer->y1 - disp_area->y1 + corner_size;
   19e9a:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
   19e9e:	990a      	ldr	r1, [sp, #40]	; 0x28
   19ea0:	f9bb 3012 	ldrsh.w	r3, [fp, #18]
   19ea4:	440a      	add	r2, r1
   19ea6:	eba2 0803 	sub.w	r8, r2, r3

        fill_area.x1 = area_outer->x1;
   19eaa:	9a05      	ldr	r2, [sp, #20]
        fill_area.x2 = area_outer->x2;
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   19eac:	f9bd 7062 	ldrsh.w	r7, [sp, #98]	; 0x62
        fill_area.x1 = area_outer->x1;
   19eb0:	8812      	ldrh	r2, [r2, #0]
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   19eb2:	443b      	add	r3, r7
        fill_area.x1 = area_outer->x1;
   19eb4:	f8ad 2068 	strh.w	r2, [sp, #104]	; 0x68
        fill_area.x2 = area_outer->x2;
   19eb8:	9a05      	ldr	r2, [sp, #20]
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   19eba:	b21b      	sxth	r3, r3
        fill_area.x2 = area_outer->x2;
   19ebc:	8892      	ldrh	r2, [r2, #4]
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   19ebe:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        fill_area.x2 = area_outer->x2;
   19ec2:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
        fill_area.y2 = fill_area.y1;
   19ec6:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        for(h = draw_area.y1; h <= upper_corner_end; h++) {
   19eca:	45b8      	cmp	r8, r7
   19ecc:	f280 8307 	bge.w	1a4de <lv_draw_rect+0x14e8>
            fill_area.y1++;
            fill_area.y2++;
        }

        /*Draw the lower corner area */
        int32_t lower_corner_end = area_outer->y2 - disp_area->y1 - corner_size;
   19ed0:	9a05      	ldr	r2, [sp, #20]
   19ed2:	f9bb 3012 	ldrsh.w	r3, [fp, #18]
   19ed6:	f9b2 7006 	ldrsh.w	r7, [r2, #6]
   19eda:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   19edc:	1abf      	subs	r7, r7, r2
   19ede:	1aff      	subs	r7, r7, r3
        if(lower_corner_end <= upper_corner_end) lower_corner_end = upper_corner_end + 1;
   19ee0:	45b8      	cmp	r8, r7
   19ee2:	bfa8      	it	ge
   19ee4:	f108 0701 	addge.w	r7, r8, #1
        fill_area.y1 = disp_area->y1 + lower_corner_end;
   19ee8:	443b      	add	r3, r7
   19eea:	b21b      	sxth	r3, r3
   19eec:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        fill_area.y2 = fill_area.y1;
   19ef0:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        for(h = lower_corner_end; h <= draw_area.y2; h++) {
   19ef4:	f9bd 3066 	ldrsh.w	r3, [sp, #102]	; 0x66
   19ef8:	429f      	cmp	r7, r3
   19efa:	f340 836e 	ble.w	1a5da <lv_draw_rect+0x15e4>
        fill_area.y1 = area_outer->y1 + corner_size + 1;
        fill_area.y2 = area_outer->y2 - corner_size - 1;

        fill_area.x1 = area_outer->x1;
        fill_area.x2 = area_outer->x1 + border_width - 1;
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   19efe:	2601      	movs	r6, #1
        fill_area.y1 = area_outer->y1 + corner_size + 1;
   19f00:	9b05      	ldr	r3, [sp, #20]
   19f02:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   19f04:	885b      	ldrh	r3, [r3, #2]
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   19f06:	4650      	mov	r0, sl
        fill_area.y1 = area_outer->y1 + corner_size + 1;
   19f08:	3301      	adds	r3, #1
   19f0a:	fa03 f382 	sxtah	r3, r3, r2
   19f0e:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        fill_area.y2 = area_outer->y2 - corner_size - 1;
   19f12:	9b05      	ldr	r3, [sp, #20]
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   19f14:	a91a      	add	r1, sp, #104	; 0x68
        fill_area.y2 = area_outer->y2 - corner_size - 1;
   19f16:	88db      	ldrh	r3, [r3, #6]
   19f18:	3b01      	subs	r3, #1
   19f1a:	eba3 0b02 	sub.w	fp, r3, r2
        fill_area.x1 = area_outer->x1;
   19f1e:	9b05      	ldr	r3, [sp, #20]
        fill_area.x2 = area_outer->x1 + border_width - 1;
   19f20:	9a08      	ldr	r2, [sp, #32]
        fill_area.x1 = area_outer->x1;
   19f22:	f9b3 3000 	ldrsh.w	r3, [r3]
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   19f26:	9600      	str	r6, [sp, #0]
        fill_area.x1 = area_outer->x1;
   19f28:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        fill_area.x2 = area_outer->x1 + border_width - 1;
   19f2c:	3b01      	subs	r3, #1
   19f2e:	441a      	add	r2, r3
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   19f30:	9b07      	ldr	r3, [sp, #28]
        fill_area.x2 = area_outer->x1 + border_width - 1;
   19f32:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   19f36:	9302      	str	r3, [sp, #8]
   19f38:	9b06      	ldr	r3, [sp, #24]
   19f3a:	462a      	mov	r2, r5
   19f3c:	9301      	str	r3, [sp, #4]
   19f3e:	2300      	movs	r3, #0
        fill_area.y2 = area_outer->y2 - corner_size - 1;
   19f40:	f8ad b06e 	strh.w	fp, [sp, #110]	; 0x6e
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   19f44:	f7fd fb4a 	bl	175dc <_lv_blend_fill>

        /*Draw the right vertical border*/
        fill_area.x1 = area_outer->x2 - border_width + 1;
   19f48:	9b05      	ldr	r3, [sp, #20]
   19f4a:	990b      	ldr	r1, [sp, #44]	; 0x2c
   19f4c:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
   19f50:	9b0d      	ldr	r3, [sp, #52]	; 0x34
        fill_area.x2 = area_outer->x2;
   19f52:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
        fill_area.x1 = area_outer->x2 - border_width + 1;
   19f56:	4413      	add	r3, r2
   19f58:	1a5b      	subs	r3, r3, r1
   19f5a:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68

        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   19f5e:	9b07      	ldr	r3, [sp, #28]
   19f60:	462a      	mov	r2, r5
   19f62:	9302      	str	r3, [sp, #8]
   19f64:	9b06      	ldr	r3, [sp, #24]
   19f66:	4650      	mov	r0, sl
   19f68:	e9cd 6300 	strd	r6, r3, [sp]
   19f6c:	a91a      	add	r1, sp, #104	; 0x68
   19f6e:	2300      	movs	r3, #0
   19f70:	f7fd fb34 	bl	175dc <_lv_blend_fill>
            fill_area.y1++;
            fill_area.y2++;

        }
    }
    lv_draw_mask_remove_id(mask_rin_id);
   19f74:	980e      	ldr	r0, [sp, #56]	; 0x38
   19f76:	f7f1 feef 	bl	bd58 <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_rout_id);
   19f7a:	980f      	ldr	r0, [sp, #60]	; 0x3c
   19f7c:	f7f1 feec 	bl	bd58 <lv_draw_mask_remove_id>
    _lv_mem_buf_release(mask_buf);
   19f80:	4620      	mov	r0, r4
        _lv_mem_buf_release(mask_buf);
   19f82:	f7f2 fe1d 	bl	cbc0 <_lv_mem_buf_release>
}
   19f86:	b02d      	add	sp, #180	; 0xb4
   19f88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
   19f8c:	4631      	mov	r1, r6
   19f8e:	463a      	mov	r2, r7
   19f90:	4628      	mov	r0, r5
   19f92:	f7fe ff58 	bl	18e46 <_lv_memcpy>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   19f96:	463b      	mov	r3, r7
   19f98:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   19f9c:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   19fa0:	4628      	mov	r0, r5
   19fa2:	f7f1 feb7 	bl	bd14 <lv_draw_mask_apply>
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   19fa6:	2801      	cmp	r0, #1
   19fa8:	bf08      	it	eq
   19faa:	2002      	moveq	r0, #2
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   19fac:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   19fb0:	4641      	mov	r1, r8
   19fb2:	9302      	str	r3, [sp, #8]
   19fb4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
            for(y = 0; y < h; y++) {
   19fb6:	f109 0901 	add.w	r9, r9, #1
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   19fba:	e9cd 0300 	strd	r0, r3, [sp]
   19fbe:	462b      	mov	r3, r5
   19fc0:	4650      	mov	r0, sl
   19fc2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   19fc4:	f7fd fb0a 	bl	175dc <_lv_blend_fill>
                fa.y1++;
   19fc8:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   19fcc:	3301      	adds	r3, #1
   19fce:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
                fa.y2++;
   19fd2:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   19fd6:	3301      	adds	r3, #1
   19fd8:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
                sh_buf_tmp += corner_size;
   19fdc:	9b06      	ldr	r3, [sp, #24]
   19fde:	441e      	add	r6, r3
            for(y = 0; y < h; y++) {
   19fe0:	f7ff bbf8 	b.w	197d4 <lv_draw_rect+0x7de>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
   19fe4:	4639      	mov	r1, r7
   19fe6:	4632      	mov	r2, r6
   19fe8:	4628      	mov	r0, r5
   19fea:	f7fe ff2c 	bl	18e46 <_lv_memcpy>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   19fee:	4633      	mov	r3, r6
   19ff0:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   19ff4:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   19ff8:	4628      	mov	r0, r5
   19ffa:	f7f1 fe8b 	bl	bd14 <lv_draw_mask_apply>
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   19ffe:	2801      	cmp	r0, #1
   1a000:	bf08      	it	eq
   1a002:	2002      	moveq	r0, #2
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   1a004:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   1a008:	4641      	mov	r1, r8
   1a00a:	9302      	str	r3, [sp, #8]
   1a00c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
            for(y = 0; y < h; y++) {
   1a00e:	f109 0901 	add.w	r9, r9, #1
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   1a012:	e9cd 0300 	strd	r0, r3, [sp]
   1a016:	462b      	mov	r3, r5
   1a018:	4650      	mov	r0, sl
   1a01a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1a01c:	f7fd fade 	bl	175dc <_lv_blend_fill>
                fa.y1--;
   1a020:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   1a024:	3b01      	subs	r3, #1
   1a026:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
                fa.y2--;
   1a02a:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   1a02e:	3b01      	subs	r3, #1
   1a030:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
                sh_buf_tmp += corner_size;
   1a034:	9b06      	ldr	r3, [sp, #24]
   1a036:	441f      	add	r7, r3
            for(y = 0; y < h; y++) {
   1a038:	e42b      	b.n	19892 <lv_draw_rect+0x89c>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
   1a03a:	4632      	mov	r2, r6
   1a03c:	4639      	mov	r1, r7
   1a03e:	4628      	mov	r0, r5
   1a040:	f7fe ff01 	bl	18e46 <_lv_memcpy>
                if(simple_mode) {
   1a044:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a046:	b94b      	cbnz	r3, 1a05c <lv_draw_rect+0x1066>
                    mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   1a048:	4633      	mov	r3, r6
   1a04a:	4628      	mov	r0, r5
   1a04c:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   1a050:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   1a054:	f7f1 fe5e 	bl	bd14 <lv_draw_mask_apply>
                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   1a058:	2801      	cmp	r0, #1
   1a05a:	d100      	bne.n	1a05e <lv_draw_rect+0x1068>
   1a05c:	2002      	movs	r0, #2
                _lv_blend_fill(clip, &fa,
   1a05e:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   1a062:	4641      	mov	r1, r8
   1a064:	9302      	str	r3, [sp, #8]
   1a066:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
            for(y = 0; y < h; y++) {
   1a06a:	f109 0901 	add.w	r9, r9, #1
                _lv_blend_fill(clip, &fa,
   1a06e:	e9cd 0300 	strd	r0, r3, [sp]
   1a072:	462b      	mov	r3, r5
   1a074:	4650      	mov	r0, sl
   1a076:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1a078:	f7fd fab0 	bl	175dc <_lv_blend_fill>
                fa.y1++;
   1a07c:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
   1a080:	3301      	adds	r3, #1
   1a082:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
                fa.y2++;
   1a086:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   1a08a:	3301      	adds	r3, #1
   1a08c:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
            for(y = 0; y < h; y++) {
   1a090:	e457      	b.n	19942 <lv_draw_rect+0x94c>
            lv_opa_t opa_tmp = sh_buf_tmp[0];
   1a092:	7833      	ldrb	r3, [r6, #0]
            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;
   1a094:	9a0a      	ldr	r2, [sp, #40]	; 0x28
            _lv_memset(mask_buf, opa_tmp, w);
   1a096:	4628      	mov	r0, r5
   1a098:	ea02 0103 	and.w	r1, r2, r3
            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;
   1a09c:	29ff      	cmp	r1, #255	; 0xff
   1a09e:	bf18      	it	ne
   1a0a0:	fb12 f303 	smulbbne	r3, r2, r3
            _lv_memset(mask_buf, opa_tmp, w);
   1a0a4:	463a      	mov	r2, r7
            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;
   1a0a6:	bf18      	it	ne
   1a0a8:	f3c3 2107 	ubfxne	r1, r3, #8, #8
            _lv_memset(mask_buf, opa_tmp, w);
   1a0ac:	f7fe fec9 	bl	18e42 <_lv_memset>
            if(simple_mode) {
   1a0b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a0b2:	b94b      	cbnz	r3, 1a0c8 <lv_draw_rect+0x10d2>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   1a0b4:	463b      	mov	r3, r7
   1a0b6:	4628      	mov	r0, r5
   1a0b8:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   1a0bc:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   1a0c0:	f7f1 fe28 	bl	bd14 <lv_draw_mask_apply>
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   1a0c4:	2801      	cmp	r0, #1
   1a0c6:	d100      	bne.n	1a0ca <lv_draw_rect+0x10d4>
   1a0c8:	2002      	movs	r0, #2
            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   1a0ca:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   1a0ce:	4641      	mov	r1, r8
   1a0d0:	9302      	str	r3, [sp, #8]
   1a0d2:	23ff      	movs	r3, #255	; 0xff
   1a0d4:	e9cd 0300 	strd	r0, r3, [sp]
   1a0d8:	462b      	mov	r3, r5
   1a0da:	4650      	mov	r0, sl
   1a0dc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1a0de:	f7fd fa7d 	bl	175dc <_lv_blend_fill>
            fa.y1++;
   1a0e2:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
        for(y = 0; y < h; y++) {
   1a0e6:	f109 0901 	add.w	r9, r9, #1
            fa.y1++;
   1a0ea:	3301      	adds	r3, #1
   1a0ec:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
            fa.y2++;
   1a0f0:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   1a0f4:	3301      	adds	r3, #1
   1a0f6:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
            sh_buf_tmp += corner_size;
   1a0fa:	9b06      	ldr	r3, [sp, #24]
   1a0fc:	441e      	add	r6, r3
        for(y = 0; y < h; y++) {
   1a0fe:	e474      	b.n	199ea <lv_draw_rect+0x9f4>
            lv_opa_t opa_tmp = sh_buf_tmp[0];
   1a100:	7833      	ldrb	r3, [r6, #0]
            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;
   1a102:	9a0a      	ldr	r2, [sp, #40]	; 0x28
            _lv_memset(mask_buf, opa_tmp, w);
   1a104:	4628      	mov	r0, r5
   1a106:	ea02 0103 	and.w	r1, r2, r3
            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;
   1a10a:	29ff      	cmp	r1, #255	; 0xff
   1a10c:	bf18      	it	ne
   1a10e:	fb12 f303 	smulbbne	r3, r2, r3
            _lv_memset(mask_buf, opa_tmp, w);
   1a112:	463a      	mov	r2, r7
            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;
   1a114:	bf18      	it	ne
   1a116:	f3c3 2107 	ubfxne	r1, r3, #8, #8
            _lv_memset(mask_buf, opa_tmp, w);
   1a11a:	f7fe fe92 	bl	18e42 <_lv_memset>
            if(simple_mode) {
   1a11e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a120:	b94b      	cbnz	r3, 1a136 <lv_draw_rect+0x1140>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   1a122:	463b      	mov	r3, r7
   1a124:	4628      	mov	r0, r5
   1a126:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   1a12a:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   1a12e:	f7f1 fdf1 	bl	bd14 <lv_draw_mask_apply>
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   1a132:	2801      	cmp	r0, #1
   1a134:	d100      	bne.n	1a138 <lv_draw_rect+0x1142>
   1a136:	2002      	movs	r0, #2
            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   1a138:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   1a13c:	4641      	mov	r1, r8
   1a13e:	9302      	str	r3, [sp, #8]
   1a140:	23ff      	movs	r3, #255	; 0xff
   1a142:	e9cd 0300 	strd	r0, r3, [sp]
   1a146:	462b      	mov	r3, r5
   1a148:	4650      	mov	r0, sl
   1a14a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1a14c:	f7fd fa46 	bl	175dc <_lv_blend_fill>
            fa.y1--;
   1a150:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
        for(y = 0; y < h; y++) {
   1a154:	f109 0901 	add.w	r9, r9, #1
            fa.y1--;
   1a158:	3b01      	subs	r3, #1
   1a15a:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
            fa.y2--;
   1a15e:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   1a162:	3b01      	subs	r3, #1
   1a164:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
            sh_buf_tmp += corner_size;
   1a168:	9b06      	ldr	r3, [sp, #24]
   1a16a:	441e      	add	r6, r3
        for(y = 0; y < h; y++) {
   1a16c:	e492      	b.n	19a94 <lv_draw_rect+0xa9e>
            _lv_memset(mask_buf, dsc->shadow_opa, w);
   1a16e:	463a      	mov	r2, r7
   1a170:	4628      	mov	r0, r5
   1a172:	f894 1038 	ldrb.w	r1, [r4, #56]	; 0x38
   1a176:	f7fe fe64 	bl	18e42 <_lv_memset>
            mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
   1a17a:	463b      	mov	r3, r7
   1a17c:	f9bd 207a 	ldrsh.w	r2, [sp, #122]	; 0x7a
   1a180:	f9bd 1078 	ldrsh.w	r1, [sp, #120]	; 0x78
   1a184:	4628      	mov	r0, r5
   1a186:	f7f1 fdc5 	bl	bd14 <lv_draw_mask_apply>
            if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
   1a18a:	2801      	cmp	r0, #1
   1a18c:	bf08      	it	eq
   1a18e:	2002      	moveq	r0, #2
            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
   1a190:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
   1a194:	9000      	str	r0, [sp, #0]
   1a196:	e9cd 9301 	strd	r9, r3, [sp, #4]
   1a19a:	4650      	mov	r0, sl
   1a19c:	462b      	mov	r3, r5
   1a19e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1a1a0:	a91e      	add	r1, sp, #120	; 0x78
   1a1a2:	f7fd fa1b 	bl	175dc <_lv_blend_fill>
            fa.y1++;
   1a1a6:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
        for(y = 0; y < h; y++) {
   1a1aa:	3601      	adds	r6, #1
            fa.y1++;
   1a1ac:	3301      	adds	r3, #1
   1a1ae:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
            fa.y2++;
   1a1b2:	f8bd 307e 	ldrh.w	r3, [sp, #126]	; 0x7e
   1a1b6:	3301      	adds	r3, #1
   1a1b8:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
        for(y = 0; y < h; y++) {
   1a1bc:	e4ac      	b.n	19b18 <lv_draw_rect+0xb22>
    if(other_mask_cnt) simple_mode = false;
   1a1be:	2300      	movs	r3, #0
   1a1c0:	e52e      	b.n	19c20 <lv_draw_rect+0xc2a>
        if(rout > 0) {
   1a1c2:	2d00      	cmp	r5, #0
   1a1c4:	f340 80a0 	ble.w	1a308 <lv_draw_rect+0x1312>
            lv_draw_mask_radius_init(&mask_rout_param, &coords_bg, rout, false);
   1a1c8:	2300      	movs	r3, #0
   1a1ca:	462a      	mov	r2, r5
   1a1cc:	a918      	add	r1, sp, #96	; 0x60
   1a1ce:	a825      	add	r0, sp, #148	; 0x94
   1a1d0:	f7f1 fe7a 	bl	bec8 <lv_draw_mask_radius_init>
            mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   1a1d4:	2100      	movs	r1, #0
   1a1d6:	a825      	add	r0, sp, #148	; 0x94
   1a1d8:	f7f1 fd86 	bl	bce8 <lv_draw_mask_add>
   1a1dc:	900d      	str	r0, [sp, #52]	; 0x34
        lv_color_t grad_color = dsc->bg_color;
   1a1de:	6863      	ldr	r3, [r4, #4]
        if(grad_dir == LV_GRAD_DIR_HOR) {
   1a1e0:	2e02      	cmp	r6, #2
        lv_color_t grad_color = dsc->bg_color;
   1a1e2:	9308      	str	r3, [sp, #32]
        if(grad_dir == LV_GRAD_DIR_HOR) {
   1a1e4:	f040 80a0 	bne.w	1a328 <lv_draw_rect+0x1332>
            grad_map = _lv_mem_buf_get(coords_w * sizeof(lv_color_t));
   1a1e8:	00b8      	lsls	r0, r7, #2
   1a1ea:	f7f2 fc87 	bl	cafc <_lv_mem_buf_get>
            for(i = 0; i < coords_w; i++) {
   1a1ee:	f04f 0900 	mov.w	r9, #0
            grad_map = _lv_mem_buf_get(coords_w * sizeof(lv_color_t));
   1a1f2:	900b      	str	r0, [sp, #44]	; 0x2c
            for(i = 0; i < coords_w; i++) {
   1a1f4:	454f      	cmp	r7, r9
   1a1f6:	f300 808b 	bgt.w	1a310 <lv_draw_rect+0x131a>
        if(lv_area_get_width(&coords_bg) - 2 * rout > SPLIT_LIMIT) split = true;
   1a1fa:	f06f 0301 	mvn.w	r3, #1
   1a1fe:	f9bd 1064 	ldrsh.w	r1, [sp, #100]	; 0x64
   1a202:	436b      	muls	r3, r5
   1a204:	f9bd 0060 	ldrsh.w	r0, [sp, #96]	; 0x60
   1a208:	1c4a      	adds	r2, r1, #1
   1a20a:	1a12      	subs	r2, r2, r0
   1a20c:	fa03 f382 	sxtah	r3, r3, r2
   1a210:	930f      	str	r3, [sp, #60]	; 0x3c
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   1a212:	9b06      	ldr	r3, [sp, #24]
   1a214:	f9bd 206a 	ldrsh.w	r2, [sp, #106]	; 0x6a
   1a218:	8a5b      	ldrh	r3, [r3, #18]
        fill_area.x1 = coords_bg.x1;
   1a21a:	f8ad 0070 	strh.w	r0, [sp, #112]	; 0x70
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   1a21e:	4413      	add	r3, r2
   1a220:	b21b      	sxth	r3, r3
   1a222:	f8ad 3072 	strh.w	r3, [sp, #114]	; 0x72
        fill_area.y2 = fill_area.y1;
   1a226:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
                fill_area2.x2 = coords_bg.x1 + rout - 1;
   1a22a:	b22b      	sxth	r3, r5
        fill_area.x2 = coords_bg.x2;
   1a22c:	f8ad 1074 	strh.w	r1, [sp, #116]	; 0x74
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a230:	9207      	str	r2, [sp, #28]
                fill_area2.x2 = coords_bg.x1 + rout - 1;
   1a232:	930e      	str	r3, [sp, #56]	; 0x38
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a234:	f9bd 306e 	ldrsh.w	r3, [sp, #110]	; 0x6e
   1a238:	9a07      	ldr	r2, [sp, #28]
   1a23a:	429a      	cmp	r2, r3
   1a23c:	dd77      	ble.n	1a32e <lv_draw_rect+0x1338>
        if(grad_dir == LV_GRAD_DIR_NONE && other_mask_cnt == 0 && split) {
   1a23e:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1a240:	4333      	orrs	r3, r6
   1a242:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   1a246:	d157      	bne.n	1a2f8 <lv_draw_rect+0x1302>
   1a248:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   1a24a:	2a32      	cmp	r2, #50	; 0x32
   1a24c:	dd54      	ble.n	1a2f8 <lv_draw_rect+0x1302>
            fill_area.x1 = coords_bg.x1 + rout;
   1a24e:	f8bd 2060 	ldrh.w	r2, [sp, #96]	; 0x60
   1a252:	b22f      	sxth	r7, r5
   1a254:	442a      	add	r2, r5
   1a256:	f8ad 2070 	strh.w	r2, [sp, #112]	; 0x70
            fill_area.x2 = coords_bg.x2 - rout;
   1a25a:	f8bd 2064 	ldrh.w	r2, [sp, #100]	; 0x64
            _lv_blend_fill(clip, &fill_area,
   1a25e:	4650      	mov	r0, sl
            fill_area.x2 = coords_bg.x2 - rout;
   1a260:	1b52      	subs	r2, r2, r5
   1a262:	f8ad 2074 	strh.w	r2, [sp, #116]	; 0x74
            fill_area.y1 = coords_bg.y1;
   1a266:	f9bd 2062 	ldrsh.w	r2, [sp, #98]	; 0x62
            _lv_blend_fill(clip, &fill_area,
   1a26a:	a91c      	add	r1, sp, #112	; 0x70
            fill_area.y2 = coords_bg.y1 + rout;
   1a26c:	4415      	add	r5, r2
            fill_area.y1 = coords_bg.y1;
   1a26e:	f8ad 2072 	strh.w	r2, [sp, #114]	; 0x72
            _lv_blend_fill(clip, &fill_area,
   1a272:	7ce2      	ldrb	r2, [r4, #19]
            fill_area.y2 = coords_bg.y1 + rout;
   1a274:	f8ad 5076 	strh.w	r5, [sp, #118]	; 0x76
            _lv_blend_fill(clip, &fill_area,
   1a278:	e9cd b201 	strd	fp, r2, [sp, #4]
   1a27c:	2201      	movs	r2, #1
            _lv_blend_fill(clip, &fill_area,
   1a27e:	2501      	movs	r5, #1
            _lv_blend_fill(clip, &fill_area,
   1a280:	9200      	str	r2, [sp, #0]
   1a282:	6862      	ldr	r2, [r4, #4]
   1a284:	f7fd f9aa 	bl	175dc <_lv_blend_fill>
            fill_area.y1 = coords_bg.y2 - rout;
   1a288:	f9bd 1066 	ldrsh.w	r1, [sp, #102]	; 0x66
            if(fill_area.y1 <= fill_area.y2) fill_area.y1 = fill_area.y2 + 1;    /*Avoid overdrawing the last line*/
   1a28c:	f9bd 3076 	ldrsh.w	r3, [sp, #118]	; 0x76
            fill_area.y1 = coords_bg.y2 - rout;
   1a290:	1bca      	subs	r2, r1, r7
   1a292:	b212      	sxth	r2, r2
            if(fill_area.y1 <= fill_area.y2) fill_area.y1 = fill_area.y2 + 1;    /*Avoid overdrawing the last line*/
   1a294:	429a      	cmp	r2, r3
   1a296:	bfd8      	it	le
   1a298:	3301      	addle	r3, #1
            fill_area.y1 = coords_bg.y2 - rout;
   1a29a:	f8ad 2072 	strh.w	r2, [sp, #114]	; 0x72
            if(fill_area.y1 <= fill_area.y2) fill_area.y1 = fill_area.y2 + 1;    /*Avoid overdrawing the last line*/
   1a29e:	bfd8      	it	le
   1a2a0:	f8ad 3072 	strhle.w	r3, [sp, #114]	; 0x72
            _lv_blend_fill(clip, &fill_area,
   1a2a4:	7ce3      	ldrb	r3, [r4, #19]
   1a2a6:	9500      	str	r5, [sp, #0]
   1a2a8:	e9cd b301 	strd	fp, r3, [sp, #4]
   1a2ac:	4650      	mov	r0, sl
   1a2ae:	2300      	movs	r3, #0
   1a2b0:	6862      	ldr	r2, [r4, #4]
            fill_area.y2 = coords_bg.y2;
   1a2b2:	f8ad 1076 	strh.w	r1, [sp, #118]	; 0x76
            _lv_blend_fill(clip, &fill_area,
   1a2b6:	a91c      	add	r1, sp, #112	; 0x70
   1a2b8:	f7fd f990 	bl	175dc <_lv_blend_fill>
            fill_area.x1 = coords_bg.x1;
   1a2bc:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
            _lv_blend_fill(clip, &fill_area,
   1a2c0:	4650      	mov	r0, sl
            fill_area.x1 = coords_bg.x1;
   1a2c2:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
            fill_area.x2 = coords_bg.x2;
   1a2c6:	f8bd 3064 	ldrh.w	r3, [sp, #100]	; 0x64
            _lv_blend_fill(clip, &fill_area,
   1a2ca:	a91c      	add	r1, sp, #112	; 0x70
            fill_area.x2 = coords_bg.x2;
   1a2cc:	f8ad 3074 	strh.w	r3, [sp, #116]	; 0x74
            fill_area.y1 = coords_bg.y1 + rout + 1;
   1a2d0:	f8bd 3062 	ldrh.w	r3, [sp, #98]	; 0x62
   1a2d4:	442b      	add	r3, r5
   1a2d6:	443b      	add	r3, r7
   1a2d8:	f8ad 3072 	strh.w	r3, [sp, #114]	; 0x72
            fill_area.y2 = coords_bg.y2 - rout - 1;
   1a2dc:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
   1a2e0:	3b01      	subs	r3, #1
   1a2e2:	1bdf      	subs	r7, r3, r7
            _lv_blend_fill(clip, &fill_area,
   1a2e4:	7ce3      	ldrb	r3, [r4, #19]
   1a2e6:	9500      	str	r5, [sp, #0]
   1a2e8:	e9cd b301 	strd	fp, r3, [sp, #4]
   1a2ec:	2300      	movs	r3, #0
   1a2ee:	6862      	ldr	r2, [r4, #4]
            fill_area.y2 = coords_bg.y2 - rout - 1;
   1a2f0:	f8ad 7076 	strh.w	r7, [sp, #118]	; 0x76
            _lv_blend_fill(clip, &fill_area,
   1a2f4:	f7fd f972 	bl	175dc <_lv_blend_fill>
        if(grad_map) _lv_mem_buf_release(grad_map);
   1a2f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a2fa:	2b00      	cmp	r3, #0
   1a2fc:	f43f acc0 	beq.w	19c80 <lv_draw_rect+0xc8a>
   1a300:	4618      	mov	r0, r3
   1a302:	f7f2 fc5d 	bl	cbc0 <_lv_mem_buf_release>
   1a306:	e4bb      	b.n	19c80 <lv_draw_rect+0xc8a>
    int16_t mask_rout_id = LV_MASK_ID_INV;
   1a308:	f04f 33ff 	mov.w	r3, #4294967295
   1a30c:	930d      	str	r3, [sp, #52]	; 0x34
   1a30e:	e766      	b.n	1a1de <lv_draw_rect+0x11e8>
                grad_map[i] = grad_get(dsc, coords_w, i);
   1a310:	fa0f f289 	sxth.w	r2, r9
   1a314:	4639      	mov	r1, r7
   1a316:	4620      	mov	r0, r4
   1a318:	f7fe fd47 	bl	18daa <grad_get>
   1a31c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1a31e:	f843 0029 	str.w	r0, [r3, r9, lsl #2]
            for(i = 0; i < coords_w; i++) {
   1a322:	f109 0901 	add.w	r9, r9, #1
   1a326:	e765      	b.n	1a1f4 <lv_draw_rect+0x11fe>
        lv_color_t * grad_map = NULL;
   1a328:	2300      	movs	r3, #0
   1a32a:	930b      	str	r3, [sp, #44]	; 0x2c
   1a32c:	e765      	b.n	1a1fa <lv_draw_rect+0x1204>
            int32_t y = h + vdb->area.y1;
   1a32e:	9b06      	ldr	r3, [sp, #24]
   1a330:	9a07      	ldr	r2, [sp, #28]
   1a332:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
   1a336:	4413      	add	r3, r2
   1a338:	930c      	str	r3, [sp, #48]	; 0x30
            if(y > coords_bg.y1 + rout + 1 &&
   1a33a:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
   1a33e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1a340:	3301      	adds	r3, #1
   1a342:	442b      	add	r3, r5
   1a344:	429a      	cmp	r2, r3
   1a346:	dd09      	ble.n	1a35c <lv_draw_rect+0x1366>
               y < coords_bg.y2 - rout - 1) {
   1a348:	f9bd 3066 	ldrsh.w	r3, [sp, #102]	; 0x66
   1a34c:	3b01      	subs	r3, #1
   1a34e:	1b5b      	subs	r3, r3, r5
            if(y > coords_bg.y1 + rout + 1 &&
   1a350:	429a      	cmp	r2, r3
   1a352:	da03      	bge.n	1a35c <lv_draw_rect+0x1366>
                if(simple_mode == false) {
   1a354:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1a356:	2b00      	cmp	r3, #0
   1a358:	f040 82ea 	bne.w	1a930 <lv_draw_rect+0x193a>
                _lv_memset(mask_buf, opa, draw_area_w);
   1a35c:	4659      	mov	r1, fp
   1a35e:	4640      	mov	r0, r8
   1a360:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1a362:	f7fe fd6e 	bl	18e42 <_lv_memset>
                mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   1a366:	9b06      	ldr	r3, [sp, #24]
   1a368:	4640      	mov	r0, r8
   1a36a:	8a5a      	ldrh	r2, [r3, #18]
   1a36c:	9b07      	ldr	r3, [sp, #28]
   1a36e:	441a      	add	r2, r3
   1a370:	9b06      	ldr	r3, [sp, #24]
   1a372:	b212      	sxth	r2, r2
   1a374:	8a19      	ldrh	r1, [r3, #16]
   1a376:	f8bd 3068 	ldrh.w	r3, [sp, #104]	; 0x68
   1a37a:	4419      	add	r1, r3
   1a37c:	b209      	sxth	r1, r1
   1a37e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a380:	f7f1 fcc8 	bl	bd14 <lv_draw_mask_apply>
                opa2 = LV_OPA_COVER;
   1a384:	2802      	cmp	r0, #2
   1a386:	bf14      	ite	ne
   1a388:	46d9      	movne	r9, fp
   1a38a:	f04f 09ff 	moveq.w	r9, #255	; 0xff
            if(grad_dir == LV_GRAD_DIR_VER) {
   1a38e:	2e01      	cmp	r6, #1
                mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   1a390:	4607      	mov	r7, r0
            if(grad_dir == LV_GRAD_DIR_VER) {
   1a392:	d175      	bne.n	1a480 <lv_draw_rect+0x148a>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1a394:	f8bd 1066 	ldrh.w	r1, [sp, #102]	; 0x66
   1a398:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
                grad_color = grad_get(dsc, lv_area_get_height(&coords_bg), y - coords_bg.y1);
   1a39c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1a39e:	3101      	adds	r1, #1
   1a3a0:	1ad2      	subs	r2, r2, r3
   1a3a2:	1ac9      	subs	r1, r1, r3
   1a3a4:	4620      	mov	r0, r4
   1a3a6:	b212      	sxth	r2, r2
   1a3a8:	b209      	sxth	r1, r1
   1a3aa:	f7fe fcfe 	bl	18daa <grad_get>
            if(simple_mode && split &&
   1a3ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
                grad_color = grad_get(dsc, lv_area_get_height(&coords_bg), y - coords_bg.y1);
   1a3b0:	9008      	str	r0, [sp, #32]
            if(simple_mode && split &&
   1a3b2:	2b00      	cmp	r3, #0
   1a3b4:	f000 808b 	beq.w	1a4ce <lv_draw_rect+0x14d8>
   1a3b8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a3ba:	2b32      	cmp	r3, #50	; 0x32
   1a3bc:	dd6b      	ble.n	1a496 <lv_draw_rect+0x14a0>
               (y < coords_bg.y1 + rout + 1 ||
   1a3be:	f9bd 3062 	ldrsh.w	r3, [sp, #98]	; 0x62
            if(simple_mode && split &&
   1a3c2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
               (y < coords_bg.y1 + rout + 1 ||
   1a3c4:	3301      	adds	r3, #1
   1a3c6:	442b      	add	r3, r5
            if(simple_mode && split &&
   1a3c8:	429a      	cmp	r2, r3
   1a3ca:	db05      	blt.n	1a3d8 <lv_draw_rect+0x13e2>
                y > coords_bg.y2 - rout - 1)) {
   1a3cc:	f9bd 3066 	ldrsh.w	r3, [sp, #102]	; 0x66
   1a3d0:	3b01      	subs	r3, #1
   1a3d2:	1b5b      	subs	r3, r3, r5
               (y < coords_bg.y1 + rout + 1 ||
   1a3d4:	429a      	cmp	r2, r3
   1a3d6:	dd5e      	ble.n	1a496 <lv_draw_rect+0x14a0>
                fill_area2.x1 = coords_bg.x1;
   1a3d8:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
                fill_area2.x2 = coords_bg.x1 + rout - 1;
   1a3dc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
                fill_area2.x1 = coords_bg.x1;
   1a3de:	f8ad 3078 	strh.w	r3, [sp, #120]	; 0x78
                fill_area2.x2 = coords_bg.x1 + rout - 1;
   1a3e2:	3b01      	subs	r3, #1
   1a3e4:	4413      	add	r3, r2
   1a3e6:	f8ad 307c 	strh.w	r3, [sp, #124]	; 0x7c
                fill_area2.y1 = fill_area.y1;
   1a3ea:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
                _lv_blend_fill(clip, &fill_area2,
   1a3ee:	4650      	mov	r0, sl
                fill_area2.y1 = fill_area.y1;
   1a3f0:	f8ad 307a 	strh.w	r3, [sp, #122]	; 0x7a
                fill_area2.y2 = fill_area.y2;
   1a3f4:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
                _lv_blend_fill(clip, &fill_area2,
   1a3f8:	9a08      	ldr	r2, [sp, #32]
                fill_area2.y2 = fill_area.y2;
   1a3fa:	f8ad 307e 	strh.w	r3, [sp, #126]	; 0x7e
                _lv_blend_fill(clip, &fill_area2,
   1a3fe:	7ce3      	ldrb	r3, [r4, #19]
   1a400:	a91e      	add	r1, sp, #120	; 0x78
   1a402:	e9cd 9301 	strd	r9, r3, [sp, #4]
   1a406:	9700      	str	r7, [sp, #0]
   1a408:	4643      	mov	r3, r8
   1a40a:	f7fd f8e7 	bl	175dc <_lv_blend_fill>
                if(grad_dir == LV_GRAD_DIR_VER) {
   1a40e:	2e01      	cmp	r6, #1
   1a410:	d114      	bne.n	1a43c <lv_draw_rect+0x1446>
                    fill_area2.x1 = coords_bg.x1 + rout;
   1a412:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1a414:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
                    _lv_blend_fill(clip, &fill_area2,
   1a418:	4650      	mov	r0, sl
                    fill_area2.x1 = coords_bg.x1 + rout;
   1a41a:	4413      	add	r3, r2
   1a41c:	f8ad 3078 	strh.w	r3, [sp, #120]	; 0x78
                    fill_area2.x2 = coords_bg.x2 - rout;
   1a420:	f8bd 3064 	ldrh.w	r3, [sp, #100]	; 0x64
                    _lv_blend_fill(clip, &fill_area2,
   1a424:	a91e      	add	r1, sp, #120	; 0x78
                    fill_area2.x2 = coords_bg.x2 - rout;
   1a426:	1a9b      	subs	r3, r3, r2
   1a428:	f8ad 307c 	strh.w	r3, [sp, #124]	; 0x7c
                    _lv_blend_fill(clip, &fill_area2,
   1a42c:	7ce3      	ldrb	r3, [r4, #19]
   1a42e:	9a08      	ldr	r2, [sp, #32]
   1a430:	e9cd b301 	strd	fp, r3, [sp, #4]
   1a434:	9600      	str	r6, [sp, #0]
   1a436:	2300      	movs	r3, #0
   1a438:	f7fd f8d0 	bl	175dc <_lv_blend_fill>
                fill_area2.x1 = coords_bg.x2 - rout + 1;
   1a43c:	f9bd 2064 	ldrsh.w	r2, [sp, #100]	; 0x64
   1a440:	990e      	ldr	r1, [sp, #56]	; 0x38
   1a442:	1c53      	adds	r3, r2, #1
                fill_area2.x2 = coords_bg.x2;
   1a444:	f8ad 207c 	strh.w	r2, [sp, #124]	; 0x7c
                int32_t mask_ofs = (coords_bg.x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a448:	f9bd 2068 	ldrsh.w	r2, [sp, #104]	; 0x68
                fill_area2.x1 = coords_bg.x2 - rout + 1;
   1a44c:	1a59      	subs	r1, r3, r1
                int32_t mask_ofs = (coords_bg.x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a44e:	1a9b      	subs	r3, r3, r2
   1a450:	9a06      	ldr	r2, [sp, #24]
                fill_area2.x1 = coords_bg.x2 - rout + 1;
   1a452:	f8ad 1078 	strh.w	r1, [sp, #120]	; 0x78
                int32_t mask_ofs = (coords_bg.x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a456:	f9b2 2010 	ldrsh.w	r2, [r2, #16]
   1a45a:	1b5b      	subs	r3, r3, r5
   1a45c:	1a9b      	subs	r3, r3, r2
                _lv_blend_fill(clip, &fill_area2,
   1a45e:	2b00      	cmp	r3, #0
   1a460:	bfac      	ite	ge
   1a462:	4443      	addge	r3, r8
   1a464:	f108 0300 	addlt.w	r3, r8, #0
   1a468:	7ce2      	ldrb	r2, [r4, #19]
   1a46a:	a91e      	add	r1, sp, #120	; 0x78
   1a46c:	e9cd 9201 	strd	r9, r2, [sp, #4]
   1a470:	9a08      	ldr	r2, [sp, #32]
   1a472:	9700      	str	r7, [sp, #0]
                    _lv_blend_fill(clip, &fill_area,
   1a474:	4650      	mov	r0, sl
   1a476:	f7fd f8b1 	bl	175dc <_lv_blend_fill>
   1a47a:	e018      	b.n	1a4ae <lv_draw_rect+0x14b8>
                mask_res = LV_DRAW_MASK_RES_FULL_COVER;
   1a47c:	4637      	mov	r7, r6
   1a47e:	e789      	b.n	1a394 <lv_draw_rect+0x139e>
            if(simple_mode && split &&
   1a480:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1a482:	2b00      	cmp	r3, #0
   1a484:	d198      	bne.n	1a3b8 <lv_draw_rect+0x13c2>
                if(grad_dir == LV_GRAD_DIR_HOR) {
   1a486:	2e02      	cmp	r6, #2
   1a488:	d007      	beq.n	1a49a <lv_draw_rect+0x14a4>
                else if(other_mask_cnt != 0 || !split) {
   1a48a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1a48c:	b9fb      	cbnz	r3, 1a4ce <lv_draw_rect+0x14d8>
   1a48e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1a490:	2b32      	cmp	r3, #50	; 0x32
   1a492:	dc0c      	bgt.n	1a4ae <lv_draw_rect+0x14b8>
   1a494:	e01b      	b.n	1a4ce <lv_draw_rect+0x14d8>
                if(grad_dir == LV_GRAD_DIR_HOR) {
   1a496:	2e02      	cmp	r6, #2
   1a498:	d117      	bne.n	1a4ca <lv_draw_rect+0x14d4>
                    _lv_blend_map(clip, &fill_area, grad_map, mask_buf, mask_res, opa2, dsc->bg_blend_mode);
   1a49a:	7ce3      	ldrb	r3, [r4, #19]
   1a49c:	4650      	mov	r0, sl
   1a49e:	e9cd 9301 	strd	r9, r3, [sp, #4]
   1a4a2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1a4a4:	4643      	mov	r3, r8
   1a4a6:	9700      	str	r7, [sp, #0]
   1a4a8:	a91c      	add	r1, sp, #112	; 0x70
   1a4aa:	f7fd fb27 	bl	17afc <_lv_blend_map>
            fill_area.y1++;
   1a4ae:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
   1a4b2:	3301      	adds	r3, #1
   1a4b4:	f8ad 3072 	strh.w	r3, [sp, #114]	; 0x72
            fill_area.y2++;
   1a4b8:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   1a4bc:	3301      	adds	r3, #1
   1a4be:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a4c2:	9b07      	ldr	r3, [sp, #28]
   1a4c4:	3301      	adds	r3, #1
   1a4c6:	9307      	str	r3, [sp, #28]
   1a4c8:	e6b4      	b.n	1a234 <lv_draw_rect+0x123e>
                else if(grad_dir == LV_GRAD_DIR_VER) {
   1a4ca:	2e01      	cmp	r6, #1
   1a4cc:	d1dd      	bne.n	1a48a <lv_draw_rect+0x1494>
                    _lv_blend_fill(clip, &fill_area,
   1a4ce:	7ce3      	ldrb	r3, [r4, #19]
   1a4d0:	9a08      	ldr	r2, [sp, #32]
   1a4d2:	e9cd 9301 	strd	r9, r3, [sp, #4]
   1a4d6:	9700      	str	r7, [sp, #0]
   1a4d8:	4643      	mov	r3, r8
   1a4da:	a91c      	add	r1, sp, #112	; 0x70
   1a4dc:	e7ca      	b.n	1a474 <lv_draw_rect+0x147e>
            _lv_memset_ff(mask_buf, draw_area_w);
   1a4de:	4631      	mov	r1, r6
   1a4e0:	4620      	mov	r0, r4
   1a4e2:	f7fe fcaa 	bl	18e3a <_lv_memset_ff>
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   1a4e6:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
   1a4ea:	f8bb 2012 	ldrh.w	r2, [fp, #18]
   1a4ee:	f8bb 1010 	ldrh.w	r1, [fp, #16]
   1a4f2:	443a      	add	r2, r7
   1a4f4:	4419      	add	r1, r3
   1a4f6:	b212      	sxth	r2, r2
   1a4f8:	4633      	mov	r3, r6
   1a4fa:	b209      	sxth	r1, r1
   1a4fc:	4620      	mov	r0, r4
   1a4fe:	f7f1 fc09 	bl	bd14 <lv_draw_mask_apply>
            fill_area2.y1 = fill_area.y1;
   1a502:	f8bd 306a 	ldrh.w	r3, [sp, #106]	; 0x6a
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   1a506:	462a      	mov	r2, r5
            fill_area2.y1 = fill_area.y1;
   1a508:	f8ad 3072 	strh.w	r3, [sp, #114]	; 0x72
            fill_area2.y2 = fill_area.y2;
   1a50c:	f8bd 306e 	ldrh.w	r3, [sp, #110]	; 0x6e
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   1a510:	900c      	str	r0, [sp, #48]	; 0x30
            fill_area2.y2 = fill_area.y2;
   1a512:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
            fill_area2.x1 = area_outer->x1;
   1a516:	9b05      	ldr	r3, [sp, #20]
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   1a518:	a91c      	add	r1, sp, #112	; 0x70
            fill_area2.x1 = area_outer->x1;
   1a51a:	f9b3 3000 	ldrsh.w	r3, [r3]
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   1a51e:	9000      	str	r0, [sp, #0]
            fill_area2.x1 = area_outer->x1;
   1a520:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
            fill_area2.x2 = area_outer->x1 + rout - 1;
   1a524:	3b01      	subs	r3, #1
   1a526:	444b      	add	r3, r9
   1a528:	f8ad 3074 	strh.w	r3, [sp, #116]	; 0x74
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   1a52c:	9b07      	ldr	r3, [sp, #28]
   1a52e:	4650      	mov	r0, sl
   1a530:	9302      	str	r3, [sp, #8]
   1a532:	9b06      	ldr	r3, [sp, #24]
   1a534:	9301      	str	r3, [sp, #4]
   1a536:	4623      	mov	r3, r4
   1a538:	f7fd f850 	bl	175dc <_lv_blend_fill>
            if(fill_area2.y2 < area_outer->y1 + border_width) {
   1a53c:	9b05      	ldr	r3, [sp, #20]
   1a53e:	9908      	ldr	r1, [sp, #32]
   1a540:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
   1a544:	f9bd 2076 	ldrsh.w	r2, [sp, #118]	; 0x76
   1a548:	440b      	add	r3, r1
   1a54a:	429a      	cmp	r2, r3
   1a54c:	da16      	bge.n	1a57c <lv_draw_rect+0x1586>
                fill_area2.x1 = area_outer->x1 + rout;
   1a54e:	9b05      	ldr	r3, [sp, #20]
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   1a550:	462a      	mov	r2, r5
                fill_area2.x1 = area_outer->x1 + rout;
   1a552:	881b      	ldrh	r3, [r3, #0]
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   1a554:	4650      	mov	r0, sl
                fill_area2.x1 = area_outer->x1 + rout;
   1a556:	444b      	add	r3, r9
   1a558:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
                fill_area2.x2 = area_outer->x2 - rout;
   1a55c:	9b05      	ldr	r3, [sp, #20]
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   1a55e:	a91c      	add	r1, sp, #112	; 0x70
                fill_area2.x2 = area_outer->x2 - rout;
   1a560:	889b      	ldrh	r3, [r3, #4]
   1a562:	eba3 0309 	sub.w	r3, r3, r9
   1a566:	f8ad 3074 	strh.w	r3, [sp, #116]	; 0x74
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   1a56a:	9b07      	ldr	r3, [sp, #28]
   1a56c:	9302      	str	r3, [sp, #8]
   1a56e:	9b06      	ldr	r3, [sp, #24]
   1a570:	9301      	str	r3, [sp, #4]
   1a572:	2301      	movs	r3, #1
   1a574:	9300      	str	r3, [sp, #0]
   1a576:	2300      	movs	r3, #0
   1a578:	f7fd f830 	bl	175dc <_lv_blend_fill>
            fill_area2.x1 = area_outer->x2 - rout + 1;
   1a57c:	9b05      	ldr	r3, [sp, #20]
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   1a57e:	4650      	mov	r0, sl
            fill_area2.x1 = area_outer->x2 - rout + 1;
   1a580:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   1a584:	a91c      	add	r1, sp, #112	; 0x70
            fill_area2.x1 = area_outer->x2 - rout + 1;
   1a586:	1c53      	adds	r3, r2, #1
   1a588:	eba3 0309 	sub.w	r3, r3, r9
   1a58c:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a590:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
            fill_area2.x2 = area_outer->x2;
   1a594:	f8ad 2074 	strh.w	r2, [sp, #116]	; 0x74
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a598:	f1c3 0301 	rsb	r3, r3, #1
   1a59c:	4413      	add	r3, r2
   1a59e:	9a09      	ldr	r2, [sp, #36]	; 0x24
        for(h = draw_area.y1; h <= upper_corner_end; h++) {
   1a5a0:	3701      	adds	r7, #1
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a5a2:	1a9b      	subs	r3, r3, r2
   1a5a4:	f9bb 2010 	ldrsh.w	r2, [fp, #16]
   1a5a8:	1a9b      	subs	r3, r3, r2
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   1a5aa:	9a07      	ldr	r2, [sp, #28]
   1a5ac:	2b00      	cmp	r3, #0
   1a5ae:	bfac      	ite	ge
   1a5b0:	18e3      	addge	r3, r4, r3
   1a5b2:	1c23      	addlt	r3, r4, #0
   1a5b4:	9202      	str	r2, [sp, #8]
   1a5b6:	9a06      	ldr	r2, [sp, #24]
   1a5b8:	9201      	str	r2, [sp, #4]
   1a5ba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1a5bc:	9200      	str	r2, [sp, #0]
   1a5be:	462a      	mov	r2, r5
   1a5c0:	f7fd f80c 	bl	175dc <_lv_blend_fill>
            fill_area.y1++;
   1a5c4:	f8bd 306a 	ldrh.w	r3, [sp, #106]	; 0x6a
   1a5c8:	3301      	adds	r3, #1
   1a5ca:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            fill_area.y2++;
   1a5ce:	f8bd 306e 	ldrh.w	r3, [sp, #110]	; 0x6e
   1a5d2:	3301      	adds	r3, #1
   1a5d4:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        for(h = draw_area.y1; h <= upper_corner_end; h++) {
   1a5d8:	e477      	b.n	19eca <lv_draw_rect+0xed4>
            _lv_memset_ff(mask_buf, draw_area_w);
   1a5da:	4631      	mov	r1, r6
   1a5dc:	4620      	mov	r0, r4
   1a5de:	f7fe fc2c 	bl	18e3a <_lv_memset_ff>
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   1a5e2:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
   1a5e6:	f8bb 2012 	ldrh.w	r2, [fp, #18]
   1a5ea:	f8bb 1010 	ldrh.w	r1, [fp, #16]
   1a5ee:	443a      	add	r2, r7
   1a5f0:	4419      	add	r1, r3
   1a5f2:	b212      	sxth	r2, r2
   1a5f4:	4633      	mov	r3, r6
   1a5f6:	b209      	sxth	r1, r1
   1a5f8:	4620      	mov	r0, r4
   1a5fa:	f7f1 fb8b 	bl	bd14 <lv_draw_mask_apply>
            fill_area2.x1 = area_outer->x1;
   1a5fe:	9b05      	ldr	r3, [sp, #20]
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   1a600:	462a      	mov	r2, r5
            fill_area2.x1 = area_outer->x1;
   1a602:	f9b3 3000 	ldrsh.w	r3, [r3]
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   1a606:	a91c      	add	r1, sp, #112	; 0x70
            fill_area2.x1 = area_outer->x1;
   1a608:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
            fill_area2.x2 = area_outer->x1 + rout - 1;
   1a60c:	3b01      	subs	r3, #1
   1a60e:	444b      	add	r3, r9
   1a610:	f8ad 3074 	strh.w	r3, [sp, #116]	; 0x74
            fill_area2.y1 = fill_area.y1;
   1a614:	f8bd 306a 	ldrh.w	r3, [sp, #106]	; 0x6a
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   1a618:	4680      	mov	r8, r0
            fill_area2.y1 = fill_area.y1;
   1a61a:	f8ad 3072 	strh.w	r3, [sp, #114]	; 0x72
            fill_area2.y2 = fill_area.y2;
   1a61e:	f8bd 306e 	ldrh.w	r3, [sp, #110]	; 0x6e
   1a622:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
   1a626:	9b07      	ldr	r3, [sp, #28]
   1a628:	9302      	str	r3, [sp, #8]
   1a62a:	9b06      	ldr	r3, [sp, #24]
   1a62c:	e9cd 0300 	strd	r0, r3, [sp]
   1a630:	4623      	mov	r3, r4
   1a632:	4650      	mov	r0, sl
   1a634:	f7fc ffd2 	bl	175dc <_lv_blend_fill>
            if(fill_area2.y2 > area_outer->y2 - border_width) {
   1a638:	9b05      	ldr	r3, [sp, #20]
   1a63a:	9908      	ldr	r1, [sp, #32]
   1a63c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
   1a640:	f9bd 2076 	ldrsh.w	r2, [sp, #118]	; 0x76
   1a644:	1a5b      	subs	r3, r3, r1
   1a646:	429a      	cmp	r2, r3
   1a648:	dd16      	ble.n	1a678 <lv_draw_rect+0x1682>
                fill_area2.x1 = area_outer->x1 + rout;
   1a64a:	9b05      	ldr	r3, [sp, #20]
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   1a64c:	462a      	mov	r2, r5
                fill_area2.x1 = area_outer->x1 + rout;
   1a64e:	881b      	ldrh	r3, [r3, #0]
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   1a650:	4650      	mov	r0, sl
                fill_area2.x1 = area_outer->x1 + rout;
   1a652:	444b      	add	r3, r9
   1a654:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
                fill_area2.x2 = area_outer->x2 - rout;
   1a658:	9b05      	ldr	r3, [sp, #20]
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   1a65a:	a91c      	add	r1, sp, #112	; 0x70
                fill_area2.x2 = area_outer->x2 - rout;
   1a65c:	889b      	ldrh	r3, [r3, #4]
   1a65e:	eba3 0309 	sub.w	r3, r3, r9
   1a662:	f8ad 3074 	strh.w	r3, [sp, #116]	; 0x74
                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
   1a666:	9b07      	ldr	r3, [sp, #28]
   1a668:	9302      	str	r3, [sp, #8]
   1a66a:	9b06      	ldr	r3, [sp, #24]
   1a66c:	9301      	str	r3, [sp, #4]
   1a66e:	2301      	movs	r3, #1
   1a670:	9300      	str	r3, [sp, #0]
   1a672:	2300      	movs	r3, #0
   1a674:	f7fc ffb2 	bl	175dc <_lv_blend_fill>
            fill_area2.x1 = area_outer->x2 - rout + 1;
   1a678:	9b05      	ldr	r3, [sp, #20]
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   1a67a:	4650      	mov	r0, sl
            fill_area2.x1 = area_outer->x2 - rout + 1;
   1a67c:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   1a680:	a91c      	add	r1, sp, #112	; 0x70
            fill_area2.x1 = area_outer->x2 - rout + 1;
   1a682:	1c53      	adds	r3, r2, #1
   1a684:	eba3 0309 	sub.w	r3, r3, r9
   1a688:	f8ad 3070 	strh.w	r3, [sp, #112]	; 0x70
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a68c:	f9bd 3060 	ldrsh.w	r3, [sp, #96]	; 0x60
            fill_area2.x2 = area_outer->x2;
   1a690:	f8ad 2074 	strh.w	r2, [sp, #116]	; 0x74
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a694:	f1c3 0301 	rsb	r3, r3, #1
   1a698:	4413      	add	r3, r2
   1a69a:	9a09      	ldr	r2, [sp, #36]	; 0x24
        for(h = lower_corner_end; h <= draw_area.y2; h++) {
   1a69c:	3701      	adds	r7, #1
            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
   1a69e:	1a9b      	subs	r3, r3, r2
   1a6a0:	f9bb 2010 	ldrsh.w	r2, [fp, #16]
   1a6a4:	1a9b      	subs	r3, r3, r2
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
   1a6a6:	9a07      	ldr	r2, [sp, #28]
   1a6a8:	2b00      	cmp	r3, #0
   1a6aa:	bfac      	ite	ge
   1a6ac:	18e3      	addge	r3, r4, r3
   1a6ae:	1c23      	addlt	r3, r4, #0
   1a6b0:	9202      	str	r2, [sp, #8]
   1a6b2:	9a06      	ldr	r2, [sp, #24]
   1a6b4:	e9cd 8200 	strd	r8, r2, [sp]
   1a6b8:	462a      	mov	r2, r5
   1a6ba:	f7fc ff8f 	bl	175dc <_lv_blend_fill>
            fill_area.y1++;
   1a6be:	f8bd 306a 	ldrh.w	r3, [sp, #106]	; 0x6a
   1a6c2:	3301      	adds	r3, #1
   1a6c4:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            fill_area.y2++;
   1a6c8:	f8bd 306e 	ldrh.w	r3, [sp, #110]	; 0x6e
   1a6cc:	3301      	adds	r3, #1
   1a6ce:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        for(h = lower_corner_end; h <= draw_area.y2; h++) {
   1a6d2:	e40f      	b.n	19ef4 <lv_draw_rect+0xefe>
        fill_area.x1 = area_outer->x1;
   1a6d4:	9b05      	ldr	r3, [sp, #20]
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   1a6d6:	f9bd 7062 	ldrsh.w	r7, [sp, #98]	; 0x62
        fill_area.x1 = area_outer->x1;
   1a6da:	881b      	ldrh	r3, [r3, #0]
   1a6dc:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        fill_area.x2 = area_outer->x2;
   1a6e0:	9b05      	ldr	r3, [sp, #20]
   1a6e2:	889b      	ldrh	r3, [r3, #4]
   1a6e4:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   1a6e8:	f8bb 3012 	ldrh.w	r3, [fp, #18]
   1a6ec:	443b      	add	r3, r7
   1a6ee:	b21b      	sxth	r3, r3
   1a6f0:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
        fill_area.y2 = fill_area.y1;
   1a6f4:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a6f8:	f9bd 3066 	ldrsh.w	r3, [sp, #102]	; 0x66
   1a6fc:	429f      	cmp	r7, r3
   1a6fe:	f73f ac39 	bgt.w	19f74 <lv_draw_rect+0xf7e>
            _lv_memset_ff(mask_buf, draw_area_w);
   1a702:	4631      	mov	r1, r6
   1a704:	4620      	mov	r0, r4
   1a706:	f7fe fb98 	bl	18e3a <_lv_memset_ff>
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   1a70a:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
   1a70e:	f8bb 2012 	ldrh.w	r2, [fp, #18]
   1a712:	f8bb 1010 	ldrh.w	r1, [fp, #16]
   1a716:	443a      	add	r2, r7
   1a718:	4419      	add	r1, r3
   1a71a:	b212      	sxth	r2, r2
   1a71c:	4633      	mov	r3, r6
   1a71e:	b209      	sxth	r1, r1
   1a720:	4620      	mov	r0, r4
   1a722:	f7f1 faf7 	bl	bd14 <lv_draw_mask_apply>
            _lv_blend_fill(clip, &fill_area, color, mask_buf, mask_res, opa, blend_mode);
   1a726:	9b07      	ldr	r3, [sp, #28]
   1a728:	462a      	mov	r2, r5
   1a72a:	9302      	str	r3, [sp, #8]
   1a72c:	9b06      	ldr	r3, [sp, #24]
   1a72e:	a91a      	add	r1, sp, #104	; 0x68
   1a730:	e9cd 0300 	strd	r0, r3, [sp]
   1a734:	4623      	mov	r3, r4
   1a736:	4650      	mov	r0, sl
   1a738:	f7fc ff50 	bl	175dc <_lv_blend_fill>
            fill_area.y1++;
   1a73c:	f8bd 306a 	ldrh.w	r3, [sp, #106]	; 0x6a
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a740:	3701      	adds	r7, #1
            fill_area.y1++;
   1a742:	3301      	adds	r3, #1
   1a744:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
            fill_area.y2++;
   1a748:	f8bd 306e 	ldrh.w	r3, [sp, #110]	; 0x6e
   1a74c:	3301      	adds	r3, #1
   1a74e:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a752:	e7d1      	b.n	1a6f8 <lv_draw_rect+0x1702>
        if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
   1a754:	9b06      	ldr	r3, [sp, #24]
   1a756:	2bfe      	cmp	r3, #254	; 0xfe
   1a758:	bf28      	it	cs
   1a75a:	23ff      	movcs	r3, #255	; 0xff
   1a75c:	9306      	str	r3, [sp, #24]
        lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
   1a75e:	f7ef ff5f 	bl	a620 <_lv_refr_get_disp_refreshing>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1a762:	f000 f9af 	bl	1aac4 <lv_disp_get_buf>
        is_common = _lv_area_intersect(&draw_area, coords, clip);
   1a766:	4652      	mov	r2, sl
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
   1a768:	4607      	mov	r7, r0
        is_common = _lv_area_intersect(&draw_area, coords, clip);
   1a76a:	9905      	ldr	r1, [sp, #20]
   1a76c:	a81a      	add	r0, sp, #104	; 0x68
   1a76e:	f000 fa95 	bl	1ac9c <_lv_area_intersect>
        if(is_common == false) return;
   1a772:	2800      	cmp	r0, #0
   1a774:	f43f ac07 	beq.w	19f86 <lv_draw_rect+0xf90>
        draw_area.x1 -= disp_area->x1;
   1a778:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
   1a77c:	f9bd 0068 	ldrsh.w	r0, [sp, #104]	; 0x68
        draw_area.y1 -= disp_area->y1;
   1a780:	f9b7 5012 	ldrsh.w	r5, [r7, #18]
        draw_area.x1 -= disp_area->x1;
   1a784:	1a83      	subs	r3, r0, r2
   1a786:	f8ad 3068 	strh.w	r3, [sp, #104]	; 0x68
        draw_area.x2 -= disp_area->x1;
   1a78a:	f9bd 306c 	ldrsh.w	r3, [sp, #108]	; 0x6c
        draw_area.y1 -= disp_area->y1;
   1a78e:	f8bd 106a 	ldrh.w	r1, [sp, #106]	; 0x6a
        draw_area.x2 -= disp_area->x1;
   1a792:	1a9a      	subs	r2, r3, r2
   1a794:	f8ad 206c 	strh.w	r2, [sp, #108]	; 0x6c
        draw_area.y2 -= disp_area->y1;
   1a798:	f8bd 206e 	ldrh.w	r2, [sp, #110]	; 0x6e
        draw_area.y1 -= disp_area->y1;
   1a79c:	1b49      	subs	r1, r1, r5
        draw_area.y2 -= disp_area->y1;
   1a79e:	1b52      	subs	r2, r2, r5
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1a7a0:	1c5d      	adds	r5, r3, #1
   1a7a2:	1a2d      	subs	r5, r5, r0
   1a7a4:	b22d      	sxth	r5, r5
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   1a7a6:	4628      	mov	r0, r5
        draw_area.y1 -= disp_area->y1;
   1a7a8:	f8ad 106a 	strh.w	r1, [sp, #106]	; 0x6a
        draw_area.y2 -= disp_area->y1;
   1a7ac:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   1a7b0:	f7f2 f9a4 	bl	cafc <_lv_mem_buf_get>
        if(rout > 0) {
   1a7b4:	f1bb 0f00 	cmp.w	fp, #0
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
   1a7b8:	4680      	mov	r8, r0
        if(rout > 0) {
   1a7ba:	fa0f f68b 	sxth.w	r6, fp
   1a7be:	dd3c      	ble.n	1a83a <lv_draw_rect+0x1844>
            lv_draw_mask_radius_init(&mask_rout_param, coords, rout, false);
   1a7c0:	2300      	movs	r3, #0
   1a7c2:	4632      	mov	r2, r6
   1a7c4:	9905      	ldr	r1, [sp, #20]
   1a7c6:	a81e      	add	r0, sp, #120	; 0x78
   1a7c8:	f7f1 fb7e 	bl	bec8 <lv_draw_mask_radius_init>
            mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
   1a7cc:	2100      	movs	r1, #0
   1a7ce:	a81e      	add	r0, sp, #120	; 0x78
   1a7d0:	f7f1 fa8a 	bl	bce8 <lv_draw_mask_add>
   1a7d4:	4681      	mov	r9, r0
        lv_draw_mask_radius_init(&mask_rin_param, &area_inner, rout - dsc->border_width, true);
   1a7d6:	8b22      	ldrh	r2, [r4, #24]
   1a7d8:	2301      	movs	r3, #1
   1a7da:	1ab2      	subs	r2, r6, r2
   1a7dc:	b212      	sxth	r2, r2
   1a7de:	a916      	add	r1, sp, #88	; 0x58
   1a7e0:	a825      	add	r0, sp, #148	; 0x94
   1a7e2:	f7f1 fb71 	bl	bec8 <lv_draw_mask_radius_init>
        int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   1a7e6:	2100      	movs	r1, #0
   1a7e8:	a825      	add	r0, sp, #148	; 0x94
   1a7ea:	f7f1 fa7d 	bl	bce8 <lv_draw_mask_add>
        int32_t corner_size = LV_MATH_MAX(rout, dsc->border_width - 1);
   1a7ee:	f9b4 6018 	ldrsh.w	r6, [r4, #24]
        lv_color_t color = dsc->border_color;
   1a7f2:	6963      	ldr	r3, [r4, #20]
        int32_t corner_size = LV_MATH_MAX(rout, dsc->border_width - 1);
   1a7f4:	3e01      	subs	r6, #1
   1a7f6:	455e      	cmp	r6, fp
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   1a7f8:	8a7a      	ldrh	r2, [r7, #18]
        int32_t corner_size = LV_MATH_MAX(rout, dsc->border_width - 1);
   1a7fa:	bfb8      	it	lt
   1a7fc:	465e      	movlt	r6, fp
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   1a7fe:	f9bd b06a 	ldrsh.w	fp, [sp, #106]	; 0x6a
        lv_color_t color = dsc->border_color;
   1a802:	9309      	str	r3, [sp, #36]	; 0x24
        lv_blend_mode_t blend_mode = dsc->border_blend_mode;
   1a804:	7f63      	ldrb	r3, [r4, #29]
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   1a806:	445a      	add	r2, fp
   1a808:	b212      	sxth	r2, r2
        lv_blend_mode_t blend_mode = dsc->border_blend_mode;
   1a80a:	9308      	str	r3, [sp, #32]
        fill_area.x1 = coords->x1;
   1a80c:	9b05      	ldr	r3, [sp, #20]
        fill_area.y1 = disp_area->y1 + draw_area.y1;
   1a80e:	f8ad 2072 	strh.w	r2, [sp, #114]	; 0x72
        fill_area.y2 = fill_area.y1;
   1a812:	f8ad 2076 	strh.w	r2, [sp, #118]	; 0x76
        if(dsc->border_side == LV_BORDER_SIDE_LEFT) fill_area.x2 = coords->x1 + corner_size;
   1a816:	f9b4 201a 	ldrsh.w	r2, [r4, #26]
        fill_area.x1 = coords->x1;
   1a81a:	f9b3 1000 	ldrsh.w	r1, [r3]
        fill_area.x2 = coords->x2;
   1a81e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
        if(dsc->border_side == LV_BORDER_SIDE_LEFT) fill_area.x2 = coords->x1 + corner_size;
   1a822:	2a04      	cmp	r2, #4
        int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
   1a824:	9007      	str	r0, [sp, #28]
        fill_area.x1 = coords->x1;
   1a826:	f8ad 1070 	strh.w	r1, [sp, #112]	; 0x70
        fill_area.x2 = coords->x2;
   1a82a:	f8ad 3074 	strh.w	r3, [sp, #116]	; 0x74
        if(dsc->border_side == LV_BORDER_SIDE_LEFT) fill_area.x2 = coords->x1 + corner_size;
   1a82e:	d107      	bne.n	1a840 <lv_draw_rect+0x184a>
   1a830:	198c      	adds	r4, r1, r6
   1a832:	f8ad 4074 	strh.w	r4, [sp, #116]	; 0x74
        uint32_t buf_ofs = 0;
   1a836:	2400      	movs	r4, #0
   1a838:	e009      	b.n	1a84e <lv_draw_rect+0x1858>
        int16_t mask_rout_id = LV_MASK_ID_INV;
   1a83a:	f04f 39ff 	mov.w	r9, #4294967295
   1a83e:	e7ca      	b.n	1a7d6 <lv_draw_rect+0x17e0>
        else if(dsc->border_side == LV_BORDER_SIDE_RIGHT) {
   1a840:	2a08      	cmp	r2, #8
   1a842:	d1f8      	bne.n	1a836 <lv_draw_rect+0x1840>
            fill_area.x1 = coords->x2 - corner_size;
   1a844:	1b9c      	subs	r4, r3, r6
   1a846:	b224      	sxth	r4, r4
   1a848:	f8ad 4070 	strh.w	r4, [sp, #112]	; 0x70
            buf_ofs = fill_area.x1 - coords->x1;
   1a84c:	1a64      	subs	r4, r4, r1
        volatile bool top_only = false;
   1a84e:	2300      	movs	r3, #0
        if(dsc->border_side == LV_BORDER_SIDE_TOP) top_only = true;
   1a850:	2a02      	cmp	r2, #2
        volatile bool top_only = false;
   1a852:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
        volatile bool bottom_only = false;
   1a856:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
        if(dsc->border_side == LV_BORDER_SIDE_TOP) top_only = true;
   1a85a:	d11b      	bne.n	1a894 <lv_draw_rect+0x189e>
   1a85c:	2301      	movs	r3, #1
   1a85e:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
        volatile bool normal = !top_only && !bottom_only ? true : false;
   1a862:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
   1a866:	bb13      	cbnz	r3, 1a8ae <lv_draw_rect+0x18b8>
   1a868:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
   1a86c:	f083 0301 	eor.w	r3, r3, #1
   1a870:	f003 0301 	and.w	r3, r3, #1
   1a874:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
                _lv_blend_fill(clip, &fill_area, color, mask_buf + buf_ofs, mask_res, opa, blend_mode);
   1a878:	4444      	add	r4, r8
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a87a:	f9bd 306e 	ldrsh.w	r3, [sp, #110]	; 0x6e
   1a87e:	459b      	cmp	fp, r3
   1a880:	dd17      	ble.n	1a8b2 <lv_draw_rect+0x18bc>
        lv_draw_mask_remove_id(mask_rin_id);
   1a882:	9807      	ldr	r0, [sp, #28]
   1a884:	f7f1 fa68 	bl	bd58 <lv_draw_mask_remove_id>
        lv_draw_mask_remove_id(mask_rout_id);
   1a888:	4648      	mov	r0, r9
   1a88a:	f7f1 fa65 	bl	bd58 <lv_draw_mask_remove_id>
        _lv_mem_buf_release(mask_buf);
   1a88e:	4640      	mov	r0, r8
   1a890:	f7ff bb77 	b.w	19f82 <lv_draw_rect+0xf8c>
        if(dsc->border_side == LV_BORDER_SIDE_BOTTOM) bottom_only = true;
   1a894:	2a01      	cmp	r2, #1
   1a896:	d007      	beq.n	1a8a8 <lv_draw_rect+0x18b2>
        if(dsc->border_side == (LV_BORDER_SIDE_TOP | LV_BORDER_SIDE_BOTTOM)) {
   1a898:	2a03      	cmp	r2, #3
   1a89a:	d1e2      	bne.n	1a862 <lv_draw_rect+0x186c>
            top_only = true;
   1a89c:	2301      	movs	r3, #1
   1a89e:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
            bottom_only = true;
   1a8a2:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
   1a8a6:	e7dc      	b.n	1a862 <lv_draw_rect+0x186c>
        if(dsc->border_side == LV_BORDER_SIDE_BOTTOM) bottom_only = true;
   1a8a8:	f88d 2050 	strb.w	r2, [sp, #80]	; 0x50
        if(dsc->border_side == (LV_BORDER_SIDE_TOP | LV_BORDER_SIDE_BOTTOM)) {
   1a8ac:	e7d9      	b.n	1a862 <lv_draw_rect+0x186c>
        volatile bool normal = !top_only && !bottom_only ? true : false;
   1a8ae:	2300      	movs	r3, #0
   1a8b0:	e7de      	b.n	1a870 <lv_draw_rect+0x187a>
            if(normal ||
   1a8b2:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
   1a8b6:	b99b      	cbnz	r3, 1a8e0 <lv_draw_rect+0x18ea>
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
   1a8b8:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
   1a8bc:	f9bd 2072 	ldrsh.w	r2, [sp, #114]	; 0x72
            if(normal ||
   1a8c0:	b12b      	cbz	r3, 1a8ce <lv_draw_rect+0x18d8>
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
   1a8c2:	9b05      	ldr	r3, [sp, #20]
   1a8c4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
   1a8c8:	4433      	add	r3, r6
   1a8ca:	429a      	cmp	r2, r3
   1a8cc:	dd08      	ble.n	1a8e0 <lv_draw_rect+0x18ea>
               (bottom_only && fill_area.y1 >= coords->y2 - corner_size)) {
   1a8ce:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
   1a8d2:	b303      	cbz	r3, 1a916 <lv_draw_rect+0x1920>
               (bottom_only && fill_area.y1 >= coords->y2 - corner_size)) {
   1a8d4:	9b05      	ldr	r3, [sp, #20]
   1a8d6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
   1a8da:	1b9b      	subs	r3, r3, r6
   1a8dc:	429a      	cmp	r2, r3
   1a8de:	db1a      	blt.n	1a916 <lv_draw_rect+0x1920>
                _lv_memset_ff(mask_buf, draw_area_w);
   1a8e0:	4629      	mov	r1, r5
   1a8e2:	4640      	mov	r0, r8
   1a8e4:	f7fe faa9 	bl	18e3a <_lv_memset_ff>
                mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
   1a8e8:	f8bd 3068 	ldrh.w	r3, [sp, #104]	; 0x68
   1a8ec:	8a7a      	ldrh	r2, [r7, #18]
   1a8ee:	8a39      	ldrh	r1, [r7, #16]
   1a8f0:	445a      	add	r2, fp
   1a8f2:	4419      	add	r1, r3
   1a8f4:	b212      	sxth	r2, r2
   1a8f6:	462b      	mov	r3, r5
   1a8f8:	b209      	sxth	r1, r1
   1a8fa:	4640      	mov	r0, r8
   1a8fc:	f7f1 fa0a 	bl	bd14 <lv_draw_mask_apply>
                _lv_blend_fill(clip, &fill_area, color, mask_buf + buf_ofs, mask_res, opa, blend_mode);
   1a900:	9b08      	ldr	r3, [sp, #32]
   1a902:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1a904:	9302      	str	r3, [sp, #8]
   1a906:	9b06      	ldr	r3, [sp, #24]
   1a908:	a91c      	add	r1, sp, #112	; 0x70
   1a90a:	e9cd 0300 	strd	r0, r3, [sp]
   1a90e:	4623      	mov	r3, r4
   1a910:	4650      	mov	r0, sl
   1a912:	f7fc fe63 	bl	175dc <_lv_blend_fill>
            fill_area.y1++;
   1a916:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a91a:	f10b 0b01 	add.w	fp, fp, #1
            fill_area.y1++;
   1a91e:	3301      	adds	r3, #1
   1a920:	f8ad 3072 	strh.w	r3, [sp, #114]	; 0x72
            fill_area.y2++;
   1a924:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   1a928:	3301      	adds	r3, #1
   1a92a:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
   1a92e:	e7a4      	b.n	1a87a <lv_draw_rect+0x1884>
            if(grad_dir == LV_GRAD_DIR_VER) {
   1a930:	2e01      	cmp	r6, #1
            opa2 = opa;
   1a932:	46d9      	mov	r9, fp
            if(grad_dir == LV_GRAD_DIR_VER) {
   1a934:	f43f ada2 	beq.w	1a47c <lv_draw_rect+0x1486>
                mask_res = LV_DRAW_MASK_RES_FULL_COVER;
   1a938:	2701      	movs	r7, #1
   1a93a:	e53d      	b.n	1a3b8 <lv_draw_rect+0x13c2>

0001a93c <_lv_img_buf_get_transformed_area>:
    res->y2 = LV_MATH_MAX4(lb.y, lt.y, rb.y, rt.y);
#else
    LV_UNUSED(angle);
    LV_UNUSED(zoom);
    LV_UNUSED(pivot);
    res->x1 = 0;
   1a93c:	2300      	movs	r3, #0
    res->y1 = 0;
    res->x2 = w - 1;
   1a93e:	3901      	subs	r1, #1
    res->y2 = h - 1;
   1a940:	3a01      	subs	r2, #1
    res->x1 = 0;
   1a942:	8003      	strh	r3, [r0, #0]
    res->y1 = 0;
   1a944:	8043      	strh	r3, [r0, #2]
    res->x2 = w - 1;
   1a946:	8081      	strh	r1, [r0, #4]
    res->y2 = h - 1;
   1a948:	80c2      	strh	r2, [r0, #6]
#endif
}
   1a94a:	4770      	bx	lr

0001a94c <_lv_memset_00>:
{
   1a94c:	460a      	mov	r2, r1
__ssp_bos_icheck3(memset, void *, int)
   1a94e:	2100      	movs	r1, #0
   1a950:	f003 b814 	b.w	1d97c <memset>

0001a954 <lv_img_decoder_built_in_close>:
{
   1a954:	b538      	push	{r3, r4, r5, lr}
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
   1a956:	6a0d      	ldr	r5, [r1, #32]
{
   1a958:	460c      	mov	r4, r1
    if(user_data) {
   1a95a:	b165      	cbz	r5, 1a976 <lv_img_decoder_built_in_close+0x22>
        if(user_data->palette) lv_mem_free(user_data->palette);
   1a95c:	6828      	ldr	r0, [r5, #0]
   1a95e:	b108      	cbz	r0, 1a964 <lv_img_decoder_built_in_close+0x10>
   1a960:	f7f2 f8ae 	bl	cac0 <lv_mem_free>
        if(user_data->opa) lv_mem_free(user_data->opa);
   1a964:	6868      	ldr	r0, [r5, #4]
   1a966:	b108      	cbz	r0, 1a96c <lv_img_decoder_built_in_close+0x18>
   1a968:	f7f2 f8aa 	bl	cac0 <lv_mem_free>
        lv_mem_free(user_data);
   1a96c:	4628      	mov	r0, r5
   1a96e:	f7f2 f8a7 	bl	cac0 <lv_mem_free>
        dsc->user_data = NULL;
   1a972:	2300      	movs	r3, #0
   1a974:	6223      	str	r3, [r4, #32]
}
   1a976:	bd38      	pop	{r3, r4, r5, pc}

0001a978 <_lv_memset_00>:
   1a978:	460a      	mov	r2, r1
   1a97a:	2100      	movs	r1, #0
   1a97c:	f002 bffe 	b.w	1d97c <memset>

0001a980 <lv_img_decoder_built_in_open>:
{
   1a980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   1a984:	7b0a      	ldrb	r2, [r1, #12]
{
   1a986:	4607      	mov	r7, r0
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   1a988:	2a01      	cmp	r2, #1
{
   1a98a:	460c      	mov	r4, r1
    if(dsc->src_type == LV_IMG_SRC_FILE) {
   1a98c:	d101      	bne.n	1a992 <lv_img_decoder_built_in_open+0x12>
                return LV_RES_INV;
   1a98e:	2000      	movs	r0, #0
   1a990:	e010      	b.n	1a9b4 <lv_img_decoder_built_in_open+0x34>
    else if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   1a992:	b91a      	cbnz	r2, 1a99c <lv_img_decoder_built_in_open+0x1c>
        if(((lv_img_dsc_t *)dsc->src)->data == NULL) {
   1a994:	684b      	ldr	r3, [r1, #4]
   1a996:	689b      	ldr	r3, [r3, #8]
   1a998:	2b00      	cmp	r3, #0
   1a99a:	d0f8      	beq.n	1a98e <lv_img_decoder_built_in_open+0xe>
    lv_img_cf_t cf = dsc->header.cf;
   1a99c:	7c23      	ldrb	r3, [r4, #16]
   1a99e:	f003 001f 	and.w	r0, r3, #31
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
   1a9a2:	1f03      	subs	r3, r0, #4
   1a9a4:	2b02      	cmp	r3, #2
   1a9a6:	d807      	bhi.n	1a9b8 <lv_img_decoder_built_in_open+0x38>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
   1a9a8:	2a00      	cmp	r2, #0
   1a9aa:	d137      	bne.n	1aa1c <lv_img_decoder_built_in_open+0x9c>
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
   1a9ac:	6863      	ldr	r3, [r4, #4]
   1a9ae:	689b      	ldr	r3, [r3, #8]
            return LV_RES_OK;
   1a9b0:	2001      	movs	r0, #1
            dsc->img_data = NULL;
   1a9b2:	6163      	str	r3, [r4, #20]
}
   1a9b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
   1a9b8:	1fc3      	subs	r3, r0, #7
   1a9ba:	2b03      	cmp	r3, #3
   1a9bc:	d846      	bhi.n	1aa4c <lv_img_decoder_built_in_open+0xcc>
        uint8_t px_size       = lv_img_cf_get_px_size(cf);
   1a9be:	f7f0 f84f 	bl	aa60 <lv_img_cf_get_px_size>
        uint32_t palette_size = 1 << px_size;
   1a9c2:	2601      	movs	r6, #1
        if(dsc->user_data == NULL) {
   1a9c4:	6a23      	ldr	r3, [r4, #32]
        uint8_t px_size       = lv_img_cf_get_px_size(cf);
   1a9c6:	4680      	mov	r8, r0
        uint32_t palette_size = 1 << px_size;
   1a9c8:	4086      	lsls	r6, r0
        if(dsc->user_data == NULL) {
   1a9ca:	b963      	cbnz	r3, 1a9e6 <lv_img_decoder_built_in_open+0x66>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
   1a9cc:	2008      	movs	r0, #8
   1a9ce:	f7f2 f863 	bl	ca98 <lv_mem_alloc>
   1a9d2:	6220      	str	r0, [r4, #32]
            if(dsc->user_data == NULL) {
   1a9d4:	b920      	cbnz	r0, 1a9e0 <lv_img_decoder_built_in_open+0x60>
                lv_img_decoder_built_in_close(decoder, dsc);
   1a9d6:	4621      	mov	r1, r4
   1a9d8:	4638      	mov	r0, r7
   1a9da:	f7ff ffbb 	bl	1a954 <lv_img_decoder_built_in_close>
   1a9de:	e7d6      	b.n	1a98e <lv_img_decoder_built_in_open+0xe>
            _lv_memset_00(dsc->user_data, sizeof(lv_img_decoder_built_in_data_t));
   1a9e0:	2108      	movs	r1, #8
   1a9e2:	f7ff ffc9 	bl	1a978 <_lv_memset_00>
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
   1a9e6:	2004      	movs	r0, #4
   1a9e8:	fa00 f008 	lsl.w	r0, r0, r8
        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
   1a9ec:	6a25      	ldr	r5, [r4, #32]
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
   1a9ee:	f7f2 f853 	bl	ca98 <lv_mem_alloc>
   1a9f2:	6028      	str	r0, [r5, #0]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
   1a9f4:	4630      	mov	r0, r6
   1a9f6:	f7f2 f84f 	bl	ca98 <lv_mem_alloc>
        if(user_data->palette == NULL || user_data->opa == NULL) {
   1a9fa:	682b      	ldr	r3, [r5, #0]
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
   1a9fc:	6068      	str	r0, [r5, #4]
        if(user_data->palette == NULL || user_data->opa == NULL) {
   1a9fe:	2b00      	cmp	r3, #0
   1aa00:	d0e9      	beq.n	1a9d6 <lv_img_decoder_built_in_open+0x56>
   1aa02:	2800      	cmp	r0, #0
   1aa04:	d0e7      	beq.n	1a9d6 <lv_img_decoder_built_in_open+0x56>
        if(dsc->src_type == LV_IMG_SRC_FILE) {
   1aa06:	7b23      	ldrb	r3, [r4, #12]
   1aa08:	2b01      	cmp	r3, #1
   1aa0a:	d0c0      	beq.n	1a98e <lv_img_decoder_built_in_open+0xe>
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
   1aa0c:	6863      	ldr	r3, [r4, #4]
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
   1aa0e:	27ff      	movs	r7, #255	; 0xff
   1aa10:	689a      	ldr	r2, [r3, #8]
            for(i = 0; i < palette_size; i++) {
   1aa12:	2300      	movs	r3, #0
   1aa14:	42b3      	cmp	r3, r6
   1aa16:	f102 0204 	add.w	r2, r2, #4
   1aa1a:	d101      	bne.n	1aa20 <lv_img_decoder_built_in_open+0xa0>
            dsc->img_data = NULL;
   1aa1c:	2300      	movs	r3, #0
   1aa1e:	e7c7      	b.n	1a9b0 <lv_img_decoder_built_in_open+0x30>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
   1aa20:	6828      	ldr	r0, [r5, #0]
   1aa22:	f812 cc02 	ldrb.w	ip, [r2, #-2]
   1aa26:	f812 ec03 	ldrb.w	lr, [r2, #-3]
   1aa2a:	f812 8c04 	ldrb.w	r8, [r2, #-4]
   1aa2e:	eb00 0183 	add.w	r1, r0, r3, lsl #2
   1aa32:	f800 8023 	strb.w	r8, [r0, r3, lsl #2]
   1aa36:	f881 e001 	strb.w	lr, [r1, #1]
   1aa3a:	f881 c002 	strb.w	ip, [r1, #2]
   1aa3e:	70cf      	strb	r7, [r1, #3]
                user_data->opa[i]     = palette_p[i].ch.alpha;
   1aa40:	f812 0c01 	ldrb.w	r0, [r2, #-1]
   1aa44:	6869      	ldr	r1, [r5, #4]
   1aa46:	54c8      	strb	r0, [r1, r3]
            for(i = 0; i < palette_size; i++) {
   1aa48:	3301      	adds	r3, #1
   1aa4a:	e7e3      	b.n	1aa14 <lv_img_decoder_built_in_open+0x94>
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
   1aa4c:	f1a0 030b 	sub.w	r3, r0, #11
   1aa50:	2b03      	cmp	r3, #3
   1aa52:	d9e3      	bls.n	1aa1c <lv_img_decoder_built_in_open+0x9c>
   1aa54:	e7bf      	b.n	1a9d6 <lv_img_decoder_built_in_open+0x56>

0001aa56 <lv_img_decoder_read_line>:
{
   1aa56:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1aa58:	4605      	mov	r5, r0
    if(dsc->decoder->read_line_cb) res = dsc->decoder->read_line_cb(dsc->decoder, dsc, x, y, len, buf);
   1aa5a:	6800      	ldr	r0, [r0, #0]
   1aa5c:	6884      	ldr	r4, [r0, #8]
   1aa5e:	b144      	cbz	r4, 1aa72 <lv_img_decoder_read_line+0x1c>
   1aa60:	9e06      	ldr	r6, [sp, #24]
   1aa62:	e9cd 3600 	strd	r3, r6, [sp]
   1aa66:	4613      	mov	r3, r2
   1aa68:	460a      	mov	r2, r1
   1aa6a:	4629      	mov	r1, r5
   1aa6c:	47a0      	blx	r4
}
   1aa6e:	b002      	add	sp, #8
   1aa70:	bd70      	pop	{r4, r5, r6, pc}
    lv_res_t res = LV_RES_INV;
   1aa72:	4620      	mov	r0, r4
   1aa74:	e7fb      	b.n	1aa6e <lv_img_decoder_read_line+0x18>

0001aa76 <lv_img_decoder_close>:
{
   1aa76:	b510      	push	{r4, lr}
   1aa78:	4604      	mov	r4, r0
    if(dsc->decoder) {
   1aa7a:	6800      	ldr	r0, [r0, #0]
   1aa7c:	b158      	cbz	r0, 1aa96 <lv_img_decoder_close+0x20>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
   1aa7e:	68c3      	ldr	r3, [r0, #12]
   1aa80:	b10b      	cbz	r3, 1aa86 <lv_img_decoder_close+0x10>
   1aa82:	4621      	mov	r1, r4
   1aa84:	4798      	blx	r3
        if(dsc->src_type == LV_IMG_SRC_FILE) {
   1aa86:	7b23      	ldrb	r3, [r4, #12]
   1aa88:	2b01      	cmp	r3, #1
   1aa8a:	d104      	bne.n	1aa96 <lv_img_decoder_close+0x20>
            lv_mem_free(dsc->src);
   1aa8c:	6860      	ldr	r0, [r4, #4]
   1aa8e:	f7f2 f817 	bl	cac0 <lv_mem_free>
            dsc->src = NULL;
   1aa92:	2300      	movs	r3, #0
   1aa94:	6063      	str	r3, [r4, #4]
}
   1aa96:	bd10      	pop	{r4, pc}

0001aa98 <_lv_memset_00>:
   1aa98:	460a      	mov	r2, r1
   1aa9a:	2100      	movs	r1, #0
   1aa9c:	f002 bf6e 	b.w	1d97c <memset>

0001aaa0 <lv_disp_buf_init>:
{
   1aaa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1aaa2:	4604      	mov	r4, r0
   1aaa4:	460d      	mov	r5, r1
   1aaa6:	4617      	mov	r7, r2
   1aaa8:	461e      	mov	r6, r3
    _lv_memset_00(disp_buf, sizeof(lv_disp_buf_t));
   1aaaa:	2124      	movs	r1, #36	; 0x24
   1aaac:	f7ff fff4 	bl	1aa98 <_lv_memset_00>
    disp_buf->buf2    = buf2;
   1aab0:	e9c4 5700 	strd	r5, r7, [r4]
    disp_buf->size    = size_in_px_cnt;
   1aab4:	e9c4 5602 	strd	r5, r6, [r4, #8]
}
   1aab8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001aaba <lv_disp_flush_ready>:
    disp_drv->buffer->flushing = 0;
   1aaba:	2200      	movs	r2, #0
   1aabc:	6843      	ldr	r3, [r0, #4]
   1aabe:	619a      	str	r2, [r3, #24]
    disp_drv->buffer->flushing_last = 0;
   1aac0:	61da      	str	r2, [r3, #28]
}
   1aac2:	4770      	bx	lr

0001aac4 <lv_disp_get_buf>:
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
    return disp->driver.buffer;
}
   1aac4:	6840      	ldr	r0, [r0, #4]
   1aac6:	4770      	bx	lr

0001aac8 <lv_disp_get_inv_buf_size>:
 * Get the number of areas in the buffer
 * @return number of invalid areas
 */
uint16_t lv_disp_get_inv_buf_size(lv_disp_t * disp)
{
    return disp->inv_p;
   1aac8:	f8b0 017e 	ldrh.w	r0, [r0, #382]	; 0x17e
}
   1aacc:	f3c0 0009 	ubfx	r0, r0, #0, #10
   1aad0:	4770      	bx	lr

0001aad2 <_lv_disp_pop_from_inv_buf>:
 * @param num number of areas to delete
 */
void _lv_disp_pop_from_inv_buf(lv_disp_t * disp, uint16_t num)
{

    if(disp->inv_p < num)
   1aad2:	f8b0 317e 	ldrh.w	r3, [r0, #382]	; 0x17e
   1aad6:	f3c3 0309 	ubfx	r3, r3, #0, #10
   1aada:	428b      	cmp	r3, r1
        disp->inv_p = 0;
   1aadc:	bfb4      	ite	lt
   1aade:	2100      	movlt	r1, #0
    else
        disp->inv_p -= num;
   1aae0:	1a59      	subge	r1, r3, r1
   1aae2:	f8b0 317e 	ldrh.w	r3, [r0, #382]	; 0x17e
   1aae6:	bfa8      	it	ge
   1aae8:	f3c1 0109 	ubfxge	r1, r1, #0, #10
   1aaec:	f361 0309 	bfi	r3, r1, #0, #10
   1aaf0:	f8a0 317e 	strh.w	r3, [r0, #382]	; 0x17e
}
   1aaf4:	4770      	bx	lr

0001aaf6 <lv_disp_is_double_buf>:
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
   1aaf6:	6843      	ldr	r3, [r0, #4]
   1aaf8:	6818      	ldr	r0, [r3, #0]
   1aafa:	b118      	cbz	r0, 1ab04 <lv_disp_is_double_buf+0xe>
   1aafc:	6858      	ldr	r0, [r3, #4]
   1aafe:	3800      	subs	r0, #0
   1ab00:	bf18      	it	ne
   1ab02:	2001      	movne	r0, #1
        return true;
    else
        return false;
}
   1ab04:	4770      	bx	lr

0001ab06 <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
   1ab06:	b508      	push	{r3, lr}
   1ab08:	4602      	mov	r2, r0
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
   1ab0a:	f7ff fff4 	bl	1aaf6 <lv_disp_is_double_buf>
   1ab0e:	b140      	cbz	r0, 1ab22 <lv_disp_is_true_double_buf+0x1c>
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
   1ab10:	8853      	ldrh	r3, [r2, #2]
   1ab12:	8810      	ldrh	r0, [r2, #0]
   1ab14:	fb10 f003 	smulbb	r0, r0, r3
    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
   1ab18:	6853      	ldr	r3, [r2, #4]
   1ab1a:	68db      	ldr	r3, [r3, #12]
   1ab1c:	1ac3      	subs	r3, r0, r3
   1ab1e:	4258      	negs	r0, r3
   1ab20:	4158      	adcs	r0, r3
        return true;
    }
    else {
        return false;
    }
}
   1ab22:	bd08      	pop	{r3, pc}

0001ab24 <_lv_memset_00>:
   1ab24:	460a      	mov	r2, r1
   1ab26:	2100      	movs	r1, #0
   1ab28:	f002 bf28 	b.w	1d97c <memset>

0001ab2c <_lv_indev_read>:
 * @param indev pointer to an input device
 * @param data input device will write its data here
 * @return false: no more data; true: there more data to read (buffered)
 */
bool _lv_indev_read(lv_indev_t * indev, lv_indev_data_t * data)
{
   1ab2c:	b570      	push	{r4, r5, r6, lr}
   1ab2e:	460c      	mov	r4, r1
   1ab30:	4605      	mov	r5, r0
    bool cont = false;

    _lv_memset_00(data, sizeof(lv_indev_data_t));
   1ab32:	2110      	movs	r1, #16
   1ab34:	4620      	mov	r0, r4
   1ab36:	f7ff fff5 	bl	1ab24 <_lv_memset_00>

    /* For touchpad sometimes users don't the last pressed coordinate on release.
     * So be sure a coordinates are initialized to the last point */
    if(indev->driver.type == LV_INDEV_TYPE_POINTER) {
   1ab3a:	782b      	ldrb	r3, [r5, #0]
   1ab3c:	2b01      	cmp	r3, #1
   1ab3e:	d10a      	bne.n	1ab56 <_lv_indev_read+0x2a>
        data->point.x = indev->proc.types.pointer.act_point.x;
   1ab40:	8cab      	ldrh	r3, [r5, #36]	; 0x24
   1ab42:	8023      	strh	r3, [r4, #0]
        data->point.y = indev->proc.types.pointer.act_point.y;
   1ab44:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
   1ab46:	8063      	strh	r3, [r4, #2]
    else if(indev->driver.type == LV_INDEV_TYPE_ENCODER) {
        data->key = LV_KEY_ENTER;
        data->enc_diff = 0;
    }

    if(indev->driver.read_cb) {
   1ab48:	686b      	ldr	r3, [r5, #4]
   1ab4a:	b183      	cbz	r3, 1ab6e <_lv_indev_read+0x42>
        LV_LOG_TRACE("idnev read started");
        cont = indev->driver.read_cb(&indev->driver, data);
   1ab4c:	4621      	mov	r1, r4
   1ab4e:	4628      	mov	r0, r5
    else {
        LV_LOG_WARN("indev function registered");
    }

    return cont;
}
   1ab50:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        cont = indev->driver.read_cb(&indev->driver, data);
   1ab54:	4718      	bx	r3
    else if(indev->driver.type == LV_INDEV_TYPE_KEYPAD) {
   1ab56:	2b02      	cmp	r3, #2
   1ab58:	d102      	bne.n	1ab60 <_lv_indev_read+0x34>
        data->key = indev->proc.types.keypad.last_key;
   1ab5a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1ab5c:	6063      	str	r3, [r4, #4]
   1ab5e:	e7f3      	b.n	1ab48 <_lv_indev_read+0x1c>
    else if(indev->driver.type == LV_INDEV_TYPE_ENCODER) {
   1ab60:	2b04      	cmp	r3, #4
        data->key = LV_KEY_ENTER;
   1ab62:	bf01      	itttt	eq
   1ab64:	230a      	moveq	r3, #10
   1ab66:	6063      	streq	r3, [r4, #4]
        data->enc_diff = 0;
   1ab68:	2300      	moveq	r3, #0
   1ab6a:	81a3      	strheq	r3, [r4, #12]
   1ab6c:	e7ec      	b.n	1ab48 <_lv_indev_read+0x1c>
}
   1ab6e:	4618      	mov	r0, r3
   1ab70:	bd70      	pop	{r4, r5, r6, pc}

0001ab72 <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
   1ab72:	b510      	push	{r4, lr}
	return z_impl_k_uptime_ticks();
   1ab74:	f002 fd17 	bl	1d5a6 <z_impl_k_uptime_ticks>
   1ab78:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   1ab7c:	fba0 2304 	umull	r2, r3, r0, r4
   1ab80:	fb04 3301 	mla	r3, r4, r1, r3
   1ab84:	0bd0      	lsrs	r0, r2, #15

    return result;
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
   1ab86:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   1ab8a:	bd10      	pop	{r4, pc}

0001ab8c <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
   1ab8c:	b538      	push	{r3, r4, r5, lr}
   1ab8e:	4604      	mov	r4, r0
   1ab90:	f002 fd09 	bl	1d5a6 <z_impl_k_uptime_ticks>
   1ab94:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   1ab98:	fba0 2305 	umull	r2, r3, r0, r5
   1ab9c:	fb05 3301 	mla	r3, r5, r1, r3
   1aba0:	0bd0      	lsrs	r0, r2, #15
   1aba2:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
        prev_tick = UINT32_MAX - prev_tick + 1;
        prev_tick += act_time;
    }

    return prev_tick;
}
   1aba6:	1b00      	subs	r0, r0, r4
   1aba8:	bd38      	pop	{r3, r4, r5, pc}

0001abaa <lv_anim_path_linear>:
    if(a->time == a->act_time) {
   1abaa:	e9d1 0309 	ldrd	r0, r3, [r1, #36]	; 0x24
   1abae:	4298      	cmp	r0, r3
        step = ((int32_t)a->act_time * LV_ANIM_RESOLUTION) / a->time;
   1abb0:	bf1a      	itte	ne
   1abb2:	029b      	lslne	r3, r3, #10
   1abb4:	fb93 f3f0 	sdivne	r3, r3, r0
        step = LV_ANIM_RESOLUTION; /*Use the last value if the time fully elapsed*/
   1abb8:	f44f 6380 	moveq.w	r3, #1024	; 0x400
    new_value = (int32_t)step * (a->end - a->start);
   1abbc:	6988      	ldr	r0, [r1, #24]
   1abbe:	6a0a      	ldr	r2, [r1, #32]
   1abc0:	1a12      	subs	r2, r2, r0
   1abc2:	4353      	muls	r3, r2
    new_value += a->start;
   1abc4:	eb00 20a3 	add.w	r0, r0, r3, asr #10
}
   1abc8:	b200      	sxth	r0, r0
   1abca:	4770      	bx	lr

0001abcc <_lv_memcpy>:
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1abcc:	f002 bec9 	b.w	1d962 <memcpy>

0001abd0 <lv_anim_speed_to_time>:
    int32_t d     = LV_MATH_ABS((int32_t)start - end);
   1abd0:	1a89      	subs	r1, r1, r2
    uint32_t time = (int32_t)((int32_t)(d * 1000) / speed);
   1abd2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    int32_t d     = LV_MATH_ABS((int32_t)start - end);
   1abd6:	2900      	cmp	r1, #0
   1abd8:	bfb8      	it	lt
   1abda:	4249      	neglt	r1, r1
    uint32_t time = (int32_t)((int32_t)(d * 1000) / speed);
   1abdc:	434a      	muls	r2, r1
   1abde:	fbb2 f0f0 	udiv	r0, r2, r0
   1abe2:	2801      	cmp	r0, #1
   1abe4:	bf38      	it	cc
   1abe6:	2001      	movcc	r0, #1
    return time;
   1abe8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1abec:	4298      	cmp	r0, r3
   1abee:	bf28      	it	cs
   1abf0:	4618      	movcs	r0, r3
}
   1abf2:	b280      	uxth	r0, r0
   1abf4:	4770      	bx	lr

0001abf6 <lv_anim_path_overshoot>:
    if(a->time == a->act_time)
   1abf6:	f44f 6380 	mov.w	r3, #1024	; 0x400
{
   1abfa:	b513      	push	{r0, r1, r4, lr}
    if(a->time == a->act_time)
   1abfc:	e9d1 2009 	ldrd	r2, r0, [r1, #36]	; 0x24
{
   1ac00:	460c      	mov	r4, r1
    if(a->time == a->act_time)
   1ac02:	4282      	cmp	r2, r0
        t = (uint32_t)((uint32_t)a->act_time * 1024) / a->time;
   1ac04:	bf1a      	itte	ne
   1ac06:	0280      	lslne	r0, r0, #10
   1ac08:	fbb0 f0f2 	udivne	r0, r0, r2
        t = 1024;
   1ac0c:	4618      	moveq	r0, r3
    int32_t step = _lv_bezier3(t, 0, 1000, 2000, 1024);
   1ac0e:	9300      	str	r3, [sp, #0]
   1ac10:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1ac14:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
   1ac18:	2100      	movs	r1, #0
   1ac1a:	f000 fbd5 	bl	1b3c8 <_lv_bezier3>
    new_value = (int32_t)step * (a->end - a->start);
   1ac1e:	69a3      	ldr	r3, [r4, #24]
   1ac20:	6a22      	ldr	r2, [r4, #32]
   1ac22:	1ad2      	subs	r2, r2, r3
   1ac24:	4350      	muls	r0, r2
    new_value += a->start;
   1ac26:	eb03 20a0 	add.w	r0, r3, r0, asr #10
}
   1ac2a:	b200      	sxth	r0, r0
   1ac2c:	b002      	add	sp, #8
   1ac2e:	bd10      	pop	{r4, pc}

0001ac30 <lv_point_within_circle>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static bool lv_point_within_circle(const lv_area_t * area, const lv_point_t * p)
{
   1ac30:	b530      	push	{r4, r5, lr}
    lv_coord_t r = (area->x2 - area->x1) / 2;
   1ac32:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
   1ac36:	f9b0 5000 	ldrsh.w	r5, [r0]
    /* Circle center */
    lv_coord_t cx = area->x1 + r;
    lv_coord_t cy = area->y1 + r;

    /*Simplify the code by moving everything to (0, 0) */
    lv_coord_t px = p->x - cx;
   1ac3a:	880a      	ldrh	r2, [r1, #0]
    lv_coord_t py = p->y - cy;
   1ac3c:	8840      	ldrh	r0, [r0, #2]
   1ac3e:	8849      	ldrh	r1, [r1, #2]
    lv_coord_t r = (area->x2 - area->x1) / 2;
   1ac40:	1b5b      	subs	r3, r3, r5
   1ac42:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    lv_coord_t py = p->y - cy;
   1ac46:	1a09      	subs	r1, r1, r0
    lv_coord_t r = (area->x2 - area->x1) / 2;
   1ac48:	105c      	asrs	r4, r3, #1
    lv_coord_t px = p->x - cx;
   1ac4a:	1b52      	subs	r2, r2, r5
    lv_coord_t r = (area->x2 - area->x1) / 2;
   1ac4c:	f343 034f 	sbfx	r3, r3, #1, #16
    lv_coord_t px = p->x - cx;
   1ac50:	1ad2      	subs	r2, r2, r3
    lv_coord_t py = p->y - cy;
   1ac52:	1acb      	subs	r3, r1, r3

    int32_t r_sqrd = r * r;
    int32_t dist = (px * px) + (py * py);
   1ac54:	fb13 f303 	smulbb	r3, r3, r3
    int32_t r_sqrd = r * r;
   1ac58:	4364      	muls	r4, r4
    int32_t dist = (px * px) + (py * py);
   1ac5a:	fb12 3202 	smlabb	r2, r2, r2, r3

    if(dist <= r_sqrd)
        return true;
    else
        return false;
}
   1ac5e:	4294      	cmp	r4, r2
   1ac60:	bfb4      	ite	lt
   1ac62:	2000      	movlt	r0, #0
   1ac64:	2001      	movge	r0, #1
   1ac66:	bd30      	pop	{r4, r5, pc}

0001ac68 <lv_area_set>:
    area_p->x2 = x2;
   1ac68:	8083      	strh	r3, [r0, #4]
    area_p->y2 = y2;
   1ac6a:	f9bd 3000 	ldrsh.w	r3, [sp]
    area_p->x1 = x1;
   1ac6e:	8001      	strh	r1, [r0, #0]
    area_p->y1 = y1;
   1ac70:	8042      	strh	r2, [r0, #2]
    area_p->y2 = y2;
   1ac72:	80c3      	strh	r3, [r0, #6]
}
   1ac74:	4770      	bx	lr

0001ac76 <lv_area_set_height>:
    area_p->y2 = area_p->y1 + h - 1;
   1ac76:	8843      	ldrh	r3, [r0, #2]
   1ac78:	3901      	subs	r1, #1
   1ac7a:	4419      	add	r1, r3
   1ac7c:	80c1      	strh	r1, [r0, #6]
}
   1ac7e:	4770      	bx	lr

0001ac80 <lv_area_get_size>:
    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
   1ac80:	f9b0 3000 	ldrsh.w	r3, [r0]
   1ac84:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
   1ac88:	1ad2      	subs	r2, r2, r3
   1ac8a:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
   1ac8e:	f9b0 0002 	ldrsh.w	r0, [r0, #2]
   1ac92:	3301      	adds	r3, #1
   1ac94:	1a18      	subs	r0, r3, r0
}
   1ac96:	fb02 0000 	mla	r0, r2, r0, r0
   1ac9a:	4770      	bx	lr

0001ac9c <_lv_area_intersect>:
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   1ac9c:	f9b1 3000 	ldrsh.w	r3, [r1]
{
   1aca0:	b570      	push	{r4, r5, r6, lr}
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   1aca2:	f9b2 6000 	ldrsh.w	r6, [r2]
{
   1aca6:	4604      	mov	r4, r0
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   1aca8:	429e      	cmp	r6, r3
   1acaa:	bfb8      	it	lt
   1acac:	461e      	movlt	r6, r3
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   1acae:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
   1acb2:	8006      	strh	r6, [r0, #0]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   1acb4:	f9b2 0002 	ldrsh.w	r0, [r2, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   1acb8:	f9b2 5004 	ldrsh.w	r5, [r2, #4]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   1acbc:	4283      	cmp	r3, r0
   1acbe:	bfb8      	it	lt
   1acc0:	4603      	movlt	r3, r0
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   1acc2:	f9b1 0004 	ldrsh.w	r0, [r1, #4]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
   1acc6:	8063      	strh	r3, [r4, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   1acc8:	4285      	cmp	r5, r0
   1acca:	bfa8      	it	ge
   1accc:	4605      	movge	r5, r0
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   1acce:	f9b2 0006 	ldrsh.w	r0, [r2, #6]
   1acd2:	f9b1 2006 	ldrsh.w	r2, [r1, #6]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
   1acd6:	80a5      	strh	r5, [r4, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   1acd8:	4290      	cmp	r0, r2
   1acda:	bfa8      	it	ge
   1acdc:	4610      	movge	r0, r2
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
   1acde:	42ae      	cmp	r6, r5
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
   1ace0:	80e0      	strh	r0, [r4, #6]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
   1ace2:	dc04      	bgt.n	1acee <_lv_area_intersect+0x52>
   1ace4:	4283      	cmp	r3, r0
   1ace6:	bfcc      	ite	gt
   1ace8:	2000      	movgt	r0, #0
   1acea:	2001      	movle	r0, #1
}
   1acec:	bd70      	pop	{r4, r5, r6, pc}
        union_ok = false;
   1acee:	2000      	movs	r0, #0
   1acf0:	e7fc      	b.n	1acec <_lv_area_intersect+0x50>

0001acf2 <_lv_area_join>:
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
   1acf2:	f9b2 3000 	ldrsh.w	r3, [r2]
{
   1acf6:	b510      	push	{r4, lr}
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
   1acf8:	f9b1 4000 	ldrsh.w	r4, [r1]
   1acfc:	42a3      	cmp	r3, r4
   1acfe:	bfa8      	it	ge
   1ad00:	4623      	movge	r3, r4
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
   1ad02:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
   1ad06:	8003      	strh	r3, [r0, #0]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
   1ad08:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
   1ad0c:	42a3      	cmp	r3, r4
   1ad0e:	bfa8      	it	ge
   1ad10:	4623      	movge	r3, r4
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
   1ad12:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
   1ad16:	8043      	strh	r3, [r0, #2]
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
   1ad18:	f9b2 3004 	ldrsh.w	r3, [r2, #4]
   1ad1c:	42a3      	cmp	r3, r4
   1ad1e:	bfb8      	it	lt
   1ad20:	4623      	movlt	r3, r4
   1ad22:	8083      	strh	r3, [r0, #4]
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
   1ad24:	f9b2 3006 	ldrsh.w	r3, [r2, #6]
   1ad28:	f9b1 2006 	ldrsh.w	r2, [r1, #6]
   1ad2c:	4293      	cmp	r3, r2
   1ad2e:	bfb8      	it	lt
   1ad30:	4613      	movlt	r3, r2
   1ad32:	80c3      	strh	r3, [r0, #6]
}
   1ad34:	bd10      	pop	{r4, pc}

0001ad36 <_lv_area_is_point_on>:
{
   1ad36:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if((p_p->x >= a_p->x1 && p_p->x <= a_p->x2) && ((p_p->y >= a_p->y1 && p_p->y <= a_p->y2))) {
   1ad3a:	f9b1 3000 	ldrsh.w	r3, [r1]
   1ad3e:	f9b0 5000 	ldrsh.w	r5, [r0]
{
   1ad42:	460e      	mov	r6, r1
    if((p_p->x >= a_p->x1 && p_p->x <= a_p->x2) && ((p_p->y >= a_p->y1 && p_p->y <= a_p->y2))) {
   1ad44:	42ab      	cmp	r3, r5
   1ad46:	db7d      	blt.n	1ae44 <_lv_area_is_point_on+0x10e>
   1ad48:	f9b0 8004 	ldrsh.w	r8, [r0, #4]
   1ad4c:	4543      	cmp	r3, r8
   1ad4e:	dc79      	bgt.n	1ae44 <_lv_area_is_point_on+0x10e>
   1ad50:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
   1ad54:	f9b0 7002 	ldrsh.w	r7, [r0, #2]
   1ad58:	42bb      	cmp	r3, r7
   1ad5a:	db73      	blt.n	1ae44 <_lv_area_is_point_on+0x10e>
   1ad5c:	f9b0 9006 	ldrsh.w	r9, [r0, #6]
   1ad60:	454b      	cmp	r3, r9
   1ad62:	dc6f      	bgt.n	1ae44 <_lv_area_is_point_on+0x10e>
    if(radius <= 0) {
   1ad64:	2a00      	cmp	r2, #0
   1ad66:	dc03      	bgt.n	1ad70 <_lv_area_is_point_on+0x3a>
        return true;
   1ad68:	2001      	movs	r0, #1
}
   1ad6a:	b003      	add	sp, #12
   1ad6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ad70:	f108 0301 	add.w	r3, r8, #1
   1ad74:	1b5b      	subs	r3, r3, r5
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1ad76:	f109 0001 	add.w	r0, r9, #1
    lv_coord_t w = lv_area_get_width(a_p) / 2;
   1ad7a:	f3c3 34c0 	ubfx	r4, r3, #15, #1
   1ad7e:	1bc0      	subs	r0, r0, r7
   1ad80:	fa04 f383 	sxtah	r3, r4, r3
    lv_coord_t h = lv_area_get_height(a_p) / 2;
   1ad84:	f3c0 34c0 	ubfx	r4, r0, #15, #1
   1ad88:	fa04 f080 	sxtah	r0, r4, r0
    lv_coord_t max_radius = LV_MATH_MIN(w, h);
   1ad8c:	105c      	asrs	r4, r3, #1
   1ad8e:	1043      	asrs	r3, r0, #1
   1ad90:	429c      	cmp	r4, r3
   1ad92:	bfa8      	it	ge
   1ad94:	461c      	movge	r4, r3
   1ad96:	4294      	cmp	r4, r2
   1ad98:	bfa8      	it	ge
   1ad9a:	4614      	movge	r4, r2
    corner_area.x1 = a_p->x1;
   1ad9c:	f8ad 5000 	strh.w	r5, [sp]
    corner_area.y2 = a_p->y1 + radius;
   1ada0:	eb07 0a04 	add.w	sl, r7, r4
    corner_area.x2 = a_p->x1 + radius;
   1ada4:	4425      	add	r5, r4
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   1ada6:	2200      	movs	r2, #0
   1ada8:	4668      	mov	r0, sp
    corner_area.x2 = a_p->x1 + radius;
   1adaa:	b22d      	sxth	r5, r5
    corner_area.y2 = a_p->y1 + radius;
   1adac:	fa0f fa8a 	sxth.w	sl, sl
    corner_area.x2 = a_p->x1 + radius;
   1adb0:	f8ad 5004 	strh.w	r5, [sp, #4]
    corner_area.y1 = a_p->y1;
   1adb4:	f8ad 7002 	strh.w	r7, [sp, #2]
    corner_area.y2 = a_p->y1 + radius;
   1adb8:	f8ad a006 	strh.w	sl, [sp, #6]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   1adbc:	f7ff ffbb 	bl	1ad36 <_lv_area_is_point_on>
   1adc0:	4602      	mov	r2, r0
   1adc2:	b130      	cbz	r0, 1add2 <_lv_area_is_point_on+0x9c>
        corner_area.x2 += radius;
   1adc4:	4425      	add	r5, r4
   1adc6:	f8ad 5004 	strh.w	r5, [sp, #4]
        corner_area.y2 += radius;
   1adca:	4454      	add	r4, sl
   1adcc:	f8ad 4006 	strh.w	r4, [sp, #6]
   1add0:	e014      	b.n	1adfc <_lv_area_is_point_on+0xc6>
    corner_area.y1 = a_p->y2 - radius;
   1add2:	eba9 0b04 	sub.w	fp, r9, r4
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   1add6:	4631      	mov	r1, r6
   1add8:	4668      	mov	r0, sp
    corner_area.y1 = a_p->y2 - radius;
   1adda:	fa0f fb8b 	sxth.w	fp, fp
   1adde:	f8ad b002 	strh.w	fp, [sp, #2]
    corner_area.y2 = a_p->y2;
   1ade2:	f8ad 9006 	strh.w	r9, [sp, #6]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   1ade6:	f7ff ffa6 	bl	1ad36 <_lv_area_is_point_on>
   1adea:	4602      	mov	r2, r0
   1adec:	b158      	cbz	r0, 1ae06 <_lv_area_is_point_on+0xd0>
        corner_area.x2 += radius;
   1adee:	4425      	add	r5, r4
   1adf0:	f8ad 5004 	strh.w	r5, [sp, #4]
        corner_area.y1 -= radius;
   1adf4:	ebab 0404 	sub.w	r4, fp, r4
   1adf8:	f8ad 4002 	strh.w	r4, [sp, #2]
        return lv_point_within_circle(&corner_area, p_p);
   1adfc:	4631      	mov	r1, r6
   1adfe:	4668      	mov	r0, sp
   1ae00:	f7ff ff16 	bl	1ac30 <lv_point_within_circle>
   1ae04:	e7b1      	b.n	1ad6a <_lv_area_is_point_on+0x34>
    corner_area.x1 = a_p->x2 - radius;
   1ae06:	eba8 0304 	sub.w	r3, r8, r4
   1ae0a:	b21d      	sxth	r5, r3
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   1ae0c:	4631      	mov	r1, r6
   1ae0e:	4668      	mov	r0, sp
    corner_area.x1 = a_p->x2 - radius;
   1ae10:	f8ad 5000 	strh.w	r5, [sp]
    corner_area.x2 = a_p->x2;
   1ae14:	f8ad 8004 	strh.w	r8, [sp, #4]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   1ae18:	f7ff ff8d 	bl	1ad36 <_lv_area_is_point_on>
   1ae1c:	4602      	mov	r2, r0
   1ae1e:	b118      	cbz	r0, 1ae28 <_lv_area_is_point_on+0xf2>
        corner_area.x1 -= radius;
   1ae20:	1b2b      	subs	r3, r5, r4
   1ae22:	f8ad 3000 	strh.w	r3, [sp]
   1ae26:	e7e5      	b.n	1adf4 <_lv_area_is_point_on+0xbe>
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   1ae28:	4631      	mov	r1, r6
   1ae2a:	4668      	mov	r0, sp
    corner_area.y1 = a_p->y1;
   1ae2c:	f8ad 7002 	strh.w	r7, [sp, #2]
    corner_area.y2 = a_p->y1 + radius;
   1ae30:	f8ad a006 	strh.w	sl, [sp, #6]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
   1ae34:	f7ff ff7f 	bl	1ad36 <_lv_area_is_point_on>
   1ae38:	2800      	cmp	r0, #0
   1ae3a:	d095      	beq.n	1ad68 <_lv_area_is_point_on+0x32>
        corner_area.x1 -= radius;
   1ae3c:	1b2b      	subs	r3, r5, r4
   1ae3e:	f8ad 3000 	strh.w	r3, [sp]
   1ae42:	e7c2      	b.n	1adca <_lv_area_is_point_on+0x94>
        return false;
   1ae44:	2000      	movs	r0, #0
   1ae46:	e790      	b.n	1ad6a <_lv_area_is_point_on+0x34>

0001ae48 <_lv_area_is_on>:
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
   1ae48:	f9b0 2000 	ldrsh.w	r2, [r0]
   1ae4c:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
   1ae50:	429a      	cmp	r2, r3
   1ae52:	dc14      	bgt.n	1ae7e <_lv_area_is_on+0x36>
   1ae54:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
   1ae58:	f9b1 3000 	ldrsh.w	r3, [r1]
   1ae5c:	429a      	cmp	r2, r3
   1ae5e:	db0e      	blt.n	1ae7e <_lv_area_is_on+0x36>
   1ae60:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
   1ae64:	f9b1 3006 	ldrsh.w	r3, [r1, #6]
   1ae68:	429a      	cmp	r2, r3
   1ae6a:	dc08      	bgt.n	1ae7e <_lv_area_is_on+0x36>
   1ae6c:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
   1ae70:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
   1ae74:	4298      	cmp	r0, r3
   1ae76:	bfb4      	ite	lt
   1ae78:	2000      	movlt	r0, #0
   1ae7a:	2001      	movge	r0, #1
   1ae7c:	4770      	bx	lr
        return false;
   1ae7e:	2000      	movs	r0, #0
}
   1ae80:	4770      	bx	lr

0001ae82 <_lv_area_is_in>:
{
   1ae82:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
   1ae86:	f9b1 3000 	ldrsh.w	r3, [r1]
   1ae8a:	f9b0 7000 	ldrsh.w	r7, [r0]
{
   1ae8e:	4605      	mov	r5, r0
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
   1ae90:	42bb      	cmp	r3, r7
{
   1ae92:	460c      	mov	r4, r1
   1ae94:	4616      	mov	r6, r2
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
   1ae96:	dc23      	bgt.n	1aee0 <_lv_area_is_in+0x5e>
   1ae98:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
   1ae9c:	f9b1 3002 	ldrsh.w	r3, [r1, #2]
   1aea0:	429a      	cmp	r2, r3
   1aea2:	db1d      	blt.n	1aee0 <_lv_area_is_in+0x5e>
   1aea4:	f9b0 2004 	ldrsh.w	r2, [r0, #4]
   1aea8:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
   1aeac:	429a      	cmp	r2, r3
   1aeae:	dc17      	bgt.n	1aee0 <_lv_area_is_in+0x5e>
   1aeb0:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
   1aeb4:	f9b1 0006 	ldrsh.w	r0, [r1, #6]
   1aeb8:	4283      	cmp	r3, r0
   1aeba:	bfcc      	ite	gt
   1aebc:	2000      	movgt	r0, #0
   1aebe:	2001      	movle	r0, #1
    if(radius == 0) return is_in;
   1aec0:	b15e      	cbz	r6, 1aeda <_lv_area_is_in+0x58>
    p.y = ain_p->y1;
   1aec2:	886b      	ldrh	r3, [r5, #2]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   1aec4:	4632      	mov	r2, r6
   1aec6:	4620      	mov	r0, r4
   1aec8:	a901      	add	r1, sp, #4
    p.x = ain_p->x1;
   1aeca:	f8ad 7004 	strh.w	r7, [sp, #4]
    p.y = ain_p->y1;
   1aece:	f8ad 3006 	strh.w	r3, [sp, #6]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   1aed2:	f7ff ff30 	bl	1ad36 <_lv_area_is_point_on>
   1aed6:	b928      	cbnz	r0, 1aee4 <_lv_area_is_in+0x62>
   1aed8:	2000      	movs	r0, #0
}
   1aeda:	b002      	add	sp, #8
   1aedc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bool is_in = false;
   1aee0:	2000      	movs	r0, #0
   1aee2:	e7ed      	b.n	1aec0 <_lv_area_is_in+0x3e>
    p.x = ain_p->x2;
   1aee4:	f9b5 8004 	ldrsh.w	r8, [r5, #4]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   1aee8:	4632      	mov	r2, r6
   1aeea:	4620      	mov	r0, r4
   1aeec:	a901      	add	r1, sp, #4
    p.x = ain_p->x2;
   1aeee:	f8ad 8004 	strh.w	r8, [sp, #4]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   1aef2:	f7ff ff20 	bl	1ad36 <_lv_area_is_point_on>
   1aef6:	2800      	cmp	r0, #0
   1aef8:	d0ee      	beq.n	1aed8 <_lv_area_is_in+0x56>
    p.y = ain_p->y2;
   1aefa:	88eb      	ldrh	r3, [r5, #6]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   1aefc:	4632      	mov	r2, r6
   1aefe:	4620      	mov	r0, r4
   1af00:	a901      	add	r1, sp, #4
    p.x = ain_p->x1;
   1af02:	f8ad 7004 	strh.w	r7, [sp, #4]
    p.y = ain_p->y2;
   1af06:	f8ad 3006 	strh.w	r3, [sp, #6]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   1af0a:	f7ff ff14 	bl	1ad36 <_lv_area_is_point_on>
   1af0e:	2800      	cmp	r0, #0
   1af10:	d0e2      	beq.n	1aed8 <_lv_area_is_in+0x56>
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   1af12:	4632      	mov	r2, r6
   1af14:	4620      	mov	r0, r4
   1af16:	a901      	add	r1, sp, #4
    p.x = ain_p->x2;
   1af18:	f8ad 8004 	strh.w	r8, [sp, #4]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
   1af1c:	f7ff ff0b 	bl	1ad36 <_lv_area_is_point_on>
   1af20:	e7db      	b.n	1aeda <_lv_area_is_in+0x58>

0001af22 <_lv_area_align>:
{
   1af22:	b5f0      	push	{r4, r5, r6, r7, lr}
   1af24:	f9b0 4002 	ldrsh.w	r4, [r0, #2]
   1af28:	f9b0 5000 	ldrsh.w	r5, [r0]
   1af2c:	2a14      	cmp	r2, #20
   1af2e:	d83f      	bhi.n	1afb0 <_lv_area_align+0x8e>
   1af30:	e8df f012 	tbh	[pc, r2, lsl #1]
   1af34:	003b0015 	.word	0x003b0015
   1af38:	005a0045 	.word	0x005a0045
   1af3c:	00690061 	.word	0x00690061
   1af40:	0083007c 	.word	0x0083007c
   1af44:	008c0085 	.word	0x008c0085
   1af48:	00a60093 	.word	0x00a60093
   1af4c:	00b300ad 	.word	0x00b300ad
   1af50:	00cd00c6 	.word	0x00cd00c6
   1af54:	00d700d2 	.word	0x00d700d2
   1af58:	00df00dc 	.word	0x00df00dc
   1af5c:	00e2      	.short	0x00e2
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1af5e:	888a      	ldrh	r2, [r1, #4]
   1af60:	880e      	ldrh	r6, [r1, #0]
   1af62:	3201      	adds	r2, #1
   1af64:	1b92      	subs	r2, r2, r6
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   1af66:	f3c2 36c0 	ubfx	r6, r2, #15, #1
   1af6a:	fa06 f682 	sxtah	r6, r6, r2
   1af6e:	8882      	ldrh	r2, [r0, #4]
   1af70:	3201      	adds	r2, #1
   1af72:	1b52      	subs	r2, r2, r5
   1af74:	f3c2 37c0 	ubfx	r7, r2, #15, #1
   1af78:	fa07 f282 	sxtah	r2, r7, r2
   1af7c:	1052      	asrs	r2, r2, #1
   1af7e:	eba2 0266 	sub.w	r2, r2, r6, asr #1
            res->x = lv_area_get_width(base);
   1af82:	801a      	strh	r2, [r3, #0]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1af84:	88ca      	ldrh	r2, [r1, #6]
   1af86:	8849      	ldrh	r1, [r1, #2]
   1af88:	3201      	adds	r2, #1
   1af8a:	1a52      	subs	r2, r2, r1
            res->y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
   1af8c:	f3c2 31c0 	ubfx	r1, r2, #15, #1
   1af90:	fa01 f182 	sxtah	r1, r1, r2
   1af94:	88c2      	ldrh	r2, [r0, #6]
   1af96:	3201      	adds	r2, #1
   1af98:	1b12      	subs	r2, r2, r4
   1af9a:	f3c2 30c0 	ubfx	r0, r2, #15, #1
   1af9e:	fa00 f282 	sxtah	r2, r0, r2
   1afa2:	1052      	asrs	r2, r2, #1
   1afa4:	eba2 0261 	sub.w	r2, r2, r1, asr #1
   1afa8:	e001      	b.n	1afae <_lv_area_align+0x8c>
            res->x = 0;
   1afaa:	2200      	movs	r2, #0
   1afac:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
   1afae:	805a      	strh	r2, [r3, #2]
    res->x += base->x1;
   1afb0:	881a      	ldrh	r2, [r3, #0]
   1afb2:	4415      	add	r5, r2
    res->y += base->y1;
   1afb4:	885a      	ldrh	r2, [r3, #2]
    res->x += base->x1;
   1afb6:	801d      	strh	r5, [r3, #0]
    res->y += base->y1;
   1afb8:	4414      	add	r4, r2
   1afba:	805c      	strh	r4, [r3, #2]
}
   1afbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1afbe:	888a      	ldrh	r2, [r1, #4]
   1afc0:	8809      	ldrh	r1, [r1, #0]
   1afc2:	3201      	adds	r2, #1
   1afc4:	1a52      	subs	r2, r2, r1
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   1afc6:	f3c2 31c0 	ubfx	r1, r2, #15, #1
   1afca:	fa01 f182 	sxtah	r1, r1, r2
   1afce:	8882      	ldrh	r2, [r0, #4]
   1afd0:	3201      	adds	r2, #1
   1afd2:	1b52      	subs	r2, r2, r5
   1afd4:	f3c2 30c0 	ubfx	r0, r2, #15, #1
   1afd8:	fa00 f282 	sxtah	r2, r0, r2
   1afdc:	1052      	asrs	r2, r2, #1
   1afde:	eba2 0261 	sub.w	r2, r2, r1, asr #1
            res->x = lv_area_get_width(base);
   1afe2:	801a      	strh	r2, [r3, #0]
            res->y = 0;
   1afe4:	2200      	movs	r2, #0
   1afe6:	e7e2      	b.n	1afae <_lv_area_align+0x8c>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   1afe8:	880a      	ldrh	r2, [r1, #0]
   1afea:	8889      	ldrh	r1, [r1, #4]
   1afec:	1a52      	subs	r2, r2, r1
   1afee:	8881      	ldrh	r1, [r0, #4]
   1aff0:	440a      	add	r2, r1
   1aff2:	1b52      	subs	r2, r2, r5
   1aff4:	e7f5      	b.n	1afe2 <_lv_area_align+0xc0>
            res->x = 0;
   1aff6:	2200      	movs	r2, #0
            res->x = lv_area_get_width(base);
   1aff8:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
   1affa:	884a      	ldrh	r2, [r1, #2]
   1affc:	88c9      	ldrh	r1, [r1, #6]
   1affe:	1a52      	subs	r2, r2, r1
   1b000:	88c1      	ldrh	r1, [r0, #6]
   1b002:	440a      	add	r2, r1
   1b004:	e047      	b.n	1b096 <_lv_area_align+0x174>
   1b006:	888a      	ldrh	r2, [r1, #4]
   1b008:	880e      	ldrh	r6, [r1, #0]
   1b00a:	3201      	adds	r2, #1
   1b00c:	1b92      	subs	r2, r2, r6
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   1b00e:	f3c2 36c0 	ubfx	r6, r2, #15, #1
   1b012:	fa06 f682 	sxtah	r6, r6, r2
   1b016:	8882      	ldrh	r2, [r0, #4]
   1b018:	3201      	adds	r2, #1
   1b01a:	1b52      	subs	r2, r2, r5
   1b01c:	f3c2 37c0 	ubfx	r7, r2, #15, #1
   1b020:	fa07 f282 	sxtah	r2, r7, r2
   1b024:	1052      	asrs	r2, r2, #1
   1b026:	eba2 0266 	sub.w	r2, r2, r6, asr #1
   1b02a:	e7e5      	b.n	1aff8 <_lv_area_align+0xd6>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   1b02c:	888e      	ldrh	r6, [r1, #4]
   1b02e:	880a      	ldrh	r2, [r1, #0]
   1b030:	1b92      	subs	r2, r2, r6
   1b032:	8886      	ldrh	r6, [r0, #4]
   1b034:	4432      	add	r2, r6
   1b036:	1b52      	subs	r2, r2, r5
   1b038:	e7de      	b.n	1aff8 <_lv_area_align+0xd6>
            res->x = 0;
   1b03a:	2200      	movs	r2, #0
   1b03c:	e7a1      	b.n	1af82 <_lv_area_align+0x60>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   1b03e:	888e      	ldrh	r6, [r1, #4]
   1b040:	880a      	ldrh	r2, [r1, #0]
   1b042:	1b92      	subs	r2, r2, r6
   1b044:	8886      	ldrh	r6, [r0, #4]
   1b046:	4432      	add	r2, r6
   1b048:	1b52      	subs	r2, r2, r5
   1b04a:	e79a      	b.n	1af82 <_lv_area_align+0x60>
            res->x = 0;
   1b04c:	2200      	movs	r2, #0
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   1b04e:	801a      	strh	r2, [r3, #0]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1b050:	88ca      	ldrh	r2, [r1, #6]
   1b052:	1c50      	adds	r0, r2, #1
   1b054:	884a      	ldrh	r2, [r1, #2]
            res->y = -lv_area_get_height(to_align);
   1b056:	1a12      	subs	r2, r2, r0
   1b058:	e7a9      	b.n	1afae <_lv_area_align+0x8c>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1b05a:	888a      	ldrh	r2, [r1, #4]
   1b05c:	880e      	ldrh	r6, [r1, #0]
   1b05e:	3201      	adds	r2, #1
   1b060:	1b92      	subs	r2, r2, r6
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   1b062:	f3c2 36c0 	ubfx	r6, r2, #15, #1
   1b066:	fa06 f682 	sxtah	r6, r6, r2
   1b06a:	8882      	ldrh	r2, [r0, #4]
   1b06c:	3201      	adds	r2, #1
   1b06e:	1b52      	subs	r2, r2, r5
   1b070:	f3c2 30c0 	ubfx	r0, r2, #15, #1
   1b074:	fa00 f282 	sxtah	r2, r0, r2
   1b078:	1052      	asrs	r2, r2, #1
   1b07a:	eba2 0266 	sub.w	r2, r2, r6, asr #1
   1b07e:	e7e6      	b.n	1b04e <_lv_area_align+0x12c>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   1b080:	880a      	ldrh	r2, [r1, #0]
   1b082:	888e      	ldrh	r6, [r1, #4]
   1b084:	8880      	ldrh	r0, [r0, #4]
   1b086:	1b92      	subs	r2, r2, r6
   1b088:	4402      	add	r2, r0
   1b08a:	1b52      	subs	r2, r2, r5
   1b08c:	e7df      	b.n	1b04e <_lv_area_align+0x12c>
            res->x = 0;
   1b08e:	2200      	movs	r2, #0
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   1b090:	801a      	strh	r2, [r3, #0]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1b092:	88c2      	ldrh	r2, [r0, #6]
   1b094:	3201      	adds	r2, #1
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
   1b096:	1b12      	subs	r2, r2, r4
   1b098:	e789      	b.n	1afae <_lv_area_align+0x8c>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1b09a:	888a      	ldrh	r2, [r1, #4]
   1b09c:	8809      	ldrh	r1, [r1, #0]
   1b09e:	3201      	adds	r2, #1
   1b0a0:	1a52      	subs	r2, r2, r1
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
   1b0a2:	f3c2 31c0 	ubfx	r1, r2, #15, #1
   1b0a6:	fa01 f182 	sxtah	r1, r1, r2
   1b0aa:	8882      	ldrh	r2, [r0, #4]
   1b0ac:	3201      	adds	r2, #1
   1b0ae:	1b52      	subs	r2, r2, r5
   1b0b0:	f3c2 36c0 	ubfx	r6, r2, #15, #1
   1b0b4:	fa06 f282 	sxtah	r2, r6, r2
   1b0b8:	1052      	asrs	r2, r2, #1
   1b0ba:	eba2 0261 	sub.w	r2, r2, r1, asr #1
   1b0be:	e7e7      	b.n	1b090 <_lv_area_align+0x16e>
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
   1b0c0:	880a      	ldrh	r2, [r1, #0]
   1b0c2:	8889      	ldrh	r1, [r1, #4]
   1b0c4:	1a52      	subs	r2, r2, r1
   1b0c6:	8881      	ldrh	r1, [r0, #4]
   1b0c8:	440a      	add	r2, r1
   1b0ca:	1b52      	subs	r2, r2, r5
   1b0cc:	e7e0      	b.n	1b090 <_lv_area_align+0x16e>
   1b0ce:	888a      	ldrh	r2, [r1, #4]
   1b0d0:	1c50      	adds	r0, r2, #1
   1b0d2:	880a      	ldrh	r2, [r1, #0]
            res->x = -lv_area_get_width(to_align);
   1b0d4:	1a12      	subs	r2, r2, r0
   1b0d6:	e784      	b.n	1afe2 <_lv_area_align+0xc0>
   1b0d8:	888a      	ldrh	r2, [r1, #4]
   1b0da:	1c56      	adds	r6, r2, #1
   1b0dc:	880a      	ldrh	r2, [r1, #0]
            res->x = -lv_area_get_width(to_align);
   1b0de:	1b92      	subs	r2, r2, r6
   1b0e0:	e74f      	b.n	1af82 <_lv_area_align+0x60>
   1b0e2:	888a      	ldrh	r2, [r1, #4]
   1b0e4:	1c56      	adds	r6, r2, #1
   1b0e6:	880a      	ldrh	r2, [r1, #0]
            res->x = -lv_area_get_width(to_align);
   1b0e8:	1b92      	subs	r2, r2, r6
   1b0ea:	e785      	b.n	1aff8 <_lv_area_align+0xd6>
   1b0ec:	8882      	ldrh	r2, [r0, #4]
   1b0ee:	3201      	adds	r2, #1
   1b0f0:	e77f      	b.n	1aff2 <_lv_area_align+0xd0>
   1b0f2:	8882      	ldrh	r2, [r0, #4]
   1b0f4:	3201      	adds	r2, #1
   1b0f6:	e7a7      	b.n	1b048 <_lv_area_align+0x126>
   1b0f8:	8882      	ldrh	r2, [r0, #4]
   1b0fa:	3201      	adds	r2, #1
   1b0fc:	e79b      	b.n	1b036 <_lv_area_align+0x114>

0001b0fe <lv_color_fill>:
        *buf = color;
        buf++;
        px_num --;
    }
#else
    while(px_num > 16) {
   1b0fe:	2a10      	cmp	r2, #16
   1b100:	4603      	mov	r3, r0
   1b102:	f100 0040 	add.w	r0, r0, #64	; 0x40
   1b106:	d804      	bhi.n	1b112 <lv_color_fill+0x14>
   1b108:	eb03 0282 	add.w	r2, r3, r2, lsl #2
        *buf = color;
        buf++;

        px_num -= 16;
    }
    while(px_num) {
   1b10c:	4293      	cmp	r3, r2
   1b10e:	d112      	bne.n	1b136 <lv_color_fill+0x38>
        *buf = color;
        buf++;
        px_num --;
    }
#endif
}
   1b110:	4770      	bx	lr
        *buf = color;
   1b112:	e940 1110 	strd	r1, r1, [r0, #-64]	; 0x40
        *buf = color;
   1b116:	e940 110e 	strd	r1, r1, [r0, #-56]	; 0x38
        *buf = color;
   1b11a:	e940 110c 	strd	r1, r1, [r0, #-48]	; 0x30
        *buf = color;
   1b11e:	e940 110a 	strd	r1, r1, [r0, #-40]	; 0x28
        *buf = color;
   1b122:	e940 1108 	strd	r1, r1, [r0, #-32]
        *buf = color;
   1b126:	e940 1106 	strd	r1, r1, [r0, #-24]
        *buf = color;
   1b12a:	e940 1104 	strd	r1, r1, [r0, #-16]
        *buf = color;
   1b12e:	e940 1102 	strd	r1, r1, [r0, #-8]
        px_num -= 16;
   1b132:	3a10      	subs	r2, #16
   1b134:	e7e3      	b.n	1b0fe <lv_color_fill>
        *buf = color;
   1b136:	f843 1b04 	str.w	r1, [r3], #4
        px_num --;
   1b13a:	e7e7      	b.n	1b10c <lv_color_fill+0xe>

0001b13c <lv_color_darken>:
    return lv_color_mix(LV_COLOR_WHITE, c, lvl);
}


lv_color_t lv_color_darken(lv_color_t c, lv_opa_t lvl)
{
   1b13c:	b510      	push	{r4, lr}
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   1b13e:	f248 0481 	movw	r4, #32897	; 0x8081
   1b142:	f1c1 01ff 	rsb	r1, r1, #255	; 0xff
   1b146:	f3c0 4307 	ubfx	r3, r0, #16, #8
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1b14a:	f3c0 2207 	ubfx	r2, r0, #8, #8
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1b14e:	b2c0      	uxtb	r0, r0
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   1b150:	434b      	muls	r3, r1
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1b152:	434a      	muls	r2, r1
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1b154:	4341      	muls	r1, r0
   1b156:	2000      	movs	r0, #0
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   1b158:	4363      	muls	r3, r4
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1b15a:	4362      	muls	r2, r4
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
   1b15c:	434c      	muls	r4, r1
   1b15e:	0de4      	lsrs	r4, r4, #23
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
   1b160:	f3c2 52c7 	ubfx	r2, r2, #23, #8
   1b164:	f364 0007 	bfi	r0, r4, #0, #8
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
   1b168:	f3c3 53c7 	ubfx	r3, r3, #23, #8
    return ret;
   1b16c:	f362 200f 	bfi	r0, r2, #8, #8
   1b170:	f363 4017 	bfi	r0, r3, #16, #8
    return lv_color_mix(LV_COLOR_BLACK, c, lvl);
}
   1b174:	f040 407f 	orr.w	r0, r0, #4278190080	; 0xff000000
   1b178:	bd10      	pop	{r4, pc}

0001b17a <node_set_prev.isra.0>:
 * @param act pointer to a node which prev. node pointer should be set
 * @param prev pointer to a node which should be the previous node before 'act'
 */
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
{
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
   1b17a:	b109      	cbz	r1, 1b180 <node_set_prev.isra.0+0x6>
    act8 += LL_PREV_P_OFFSET(ll_p);

    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
    lv_ll_node_t ** prev_node_p = (lv_ll_node_t **) &prev;

    *act_node_p = *prev_node_p;
   1b17c:	6803      	ldr	r3, [r0, #0]
   1b17e:	50ca      	str	r2, [r1, r3]
}
   1b180:	4770      	bx	lr

0001b182 <node_set_next.isra.0>:
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
   1b182:	b111      	cbz	r1, 1b18a <node_set_next.isra.0+0x8>

    act8 += LL_NEXT_P_OFFSET(ll_p);
    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
    lv_ll_node_t ** next_node_p = (lv_ll_node_t **) &next;

    *act_node_p = *next_node_p;
   1b184:	6803      	ldr	r3, [r0, #0]
   1b186:	4419      	add	r1, r3
   1b188:	604a      	str	r2, [r1, #4]
}
   1b18a:	4770      	bx	lr

0001b18c <_lv_ll_init>:
    ll_p->head = NULL;
   1b18c:	2300      	movs	r3, #0
    node_size = (node_size + 3) & (~0x3);
   1b18e:	3103      	adds	r1, #3
   1b190:	f021 0103 	bic.w	r1, r1, #3
    ll_p->tail = NULL;
   1b194:	e9c0 3301 	strd	r3, r3, [r0, #4]
    ll_p->n_size = node_size;
   1b198:	6001      	str	r1, [r0, #0]
}
   1b19a:	4770      	bx	lr

0001b19c <_lv_ll_ins_head>:
{
   1b19c:	b538      	push	{r3, r4, r5, lr}
   1b19e:	4604      	mov	r4, r0
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   1b1a0:	6800      	ldr	r0, [r0, #0]
   1b1a2:	3008      	adds	r0, #8
   1b1a4:	f7f1 fc78 	bl	ca98 <lv_mem_alloc>
    if(n_new != NULL) {
   1b1a8:	4605      	mov	r5, r0
   1b1aa:	b180      	cbz	r0, 1b1ce <_lv_ll_ins_head+0x32>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
   1b1ac:	4601      	mov	r1, r0
   1b1ae:	2200      	movs	r2, #0
   1b1b0:	4620      	mov	r0, r4
   1b1b2:	f7ff ffe2 	bl	1b17a <node_set_prev.isra.0>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
   1b1b6:	6862      	ldr	r2, [r4, #4]
   1b1b8:	f7ff ffe3 	bl	1b182 <node_set_next.isra.0>
        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
   1b1bc:	6861      	ldr	r1, [r4, #4]
   1b1be:	b111      	cbz	r1, 1b1c6 <_lv_ll_ins_head+0x2a>
            node_set_prev(ll_p, ll_p->head, n_new);
   1b1c0:	462a      	mov	r2, r5
   1b1c2:	f7ff ffda 	bl	1b17a <node_set_prev.isra.0>
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
   1b1c6:	68a3      	ldr	r3, [r4, #8]
        ll_p->head = n_new;      /*Set the new head in the dsc.*/
   1b1c8:	6065      	str	r5, [r4, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
   1b1ca:	b903      	cbnz	r3, 1b1ce <_lv_ll_ins_head+0x32>
            ll_p->tail = n_new;
   1b1cc:	60a5      	str	r5, [r4, #8]
}
   1b1ce:	4628      	mov	r0, r5
   1b1d0:	bd38      	pop	{r3, r4, r5, pc}

0001b1d2 <_lv_ll_ins_tail>:
{
   1b1d2:	b538      	push	{r3, r4, r5, lr}
   1b1d4:	4604      	mov	r4, r0
    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   1b1d6:	6800      	ldr	r0, [r0, #0]
   1b1d8:	3008      	adds	r0, #8
   1b1da:	f7f1 fc5d 	bl	ca98 <lv_mem_alloc>
    if(n_new != NULL) {
   1b1de:	4605      	mov	r5, r0
   1b1e0:	b188      	cbz	r0, 1b206 <_lv_ll_ins_tail+0x34>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
   1b1e2:	4601      	mov	r1, r0
   1b1e4:	2200      	movs	r2, #0
   1b1e6:	4620      	mov	r0, r4
   1b1e8:	f7ff ffcb 	bl	1b182 <node_set_next.isra.0>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is the old tail*/
   1b1ec:	4629      	mov	r1, r5
   1b1ee:	68a2      	ldr	r2, [r4, #8]
   1b1f0:	f7ff ffc3 	bl	1b17a <node_set_prev.isra.0>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
   1b1f4:	68a1      	ldr	r1, [r4, #8]
   1b1f6:	b111      	cbz	r1, 1b1fe <_lv_ll_ins_tail+0x2c>
            node_set_next(ll_p, ll_p->tail, n_new);
   1b1f8:	462a      	mov	r2, r5
   1b1fa:	f7ff ffc2 	bl	1b182 <node_set_next.isra.0>
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
   1b1fe:	6863      	ldr	r3, [r4, #4]
        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
   1b200:	60a5      	str	r5, [r4, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
   1b202:	b903      	cbnz	r3, 1b206 <_lv_ll_ins_tail+0x34>
            ll_p->head = n_new;
   1b204:	6065      	str	r5, [r4, #4]
}
   1b206:	4628      	mov	r0, r5
   1b208:	bd38      	pop	{r3, r4, r5, pc}

0001b20a <_lv_ll_get_head>:
    if(ll_p != NULL) {
   1b20a:	b100      	cbz	r0, 1b20e <_lv_ll_get_head+0x4>
        head = ll_p->head;
   1b20c:	6840      	ldr	r0, [r0, #4]
}
   1b20e:	4770      	bx	lr

0001b210 <_lv_ll_get_tail>:
    if(ll_p != NULL) {
   1b210:	b100      	cbz	r0, 1b214 <_lv_ll_get_tail+0x4>
        tail = ll_p->tail;
   1b212:	6880      	ldr	r0, [r0, #8]
}
   1b214:	4770      	bx	lr

0001b216 <_lv_ll_get_next>:
    if(ll_p == NULL) return NULL;
   1b216:	b110      	cbz	r0, 1b21e <_lv_ll_get_next+0x8>
    return *((lv_ll_node_t **)n_act_d);
   1b218:	6803      	ldr	r3, [r0, #0]
   1b21a:	4419      	add	r1, r3
   1b21c:	6848      	ldr	r0, [r1, #4]
}
   1b21e:	4770      	bx	lr

0001b220 <_lv_ll_get_prev>:
    if(ll_p == NULL) return NULL;
   1b220:	b108      	cbz	r0, 1b226 <_lv_ll_get_prev+0x6>
    return *((lv_ll_node_t **)n_act_d);
   1b222:	6803      	ldr	r3, [r0, #0]
   1b224:	58c8      	ldr	r0, [r1, r3]
}
   1b226:	4770      	bx	lr

0001b228 <_lv_ll_ins_prev>:
{
   1b228:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b22a:	460e      	mov	r6, r1
    if(NULL == ll_p || NULL == n_act) return NULL;
   1b22c:	4605      	mov	r5, r0
   1b22e:	b348      	cbz	r0, 1b284 <_lv_ll_ins_prev+0x5c>
   1b230:	b351      	cbz	r1, 1b288 <_lv_ll_ins_prev+0x60>
    if(_lv_ll_get_head(ll_p) == n_act) {
   1b232:	6843      	ldr	r3, [r0, #4]
   1b234:	4299      	cmp	r1, r3
   1b236:	d107      	bne.n	1b248 <_lv_ll_ins_prev+0x20>
        n_new = _lv_ll_ins_head(ll_p);
   1b238:	f7ff ffb0 	bl	1b19c <_lv_ll_ins_head>
        if(n_new == NULL) return NULL;
   1b23c:	2800      	cmp	r0, #0
   1b23e:	bf38      	it	cc
   1b240:	2000      	movcc	r0, #0
   1b242:	4604      	mov	r4, r0
}
   1b244:	4620      	mov	r0, r4
   1b246:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
   1b248:	6800      	ldr	r0, [r0, #0]
   1b24a:	3008      	adds	r0, #8
   1b24c:	f7f1 fc24 	bl	ca98 <lv_mem_alloc>
        if(n_new == NULL) return NULL;
   1b250:	4604      	mov	r4, r0
   1b252:	2800      	cmp	r0, #0
   1b254:	d0f6      	beq.n	1b244 <_lv_ll_ins_prev+0x1c>
        n_prev = _lv_ll_get_prev(ll_p, n_act);
   1b256:	4631      	mov	r1, r6
   1b258:	4628      	mov	r0, r5
   1b25a:	f7ff ffe1 	bl	1b220 <_lv_ll_get_prev>
   1b25e:	4607      	mov	r7, r0
        node_set_next(ll_p, n_prev, n_new);
   1b260:	4622      	mov	r2, r4
   1b262:	4601      	mov	r1, r0
   1b264:	4628      	mov	r0, r5
   1b266:	f7ff ff8c 	bl	1b182 <node_set_next.isra.0>
        node_set_prev(ll_p, n_new, n_prev);
   1b26a:	463a      	mov	r2, r7
   1b26c:	4621      	mov	r1, r4
   1b26e:	f7ff ff84 	bl	1b17a <node_set_prev.isra.0>
        node_set_prev(ll_p, n_act, n_new);
   1b272:	4622      	mov	r2, r4
   1b274:	4631      	mov	r1, r6
   1b276:	f7ff ff80 	bl	1b17a <node_set_prev.isra.0>
        node_set_next(ll_p, n_new, n_act);
   1b27a:	4632      	mov	r2, r6
   1b27c:	4621      	mov	r1, r4
   1b27e:	f7ff ff80 	bl	1b182 <node_set_next.isra.0>
   1b282:	e7df      	b.n	1b244 <_lv_ll_ins_prev+0x1c>
    if(NULL == ll_p || NULL == n_act) return NULL;
   1b284:	4604      	mov	r4, r0
   1b286:	e7dd      	b.n	1b244 <_lv_ll_ins_prev+0x1c>
   1b288:	460c      	mov	r4, r1
   1b28a:	e7db      	b.n	1b244 <_lv_ll_ins_prev+0x1c>

0001b28c <_lv_ll_remove>:
{
   1b28c:	b570      	push	{r4, r5, r6, lr}
   1b28e:	460d      	mov	r5, r1
    if(ll_p != NULL) {
   1b290:	4604      	mov	r4, r0
   1b292:	b308      	cbz	r0, 1b2d8 <_lv_ll_remove+0x4c>
    if(_lv_ll_get_head(ll_p) == node_p) {
   1b294:	6843      	ldr	r3, [r0, #4]
   1b296:	4299      	cmp	r1, r3
   1b298:	d10e      	bne.n	1b2b8 <_lv_ll_remove+0x2c>
        ll_p->head = _lv_ll_get_next(ll_p, node_p);
   1b29a:	4629      	mov	r1, r5
   1b29c:	4620      	mov	r0, r4
   1b29e:	f7ff ffba 	bl	1b216 <_lv_ll_get_next>
   1b2a2:	4601      	mov	r1, r0
   1b2a4:	6060      	str	r0, [r4, #4]
        if(ll_p->head == NULL) {
   1b2a6:	b908      	cbnz	r0, 1b2ac <_lv_ll_remove+0x20>
            ll_p->tail = NULL;
   1b2a8:	60a0      	str	r0, [r4, #8]
}
   1b2aa:	bd70      	pop	{r4, r5, r6, pc}
            node_set_prev(ll_p, ll_p->head, NULL);
   1b2ac:	2200      	movs	r2, #0
        node_set_prev(ll_p, n_next, n_prev);
   1b2ae:	4620      	mov	r0, r4
}
   1b2b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        node_set_prev(ll_p, n_next, n_prev);
   1b2b4:	f7ff bf61 	b.w	1b17a <node_set_prev.isra.0>
    else if(_lv_ll_get_tail(ll_p) == node_p) {
   1b2b8:	6883      	ldr	r3, [r0, #8]
   1b2ba:	4299      	cmp	r1, r3
   1b2bc:	d10e      	bne.n	1b2dc <_lv_ll_remove+0x50>
   1b2be:	f7ff ffaf 	bl	1b220 <_lv_ll_get_prev>
   1b2c2:	4601      	mov	r1, r0
        ll_p->tail = _lv_ll_get_prev(ll_p, node_p);
   1b2c4:	60a0      	str	r0, [r4, #8]
        if(ll_p->tail == NULL) {
   1b2c6:	b908      	cbnz	r0, 1b2cc <_lv_ll_remove+0x40>
            ll_p->head = NULL;
   1b2c8:	6060      	str	r0, [r4, #4]
   1b2ca:	e7ee      	b.n	1b2aa <_lv_ll_remove+0x1e>
            node_set_next(ll_p, ll_p->tail, NULL);
   1b2cc:	4620      	mov	r0, r4
}
   1b2ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            node_set_next(ll_p, ll_p->tail, NULL);
   1b2d2:	2200      	movs	r2, #0
   1b2d4:	f7ff bf55 	b.w	1b182 <node_set_next.isra.0>
    if(_lv_ll_get_head(ll_p) == node_p) {
   1b2d8:	2900      	cmp	r1, #0
   1b2da:	d0de      	beq.n	1b29a <_lv_ll_remove+0xe>
        lv_ll_node_t * n_prev = _lv_ll_get_prev(ll_p, node_p);
   1b2dc:	4629      	mov	r1, r5
   1b2de:	4620      	mov	r0, r4
   1b2e0:	f7ff ff9e 	bl	1b220 <_lv_ll_get_prev>
   1b2e4:	4606      	mov	r6, r0
        lv_ll_node_t * n_next = _lv_ll_get_next(ll_p, node_p);
   1b2e6:	4620      	mov	r0, r4
   1b2e8:	f7ff ff95 	bl	1b216 <_lv_ll_get_next>
   1b2ec:	4605      	mov	r5, r0
        node_set_next(ll_p, n_prev, n_next);
   1b2ee:	4602      	mov	r2, r0
   1b2f0:	4631      	mov	r1, r6
   1b2f2:	4620      	mov	r0, r4
   1b2f4:	f7ff ff45 	bl	1b182 <node_set_next.isra.0>
        node_set_prev(ll_p, n_next, n_prev);
   1b2f8:	4632      	mov	r2, r6
   1b2fa:	4629      	mov	r1, r5
   1b2fc:	e7d7      	b.n	1b2ae <_lv_ll_remove+0x22>

0001b2fe <_lv_ll_chg_list>:
{
   1b2fe:	b570      	push	{r4, r5, r6, lr}
   1b300:	461e      	mov	r6, r3
   1b302:	460c      	mov	r4, r1
    _lv_ll_remove(ll_ori_p, node);
   1b304:	4611      	mov	r1, r2
{
   1b306:	4615      	mov	r5, r2
    _lv_ll_remove(ll_ori_p, node);
   1b308:	f7ff ffc0 	bl	1b28c <_lv_ll_remove>
    if(head) {
   1b30c:	b18e      	cbz	r6, 1b332 <_lv_ll_chg_list+0x34>
        node_set_prev(ll_new_p, node, NULL);
   1b30e:	4629      	mov	r1, r5
   1b310:	2200      	movs	r2, #0
   1b312:	4620      	mov	r0, r4
   1b314:	f7ff ff31 	bl	1b17a <node_set_prev.isra.0>
        node_set_next(ll_new_p, node, ll_new_p->head);
   1b318:	6862      	ldr	r2, [r4, #4]
   1b31a:	f7ff ff32 	bl	1b182 <node_set_next.isra.0>
        if(ll_new_p->head != NULL) { /*If there is old head then before it goes the new*/
   1b31e:	6861      	ldr	r1, [r4, #4]
   1b320:	b111      	cbz	r1, 1b328 <_lv_ll_chg_list+0x2a>
            node_set_prev(ll_new_p, ll_new_p->head, node);
   1b322:	462a      	mov	r2, r5
   1b324:	f7ff ff29 	bl	1b17a <node_set_prev.isra.0>
        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/
   1b328:	68a3      	ldr	r3, [r4, #8]
        ll_new_p->head = node;       /*Set the new head in the dsc.*/
   1b32a:	6065      	str	r5, [r4, #4]
        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/
   1b32c:	b903      	cbnz	r3, 1b330 <_lv_ll_chg_list+0x32>
            ll_new_p->tail = node;
   1b32e:	60a5      	str	r5, [r4, #8]
}
   1b330:	bd70      	pop	{r4, r5, r6, pc}
        node_set_prev(ll_new_p, node, ll_new_p->tail);
   1b332:	4629      	mov	r1, r5
   1b334:	4620      	mov	r0, r4
   1b336:	68a2      	ldr	r2, [r4, #8]
   1b338:	f7ff ff1f 	bl	1b17a <node_set_prev.isra.0>
        node_set_next(ll_new_p, node, NULL);
   1b33c:	4632      	mov	r2, r6
   1b33e:	f7ff ff20 	bl	1b182 <node_set_next.isra.0>
        if(ll_new_p->tail != NULL) { /*If there is old tail then after it goes the new*/
   1b342:	68a1      	ldr	r1, [r4, #8]
   1b344:	b111      	cbz	r1, 1b34c <_lv_ll_chg_list+0x4e>
            node_set_next(ll_new_p, ll_new_p->tail, node);
   1b346:	462a      	mov	r2, r5
   1b348:	f7ff ff1b 	bl	1b182 <node_set_next.isra.0>
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
   1b34c:	6863      	ldr	r3, [r4, #4]
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
   1b34e:	60a5      	str	r5, [r4, #8]
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
   1b350:	2b00      	cmp	r3, #0
   1b352:	d1ed      	bne.n	1b330 <_lv_ll_chg_list+0x32>
            ll_new_p->head = node;
   1b354:	6065      	str	r5, [r4, #4]
}
   1b356:	e7eb      	b.n	1b330 <_lv_ll_chg_list+0x32>

0001b358 <_lv_ll_move_before>:
    if(n_act == n_after) return; /*Can't move before itself*/
   1b358:	4291      	cmp	r1, r2
{
   1b35a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b35c:	4604      	mov	r4, r0
   1b35e:	460d      	mov	r5, r1
   1b360:	4617      	mov	r7, r2
    if(n_act == n_after) return; /*Can't move before itself*/
   1b362:	d01f      	beq.n	1b3a4 <_lv_ll_move_before+0x4c>
    if(n_after != NULL)
   1b364:	b1fa      	cbz	r2, 1b3a6 <_lv_ll_move_before+0x4e>
        n_before = _lv_ll_get_prev(ll_p, n_after);
   1b366:	4611      	mov	r1, r2
   1b368:	f7ff ff5a 	bl	1b220 <_lv_ll_get_prev>
   1b36c:	4606      	mov	r6, r0
    if(n_act == n_before) return; /*Already before `n_after`*/
   1b36e:	42ae      	cmp	r6, r5
   1b370:	d018      	beq.n	1b3a4 <_lv_ll_move_before+0x4c>
    _lv_ll_remove(ll_p, n_act);
   1b372:	4629      	mov	r1, r5
   1b374:	4620      	mov	r0, r4
   1b376:	f7ff ff89 	bl	1b28c <_lv_ll_remove>
    node_set_next(ll_p, n_before, n_act);
   1b37a:	4620      	mov	r0, r4
   1b37c:	462a      	mov	r2, r5
   1b37e:	4631      	mov	r1, r6
   1b380:	f7ff feff 	bl	1b182 <node_set_next.isra.0>
    node_set_prev(ll_p, n_act, n_before);
   1b384:	4632      	mov	r2, r6
   1b386:	4629      	mov	r1, r5
   1b388:	f7ff fef7 	bl	1b17a <node_set_prev.isra.0>
    node_set_prev(ll_p, n_after, n_act);
   1b38c:	462a      	mov	r2, r5
   1b38e:	4639      	mov	r1, r7
   1b390:	f7ff fef3 	bl	1b17a <node_set_prev.isra.0>
    node_set_next(ll_p, n_act, n_after);
   1b394:	463a      	mov	r2, r7
   1b396:	4629      	mov	r1, r5
   1b398:	f7ff fef3 	bl	1b182 <node_set_next.isra.0>
    if(n_after == NULL) ll_p->tail = n_act;
   1b39c:	b907      	cbnz	r7, 1b3a0 <_lv_ll_move_before+0x48>
   1b39e:	60a5      	str	r5, [r4, #8]
    if(n_before == NULL) ll_p->head = n_act;
   1b3a0:	b906      	cbnz	r6, 1b3a4 <_lv_ll_move_before+0x4c>
   1b3a2:	6065      	str	r5, [r4, #4]
}
   1b3a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(ll_p != NULL) {
   1b3a6:	b108      	cbz	r0, 1b3ac <_lv_ll_move_before+0x54>
        tail = ll_p->tail;
   1b3a8:	6886      	ldr	r6, [r0, #8]
   1b3aa:	e7e0      	b.n	1b36e <_lv_ll_move_before+0x16>
    void * tail = NULL;
   1b3ac:	4606      	mov	r6, r0
   1b3ae:	e7de      	b.n	1b36e <_lv_ll_move_before+0x16>

0001b3b0 <_lv_ll_is_empty>:
    if(ll_p == NULL) return true;
   1b3b0:	b130      	cbz	r0, 1b3c0 <_lv_ll_is_empty+0x10>
    if(ll_p->head == NULL && ll_p->tail == NULL) return true;
   1b3b2:	6843      	ldr	r3, [r0, #4]
   1b3b4:	b933      	cbnz	r3, 1b3c4 <_lv_ll_is_empty+0x14>
   1b3b6:	6880      	ldr	r0, [r0, #8]
   1b3b8:	fab0 f080 	clz	r0, r0
   1b3bc:	0940      	lsrs	r0, r0, #5
   1b3be:	4770      	bx	lr
    if(ll_p == NULL) return true;
   1b3c0:	2001      	movs	r0, #1
   1b3c2:	4770      	bx	lr
    return false;
   1b3c4:	2000      	movs	r0, #0
}
   1b3c6:	4770      	bx	lr

0001b3c8 <_lv_bezier3>:
 * @param u2 control value 2 in range of [0..LV_BEZIER_VAL_MAX]
 * @param u3 end values in range of [0..LV_BEZIER_VAL_MAX]
 * @return the value calculated from the given parameters in range of [0..LV_BEZIER_VAL_MAX]
 */
int32_t _lv_bezier3(uint32_t t, int32_t u0, int32_t u1, int32_t u2, int32_t u3)
{
   1b3c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t t_rem  = 1024 - t;
    uint32_t t_rem2 = (t_rem * t_rem) >> 10;
    uint32_t t_rem3 = (t_rem2 * t_rem) >> 10;
    uint32_t t2     = (t * t) >> 10;
   1b3ca:	fb00 f500 	mul.w	r5, r0, r0
    uint32_t t_rem  = 1024 - t;
   1b3ce:	f5c0 6780 	rsb	r7, r0, #1024	; 0x400
    uint32_t t_rem2 = (t_rem * t_rem) >> 10;
   1b3d2:	fb07 f607 	mul.w	r6, r7, r7
    uint32_t t3     = (t2 * t) >> 10;

    uint32_t v1 = ((uint32_t)t_rem3 * u0) >> 10;
    uint32_t v2 = ((uint32_t)3 * t_rem2 * t * u1) >> 20;
   1b3d6:	4342      	muls	r2, r0
    uint32_t t2     = (t * t) >> 10;
   1b3d8:	0aad      	lsrs	r5, r5, #10
    uint32_t t3     = (t2 * t) >> 10;
   1b3da:	4368      	muls	r0, r5
    uint32_t v3 = ((uint32_t)3 * t_rem * t2 * u2) >> 20;
   1b3dc:	437b      	muls	r3, r7
    uint32_t t_rem2 = (t_rem * t_rem) >> 10;
   1b3de:	0ab6      	lsrs	r6, r6, #10
    uint32_t v2 = ((uint32_t)3 * t_rem2 * t * u1) >> 20;
   1b3e0:	4372      	muls	r2, r6
    uint32_t v4 = ((uint32_t)t3 * u3) >> 10;
   1b3e2:	9c05      	ldr	r4, [sp, #20]
    uint32_t t_rem3 = (t_rem2 * t_rem) >> 10;
   1b3e4:	437e      	muls	r6, r7
    uint32_t t3     = (t2 * t) >> 10;
   1b3e6:	0a80      	lsrs	r0, r0, #10
    uint32_t v4 = ((uint32_t)t3 * u3) >> 10;
   1b3e8:	4360      	muls	r0, r4
    uint32_t v3 = ((uint32_t)3 * t_rem * t2 * u2) >> 20;
   1b3ea:	435d      	muls	r5, r3
    uint32_t t_rem3 = (t_rem2 * t_rem) >> 10;
   1b3ec:	0ab6      	lsrs	r6, r6, #10
    uint32_t v1 = ((uint32_t)t_rem3 * u0) >> 10;
   1b3ee:	4371      	muls	r1, r6
    uint32_t v2 = ((uint32_t)3 * t_rem2 * t * u1) >> 20;
   1b3f0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    uint32_t v4 = ((uint32_t)t3 * u3) >> 10;
   1b3f4:	0a80      	lsrs	r0, r0, #10

    return v1 + v2 + v3 + v4;
   1b3f6:	eb00 5012 	add.w	r0, r0, r2, lsr #20
    uint32_t v3 = ((uint32_t)3 * t_rem * t2 * u2) >> 20;
   1b3fa:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    return v1 + v2 + v3 + v4;
   1b3fe:	eb00 5015 	add.w	r0, r0, r5, lsr #20
}
   1b402:	eb00 2091 	add.w	r0, r0, r1, lsr #10
   1b406:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001b408 <_lv_sqrt>:
 */
LV_ATTRIBUTE_FAST_MEM void _lv_sqrt(uint32_t x, lv_sqrt_res_t * q, uint32_t mask)
{
    x = x << 8; /*To get 4 bit precision. (sqrt(256) = 16 = 4 bit)*/

    uint32_t root = 0;
   1b408:	2300      	movs	r3, #0
{
   1b40a:	b530      	push	{r4, r5, lr}
    x = x << 8; /*To get 4 bit precision. (sqrt(256) = 16 = 4 bit)*/
   1b40c:	0200      	lsls	r0, r0, #8
    uint32_t trial;
    // http://ww1.microchip.com/...en/AppNotes/91040a.pdf
    do {
        trial = root + mask;
   1b40e:	18d4      	adds	r4, r2, r3
        if((uint32_t)trial * trial <= x) root = trial;
   1b410:	fb04 f504 	mul.w	r5, r4, r4
   1b414:	4285      	cmp	r5, r0
   1b416:	bf98      	it	ls
   1b418:	4623      	movls	r3, r4
        mask = mask >> 1;
    } while(mask);
   1b41a:	0852      	lsrs	r2, r2, #1
   1b41c:	d1f7      	bne.n	1b40e <_lv_sqrt+0x6>

    q->i = (uint32_t) root >> 4;
   1b41e:	091a      	lsrs	r2, r3, #4
    q->f = (uint32_t)(root & 0xf) << 4;
   1b420:	011b      	lsls	r3, r3, #4
   1b422:	b2db      	uxtb	r3, r3
    q->i = (uint32_t) root >> 4;
   1b424:	800a      	strh	r2, [r1, #0]
    q->f = (uint32_t)(root & 0xf) << 4;
   1b426:	804b      	strh	r3, [r1, #2]
}
   1b428:	bd30      	pop	{r4, r5, pc}

0001b42a <_lv_mem_init>:
}
   1b42a:	4770      	bx	lr

0001b42c <lv_mem_realloc>:
{
   1b42c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    new_size = (new_size + 3) & (~0x3);
   1b42e:	1ccd      	adds	r5, r1, #3
    if(data_p != NULL) {
   1b430:	4604      	mov	r4, r0
    new_size = (new_size + 3) & (~0x3);
   1b432:	f025 0503 	bic.w	r5, r5, #3
    if(data_p != NULL) {
   1b436:	b130      	cbz	r0, 1b446 <lv_mem_realloc+0x1a>
        if(e->header.s.used == 0) {
   1b438:	f810 3c04 	ldrb.w	r3, [r0, #-4]
            data_p = NULL;
   1b43c:	f013 0f01 	tst.w	r3, #1
   1b440:	bf14      	ite	ne
   1b442:	4604      	movne	r4, r0
   1b444:	2400      	moveq	r4, #0
    uint32_t old_size = _lv_mem_get_size(data_p);
   1b446:	4620      	mov	r0, r4
   1b448:	f7f1 fb4a 	bl	cae0 <_lv_mem_get_size>
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
   1b44c:	4285      	cmp	r5, r0
    uint32_t old_size = _lv_mem_get_size(data_p);
   1b44e:	4607      	mov	r7, r0
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
   1b450:	d012      	beq.n	1b478 <lv_mem_realloc+0x4c>
    new_p = lv_mem_alloc(new_size);
   1b452:	4628      	mov	r0, r5
   1b454:	f7f1 fb20 	bl	ca98 <lv_mem_alloc>
    if(new_p == NULL) {
   1b458:	4606      	mov	r6, r0
   1b45a:	b158      	cbz	r0, 1b474 <lv_mem_realloc+0x48>
    if(data_p != NULL) {
   1b45c:	b154      	cbz	r4, 1b474 <lv_mem_realloc+0x48>
        if(old_size != 0) {
   1b45e:	b14f      	cbz	r7, 1b474 <lv_mem_realloc+0x48>
   1b460:	42bd      	cmp	r5, r7
   1b462:	462a      	mov	r2, r5
   1b464:	4621      	mov	r1, r4
   1b466:	bf28      	it	cs
   1b468:	463a      	movcs	r2, r7
   1b46a:	f002 fa7a 	bl	1d962 <memcpy>
            lv_mem_free(data_p);
   1b46e:	4620      	mov	r0, r4
   1b470:	f7f1 fb26 	bl	cac0 <lv_mem_free>
}
   1b474:	4630      	mov	r0, r6
   1b476:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1b478:	4626      	mov	r6, r4
   1b47a:	e7fb      	b.n	1b474 <lv_mem_realloc+0x48>

0001b47c <lv_task_create>:
{
   1b47c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b480:	4680      	mov	r8, r0
   1b482:	460f      	mov	r7, r1
   1b484:	4616      	mov	r6, r2
   1b486:	461d      	mov	r5, r3
    lv_task_t * new_task = lv_task_create_basic();
   1b488:	f7f1 fbf8 	bl	cc7c <lv_task_create_basic>
    if(new_task == NULL) return NULL;
   1b48c:	4604      	mov	r4, r0
   1b48e:	b130      	cbz	r0, 1b49e <lv_task_create+0x22>
    lv_task_set_prio(new_task, prio);
   1b490:	4631      	mov	r1, r6
    task->task_cb = task_cb;
   1b492:	f8c0 8008 	str.w	r8, [r0, #8]
    task->period = period;
   1b496:	6007      	str	r7, [r0, #0]
    lv_task_set_prio(new_task, prio);
   1b498:	f7f1 fd3a 	bl	cf10 <lv_task_set_prio>
    new_task->user_data = user_data;
   1b49c:	60e5      	str	r5, [r4, #12]
}
   1b49e:	4620      	mov	r0, r4
   1b4a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001b4a4 <lv_task_ready>:
{
   1b4a4:	b510      	push	{r4, lr}
   1b4a6:	4604      	mov	r4, r0
    task->last_run = lv_tick_get() - task->period - 1;
   1b4a8:	f7ff fb63 	bl	1ab72 <lv_tick_get>
   1b4ac:	6823      	ldr	r3, [r4, #0]
   1b4ae:	43db      	mvns	r3, r3
   1b4b0:	4403      	add	r3, r0
   1b4b2:	6063      	str	r3, [r4, #4]
}
   1b4b4:	bd10      	pop	{r4, pc}

0001b4b6 <lv_txt_iso8859_1_size>:
}
   1b4b6:	2001      	movs	r0, #1
   1b4b8:	4770      	bx	lr

0001b4ba <lv_txt_iso8859_1_next>:
    if(i == NULL) return txt[1]; /*Get the next char */
   1b4ba:	b909      	cbnz	r1, 1b4c0 <lv_txt_iso8859_1_next+0x6>
   1b4bc:	7840      	ldrb	r0, [r0, #1]
   1b4be:	4770      	bx	lr
    uint8_t letter = txt[*i];
   1b4c0:	680b      	ldr	r3, [r1, #0]
   1b4c2:	5cc0      	ldrb	r0, [r0, r3]
    (*i)++;
   1b4c4:	3301      	adds	r3, #1
   1b4c6:	600b      	str	r3, [r1, #0]
}
   1b4c8:	4770      	bx	lr

0001b4ca <lv_txt_iso8859_1_prev>:
    if(i == NULL) return *(txt - 1); /*Get the prev. char */
   1b4ca:	b911      	cbnz	r1, 1b4d2 <lv_txt_iso8859_1_prev+0x8>
   1b4cc:	f810 0c01 	ldrb.w	r0, [r0, #-1]
   1b4d0:	4770      	bx	lr
    (*i)--;
   1b4d2:	680b      	ldr	r3, [r1, #0]
   1b4d4:	3b01      	subs	r3, #1
   1b4d6:	600b      	str	r3, [r1, #0]
    return letter;
   1b4d8:	5cc0      	ldrb	r0, [r0, r3]
}
   1b4da:	4770      	bx	lr

0001b4dc <lv_txt_iso8859_1_get_byte_id>:
}
   1b4dc:	4608      	mov	r0, r1
   1b4de:	4770      	bx	lr

0001b4e0 <lv_txt_iso8859_1_get_length>:
    return strlen(txt);
   1b4e0:	f7e4 bfc0 	b.w	464 <strlen>

0001b4e4 <lv_txt_iso8859_1_get_char_id>:
   1b4e4:	4608      	mov	r0, r1
   1b4e6:	4770      	bx	lr

0001b4e8 <_lv_txt_is_cmd>:
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
   1b4e8:	2923      	cmp	r1, #35	; 0x23
{
   1b4ea:	4603      	mov	r3, r0
    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
   1b4ec:	d116      	bne.n	1b51c <_lv_txt_is_cmd+0x34>
   1b4ee:	7802      	ldrb	r2, [r0, #0]
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
   1b4f0:	b95a      	cbnz	r2, 1b50a <_lv_txt_is_cmd+0x22>
            *state = LV_TXT_CMD_STATE_PAR;
   1b4f2:	2001      	movs	r0, #1
            *state = LV_TXT_CMD_STATE_WAIT;
   1b4f4:	7018      	strb	r0, [r3, #0]
    if(*state == LV_TXT_CMD_STATE_PAR) {
   1b4f6:	781a      	ldrb	r2, [r3, #0]
   1b4f8:	2a01      	cmp	r2, #1
   1b4fa:	d105      	bne.n	1b508 <_lv_txt_is_cmd+0x20>
        if(c == ' ') {
   1b4fc:	2920      	cmp	r1, #32
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
   1b4fe:	bf08      	it	eq
   1b500:	2102      	moveq	r1, #2
        ret = true;
   1b502:	4610      	mov	r0, r2
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
   1b504:	bf08      	it	eq
   1b506:	7019      	strbeq	r1, [r3, #0]
}
   1b508:	4770      	bx	lr
        else if(*state == LV_TXT_CMD_STATE_PAR) {
   1b50a:	2a01      	cmp	r2, #1
   1b50c:	f04f 0000 	mov.w	r0, #0
   1b510:	d0f0      	beq.n	1b4f4 <_lv_txt_is_cmd+0xc>
        else if(*state == LV_TXT_CMD_STATE_IN) {
   1b512:	2a02      	cmp	r2, #2
   1b514:	d1ef      	bne.n	1b4f6 <_lv_txt_is_cmd+0xe>
            *state = LV_TXT_CMD_STATE_WAIT;
   1b516:	7018      	strb	r0, [r3, #0]
            ret    = true;
   1b518:	2001      	movs	r0, #1
   1b51a:	e7ec      	b.n	1b4f6 <_lv_txt_is_cmd+0xe>
    bool ret = false;
   1b51c:	2000      	movs	r0, #0
   1b51e:	e7ea      	b.n	1b4f6 <_lv_txt_is_cmd+0xe>

0001b520 <_lv_txt_get_size>:
{
   1b520:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    size_res->x = 0;
   1b524:	2500      	movs	r5, #0
{
   1b526:	b087      	sub	sp, #28
   1b528:	4698      	mov	r8, r3
   1b52a:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
   1b52e:	4604      	mov	r4, r0
   1b530:	4616      	mov	r6, r2
   1b532:	f9bd 7040 	ldrsh.w	r7, [sp, #64]	; 0x40
   1b536:	f9bd a044 	ldrsh.w	sl, [sp, #68]	; 0x44
   1b53a:	9303      	str	r3, [sp, #12]
    size_res->x = 0;
   1b53c:	8005      	strh	r5, [r0, #0]
    size_res->y = 0;
   1b53e:	8045      	strh	r5, [r0, #2]
    if(text == NULL) return;
   1b540:	9102      	str	r1, [sp, #8]
   1b542:	b329      	cbz	r1, 1b590 <_lv_txt_get_size+0x70>
    if(font == NULL) return;
   1b544:	b322      	cbz	r2, 1b590 <_lv_txt_get_size+0x70>
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   1b546:	9b03      	ldr	r3, [sp, #12]
    uint16_t letter_height = lv_font_get_line_height(font);
   1b548:	f9b2 b008 	ldrsh.w	fp, [r2, #8]
    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
   1b54c:	f013 0f02 	tst.w	r3, #2
   1b550:	f647 4318 	movw	r3, #31768	; 0x7c18
   1b554:	bf18      	it	ne
   1b556:	469a      	movne	sl, r3
    uint16_t letter_height = lv_font_get_line_height(font);
   1b558:	8913      	ldrh	r3, [r2, #8]
        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {
   1b55a:	443b      	add	r3, r7
   1b55c:	9304      	str	r3, [sp, #16]
            size_res->y += line_space;
   1b55e:	eb07 030b 	add.w	r3, r7, fp
   1b562:	9305      	str	r3, [sp, #20]
    while(text[line_start] != '\0') {
   1b564:	9b02      	ldr	r3, [sp, #8]
   1b566:	eb03 0905 	add.w	r9, r3, r5
   1b56a:	5d5b      	ldrb	r3, [r3, r5]
   1b56c:	b99b      	cbnz	r3, 1b596 <_lv_txt_get_size+0x76>
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
   1b56e:	b155      	cbz	r5, 1b586 <_lv_txt_get_size+0x66>
   1b570:	f819 3c01 	ldrb.w	r3, [r9, #-1]
   1b574:	2b0a      	cmp	r3, #10
   1b576:	d001      	beq.n	1b57c <_lv_txt_get_size+0x5c>
   1b578:	2b0d      	cmp	r3, #13
   1b57a:	d104      	bne.n	1b586 <_lv_txt_get_size+0x66>
        size_res->y += letter_height + line_space;
   1b57c:	8862      	ldrh	r2, [r4, #2]
   1b57e:	eb07 030b 	add.w	r3, r7, fp
   1b582:	4413      	add	r3, r2
   1b584:	8063      	strh	r3, [r4, #2]
    if(size_res->y == 0)
   1b586:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
   1b58a:	bb33      	cbnz	r3, 1b5da <_lv_txt_get_size+0xba>
        size_res->y = letter_height;
   1b58c:	f8a4 b002 	strh.w	fp, [r4, #2]
}
   1b590:	b007      	add	sp, #28
   1b592:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   1b596:	9b03      	ldr	r3, [sp, #12]
   1b598:	4642      	mov	r2, r8
   1b59a:	4631      	mov	r1, r6
   1b59c:	9300      	str	r3, [sp, #0]
   1b59e:	4648      	mov	r0, r9
   1b5a0:	4653      	mov	r3, sl
   1b5a2:	f7f1 fd33 	bl	d00c <_lv_txt_get_next_line>
        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {
   1b5a6:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
   1b5aa:	9a04      	ldr	r2, [sp, #16]
        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   1b5ac:	4601      	mov	r1, r0
        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {
   1b5ae:	441a      	add	r2, r3
   1b5b0:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
   1b5b4:	4405      	add	r5, r0
        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {
   1b5b6:	d2eb      	bcs.n	1b590 <_lv_txt_get_size+0x70>
            size_res->y += line_space;
   1b5b8:	9a05      	ldr	r2, [sp, #20]
        lv_coord_t act_line_length = _lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space,
   1b5ba:	4648      	mov	r0, r9
            size_res->y += line_space;
   1b5bc:	4413      	add	r3, r2
   1b5be:	8063      	strh	r3, [r4, #2]
        lv_coord_t act_line_length = _lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space,
   1b5c0:	9b03      	ldr	r3, [sp, #12]
   1b5c2:	4632      	mov	r2, r6
   1b5c4:	9300      	str	r3, [sp, #0]
   1b5c6:	4643      	mov	r3, r8
   1b5c8:	f7f1 fcce 	bl	cf68 <_lv_txt_get_width>
        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
   1b5cc:	f9b4 3000 	ldrsh.w	r3, [r4]
   1b5d0:	4283      	cmp	r3, r0
   1b5d2:	bfb8      	it	lt
   1b5d4:	4603      	movlt	r3, r0
   1b5d6:	8023      	strh	r3, [r4, #0]
        line_start  = new_line_start;
   1b5d8:	e7c4      	b.n	1b564 <_lv_txt_get_size+0x44>
        size_res->y -= line_space;
   1b5da:	1bdf      	subs	r7, r3, r7
   1b5dc:	8067      	strh	r7, [r4, #2]
   1b5de:	e7d7      	b.n	1b590 <_lv_txt_get_size+0x70>

0001b5e0 <_lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * _lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                         int32_t (*cmp)(const void * pRef, const void * pElement))
{
   1b5e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1b5e4:	4680      	mov	r8, r0
   1b5e6:	460f      	mov	r7, r1
   1b5e8:	4614      	mov	r4, r2
   1b5ea:	4699      	mov	r9, r3
   1b5ec:	9d08      	ldr	r5, [sp, #32]
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
   1b5ee:	b90c      	cbnz	r4, 1b5f4 <_lv_utils_bsearch+0x14>
        }
        else {
            return (char *)middle;
        }
    }
    return NULL;
   1b5f0:	4626      	mov	r6, r4
   1b5f2:	e012      	b.n	1b61a <_lv_utils_bsearch+0x3a>
        middle += (n / 2) * size;
   1b5f4:	ea4f 0a54 	mov.w	sl, r4, lsr #1
   1b5f8:	fb09 760a 	mla	r6, r9, sl, r7
        if((c = (*cmp)(key, middle)) > 0) {
   1b5fc:	4640      	mov	r0, r8
   1b5fe:	4631      	mov	r1, r6
   1b600:	47a8      	blx	r5
   1b602:	2800      	cmp	r0, #0
   1b604:	dd08      	ble.n	1b618 <_lv_utils_bsearch+0x38>
            n    = (n / 2) - ((n & 1) == 0);
   1b606:	43e4      	mvns	r4, r4
   1b608:	f004 0401 	and.w	r4, r4, #1
   1b60c:	ebaa 0a04 	sub.w	sl, sl, r4
            base = (middle += size);
   1b610:	eb06 0709 	add.w	r7, r6, r9
{
   1b614:	4654      	mov	r4, sl
   1b616:	e7ea      	b.n	1b5ee <_lv_utils_bsearch+0xe>
        else if(c < 0) {
   1b618:	d1fc      	bne.n	1b614 <_lv_utils_bsearch+0x34>
}
   1b61a:	4630      	mov	r0, r6
   1b61c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001b620 <lv_font_get_glyph_bitmap>:
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
    return font_p->get_glyph_bitmap(font_p, letter);
   1b620:	6843      	ldr	r3, [r0, #4]
   1b622:	4718      	bx	r3

0001b624 <lv_font_get_glyph_dsc>:
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter,
                           uint32_t letter_next)
{
   1b624:	b410      	push	{r4}
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
   1b626:	6804      	ldr	r4, [r0, #0]
   1b628:	46a4      	mov	ip, r4
}
   1b62a:	bc10      	pop	{r4}
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
   1b62c:	4760      	bx	ip

0001b62e <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
   1b62e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   1b630:	4613      	mov	r3, r2
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
   1b632:	460a      	mov	r2, r1
   1b634:	a901      	add	r1, sp, #4
   1b636:	f7ff fff5 	bl	1b624 <lv_font_get_glyph_dsc>
    if(ret) return g.adv_w;
   1b63a:	b108      	cbz	r0, 1b640 <lv_font_get_glyph_width+0x12>
   1b63c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
    else return 0;
}
   1b640:	b005      	add	sp, #20
   1b642:	f85d fb04 	ldr.w	pc, [sp], #4

0001b646 <kern_pair_8_compare>:
{
    const uint8_t * ref8_p = ref;
    const uint8_t * element8_p = element;

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
   1b646:	7803      	ldrb	r3, [r0, #0]
   1b648:	780a      	ldrb	r2, [r1, #0]
   1b64a:	4293      	cmp	r3, r2
    else return (int32_t) ref8_p[1] - element8_p[1];
   1b64c:	bf09      	itett	eq
   1b64e:	784b      	ldrbeq	r3, [r1, #1]
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
   1b650:	1a98      	subne	r0, r3, r2
    else return (int32_t) ref8_p[1] - element8_p[1];
   1b652:	7840      	ldrbeq	r0, [r0, #1]
   1b654:	1ac0      	subeq	r0, r0, r3

}
   1b656:	4770      	bx	lr

0001b658 <kern_pair_16_compare>:
{
    const uint16_t * ref16_p = ref;
    const uint16_t * element16_p = element;

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
   1b658:	8803      	ldrh	r3, [r0, #0]
   1b65a:	880a      	ldrh	r2, [r1, #0]
   1b65c:	4293      	cmp	r3, r2
    else return (int32_t) ref16_p[1] - element16_p[1];
   1b65e:	bf09      	itett	eq
   1b660:	884b      	ldrheq	r3, [r1, #2]
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
   1b662:	1a98      	subne	r0, r3, r2
    else return (int32_t) ref16_p[1] - element16_p[1];
   1b664:	8840      	ldrheq	r0, [r0, #2]
   1b666:	1ac0      	subeq	r0, r0, r3
}
   1b668:	4770      	bx	lr

0001b66a <unicode_list_compare>:
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
    return ((int32_t)(*(uint16_t *)ref)) - ((int32_t)(*(uint16_t *)element));
   1b66a:	8800      	ldrh	r0, [r0, #0]
   1b66c:	880b      	ldrh	r3, [r1, #0]
}
   1b66e:	1ac0      	subs	r0, r0, r3
   1b670:	4770      	bx	lr

0001b672 <lv_font_get_bitmap_fmt_txt>:
    if(unicode_letter == '\t') unicode_letter = ' ';
   1b672:	2909      	cmp	r1, #9
{
   1b674:	b510      	push	{r4, lr}
    if(unicode_letter == '\t') unicode_letter = ' ';
   1b676:	d002      	beq.n	1b67e <lv_font_get_bitmap_fmt_txt+0xc>
    if(letter == '\0') return 0;
   1b678:	b911      	cbnz	r1, 1b680 <lv_font_get_bitmap_fmt_txt+0xe>
    if(!gid) return NULL;
   1b67a:	2000      	movs	r0, #0
}
   1b67c:	bd10      	pop	{r4, pc}
    if(unicode_letter == '\t') unicode_letter = ' ';
   1b67e:	2120      	movs	r1, #32
   1b680:	f850 4f10 	ldr.w	r4, [r0, #16]!
   1b684:	f7f1 fda6 	bl	d1d4 <get_glyph_dsc_id.isra.0.part.0>
    if(!gid) return NULL;
   1b688:	2800      	cmp	r0, #0
   1b68a:	d0f6      	beq.n	1b67a <lv_font_get_bitmap_fmt_txt+0x8>
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
   1b68c:	7d21      	ldrb	r1, [r4, #20]
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
   1b68e:	6863      	ldr	r3, [r4, #4]
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
   1b690:	0789      	lsls	r1, r1, #30
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
   1b692:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
   1b696:	d1f0      	bne.n	1b67a <lv_font_get_bitmap_fmt_txt+0x8>
        if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
   1b698:	2a00      	cmp	r2, #0
   1b69a:	d0ee      	beq.n	1b67a <lv_font_get_bitmap_fmt_txt+0x8>
   1b69c:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
   1b6a0:	6820      	ldr	r0, [r4, #0]
   1b6a2:	f3c3 0313 	ubfx	r3, r3, #0, #20
   1b6a6:	4418      	add	r0, r3
   1b6a8:	e7e8      	b.n	1b67c <lv_font_get_bitmap_fmt_txt+0xa>

0001b6aa <lv_color_hex>:
    return LV_COLOR_MAKE(r, g, b);
   1b6aa:	2300      	movs	r3, #0
   1b6ac:	f360 030f 	bfi	r3, r0, #0, #16
}

static inline lv_color_t lv_color_hex(uint32_t c)
{
    return lv_color_make((uint8_t)((c >> 16) & 0xFF), (uint8_t)((c >> 8) & 0xFF), (uint8_t)(c & 0xFF));
   1b6b0:	0c00      	lsrs	r0, r0, #16
   1b6b2:	f360 4317 	bfi	r3, r0, #16, #8
}
   1b6b6:	f043 407f 	orr.w	r0, r3, #4278190080	; 0xff000000
   1b6ba:	4770      	bx	lr

0001b6bc <lv_btn_set_checkable>:
{
   1b6bc:	b510      	push	{r4, lr}
   1b6be:	460c      	mov	r4, r1
    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
   1b6c0:	f7fa fd3c 	bl	1613c <lv_obj_get_ext_attr>
    ext->checkable = tgl != false ? 1 : 0;
   1b6c4:	7883      	ldrb	r3, [r0, #2]
   1b6c6:	f364 0300 	bfi	r3, r4, #0, #1
   1b6ca:	7083      	strb	r3, [r0, #2]
}
   1b6cc:	bd10      	pop	{r4, pc}

0001b6ce <lv_btn_set_state>:
{
   1b6ce:	b510      	push	{r4, lr}
   1b6d0:	4604      	mov	r4, r0
   1b6d2:	2905      	cmp	r1, #5
   1b6d4:	d827      	bhi.n	1b726 <lv_btn_set_state+0x58>
   1b6d6:	e8df f001 	tbb	[pc, r1]
   1b6da:	0903      	.short	0x0903
   1b6dc:	2117121c 	.word	0x2117121c
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_CHECKED | LV_STATE_DISABLED);
   1b6e0:	2131      	movs	r1, #49	; 0x31
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_DISABLED);
   1b6e2:	4620      	mov	r0, r4
}
   1b6e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_DISABLED);
   1b6e8:	f7fb b8a0 	b.w	1682c <lv_obj_clear_state>
            lv_obj_clear_state(btn, LV_STATE_CHECKED | LV_STATE_DISABLED);
   1b6ec:	2121      	movs	r1, #33	; 0x21
   1b6ee:	f7fb f89d 	bl	1682c <lv_obj_clear_state>
            lv_obj_add_state(btn, LV_STATE_PRESSED);
   1b6f2:	2110      	movs	r1, #16
            lv_obj_add_state(btn, LV_STATE_DISABLED | LV_STATE_CHECKED);
   1b6f4:	4620      	mov	r0, r4
}
   1b6f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            lv_obj_add_state(btn, LV_STATE_DISABLED | LV_STATE_CHECKED);
   1b6fa:	f7fb b88d 	b.w	16818 <lv_obj_add_state>
            lv_obj_add_state(btn, LV_STATE_CHECKED);
   1b6fe:	2101      	movs	r1, #1
   1b700:	f7fb f88a 	bl	16818 <lv_obj_add_state>
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_DISABLED);
   1b704:	2130      	movs	r1, #48	; 0x30
   1b706:	e7ec      	b.n	1b6e2 <lv_btn_set_state+0x14>
            lv_obj_add_state(btn, LV_STATE_PRESSED | LV_STATE_CHECKED);
   1b708:	2111      	movs	r1, #17
   1b70a:	f7fb f885 	bl	16818 <lv_obj_add_state>
            lv_obj_clear_state(btn, LV_STATE_DISABLED);
   1b70e:	2120      	movs	r1, #32
   1b710:	e7e7      	b.n	1b6e2 <lv_btn_set_state+0x14>
            lv_obj_clear_state(btn, LV_STATE_PRESSED | LV_STATE_CHECKED);
   1b712:	2111      	movs	r1, #17
   1b714:	f7fb f88a 	bl	1682c <lv_obj_clear_state>
            lv_obj_add_state(btn, LV_STATE_DISABLED);
   1b718:	2120      	movs	r1, #32
   1b71a:	e7eb      	b.n	1b6f4 <lv_btn_set_state+0x26>
            lv_obj_clear_state(btn, LV_STATE_PRESSED);
   1b71c:	2110      	movs	r1, #16
   1b71e:	f7fb f885 	bl	1682c <lv_obj_clear_state>
            lv_obj_add_state(btn, LV_STATE_DISABLED | LV_STATE_CHECKED);
   1b722:	2121      	movs	r1, #33	; 0x21
   1b724:	e7e6      	b.n	1b6f4 <lv_btn_set_state+0x26>
}
   1b726:	bd10      	pop	{r4, pc}

0001b728 <lv_btn_get_checkable>:
{
   1b728:	b508      	push	{r3, lr}
    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
   1b72a:	f7fa fd07 	bl	1613c <lv_obj_get_ext_attr>
    return ext->checkable != 0 ? true : false;
   1b72e:	7880      	ldrb	r0, [r0, #2]
}
   1b730:	f000 0001 	and.w	r0, r0, #1
   1b734:	bd08      	pop	{r3, pc}

0001b736 <lv_area_copy>:
   1b736:	680b      	ldr	r3, [r1, #0]
   1b738:	6003      	str	r3, [r0, #0]
   1b73a:	684b      	ldr	r3, [r1, #4]
   1b73c:	6043      	str	r3, [r0, #4]
}
   1b73e:	4770      	bx	lr

0001b740 <lv_cont_set_layout>:
{
   1b740:	b570      	push	{r4, r5, r6, lr}
   1b742:	460d      	mov	r5, r1
   1b744:	4604      	mov	r4, r0
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   1b746:	f7fa fcf9 	bl	1613c <lv_obj_get_ext_attr>
    if(ext->layout == layout) return;
   1b74a:	7803      	ldrb	r3, [r0, #0]
   1b74c:	f003 020f 	and.w	r2, r3, #15
   1b750:	42aa      	cmp	r2, r5
   1b752:	d009      	beq.n	1b768 <lv_cont_set_layout+0x28>
    ext->layout = layout;
   1b754:	f365 0303 	bfi	r3, r5, #0, #4
   1b758:	7003      	strb	r3, [r0, #0]
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   1b75a:	2200      	movs	r2, #0
   1b75c:	4620      	mov	r0, r4
   1b75e:	69e3      	ldr	r3, [r4, #28]
   1b760:	2101      	movs	r1, #1
}
   1b762:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
   1b766:	4718      	bx	r3
}
   1b768:	bd70      	pop	{r4, r5, r6, pc}

0001b76a <lv_cont_get_layout>:
{
   1b76a:	b508      	push	{r3, lr}
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
   1b76c:	f7fa fce6 	bl	1613c <lv_obj_get_ext_attr>
    return ext->layout;
   1b770:	7800      	ldrb	r0, [r0, #0]
}
   1b772:	f000 000f 	and.w	r0, r0, #15
   1b776:	bd08      	pop	{r3, pc}

0001b778 <lv_cont_refr_layout>:
{
   1b778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
   1b77c:	2101      	movs	r1, #1
{
   1b77e:	b08f      	sub	sp, #60	; 0x3c
   1b780:	4681      	mov	r9, r0
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
   1b782:	f7fa fa3a 	bl	15bfa <lv_obj_is_protected>
   1b786:	4604      	mov	r4, r0
   1b788:	2800      	cmp	r0, #0
   1b78a:	f040 8313 	bne.w	1bdb4 <lv_cont_refr_layout+0x63c>
    lv_layout_t type = lv_cont_get_layout(cont);
   1b78e:	4648      	mov	r0, r9
   1b790:	f7ff ffeb 	bl	1b76a <lv_cont_get_layout>
    if(lv_obj_get_child(cont, NULL) == NULL) return;
   1b794:	4621      	mov	r1, r4
    lv_layout_t type = lv_cont_get_layout(cont);
   1b796:	4605      	mov	r5, r0
    if(lv_obj_get_child(cont, NULL) == NULL) return;
   1b798:	4648      	mov	r0, r9
   1b79a:	f7fa f94d 	bl	15a38 <lv_obj_get_child>
   1b79e:	2800      	cmp	r0, #0
   1b7a0:	f000 8308 	beq.w	1bdb4 <lv_cont_refr_layout+0x63c>
    if(type == LV_LAYOUT_OFF) return;
   1b7a4:	2d00      	cmp	r5, #0
   1b7a6:	f000 8305 	beq.w	1bdb4 <lv_cont_refr_layout+0x63c>
    if(type == LV_LAYOUT_CENTER) {
   1b7aa:	2d01      	cmp	r5, #1
   1b7ac:	d165      	bne.n	1b87a <lv_cont_refr_layout+0x102>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   1b7ae:	2214      	movs	r2, #20
   1b7b0:	4621      	mov	r1, r4
   1b7b2:	4648      	mov	r0, r9
   1b7b4:	f7ee f828 	bl	9808 <_lv_obj_get_style_int>
    _LV_LL_READ(cont->child_ll, child) {
   1b7b8:	f109 0604 	add.w	r6, r9, #4
   1b7bc:	4605      	mov	r5, r0
   1b7be:	4630      	mov	r0, r6
   1b7c0:	f7ff fd23 	bl	1b20a <_lv_ll_get_head>
    uint32_t obj_num         = 0;
   1b7c4:	46a0      	mov	r8, r4
    _LV_LL_READ(cont->child_ll, child) {
   1b7c6:	4607      	mov	r7, r0
   1b7c8:	b9d7      	cbnz	r7, 1b800 <lv_cont_refr_layout+0x88>
    if(obj_num == 0) return;
   1b7ca:	f1b8 0f00 	cmp.w	r8, #0
   1b7ce:	f000 82f1 	beq.w	1bdb4 <lv_cont_refr_layout+0x63c>
    h_tot -= inner;
   1b7d2:	1b64      	subs	r4, r4, r5
   1b7d4:	b224      	sxth	r4, r4
    lv_coord_t last_cord = -(h_tot / 2);
   1b7d6:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   1b7da:	4648      	mov	r0, r9
   1b7dc:	2101      	movs	r1, #1
    lv_coord_t last_cord = -(h_tot / 2);
   1b7de:	1064      	asrs	r4, r4, #1
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   1b7e0:	f7f9 ff7e 	bl	156e0 <lv_obj_add_protect>
    lv_coord_t last_cord = -(h_tot / 2);
   1b7e4:	4264      	negs	r4, r4
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1b7e6:	4630      	mov	r0, r6
    lv_coord_t last_cord = -(h_tot / 2);
   1b7e8:	b224      	sxth	r4, r4
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1b7ea:	f7ff fd11 	bl	1b210 <_lv_ll_get_tail>
   1b7ee:	4607      	mov	r7, r0
   1b7f0:	b9f0      	cbnz	r0, 1b830 <lv_cont_refr_layout+0xb8>
    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
   1b7f2:	2101      	movs	r1, #1
   1b7f4:	4648      	mov	r0, r9
}
   1b7f6:	b00f      	add	sp, #60	; 0x3c
   1b7f8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
   1b7fc:	f7f9 bf76 	b.w	156ec <lv_obj_clear_protect>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   1b800:	4638      	mov	r0, r7
   1b802:	f7fa f9d5 	bl	15bb0 <lv_obj_get_hidden>
   1b806:	b968      	cbnz	r0, 1b824 <lv_cont_refr_layout+0xac>
   1b808:	2104      	movs	r1, #4
   1b80a:	4638      	mov	r0, r7
   1b80c:	f7fa f9f5 	bl	15bfa <lv_obj_is_protected>
   1b810:	b940      	cbnz	r0, 1b824 <lv_cont_refr_layout+0xac>
        h_tot += lv_obj_get_height(child) + inner;
   1b812:	4638      	mov	r0, r7
   1b814:	f7fa f962 	bl	15adc <lv_obj_get_height>
   1b818:	442c      	add	r4, r5
   1b81a:	fa00 f484 	sxtah	r4, r0, r4
   1b81e:	b224      	sxth	r4, r4
        obj_num++;
   1b820:	f108 0801 	add.w	r8, r8, #1
    _LV_LL_READ(cont->child_ll, child) {
   1b824:	4639      	mov	r1, r7
   1b826:	4630      	mov	r0, r6
   1b828:	f7ff fcf5 	bl	1b216 <_lv_ll_get_next>
   1b82c:	4607      	mov	r7, r0
   1b82e:	e7cb      	b.n	1b7c8 <lv_cont_refr_layout+0x50>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   1b830:	4638      	mov	r0, r7
   1b832:	f7fa f9bd 	bl	15bb0 <lv_obj_get_hidden>
   1b836:	b9d8      	cbnz	r0, 1b870 <lv_cont_refr_layout+0xf8>
   1b838:	2104      	movs	r1, #4
   1b83a:	4638      	mov	r0, r7
   1b83c:	f7fa f9dd 	bl	15bfa <lv_obj_is_protected>
   1b840:	4680      	mov	r8, r0
   1b842:	b9a8      	cbnz	r0, 1b870 <lv_cont_refr_layout+0xf8>
        lv_obj_align(child, cont, LV_ALIGN_CENTER, 0, last_cord + lv_obj_get_height(child) / 2);
   1b844:	4638      	mov	r0, r7
   1b846:	f7fa f949 	bl	15adc <lv_obj_get_height>
   1b84a:	eb00 72d0 	add.w	r2, r0, r0, lsr #31
   1b84e:	eb04 0262 	add.w	r2, r4, r2, asr #1
   1b852:	b212      	sxth	r2, r2
   1b854:	4643      	mov	r3, r8
   1b856:	4649      	mov	r1, r9
   1b858:	4638      	mov	r0, r7
   1b85a:	9200      	str	r2, [sp, #0]
   1b85c:	4642      	mov	r2, r8
   1b85e:	f7fa f85b 	bl	15918 <lv_obj_align>
        last_cord += lv_obj_get_height(child) + inner;
   1b862:	4638      	mov	r0, r7
   1b864:	f7fa f93a 	bl	15adc <lv_obj_get_height>
   1b868:	442c      	add	r4, r5
   1b86a:	fa00 f484 	sxtah	r4, r0, r4
   1b86e:	b224      	sxth	r4, r4
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1b870:	4639      	mov	r1, r7
   1b872:	4630      	mov	r0, r6
   1b874:	f7ff fcd4 	bl	1b220 <_lv_ll_get_prev>
   1b878:	e7b9      	b.n	1b7ee <lv_cont_refr_layout+0x76>
    else if(type == LV_LAYOUT_COLUMN_LEFT || type == LV_LAYOUT_COLUMN_MID || type == LV_LAYOUT_COLUMN_RIGHT) {
   1b87a:	1eab      	subs	r3, r5, #2
   1b87c:	b2db      	uxtb	r3, r3
   1b87e:	2b02      	cmp	r3, #2
   1b880:	d86c      	bhi.n	1b95c <lv_cont_refr_layout+0x1e4>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1b882:	2212      	movs	r2, #18
   1b884:	4621      	mov	r1, r4
   1b886:	4648      	mov	r0, r9
   1b888:	f7ed ffbe 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1b88c:	2213      	movs	r2, #19
   1b88e:	4621      	mov	r1, r4
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1b890:	4605      	mov	r5, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1b892:	4648      	mov	r0, r9
   1b894:	f7ed ffb8 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1b898:	2210      	movs	r2, #16
   1b89a:	4621      	mov	r1, r4
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1b89c:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1b89e:	4648      	mov	r0, r9
   1b8a0:	f7ed ffb2 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   1b8a4:	2214      	movs	r2, #20
   1b8a6:	4621      	mov	r1, r4
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1b8a8:	4606      	mov	r6, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   1b8aa:	4648      	mov	r0, r9
   1b8ac:	f7ed ffac 	bl	9808 <_lv_obj_get_style_int>
   1b8b0:	9003      	str	r0, [sp, #12]
    lv_layout_t type = lv_cont_get_layout(cont);
   1b8b2:	4648      	mov	r0, r9
   1b8b4:	f7ff ff59 	bl	1b76a <lv_cont_get_layout>
    switch(type) {
   1b8b8:	2803      	cmp	r0, #3
   1b8ba:	d04b      	beq.n	1b954 <lv_cont_refr_layout+0x1dc>
   1b8bc:	2804      	cmp	r0, #4
   1b8be:	d044      	beq.n	1b94a <lv_cont_refr_layout+0x1d2>
            align     = LV_ALIGN_IN_TOP_LEFT;
   1b8c0:	2802      	cmp	r0, #2
   1b8c2:	f04f 0801 	mov.w	r8, #1
   1b8c6:	bf18      	it	ne
   1b8c8:	2500      	movne	r5, #0
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   1b8ca:	4648      	mov	r0, r9
   1b8cc:	2101      	movs	r1, #1
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1b8ce:	f109 0b04 	add.w	fp, r9, #4
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   1b8d2:	f7f9 ff05 	bl	156e0 <lv_obj_add_protect>
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1b8d6:	4658      	mov	r0, fp
   1b8d8:	f7ff fc9a 	bl	1b210 <_lv_ll_get_tail>
   1b8dc:	4604      	mov	r4, r0
   1b8de:	2800      	cmp	r0, #0
   1b8e0:	d087      	beq.n	1b7f2 <lv_cont_refr_layout+0x7a>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   1b8e2:	4620      	mov	r0, r4
   1b8e4:	f7fa f964 	bl	15bb0 <lv_obj_get_hidden>
   1b8e8:	bb50      	cbnz	r0, 1b940 <lv_cont_refr_layout+0x1c8>
   1b8ea:	2104      	movs	r1, #4
   1b8ec:	4620      	mov	r0, r4
   1b8ee:	f7fa f984 	bl	15bfa <lv_obj_is_protected>
   1b8f2:	4682      	mov	sl, r0
   1b8f4:	bb20      	cbnz	r0, 1b940 <lv_cont_refr_layout+0x1c8>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   1b8f6:	4601      	mov	r1, r0
   1b8f8:	2215      	movs	r2, #21
   1b8fa:	4620      	mov	r0, r4
   1b8fc:	f7ed ff84 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   1b900:	2216      	movs	r2, #22
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   1b902:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   1b904:	4651      	mov	r1, sl
   1b906:	4620      	mov	r0, r4
   1b908:	f7ed ff7e 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   1b90c:	2217      	movs	r2, #23
   1b90e:	4651      	mov	r1, sl
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   1b910:	9004      	str	r0, [sp, #16]
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   1b912:	4620      	mov	r0, r4
   1b914:	f7ed ff78 	bl	9808 <_lv_obj_get_style_int>
        lv_obj_align(child, cont, align, hpad_corr + mleft, last_cord + mtop);
   1b918:	19f2      	adds	r2, r6, r7
   1b91a:	182b      	adds	r3, r5, r0
   1b91c:	b212      	sxth	r2, r2
   1b91e:	b21b      	sxth	r3, r3
   1b920:	4649      	mov	r1, r9
   1b922:	4620      	mov	r0, r4
   1b924:	9200      	str	r2, [sp, #0]
   1b926:	4642      	mov	r2, r8
   1b928:	f7f9 fff6 	bl	15918 <lv_obj_align>
        last_cord += lv_obj_get_height(child) + inner + mtop + mbottom;
   1b92c:	4620      	mov	r0, r4
   1b92e:	f7fa f8d5 	bl	15adc <lv_obj_get_height>
   1b932:	9b03      	ldr	r3, [sp, #12]
   1b934:	4407      	add	r7, r0
   1b936:	441f      	add	r7, r3
   1b938:	9b04      	ldr	r3, [sp, #16]
   1b93a:	443b      	add	r3, r7
   1b93c:	441e      	add	r6, r3
   1b93e:	b236      	sxth	r6, r6
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1b940:	4621      	mov	r1, r4
   1b942:	4658      	mov	r0, fp
   1b944:	f7ff fc6c 	bl	1b220 <_lv_ll_get_prev>
   1b948:	e7c8      	b.n	1b8dc <lv_cont_refr_layout+0x164>
            hpad_corr = -right;
   1b94a:	427d      	negs	r5, r7
            align     = LV_ALIGN_IN_TOP_RIGHT;
   1b94c:	f04f 0803 	mov.w	r8, #3
            hpad_corr = -right;
   1b950:	b22d      	sxth	r5, r5
            break;
   1b952:	e7ba      	b.n	1b8ca <lv_cont_refr_layout+0x152>
    switch(type) {
   1b954:	4625      	mov	r5, r4
   1b956:	f04f 0802 	mov.w	r8, #2
   1b95a:	e7b6      	b.n	1b8ca <lv_cont_refr_layout+0x152>
    else if(type == LV_LAYOUT_ROW_TOP || type == LV_LAYOUT_ROW_MID || type == LV_LAYOUT_ROW_BOTTOM) {
   1b95c:	1f6b      	subs	r3, r5, #5
   1b95e:	b2db      	uxtb	r3, r3
   1b960:	2b02      	cmp	r3, #2
   1b962:	d86d      	bhi.n	1ba40 <lv_cont_refr_layout+0x2c8>
    lv_layout_t type = lv_cont_get_layout(cont);
   1b964:	4648      	mov	r0, r9
   1b966:	f7ff ff00 	bl	1b76a <lv_cont_get_layout>
   1b96a:	4605      	mov	r5, r0
    lv_bidi_dir_t base_dir = lv_obj_get_base_dir(cont);
   1b96c:	4648      	mov	r0, r9
   1b96e:	f7fa f942 	bl	15bf6 <lv_obj_get_base_dir>
    switch(type) {
   1b972:	2d06      	cmp	r5, #6
    lv_bidi_dir_t base_dir = lv_obj_get_base_dir(cont);
   1b974:	4607      	mov	r7, r0
    switch(type) {
   1b976:	d010      	beq.n	1b99a <lv_cont_refr_layout+0x222>
   1b978:	2d07      	cmp	r5, #7
   1b97a:	d052      	beq.n	1ba22 <lv_cont_refr_layout+0x2aa>
   1b97c:	2d05      	cmp	r5, #5
   1b97e:	d105      	bne.n	1b98c <lv_cont_refr_layout+0x214>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1b980:	4621      	mov	r1, r4
   1b982:	2210      	movs	r2, #16
   1b984:	4648      	mov	r0, r9
   1b986:	f7ed ff3f 	bl	9808 <_lv_obj_get_style_int>
   1b98a:	4604      	mov	r4, r0
            vpad_corr = 0;
   1b98c:	2f01      	cmp	r7, #1
   1b98e:	bf0c      	ite	eq
   1b990:	f04f 0803 	moveq.w	r8, #3
   1b994:	f04f 0801 	movne.w	r8, #1
   1b998:	e005      	b.n	1b9a6 <lv_cont_refr_layout+0x22e>
            vpad_corr = 0;
   1b99a:	2801      	cmp	r0, #1
   1b99c:	bf0c      	ite	eq
   1b99e:	f04f 0808 	moveq.w	r8, #8
   1b9a2:	f04f 0807 	movne.w	r8, #7
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   1b9a6:	2101      	movs	r1, #1
   1b9a8:	4648      	mov	r0, r9
   1b9aa:	f7f9 fe99 	bl	156e0 <lv_obj_add_protect>
    if(base_dir == LV_BIDI_DIR_RTL) last_cord = lv_obj_get_style_pad_right(cont, LV_CONT_PART_MAIN);
   1b9ae:	2f01      	cmp	r7, #1
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1b9b0:	bf0c      	ite	eq
   1b9b2:	2213      	moveq	r2, #19
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1b9b4:	2212      	movne	r2, #18
   1b9b6:	2100      	movs	r1, #0
   1b9b8:	4648      	mov	r0, r9
   1b9ba:	f7ed ff25 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   1b9be:	2214      	movs	r2, #20
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1b9c0:	4605      	mov	r5, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   1b9c2:	2100      	movs	r1, #0
   1b9c4:	4648      	mov	r0, r9
   1b9c6:	f7ed ff1f 	bl	9808 <_lv_obj_get_style_int>
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1b9ca:	f109 0a04 	add.w	sl, r9, #4
   1b9ce:	4683      	mov	fp, r0
   1b9d0:	4650      	mov	r0, sl
   1b9d2:	f7ff fc1d 	bl	1b210 <_lv_ll_get_tail>
   1b9d6:	4606      	mov	r6, r0
   1b9d8:	2800      	cmp	r0, #0
   1b9da:	f43f af0a 	beq.w	1b7f2 <lv_cont_refr_layout+0x7a>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   1b9de:	4630      	mov	r0, r6
   1b9e0:	f7fa f8e6 	bl	15bb0 <lv_obj_get_hidden>
   1b9e4:	b9c0      	cbnz	r0, 1ba18 <lv_cont_refr_layout+0x2a0>
   1b9e6:	2104      	movs	r1, #4
   1b9e8:	4630      	mov	r0, r6
   1b9ea:	f7fa f906 	bl	15bfa <lv_obj_is_protected>
   1b9ee:	b998      	cbnz	r0, 1ba18 <lv_cont_refr_layout+0x2a0>
        if(base_dir == LV_BIDI_DIR_RTL) lv_obj_align(child, cont, align, -last_cord, vpad_corr);
   1b9f0:	2f01      	cmp	r7, #1
   1b9f2:	bf0c      	ite	eq
   1b9f4:	426b      	negeq	r3, r5
        else lv_obj_align(child, cont, align, last_cord, vpad_corr);
   1b9f6:	462b      	movne	r3, r5
   1b9f8:	4642      	mov	r2, r8
   1b9fa:	4649      	mov	r1, r9
   1b9fc:	4630      	mov	r0, r6
        if(base_dir == LV_BIDI_DIR_RTL) lv_obj_align(child, cont, align, -last_cord, vpad_corr);
   1b9fe:	bf06      	itte	eq
   1ba00:	9400      	streq	r4, [sp, #0]
   1ba02:	b21b      	sxtheq	r3, r3
        else lv_obj_align(child, cont, align, last_cord, vpad_corr);
   1ba04:	9400      	strne	r4, [sp, #0]
   1ba06:	f7f9 ff87 	bl	15918 <lv_obj_align>
        last_cord += lv_obj_get_width(child) + inner;
   1ba0a:	4630      	mov	r0, r6
   1ba0c:	f7fa f860 	bl	15ad0 <lv_obj_get_width>
   1ba10:	445d      	add	r5, fp
   1ba12:	fa00 f585 	sxtah	r5, r0, r5
   1ba16:	b22d      	sxth	r5, r5
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1ba18:	4631      	mov	r1, r6
   1ba1a:	4650      	mov	r0, sl
   1ba1c:	f7ff fc00 	bl	1b220 <_lv_ll_get_prev>
   1ba20:	e7d9      	b.n	1b9d6 <lv_cont_refr_layout+0x25e>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   1ba22:	4621      	mov	r1, r4
   1ba24:	2211      	movs	r2, #17
   1ba26:	4648      	mov	r0, r9
   1ba28:	f7ed feee 	bl	9808 <_lv_obj_get_style_int>
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_BOTTOM_RIGHT : LV_ALIGN_IN_BOTTOM_LEFT;
   1ba2c:	2f01      	cmp	r7, #1
            vpad_corr = -lv_obj_get_style_pad_bottom(cont, LV_CONT_PART_MAIN);
   1ba2e:	f1c0 0400 	rsb	r4, r0, #0
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_BOTTOM_RIGHT : LV_ALIGN_IN_BOTTOM_LEFT;
   1ba32:	bf0c      	ite	eq
   1ba34:	f04f 0806 	moveq.w	r8, #6
   1ba38:	f04f 0804 	movne.w	r8, #4
            vpad_corr = -lv_obj_get_style_pad_bottom(cont, LV_CONT_PART_MAIN);
   1ba3c:	b224      	sxth	r4, r4
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_BOTTOM_RIGHT : LV_ALIGN_IN_BOTTOM_LEFT;
   1ba3e:	e7b2      	b.n	1b9a6 <lv_cont_refr_layout+0x22e>
    else if(type == LV_LAYOUT_PRETTY_MID || type == LV_LAYOUT_PRETTY_TOP || type == LV_LAYOUT_PRETTY_BOTTOM) {
   1ba40:	f1a5 0308 	sub.w	r3, r5, #8
   1ba44:	b2db      	uxtb	r3, r3
   1ba46:	2b02      	cmp	r3, #2
   1ba48:	f200 812c 	bhi.w	1bca4 <lv_cont_refr_layout+0x52c>
    lv_layout_t type = lv_cont_get_layout(cont);
   1ba4c:	4648      	mov	r0, r9
   1ba4e:	f7ff fe8c 	bl	1b76a <lv_cont_get_layout>
   1ba52:	9005      	str	r0, [sp, #20]
    lv_coord_t w_obj         = lv_obj_get_width(cont);
   1ba54:	4648      	mov	r0, r9
   1ba56:	f7fa f83b 	bl	15ad0 <lv_obj_get_width>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1ba5a:	2210      	movs	r2, #16
   1ba5c:	4621      	mov	r1, r4
   1ba5e:	9007      	str	r0, [sp, #28]
   1ba60:	4648      	mov	r0, r9
   1ba62:	f7ed fed1 	bl	9808 <_lv_obj_get_style_int>
    child_rs = _lv_ll_get_tail(&cont->child_ll); /*Set the row starter child*/
   1ba66:	f109 0304 	add.w	r3, r9, #4
   1ba6a:	4607      	mov	r7, r0
   1ba6c:	4618      	mov	r0, r3
   1ba6e:	9304      	str	r3, [sp, #16]
   1ba70:	f7ff fbce 	bl	1b210 <_lv_ll_get_tail>
    if(child_rs == NULL) return;                /*Return if no child*/
   1ba74:	4605      	mov	r5, r0
   1ba76:	2800      	cmp	r0, #0
   1ba78:	f000 819c 	beq.w	1bdb4 <lv_cont_refr_layout+0x63c>
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   1ba7c:	2101      	movs	r1, #1
   1ba7e:	4648      	mov	r0, r9
   1ba80:	f7f9 fe2e 	bl	156e0 <lv_obj_add_protect>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1ba84:	2212      	movs	r2, #18
   1ba86:	4621      	mov	r1, r4
   1ba88:	4648      	mov	r0, r9
   1ba8a:	f7ed febd 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1ba8e:	2213      	movs	r2, #19
   1ba90:	4621      	mov	r1, r4
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1ba92:	9008      	str	r0, [sp, #32]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1ba94:	4648      	mov	r0, r9
   1ba96:	f7ed feb7 	bl	9808 <_lv_obj_get_style_int>
   1ba9a:	4606      	mov	r6, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   1ba9c:	2214      	movs	r2, #20
   1ba9e:	4621      	mov	r1, r4
   1baa0:	4648      	mov	r0, r9
   1baa2:	f7ed feb1 	bl	9808 <_lv_obj_get_style_int>
        lv_coord_t w_row = pleft + pright; /*The width is at least the left+right pad*/
   1baa6:	9b08      	ldr	r3, [sp, #32]
   1baa8:	9006      	str	r0, [sp, #24]
   1baaa:	441e      	add	r6, r3
   1baac:	b233      	sxth	r3, r6
   1baae:	930c      	str	r3, [sp, #48]	; 0x30
        uint32_t obj_num = 0;
   1bab0:	2600      	movs	r6, #0
        lv_coord_t w_row = pleft + pright; /*The width is at least the left+right pad*/
   1bab2:	462c      	mov	r4, r5
   1bab4:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
        lv_coord_t h_row = 0;
   1bab8:	9603      	str	r6, [sp, #12]
            if(lv_obj_get_hidden(child_rc) == false && lv_obj_is_protected(child_rc, LV_PROTECT_POS) == false) {
   1baba:	4628      	mov	r0, r5
   1babc:	f7fa f878 	bl	15bb0 <lv_obj_get_hidden>
   1bac0:	2800      	cmp	r0, #0
   1bac2:	d162      	bne.n	1bb8a <lv_cont_refr_layout+0x412>
   1bac4:	2104      	movs	r1, #4
   1bac6:	4628      	mov	r0, r5
   1bac8:	f7fa f897 	bl	15bfa <lv_obj_is_protected>
   1bacc:	4683      	mov	fp, r0
   1bace:	2800      	cmp	r0, #0
   1bad0:	d15b      	bne.n	1bb8a <lv_cont_refr_layout+0x412>
                lv_coord_t w = lv_obj_get_width(child_rc);
   1bad2:	4628      	mov	r0, r5
   1bad4:	f7f9 fffc 	bl	15ad0 <lv_obj_get_width>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   1bad8:	2217      	movs	r2, #23
   1bada:	4682      	mov	sl, r0
   1badc:	4659      	mov	r1, fp
   1bade:	4628      	mov	r0, r5
   1bae0:	f7ed fe92 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   1bae4:	2218      	movs	r2, #24
                w += lv_obj_get_style_margin_left(child_rc, LV_OBJ_PART_MAIN);
   1bae6:	4482      	add	sl, r0
   1bae8:	4659      	mov	r1, fp
   1baea:	4628      	mov	r0, r5
   1baec:	f7ed fe8c 	bl	9808 <_lv_obj_get_style_int>
   1baf0:	fa0f fa8a 	sxth.w	sl, sl
                w += lv_obj_get_style_margin_right(child_rc, LV_OBJ_PART_MAIN);
   1baf4:	4482      	add	sl, r0
                if(w_row + w > w_obj) {
   1baf6:	9a07      	ldr	r2, [sp, #28]
                w += lv_obj_get_style_margin_right(child_rc, LV_OBJ_PART_MAIN);
   1baf8:	fa0f f38a 	sxth.w	r3, sl
                if(w_row + w > w_obj) {
   1bafc:	fa08 fa8a 	sxtah	sl, r8, sl
   1bb00:	4592      	cmp	sl, r2
   1bb02:	dd1b      	ble.n	1bb3c <lv_cont_refr_layout+0x3c4>
                    if(child_rc != NULL && obj_num != 0) {
   1bb04:	2e00      	cmp	r6, #0
   1bb06:	f000 8126 	beq.w	1bd56 <lv_cont_refr_layout+0x5de>
                        child_rc = _lv_ll_get_next(&cont->child_ll, child_rc);
   1bb0a:	4629      	mov	r1, r5
   1bb0c:	9804      	ldr	r0, [sp, #16]
   1bb0e:	f7ff fb82 	bl	1b216 <_lv_ll_get_next>
   1bb12:	4605      	mov	r5, r0
        else if(obj_num == 1) {
   1bb14:	2e01      	cmp	r6, #1
   1bb16:	d143      	bne.n	1bba0 <lv_cont_refr_layout+0x428>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   1bb18:	2215      	movs	r2, #21
   1bb1a:	2100      	movs	r1, #0
   1bb1c:	4620      	mov	r0, r4
   1bb1e:	f7ed fe73 	bl	9808 <_lv_obj_get_style_int>
            lv_obj_align(child_rs, cont, LV_ALIGN_IN_TOP_MID,
   1bb22:	4438      	add	r0, r7
   1bb24:	b200      	sxth	r0, r0
   1bb26:	9000      	str	r0, [sp, #0]
   1bb28:	2300      	movs	r3, #0
   1bb2a:	2202      	movs	r2, #2
   1bb2c:	4649      	mov	r1, r9
   1bb2e:	4620      	mov	r0, r4
   1bb30:	f7f9 fef2 	bl	15918 <lv_obj_align>
        if(child_rc == NULL) break;
   1bb34:	2d00      	cmp	r5, #0
   1bb36:	f040 812a 	bne.w	1bd8e <lv_cont_refr_layout+0x616>
   1bb3a:	e65a      	b.n	1b7f2 <lv_cont_refr_layout+0x7a>
                w_row += w + pinner; /*Add the object width + inner padding*/
   1bb3c:	9a06      	ldr	r2, [sp, #24]
                lv_coord_t h = lv_obj_get_height(child_rc);
   1bb3e:	4628      	mov	r0, r5
   1bb40:	4490      	add	r8, r2
                w_row += w + pinner; /*Add the object width + inner padding*/
   1bb42:	fa03 f888 	sxtah	r8, r3, r8
                lv_coord_t h = lv_obj_get_height(child_rc);
   1bb46:	f7f9 ffc9 	bl	15adc <lv_obj_get_height>
   1bb4a:	2215      	movs	r2, #21
   1bb4c:	4682      	mov	sl, r0
   1bb4e:	4659      	mov	r1, fp
   1bb50:	4628      	mov	r0, r5
   1bb52:	f7ed fe59 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   1bb56:	4659      	mov	r1, fp
                h += lv_obj_get_style_margin_top(child_rc, LV_OBJ_PART_MAIN);
   1bb58:	4482      	add	sl, r0
   1bb5a:	2216      	movs	r2, #22
   1bb5c:	4628      	mov	r0, r5
   1bb5e:	f7ed fe53 	bl	9808 <_lv_obj_get_style_int>
   1bb62:	fa0f fa8a 	sxth.w	sl, sl
                h_row = LV_MATH_MAX(h_row, h);         /*Search the highest object*/
   1bb66:	9b03      	ldr	r3, [sp, #12]
                h += lv_obj_get_style_margin_bottom(child_rc, LV_OBJ_PART_MAIN);
   1bb68:	4482      	add	sl, r0
                h_row = LV_MATH_MAX(h_row, h);         /*Search the highest object*/
   1bb6a:	fa0f fa8a 	sxth.w	sl, sl
   1bb6e:	4553      	cmp	r3, sl
   1bb70:	bfb8      	it	lt
   1bb72:	4653      	movlt	r3, sl
                if(lv_obj_is_protected(child_rc, LV_PROTECT_FOLLOW))
   1bb74:	2108      	movs	r1, #8
   1bb76:	4628      	mov	r0, r5
                w_row += w + pinner; /*Add the object width + inner padding*/
   1bb78:	fa0f f888 	sxth.w	r8, r8
                h_row = LV_MATH_MAX(h_row, h);         /*Search the highest object*/
   1bb7c:	9303      	str	r3, [sp, #12]
                obj_num++;
   1bb7e:	3601      	adds	r6, #1
                if(lv_obj_is_protected(child_rc, LV_PROTECT_FOLLOW))
   1bb80:	f7fa f83b 	bl	15bfa <lv_obj_is_protected>
   1bb84:	2800      	cmp	r0, #0
   1bb86:	f040 80e3 	bne.w	1bd50 <lv_cont_refr_layout+0x5d8>
            child_rc = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Load the next object*/
   1bb8a:	4629      	mov	r1, r5
   1bb8c:	9804      	ldr	r0, [sp, #16]
   1bb8e:	f7ff fb47 	bl	1b220 <_lv_ll_get_prev>
   1bb92:	4605      	mov	r5, r0
            if(obj_num == 0)
   1bb94:	2e00      	cmp	r6, #0
   1bb96:	f000 8108 	beq.w	1bdaa <lv_cont_refr_layout+0x632>
        } while(child_rc != NULL);
   1bb9a:	2800      	cmp	r0, #0
   1bb9c:	d18d      	bne.n	1baba <lv_cont_refr_layout+0x342>
   1bb9e:	e7b9      	b.n	1bb14 <lv_cont_refr_layout+0x39c>
            w_row -= pinner * obj_num;
   1bba0:	9b06      	ldr	r3, [sp, #24]
            lv_coord_t act_x    = pleft; /*x init*/
   1bba2:	f8dd a020 	ldr.w	sl, [sp, #32]
            w_row -= pinner * obj_num;
   1bba6:	fb13 f306 	smulbb	r3, r3, r6
   1bbaa:	eba8 0803 	sub.w	r8, r8, r3
            lv_coord_t new_pinner = (w_obj - w_row) / (obj_num - 1);
   1bbae:	9b07      	ldr	r3, [sp, #28]
   1bbb0:	fa0f f888 	sxth.w	r8, r8
   1bbb4:	eba3 0808 	sub.w	r8, r3, r8
   1bbb8:	3e01      	subs	r6, #1
   1bbba:	fbb8 f6f6 	udiv	r6, r8, r6
   1bbbe:	b233      	sxth	r3, r6
   1bbc0:	9309      	str	r3, [sp, #36]	; 0x24
                                         act_y + h_row - lv_obj_get_height(child_tmp) - lv_obj_get_style_margin_bottom(child_tmp, LV_OBJ_PART_MAIN));
   1bbc2:	9b03      	ldr	r3, [sp, #12]
   1bbc4:	18fb      	adds	r3, r7, r3
   1bbc6:	b21b      	sxth	r3, r3
   1bbc8:	930b      	str	r3, [sp, #44]	; 0x2c
            while(child_tmp != NULL) {
   1bbca:	2c00      	cmp	r4, #0
   1bbcc:	d0b2      	beq.n	1bb34 <lv_cont_refr_layout+0x3bc>
                if(lv_obj_get_hidden(child_tmp) == false && lv_obj_is_protected(child_tmp, LV_PROTECT_POS) == false) {
   1bbce:	4620      	mov	r0, r4
   1bbd0:	f7f9 ffee 	bl	15bb0 <lv_obj_get_hidden>
   1bbd4:	2800      	cmp	r0, #0
   1bbd6:	d136      	bne.n	1bc46 <lv_cont_refr_layout+0x4ce>
   1bbd8:	2104      	movs	r1, #4
   1bbda:	4620      	mov	r0, r4
   1bbdc:	f7fa f80d 	bl	15bfa <lv_obj_is_protected>
   1bbe0:	4601      	mov	r1, r0
   1bbe2:	bb80      	cbnz	r0, 1bc46 <lv_cont_refr_layout+0x4ce>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   1bbe4:	2217      	movs	r2, #23
   1bbe6:	900a      	str	r0, [sp, #40]	; 0x28
   1bbe8:	4620      	mov	r0, r4
   1bbea:	f7ed fe0d 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   1bbee:	990a      	ldr	r1, [sp, #40]	; 0x28
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
   1bbf0:	4606      	mov	r6, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
   1bbf2:	2218      	movs	r2, #24
   1bbf4:	4620      	mov	r0, r4
   1bbf6:	910d      	str	r1, [sp, #52]	; 0x34
   1bbf8:	f7ed fe06 	bl	9808 <_lv_obj_get_style_int>
                    switch(type) {
   1bbfc:	9b05      	ldr	r3, [sp, #20]
   1bbfe:	900a      	str	r0, [sp, #40]	; 0x28
   1bc00:	2b09      	cmp	r3, #9
   1bc02:	d029      	beq.n	1bc58 <lv_cont_refr_layout+0x4e0>
   1bc04:	2b0a      	cmp	r3, #10
   1bc06:	990d      	ldr	r1, [sp, #52]	; 0x34
   1bc08:	d034      	beq.n	1bc74 <lv_cont_refr_layout+0x4fc>
   1bc0a:	2b08      	cmp	r3, #8
   1bc0c:	d110      	bne.n	1bc30 <lv_cont_refr_layout+0x4b8>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   1bc0e:	2215      	movs	r2, #21
   1bc10:	4620      	mov	r0, r4
   1bc12:	f7ed fdf9 	bl	9808 <_lv_obj_get_style_int>
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   1bc16:	eb0a 0806 	add.w	r8, sl, r6
   1bc1a:	fa0f f888 	sxth.w	r8, r8
   1bc1e:	4438      	add	r0, r7
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   1bc20:	4643      	mov	r3, r8
   1bc22:	b200      	sxth	r0, r0
   1bc24:	9000      	str	r0, [sp, #0]
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   1bc26:	2201      	movs	r2, #1
   1bc28:	4649      	mov	r1, r9
   1bc2a:	4620      	mov	r0, r4
   1bc2c:	f7f9 fe74 	bl	15918 <lv_obj_align>
                    act_x += lv_obj_get_width(child_tmp) + new_pinner + mleft + mright;
   1bc30:	4620      	mov	r0, r4
   1bc32:	f7f9 ff4d 	bl	15ad0 <lv_obj_get_width>
   1bc36:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1bc38:	441e      	add	r6, r3
   1bc3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1bc3c:	441e      	add	r6, r3
   1bc3e:	4406      	add	r6, r0
   1bc40:	44b2      	add	sl, r6
   1bc42:	fa0f fa8a 	sxth.w	sl, sl
                if(child_tmp == child_rc) break;
   1bc46:	42ac      	cmp	r4, r5
   1bc48:	f000 80a1 	beq.w	1bd8e <lv_cont_refr_layout+0x616>
                child_tmp = _lv_ll_get_prev(&cont->child_ll, child_tmp);
   1bc4c:	4621      	mov	r1, r4
   1bc4e:	9804      	ldr	r0, [sp, #16]
   1bc50:	f7ff fae6 	bl	1b220 <_lv_ll_get_prev>
   1bc54:	4604      	mov	r4, r0
   1bc56:	e7b8      	b.n	1bbca <lv_cont_refr_layout+0x452>
                                         act_y + (h_row - lv_obj_get_height(child_tmp)) / 2);
   1bc58:	4620      	mov	r0, r4
   1bc5a:	f7f9 ff3f 	bl	15adc <lv_obj_get_height>
   1bc5e:	9b03      	ldr	r3, [sp, #12]
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   1bc60:	eb0a 0806 	add.w	r8, sl, r6
                                         act_y + (h_row - lv_obj_get_height(child_tmp)) / 2);
   1bc64:	1a18      	subs	r0, r3, r0
   1bc66:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   1bc6a:	fa0f f888 	sxth.w	r8, r8
   1bc6e:	eb07 0060 	add.w	r0, r7, r0, asr #1
   1bc72:	e7d5      	b.n	1bc20 <lv_cont_refr_layout+0x4a8>
                                         act_y + h_row - lv_obj_get_height(child_tmp) - lv_obj_get_style_margin_bottom(child_tmp, LV_OBJ_PART_MAIN));
   1bc74:	4620      	mov	r0, r4
   1bc76:	910d      	str	r1, [sp, #52]	; 0x34
   1bc78:	f7f9 ff30 	bl	15adc <lv_obj_get_height>
   1bc7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   1bc7e:	2216      	movs	r2, #22
   1bc80:	eba3 0800 	sub.w	r8, r3, r0
   1bc84:	990d      	ldr	r1, [sp, #52]	; 0x34
   1bc86:	4620      	mov	r0, r4
   1bc88:	f7ed fdbe 	bl	9808 <_lv_obj_get_style_int>
   1bc8c:	fa0f f888 	sxth.w	r8, r8
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
   1bc90:	eb0a 0b06 	add.w	fp, sl, r6
   1bc94:	eba8 0000 	sub.w	r0, r8, r0
   1bc98:	fa0f fb8b 	sxth.w	fp, fp
   1bc9c:	b200      	sxth	r0, r0
   1bc9e:	465b      	mov	r3, fp
   1bca0:	9000      	str	r0, [sp, #0]
   1bca2:	e7c0      	b.n	1bc26 <lv_cont_refr_layout+0x4ae>
    else if(type == LV_LAYOUT_GRID) {
   1bca4:	2d0b      	cmp	r5, #11
   1bca6:	f040 8085 	bne.w	1bdb4 <lv_cont_refr_layout+0x63c>
    lv_coord_t w_fit         =  lv_obj_get_width_fit(cont);
   1bcaa:	4648      	mov	r0, r9
   1bcac:	f7f9 fff9 	bl	15ca2 <lv_obj_get_width_fit>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
   1bcb0:	2214      	movs	r2, #20
   1bcb2:	4621      	mov	r1, r4
   1bcb4:	9003      	str	r0, [sp, #12]
   1bcb6:	4648      	mov	r0, r9
   1bcb8:	f7ed fda6 	bl	9808 <_lv_obj_get_style_int>
    lv_coord_t y_ofs = inner + lv_obj_get_height(lv_obj_get_child(cont, NULL));
   1bcbc:	4621      	mov	r1, r4
   1bcbe:	4682      	mov	sl, r0
   1bcc0:	4648      	mov	r0, r9
   1bcc2:	f7f9 feb9 	bl	15a38 <lv_obj_get_child>
   1bcc6:	f7f9 ff09 	bl	15adc <lv_obj_get_height>
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   1bcca:	2101      	movs	r1, #1
    lv_coord_t y_ofs = inner + lv_obj_get_height(lv_obj_get_child(cont, NULL));
   1bccc:	eb00 060a 	add.w	r6, r0, sl
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
   1bcd0:	4648      	mov	r0, r9
   1bcd2:	f7f9 fd05 	bl	156e0 <lv_obj_add_protect>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1bcd6:	4621      	mov	r1, r4
   1bcd8:	2212      	movs	r2, #18
   1bcda:	4648      	mov	r0, r9
   1bcdc:	f7ed fd94 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1bce0:	4621      	mov	r1, r4
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1bce2:	4680      	mov	r8, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1bce4:	2210      	movs	r2, #16
   1bce6:	4648      	mov	r0, r9
   1bce8:	f7ed fd8e 	bl	9808 <_lv_obj_get_style_int>
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1bcec:	f109 0b04 	add.w	fp, r9, #4
   1bcf0:	4605      	mov	r5, r0
   1bcf2:	4658      	mov	r0, fp
   1bcf4:	f7ff fa8c 	bl	1b210 <_lv_ll_get_tail>
    lv_coord_t act_x = left;
   1bcf8:	4647      	mov	r7, r8
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1bcfa:	4604      	mov	r4, r0
        if(act_x + obj_w > w_fit + left) {
   1bcfc:	9b03      	ldr	r3, [sp, #12]
    lv_coord_t y_ofs = inner + lv_obj_get_height(lv_obj_get_child(cont, NULL));
   1bcfe:	b236      	sxth	r6, r6
        if(act_x + obj_w > w_fit + left) {
   1bd00:	4443      	add	r3, r8
   1bd02:	9303      	str	r3, [sp, #12]
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1bd04:	2c00      	cmp	r4, #0
   1bd06:	f43f ad74 	beq.w	1b7f2 <lv_cont_refr_layout+0x7a>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
   1bd0a:	4620      	mov	r0, r4
   1bd0c:	f7f9 ff50 	bl	15bb0 <lv_obj_get_hidden>
   1bd10:	b9c0      	cbnz	r0, 1bd44 <lv_cont_refr_layout+0x5cc>
   1bd12:	2104      	movs	r1, #4
   1bd14:	4620      	mov	r0, r4
   1bd16:	f7f9 ff70 	bl	15bfa <lv_obj_is_protected>
   1bd1a:	b998      	cbnz	r0, 1bd44 <lv_cont_refr_layout+0x5cc>
        lv_coord_t obj_w = lv_obj_get_width(child);
   1bd1c:	4620      	mov	r0, r4
   1bd1e:	f7f9 fed7 	bl	15ad0 <lv_obj_get_width>
        if(act_x + obj_w > w_fit + left) {
   1bd22:	9903      	ldr	r1, [sp, #12]
   1bd24:	183a      	adds	r2, r7, r0
   1bd26:	428a      	cmp	r2, r1
            act_x = left;
   1bd28:	bfc2      	ittt	gt
   1bd2a:	4647      	movgt	r7, r8
            act_y += y_ofs;
   1bd2c:	19ad      	addgt	r5, r5, r6
   1bd2e:	b22d      	sxthgt	r5, r5
        lv_obj_set_pos(child, act_x, act_y);
   1bd30:	4639      	mov	r1, r7
   1bd32:	9004      	str	r0, [sp, #16]
   1bd34:	462a      	mov	r2, r5
   1bd36:	4620      	mov	r0, r4
   1bd38:	f7f9 fdb2 	bl	158a0 <lv_obj_set_pos>
        act_x += inner + obj_w;
   1bd3c:	9b04      	ldr	r3, [sp, #16]
   1bd3e:	4453      	add	r3, sl
   1bd40:	441f      	add	r7, r3
   1bd42:	b23f      	sxth	r7, r7
    _LV_LL_READ_BACK(cont->child_ll, child) {
   1bd44:	4621      	mov	r1, r4
   1bd46:	4658      	mov	r0, fp
   1bd48:	f7ff fa6a 	bl	1b220 <_lv_ll_get_prev>
   1bd4c:	4604      	mov	r4, r0
   1bd4e:	e7d9      	b.n	1bd04 <lv_cont_refr_layout+0x58c>
        if(obj_num == 0) {
   1bd50:	2e00      	cmp	r6, #0
   1bd52:	f47f aedf 	bne.w	1bb14 <lv_cont_refr_layout+0x39c>
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
   1bd56:	2215      	movs	r2, #21
   1bd58:	2100      	movs	r1, #0
   1bd5a:	4628      	mov	r0, r5
   1bd5c:	f7ed fd54 	bl	9808 <_lv_obj_get_style_int>
                lv_obj_align(child_rc, cont, LV_ALIGN_IN_TOP_MID, 0, act_y + mtop);
   1bd60:	19c3      	adds	r3, r0, r7
   1bd62:	b21b      	sxth	r3, r3
   1bd64:	4604      	mov	r4, r0
   1bd66:	2202      	movs	r2, #2
   1bd68:	4649      	mov	r1, r9
   1bd6a:	4628      	mov	r0, r5
   1bd6c:	9300      	str	r3, [sp, #0]
   1bd6e:	2300      	movs	r3, #0
   1bd70:	f7f9 fdd2 	bl	15918 <lv_obj_align>
                h_row = lv_obj_get_height(child_rc); /*Not set previously because of the early break*/
   1bd74:	4628      	mov	r0, r5
   1bd76:	f7f9 feb1 	bl	15adc <lv_obj_get_height>
                h_row += mtop;
   1bd7a:	4420      	add	r0, r4
   1bd7c:	b204      	sxth	r4, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
   1bd7e:	2216      	movs	r2, #22
   1bd80:	2100      	movs	r1, #0
   1bd82:	4628      	mov	r0, r5
   1bd84:	f7ed fd40 	bl	9808 <_lv_obj_get_style_int>
                h_row += lv_obj_get_style_margin_bottom(child_rc, LV_OBJ_PART_MAIN);
   1bd88:	4420      	add	r0, r4
   1bd8a:	b203      	sxth	r3, r0
   1bd8c:	9303      	str	r3, [sp, #12]
        act_y += pinner + h_row;           /*y increment*/
   1bd8e:	9b03      	ldr	r3, [sp, #12]
   1bd90:	9a06      	ldr	r2, [sp, #24]
        child_rs = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
   1bd92:	4629      	mov	r1, r5
        act_y += pinner + h_row;           /*y increment*/
   1bd94:	4413      	add	r3, r2
        child_rs = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
   1bd96:	9804      	ldr	r0, [sp, #16]
        act_y += pinner + h_row;           /*y increment*/
   1bd98:	441f      	add	r7, r3
        child_rs = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
   1bd9a:	f7ff fa41 	bl	1b220 <_lv_ll_get_prev>
        act_y += pinner + h_row;           /*y increment*/
   1bd9e:	b23f      	sxth	r7, r7
    while(child_rs != NULL) {
   1bda0:	4605      	mov	r5, r0
   1bda2:	2800      	cmp	r0, #0
   1bda4:	f47f ae84 	bne.w	1bab0 <lv_cont_refr_layout+0x338>
   1bda8:	e523      	b.n	1b7f2 <lv_cont_refr_layout+0x7a>
        } while(child_rc != NULL);
   1bdaa:	2800      	cmp	r0, #0
   1bdac:	f43f ad21 	beq.w	1b7f2 <lv_cont_refr_layout+0x7a>
            child_rc = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Load the next object*/
   1bdb0:	462c      	mov	r4, r5
   1bdb2:	e682      	b.n	1baba <lv_cont_refr_layout+0x342>
}
   1bdb4:	b00f      	add	sp, #60	; 0x3c
   1bdb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001bdba <lv_img_design>:
{
   1bdba:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1bdbe:	4615      	mov	r5, r2
   1bdc0:	b0b3      	sub	sp, #204	; 0xcc
   1bdc2:	4604      	mov	r4, r0
   1bdc4:	4688      	mov	r8, r1
    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
   1bdc6:	f7fa f9b9 	bl	1613c <lv_obj_get_ext_attr>
    if(mode == LV_DESIGN_COVER_CHK) {
   1bdca:	2d02      	cmp	r5, #2
    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
   1bdcc:	4606      	mov	r6, r0
    if(mode == LV_DESIGN_COVER_CHK) {
   1bdce:	d166      	bne.n	1be9e <lv_img_design+0xe4>
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
   1bdd0:	462a      	mov	r2, r5
   1bdd2:	2100      	movs	r1, #0
   1bdd4:	4620      	mov	r0, r4
   1bdd6:	f7ed fd17 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_clip_corner(img, LV_IMG_PART_MAIN)) return LV_DESIGN_RES_MASKED;
   1bdda:	2800      	cmp	r0, #0
   1bddc:	f040 8295 	bne.w	1c30a <lv_img_design+0x550>
        if(ext->src_type == LV_IMG_SRC_UNKNOWN || ext->src_type == LV_IMG_SRC_SYMBOL) return LV_DESIGN_RES_NOT_COVER;
   1bde0:	7d33      	ldrb	r3, [r6, #20]
   1bde2:	079a      	lsls	r2, r3, #30
   1bde4:	d42b      	bmi.n	1be3e <lv_img_design+0x84>
        if(ext->cf != LV_IMG_CF_TRUE_COLOR && ext->cf != LV_IMG_CF_RAW) return LV_DESIGN_RES_NOT_COVER;
   1bde6:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
   1bdea:	2b20      	cmp	r3, #32
   1bdec:	d001      	beq.n	1bdf2 <lv_img_design+0x38>
   1bdee:	2b08      	cmp	r3, #8
   1bdf0:	d125      	bne.n	1be3e <lv_img_design+0x84>
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_OPA, image_opa, lv_opa_t, _opa, scalar)
   1bdf2:	f248 02ac 	movw	r2, #32940	; 0x80ac
   1bdf6:	2100      	movs	r1, #0
   1bdf8:	4620      	mov	r0, r4
   1bdfa:	f7f9 ff66 	bl	15cca <_lv_obj_get_style_opa>
        if(lv_obj_get_style_image_opa(img, LV_IMG_PART_MAIN) != LV_OPA_COVER) return LV_DESIGN_RES_NOT_COVER;
   1bdfe:	28ff      	cmp	r0, #255	; 0xff
   1be00:	d11d      	bne.n	1be3e <lv_img_design+0x84>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
   1be02:	2206      	movs	r2, #6
   1be04:	2100      	movs	r1, #0
   1be06:	4620      	mov	r0, r4
   1be08:	f7ed fcfe 	bl	9808 <_lv_obj_get_style_int>
        angle_final += ext->angle;
   1be0c:	f8b6 900c 	ldrh.w	r9, [r6, #12]
        if(angle_final != 0) return LV_DESIGN_RES_NOT_COVER;
   1be10:	eb19 0900 	adds.w	r9, r9, r0
   1be14:	d113      	bne.n	1be3e <lv_img_design+0x84>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
   1be16:	2207      	movs	r2, #7
   1be18:	4649      	mov	r1, r9
   1be1a:	4620      	mov	r0, r4
   1be1c:	f7ed fcf4 	bl	9808 <_lv_obj_get_style_int>
        zoom_final = (zoom_final * ext->zoom) >> 8;
   1be20:	8a77      	ldrh	r7, [r6, #18]
   1be22:	4347      	muls	r7, r0
   1be24:	123f      	asrs	r7, r7, #8
        if(zoom_final == LV_IMG_ZOOM_NONE) {
   1be26:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
   1be2a:	d10c      	bne.n	1be46 <lv_img_design+0x8c>
            if(_lv_area_is_in(clip_area, &img->coords, 0) == false) return LV_DESIGN_RES_NOT_COVER;
   1be2c:	464a      	mov	r2, r9
   1be2e:	f104 0110 	add.w	r1, r4, #16
            if(_lv_area_is_in(clip_area, &a, 0) == false) return LV_DESIGN_RES_NOT_COVER;
   1be32:	4640      	mov	r0, r8
   1be34:	f7ff f825 	bl	1ae82 <_lv_area_is_in>
        return LV_DESIGN_RES_COVER;
   1be38:	2800      	cmp	r0, #0
   1be3a:	bf18      	it	ne
   1be3c:	2501      	movne	r5, #1
}
   1be3e:	4628      	mov	r0, r5
   1be40:	b033      	add	sp, #204	; 0xcc
   1be42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            _lv_img_buf_get_transformed_area(&a, lv_obj_get_width(img), lv_obj_get_height(img), 0, zoom_final, &ext->pivot);
   1be46:	4620      	mov	r0, r4
   1be48:	f7f9 fe42 	bl	15ad0 <lv_obj_get_width>
   1be4c:	4682      	mov	sl, r0
   1be4e:	4620      	mov	r0, r4
   1be50:	f7f9 fe44 	bl	15adc <lv_obj_get_height>
   1be54:	360e      	adds	r6, #14
   1be56:	b2bf      	uxth	r7, r7
   1be58:	4602      	mov	r2, r0
   1be5a:	464b      	mov	r3, r9
   1be5c:	4651      	mov	r1, sl
   1be5e:	9601      	str	r6, [sp, #4]
   1be60:	9700      	str	r7, [sp, #0]
   1be62:	a818      	add	r0, sp, #96	; 0x60
   1be64:	f7fe fd6a 	bl	1a93c <_lv_img_buf_get_transformed_area>
            a.x1 += img->coords.x1;
   1be68:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
   1be6c:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
            a.y1 += img->coords.y1;
   1be70:	f8bd 1062 	ldrh.w	r1, [sp, #98]	; 0x62
            a.x1 += img->coords.x1;
   1be74:	4413      	add	r3, r2
   1be76:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
            a.y1 += img->coords.y1;
   1be7a:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
   1be7e:	4419      	add	r1, r3
   1be80:	f8ad 1062 	strh.w	r1, [sp, #98]	; 0x62
            a.x2 += img->coords.x1;
   1be84:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
   1be88:	440a      	add	r2, r1
   1be8a:	f8ad 2064 	strh.w	r2, [sp, #100]	; 0x64
            a.y2 += img->coords.y1;
   1be8e:	f8bd 2066 	ldrh.w	r2, [sp, #102]	; 0x66
            if(_lv_area_is_in(clip_area, &a, 0) == false) return LV_DESIGN_RES_NOT_COVER;
   1be92:	a918      	add	r1, sp, #96	; 0x60
            a.y2 += img->coords.y1;
   1be94:	4413      	add	r3, r2
   1be96:	f8ad 3066 	strh.w	r3, [sp, #102]	; 0x66
            if(_lv_area_is_in(clip_area, &a, 0) == false) return LV_DESIGN_RES_NOT_COVER;
   1be9a:	464a      	mov	r2, r9
   1be9c:	e7c9      	b.n	1be32 <lv_img_design+0x78>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
   1be9e:	2d00      	cmp	r5, #0
   1bea0:	f040 81a4 	bne.w	1c1ec <lv_img_design+0x432>
        if(ext->h == 0 || ext->w == 0) return true;
   1bea4:	f9b0 300a 	ldrsh.w	r3, [r0, #10]
   1bea8:	2b00      	cmp	r3, #0
   1beaa:	f000 819d 	beq.w	1c1e8 <lv_img_design+0x42e>
   1beae:	f9b0 3008 	ldrsh.w	r3, [r0, #8]
   1beb2:	2b00      	cmp	r3, #0
   1beb4:	f000 8198 	beq.w	1c1e8 <lv_img_design+0x42e>
        lv_draw_rect_dsc_init(&bg_dsc);
   1beb8:	a818      	add	r0, sp, #96	; 0x60
   1beba:	f7f0 f82f 	bl	bf1c <lv_draw_rect_dsc_init>
        lv_obj_init_draw_rect_dsc(img, LV_IMG_PART_MAIN, &bg_dsc);
   1bebe:	4629      	mov	r1, r5
   1bec0:	4620      	mov	r0, r4
   1bec2:	aa18      	add	r2, sp, #96	; 0x60
   1bec4:	f7fa f962 	bl	1618c <lv_obj_init_draw_rect_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   1bec8:	2233      	movs	r2, #51	; 0x33
   1beca:	4629      	mov	r1, r5
   1becc:	4620      	mov	r0, r4
   1bece:	f7ed fc9b 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_border_post(img, LV_OBJ_PART_MAIN)) {
   1bed2:	b108      	cbz	r0, 1bed8 <lv_img_design+0x11e>
            bg_dsc.border_opa = LV_OPA_TRANSP;
   1bed4:	f88d 507c 	strb.w	r5, [sp, #124]	; 0x7c
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
   1bed8:	2207      	movs	r2, #7
   1beda:	2100      	movs	r1, #0
   1bedc:	4620      	mov	r0, r4
   1bede:	f7ed fc93 	bl	9808 <_lv_obj_get_style_int>
        zoom_final = (zoom_final * ext->zoom) >> 8;
   1bee2:	8a77      	ldrh	r7, [r6, #18]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
   1bee4:	2206      	movs	r2, #6
   1bee6:	2100      	movs	r1, #0
   1bee8:	4347      	muls	r7, r0
   1beea:	4620      	mov	r0, r4
   1beec:	f7ed fc8c 	bl	9808 <_lv_obj_get_style_int>
        angle_final += ext->angle;
   1bef0:	f8b6 a00c 	ldrh.w	sl, [r6, #12]
        zoom_final = (zoom_final * ext->zoom) >> 8;
   1bef4:	123f      	asrs	r7, r7, #8
        angle_final += ext->angle;
   1bef6:	4482      	add	sl, r0
        lv_coord_t obj_w = lv_obj_get_width(img);
   1bef8:	4620      	mov	r0, r4
   1befa:	f7f9 fde9 	bl	15ad0 <lv_obj_get_width>
   1befe:	9004      	str	r0, [sp, #16]
        lv_coord_t obj_h = lv_obj_get_height(img);
   1bf00:	4620      	mov	r0, r4
   1bf02:	f7f9 fdeb 	bl	15adc <lv_obj_get_height>
        _lv_img_buf_get_transformed_area(&bg_coords, obj_w, obj_h,
   1bf06:	b2bb      	uxth	r3, r7
   1bf08:	9302      	str	r3, [sp, #8]
                                         angle_final, zoom_final, &ext->pivot);
   1bf0a:	f106 030e 	add.w	r3, r6, #14
   1bf0e:	9303      	str	r3, [sp, #12]
        _lv_img_buf_get_transformed_area(&bg_coords, obj_w, obj_h,
   1bf10:	9301      	str	r3, [sp, #4]
   1bf12:	9b02      	ldr	r3, [sp, #8]
   1bf14:	fa0f fb8a 	sxth.w	fp, sl
   1bf18:	4602      	mov	r2, r0
   1bf1a:	9904      	ldr	r1, [sp, #16]
        lv_coord_t obj_h = lv_obj_get_height(img);
   1bf1c:	9005      	str	r0, [sp, #20]
        _lv_img_buf_get_transformed_area(&bg_coords, obj_w, obj_h,
   1bf1e:	9300      	str	r3, [sp, #0]
   1bf20:	a807      	add	r0, sp, #28
   1bf22:	465b      	mov	r3, fp
   1bf24:	f7fe fd0a 	bl	1a93c <_lv_img_buf_get_transformed_area>
        bg_coords.x1 += img->coords.x1;
   1bf28:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
   1bf2c:	f8bd 301c 	ldrh.w	r3, [sp, #28]
        bg_coords.y1 += img->coords.y1;
   1bf30:	f8bd 101e 	ldrh.w	r1, [sp, #30]
        bg_coords.x1 += img->coords.x1;
   1bf34:	4413      	add	r3, r2
   1bf36:	f8ad 301c 	strh.w	r3, [sp, #28]
        bg_coords.y1 += img->coords.y1;
   1bf3a:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1bf3e:	4620      	mov	r0, r4
   1bf40:	4419      	add	r1, r3
   1bf42:	f8ad 101e 	strh.w	r1, [sp, #30]
        bg_coords.x2 += img->coords.x1;
   1bf46:	f8bd 1020 	ldrh.w	r1, [sp, #32]
   1bf4a:	440a      	add	r2, r1
   1bf4c:	f8ad 2020 	strh.w	r2, [sp, #32]
        bg_coords.y2 += img->coords.y1;
   1bf50:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
   1bf54:	2100      	movs	r1, #0
   1bf56:	4413      	add	r3, r2
   1bf58:	2212      	movs	r2, #18
   1bf5a:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
   1bf5e:	f7ed fc53 	bl	9808 <_lv_obj_get_style_int>
        bg_coords.x1 -= lv_obj_get_style_pad_left(img, LV_IMG_PART_MAIN);
   1bf62:	f8bd 301c 	ldrh.w	r3, [sp, #28]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1bf66:	2213      	movs	r2, #19
   1bf68:	1a1b      	subs	r3, r3, r0
   1bf6a:	2100      	movs	r1, #0
   1bf6c:	4620      	mov	r0, r4
   1bf6e:	f8ad 301c 	strh.w	r3, [sp, #28]
   1bf72:	f7ed fc49 	bl	9808 <_lv_obj_get_style_int>
        bg_coords.x2 += lv_obj_get_style_pad_right(img, LV_IMG_PART_MAIN);
   1bf76:	f8bd 3020 	ldrh.w	r3, [sp, #32]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1bf7a:	2210      	movs	r2, #16
   1bf7c:	4418      	add	r0, r3
   1bf7e:	2100      	movs	r1, #0
   1bf80:	f8ad 0020 	strh.w	r0, [sp, #32]
   1bf84:	4620      	mov	r0, r4
   1bf86:	f7ed fc3f 	bl	9808 <_lv_obj_get_style_int>
        bg_coords.y1 -= lv_obj_get_style_pad_top(img, LV_IMG_PART_MAIN);
   1bf8a:	f8bd 301e 	ldrh.w	r3, [sp, #30]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   1bf8e:	2211      	movs	r2, #17
   1bf90:	1a1b      	subs	r3, r3, r0
   1bf92:	2100      	movs	r1, #0
   1bf94:	4620      	mov	r0, r4
   1bf96:	f8ad 301e 	strh.w	r3, [sp, #30]
   1bf9a:	f7ed fc35 	bl	9808 <_lv_obj_get_style_int>
        bg_coords.y2 += lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
   1bf9e:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
        lv_draw_rect(&bg_coords, clip_area, &bg_dsc);
   1bfa2:	4641      	mov	r1, r8
        bg_coords.y2 += lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
   1bfa4:	4418      	add	r0, r3
   1bfa6:	f8ad 0022 	strh.w	r0, [sp, #34]	; 0x22
        lv_draw_rect(&bg_coords, clip_area, &bg_dsc);
   1bfaa:	aa18      	add	r2, sp, #96	; 0x60
   1bfac:	a807      	add	r0, sp, #28
   1bfae:	f7fd f822 	bl	18ff6 <lv_draw_rect>
        if(zoom_final == 0) return LV_DESIGN_RES_OK;
   1bfb2:	2f00      	cmp	r7, #0
   1bfb4:	f43f af43 	beq.w	1be3e <lv_img_design+0x84>
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
   1bfb8:	2202      	movs	r2, #2
   1bfba:	2100      	movs	r1, #0
   1bfbc:	4620      	mov	r0, r4
   1bfbe:	f7ed fc23 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_clip_corner(img, LV_OBJ_PART_MAIN)) {
   1bfc2:	b198      	cbz	r0, 1bfec <lv_img_design+0x232>
            lv_draw_mask_radius_param_t * mp = _lv_mem_buf_get(sizeof(lv_draw_mask_radius_param_t));
   1bfc4:	201c      	movs	r0, #28
   1bfc6:	f7f0 fd99 	bl	cafc <_lv_mem_buf_get>
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
   1bfca:	2201      	movs	r2, #1
   1bfcc:	4681      	mov	r9, r0
   1bfce:	2100      	movs	r1, #0
   1bfd0:	4620      	mov	r0, r4
   1bfd2:	f7ed fc19 	bl	9808 <_lv_obj_get_style_int>
            lv_draw_mask_radius_init(mp, &bg_coords, r, false);
   1bfd6:	a907      	add	r1, sp, #28
   1bfd8:	4602      	mov	r2, r0
   1bfda:	2300      	movs	r3, #0
   1bfdc:	4648      	mov	r0, r9
   1bfde:	f7ef ff73 	bl	bec8 <lv_draw_mask_radius_init>
            lv_draw_mask_add(mp, img + 8);
   1bfe2:	4648      	mov	r0, r9
   1bfe4:	f504 71f0 	add.w	r1, r4, #480	; 0x1e0
   1bfe8:	f7ef fe7e 	bl	bce8 <lv_draw_mask_add>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_VARIABLE) {
   1bfec:	7d33      	ldrb	r3, [r6, #20]
   1bfee:	f013 0902 	ands.w	r9, r3, #2
   1bff2:	f040 80d4 	bne.w	1c19e <lv_img_design+0x3e4>
            lv_draw_img_dsc_init(&img_dsc);
   1bff6:	a80f      	add	r0, sp, #60	; 0x3c
   1bff8:	f7fc fa79 	bl	184ee <lv_draw_img_dsc_init>
            lv_obj_init_draw_img_dsc(img, LV_IMG_PART_MAIN, &img_dsc);
   1bffc:	4649      	mov	r1, r9
   1bffe:	4620      	mov	r0, r4
   1c000:	aa0f      	add	r2, sp, #60	; 0x3c
   1c002:	f7fa faaf 	bl	16564 <lv_obj_init_draw_img_dsc>
            img_dsc.zoom = zoom_final;
   1c006:	9b02      	ldr	r3, [sp, #8]
   1c008:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
            if(img_dsc.zoom == 0) return LV_DESIGN_RES_OK;
   1c00c:	2b00      	cmp	r3, #0
   1c00e:	f000 80ef 	beq.w	1c1f0 <lv_img_design+0x436>
            img_dsc.pivot.x = ext->pivot.x;
   1c012:	89f3      	ldrh	r3, [r6, #14]
            img_dsc.antialias = ext->antialias;
   1c014:	f89d 204d 	ldrb.w	r2, [sp, #77]	; 0x4d
            img_dsc.pivot.x = ext->pivot.x;
   1c018:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
            img_dsc.pivot.y = ext->pivot.y;
   1c01c:	8a33      	ldrh	r3, [r6, #16]
            img_dsc.angle = angle_final;
   1c01e:	f8ad a03e 	strh.w	sl, [sp, #62]	; 0x3e
            img_dsc.pivot.y = ext->pivot.y;
   1c022:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
            img_dsc.antialias = ext->antialias;
   1c026:	7d73      	ldrb	r3, [r6, #21]
   1c028:	f3c3 0300 	ubfx	r3, r3, #0, #1
   1c02c:	f363 0200 	bfi	r2, r3, #0, #1
   1c030:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d
            lv_coord_t zoomed_src_w = (int32_t)((int32_t)ext->w * zoom_final) >> 8;
   1c034:	f9b6 9008 	ldrsh.w	r9, [r6, #8]
   1c038:	fb07 f909 	mul.w	r9, r7, r9
   1c03c:	f349 290f 	sbfx	r9, r9, #8, #16
            if(zoomed_src_w <= 0) return LV_DESIGN_RES_OK;
   1c040:	f1b9 0f00 	cmp.w	r9, #0
   1c044:	f340 80d4 	ble.w	1c1f0 <lv_img_design+0x436>
            lv_coord_t zoomed_src_h = (int32_t)((int32_t)ext->h * zoom_final) >> 8;
   1c048:	f9b6 a00a 	ldrsh.w	sl, [r6, #10]
   1c04c:	fb07 fa0a 	mul.w	sl, r7, sl
   1c050:	f34a 2a0f 	sbfx	sl, sl, #8, #16
            if(zoomed_src_h <= 0) return LV_DESIGN_RES_OK;
   1c054:	f1ba 0f00 	cmp.w	sl, #0
   1c058:	f340 80ca 	ble.w	1c1f0 <lv_img_design+0x436>
            lv_obj_get_coords(img, &zommed_coords);
   1c05c:	4620      	mov	r0, r4
   1c05e:	a909      	add	r1, sp, #36	; 0x24
   1c060:	f7f9 fd0b 	bl	15a7a <lv_obj_get_coords>
            zommed_coords.x1 += (int32_t)((int32_t)ext->offset.x * zoom_final) >> 8;
   1c064:	f9b6 2004 	ldrsh.w	r2, [r6, #4]
   1c068:	fb07 f302 	mul.w	r3, r7, r2
   1c06c:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   1c070:	eb02 2223 	add.w	r2, r2, r3, asr #8
            zommed_coords.y1 += (int32_t)((int32_t)ext->offset.y * zoom_final) >> 8;
   1c074:	f9b6 3006 	ldrsh.w	r3, [r6, #6]
            zommed_coords.x1 += (int32_t)((int32_t)ext->offset.x * zoom_final) >> 8;
   1c078:	b212      	sxth	r2, r2
            zommed_coords.y1 += (int32_t)((int32_t)ext->offset.y * zoom_final) >> 8;
   1c07a:	fb07 f103 	mul.w	r1, r7, r3
   1c07e:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
            zommed_coords.x1 += (int32_t)((int32_t)ext->offset.x * zoom_final) >> 8;
   1c082:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
            zommed_coords.y1 += (int32_t)((int32_t)ext->offset.y * zoom_final) >> 8;
   1c086:	eb03 2321 	add.w	r3, r3, r1, asr #8
            zommed_coords.x2 = zommed_coords.x1 + ((int32_t)((int32_t)(obj_w - 1) * zoom_final) >> 8);
   1c08a:	9904      	ldr	r1, [sp, #16]
            zommed_coords.y1 += (int32_t)((int32_t)ext->offset.y * zoom_final) >> 8;
   1c08c:	b21b      	sxth	r3, r3
            zommed_coords.x2 = zommed_coords.x1 + ((int32_t)((int32_t)(obj_w - 1) * zoom_final) >> 8);
   1c08e:	1e48      	subs	r0, r1, #1
   1c090:	4378      	muls	r0, r7
            zommed_coords.y2 = zommed_coords.y1 + ((int32_t)((int32_t)(obj_h - 1) * zoom_final) >> 8);
   1c092:	9905      	ldr	r1, [sp, #20]
            zommed_coords.x2 = zommed_coords.x1 + ((int32_t)((int32_t)(obj_w - 1) * zoom_final) >> 8);
   1c094:	eb02 2020 	add.w	r0, r2, r0, asr #8
   1c098:	f8ad 0028 	strh.w	r0, [sp, #40]	; 0x28
            zommed_coords.y2 = zommed_coords.y1 + ((int32_t)((int32_t)(obj_h - 1) * zoom_final) >> 8);
   1c09c:	1e48      	subs	r0, r1, #1
            if(zommed_coords.x1 > img->coords.x1) zommed_coords.x1 -= ext->w;
   1c09e:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
            zommed_coords.y2 = zommed_coords.y1 + ((int32_t)((int32_t)(obj_h - 1) * zoom_final) >> 8);
   1c0a2:	4347      	muls	r7, r0
            if(zommed_coords.x1 > img->coords.x1) zommed_coords.x1 -= ext->w;
   1c0a4:	4291      	cmp	r1, r2
   1c0a6:	bfb8      	it	lt
   1c0a8:	8931      	ldrhlt	r1, [r6, #8]
            zommed_coords.y2 = zommed_coords.y1 + ((int32_t)((int32_t)(obj_h - 1) * zoom_final) >> 8);
   1c0aa:	eb03 2727 	add.w	r7, r3, r7, asr #8
            if(zommed_coords.x1 > img->coords.x1) zommed_coords.x1 -= ext->w;
   1c0ae:	bfbc      	itt	lt
   1c0b0:	1a52      	sublt	r2, r2, r1
   1c0b2:	f8ad 2024 	strhlt.w	r2, [sp, #36]	; 0x24
            if(zommed_coords.y1 > img->coords.y1) zommed_coords.y1 -= ext->h;
   1c0b6:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
            zommed_coords.y1 += (int32_t)((int32_t)ext->offset.y * zoom_final) >> 8;
   1c0ba:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
            if(zommed_coords.y1 > img->coords.y1) zommed_coords.y1 -= ext->h;
   1c0be:	429a      	cmp	r2, r3
   1c0c0:	bfb8      	it	lt
   1c0c2:	8972      	ldrhlt	r2, [r6, #10]
            _lv_img_buf_get_transformed_area(&clip_real, lv_obj_get_width(img), lv_obj_get_height(img), angle_final, zoom_final,
   1c0c4:	4620      	mov	r0, r4
            if(zommed_coords.y1 > img->coords.y1) zommed_coords.y1 -= ext->h;
   1c0c6:	bfbc      	itt	lt
   1c0c8:	1a9b      	sublt	r3, r3, r2
   1c0ca:	f8ad 3026 	strhlt.w	r3, [sp, #38]	; 0x26
            zommed_coords.y2 = zommed_coords.y1 + ((int32_t)((int32_t)(obj_h - 1) * zoom_final) >> 8);
   1c0ce:	f8ad 702a 	strh.w	r7, [sp, #42]	; 0x2a
            _lv_img_buf_get_transformed_area(&clip_real, lv_obj_get_width(img), lv_obj_get_height(img), angle_final, zoom_final,
   1c0d2:	f7f9 fcfd 	bl	15ad0 <lv_obj_get_width>
   1c0d6:	4607      	mov	r7, r0
   1c0d8:	4620      	mov	r0, r4
   1c0da:	f7f9 fcff 	bl	15adc <lv_obj_get_height>
   1c0de:	9b03      	ldr	r3, [sp, #12]
   1c0e0:	4602      	mov	r2, r0
   1c0e2:	9301      	str	r3, [sp, #4]
   1c0e4:	9b02      	ldr	r3, [sp, #8]
   1c0e6:	4639      	mov	r1, r7
   1c0e8:	9300      	str	r3, [sp, #0]
   1c0ea:	a80b      	add	r0, sp, #44	; 0x2c
   1c0ec:	465b      	mov	r3, fp
   1c0ee:	f7fe fc25 	bl	1a93c <_lv_img_buf_get_transformed_area>
            clip_real.x1 += img->coords.x1;
   1c0f2:	f9b4 3010 	ldrsh.w	r3, [r4, #16]
   1c0f6:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
            if(_lv_area_intersect(&clip_real, &clip_real, clip_area) == false) return LV_DESIGN_RES_OK;
   1c0fa:	a90b      	add	r1, sp, #44	; 0x2c
            clip_real.x1 += img->coords.x1;
   1c0fc:	441a      	add	r2, r3
   1c0fe:	f8ad 202c 	strh.w	r2, [sp, #44]	; 0x2c
            clip_real.x2 += img->coords.x1;
   1c102:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
            if(_lv_area_intersect(&clip_real, &clip_real, clip_area) == false) return LV_DESIGN_RES_OK;
   1c106:	4608      	mov	r0, r1
            clip_real.x2 += img->coords.x1;
   1c108:	4413      	add	r3, r2
   1c10a:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
            clip_real.y1 += img->coords.y1;
   1c10e:	f8bd 202e 	ldrh.w	r2, [sp, #46]	; 0x2e
   1c112:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
   1c116:	441a      	add	r2, r3
   1c118:	f8ad 202e 	strh.w	r2, [sp, #46]	; 0x2e
            clip_real.y2 += img->coords.y1;
   1c11c:	f8bd 2032 	ldrh.w	r2, [sp, #50]	; 0x32
   1c120:	4413      	add	r3, r2
            if(_lv_area_intersect(&clip_real, &clip_real, clip_area) == false) return LV_DESIGN_RES_OK;
   1c122:	4642      	mov	r2, r8
            clip_real.y2 += img->coords.y1;
   1c124:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
            if(_lv_area_intersect(&clip_real, &clip_real, clip_area) == false) return LV_DESIGN_RES_OK;
   1c128:	f7fe fdb8 	bl	1ac9c <_lv_area_intersect>
   1c12c:	2800      	cmp	r0, #0
   1c12e:	d05f      	beq.n	1c1f0 <lv_img_design+0x436>
            coords_tmp.y1 = zommed_coords.y1;
   1c130:	f9bd 3026 	ldrsh.w	r3, [sp, #38]	; 0x26
            coords_tmp.y2 = zommed_coords.y1 + ext->h - 1;
   1c134:	8972      	ldrh	r2, [r6, #10]
            coords_tmp.y1 = zommed_coords.y1;
   1c136:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
            coords_tmp.y2 = zommed_coords.y1 + ext->h - 1;
   1c13a:	3b01      	subs	r3, #1
   1c13c:	4413      	add	r3, r2
            for(; coords_tmp.y1 <= clip_real.y2; coords_tmp.y1 += zoomed_src_h, coords_tmp.y2 += zoomed_src_h) {
   1c13e:	f9bd 2036 	ldrsh.w	r2, [sp, #54]	; 0x36
   1c142:	f8ad 303a 	strh.w	r3, [sp, #58]	; 0x3a
   1c146:	f9bd 3032 	ldrsh.w	r3, [sp, #50]	; 0x32
   1c14a:	429a      	cmp	r2, r3
   1c14c:	f73f ae77 	bgt.w	1be3e <lv_img_design+0x84>
                coords_tmp.x1 = zommed_coords.x1;
   1c150:	f9bd 3024 	ldrsh.w	r3, [sp, #36]	; 0x24
                coords_tmp.x2 = zommed_coords.x1 + ext->w - 1;
   1c154:	8932      	ldrh	r2, [r6, #8]
                coords_tmp.x1 = zommed_coords.x1;
   1c156:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
                coords_tmp.x2 = zommed_coords.x1 + ext->w - 1;
   1c15a:	3b01      	subs	r3, #1
   1c15c:	4413      	add	r3, r2
                for(; coords_tmp.x1 <= clip_real.x2; coords_tmp.x1 += zoomed_src_w, coords_tmp.x2 += zoomed_src_w) {
   1c15e:	f9bd 2034 	ldrsh.w	r2, [sp, #52]	; 0x34
   1c162:	f8ad 3038 	strh.w	r3, [sp, #56]	; 0x38
   1c166:	f9bd 3030 	ldrsh.w	r3, [sp, #48]	; 0x30
   1c16a:	429a      	cmp	r2, r3
   1c16c:	dd08      	ble.n	1c180 <lv_img_design+0x3c6>
            for(; coords_tmp.y1 <= clip_real.y2; coords_tmp.y1 += zoomed_src_h, coords_tmp.y2 += zoomed_src_h) {
   1c16e:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
   1c172:	4453      	add	r3, sl
   1c174:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
   1c178:	f8bd 303a 	ldrh.w	r3, [sp, #58]	; 0x3a
   1c17c:	4453      	add	r3, sl
   1c17e:	e7de      	b.n	1c13e <lv_img_design+0x384>
                    lv_draw_img(&coords_tmp, &clip_real, ext->src, &img_dsc);
   1c180:	ab0f      	add	r3, sp, #60	; 0x3c
   1c182:	6832      	ldr	r2, [r6, #0]
   1c184:	a90b      	add	r1, sp, #44	; 0x2c
   1c186:	a80d      	add	r0, sp, #52	; 0x34
   1c188:	f7ee fc74 	bl	aa74 <lv_draw_img>
                for(; coords_tmp.x1 <= clip_real.x2; coords_tmp.x1 += zoomed_src_w, coords_tmp.x2 += zoomed_src_w) {
   1c18c:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
   1c190:	444b      	add	r3, r9
   1c192:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
   1c196:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
   1c19a:	444b      	add	r3, r9
   1c19c:	e7df      	b.n	1c15e <lv_img_design+0x3a4>
        else if(ext->src_type == LV_IMG_SRC_SYMBOL) {
   1c19e:	f003 0303 	and.w	r3, r3, #3
   1c1a2:	2b02      	cmp	r3, #2
   1c1a4:	f104 0710 	add.w	r7, r4, #16
   1c1a8:	d117      	bne.n	1c1da <lv_img_design+0x420>
            lv_draw_label_dsc_init(&label_dsc);
   1c1aa:	a80f      	add	r0, sp, #60	; 0x3c
   1c1ac:	f7ee fd3a 	bl	ac24 <lv_draw_label_dsc_init>
            lv_obj_init_draw_label_dsc(img, LV_IMG_PART_MAIN, &label_dsc);
   1c1b0:	4620      	mov	r0, r4
   1c1b2:	aa0f      	add	r2, sp, #60	; 0x3c
   1c1b4:	2100      	movs	r1, #0
   1c1b6:	f7fa f996 	bl	164e6 <lv_obj_init_draw_label_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
   1c1ba:	f248 02a9 	movw	r2, #32937	; 0x80a9
   1c1be:	2100      	movs	r1, #0
   1c1c0:	4620      	mov	r0, r4
   1c1c2:	f7f9 fd35 	bl	15c30 <_lv_obj_get_style_color>
            lv_draw_label(&img->coords, clip_area, &label_dsc, ext->src, NULL);
   1c1c6:	2300      	movs	r3, #0
   1c1c8:	9300      	str	r3, [sp, #0]
            label_dsc.color = lv_obj_get_style_image_recolor(img, LV_IMG_PART_MAIN);
   1c1ca:	900f      	str	r0, [sp, #60]	; 0x3c
            lv_draw_label(&img->coords, clip_area, &label_dsc, ext->src, NULL);
   1c1cc:	4641      	mov	r1, r8
   1c1ce:	4638      	mov	r0, r7
   1c1d0:	6833      	ldr	r3, [r6, #0]
   1c1d2:	aa0f      	add	r2, sp, #60	; 0x3c
   1c1d4:	f7ee fd3e 	bl	ac54 <lv_draw_label>
   1c1d8:	e631      	b.n	1be3e <lv_img_design+0x84>
            lv_draw_img(&img->coords, clip_area, NULL, NULL);
   1c1da:	2300      	movs	r3, #0
   1c1dc:	4641      	mov	r1, r8
   1c1de:	461a      	mov	r2, r3
   1c1e0:	4638      	mov	r0, r7
   1c1e2:	f7ee fc47 	bl	aa74 <lv_draw_img>
   1c1e6:	e62a      	b.n	1be3e <lv_img_design+0x84>
        if(ext->h == 0 || ext->w == 0) return true;
   1c1e8:	2501      	movs	r5, #1
   1c1ea:	e628      	b.n	1be3e <lv_img_design+0x84>
    else if(mode == LV_DESIGN_DRAW_POST) {
   1c1ec:	2d01      	cmp	r5, #1
   1c1ee:	d001      	beq.n	1c1f4 <lv_img_design+0x43a>
    return LV_DESIGN_RES_OK;
   1c1f0:	2500      	movs	r5, #0
   1c1f2:	e624      	b.n	1be3e <lv_img_design+0x84>
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
   1c1f4:	2202      	movs	r2, #2
   1c1f6:	2100      	movs	r1, #0
   1c1f8:	4620      	mov	r0, r4
   1c1fa:	f7ed fb05 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_clip_corner(img, LV_OBJ_PART_MAIN)) {
   1c1fe:	b128      	cbz	r0, 1c20c <lv_img_design+0x452>
            lv_draw_mask_radius_param_t * param = lv_draw_mask_remove_custom(img + 8);
   1c200:	f504 70f0 	add.w	r0, r4, #480	; 0x1e0
   1c204:	f7ef fdba 	bl	bd7c <lv_draw_mask_remove_custom>
            _lv_mem_buf_release(param);
   1c208:	f7f0 fcda 	bl	cbc0 <_lv_mem_buf_release>
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
   1c20c:	2233      	movs	r2, #51	; 0x33
   1c20e:	2100      	movs	r1, #0
   1c210:	4620      	mov	r0, r4
   1c212:	f7ed faf9 	bl	9808 <_lv_obj_get_style_int>
        if(lv_obj_get_style_border_post(img, LV_OBJ_PART_MAIN)) {
   1c216:	2800      	cmp	r0, #0
   1c218:	d0ea      	beq.n	1c1f0 <lv_img_design+0x436>
            draw_dsc.bg_opa = LV_OPA_TRANSP;
   1c21a:	2500      	movs	r5, #0
            lv_draw_rect_dsc_init(&draw_dsc);
   1c21c:	a818      	add	r0, sp, #96	; 0x60
   1c21e:	f7ef fe7d 	bl	bf1c <lv_draw_rect_dsc_init>
            lv_obj_init_draw_rect_dsc(img, LV_OBJ_PART_MAIN, &draw_dsc);
   1c222:	4629      	mov	r1, r5
   1c224:	4620      	mov	r0, r4
   1c226:	aa18      	add	r2, sp, #96	; 0x60
            draw_dsc.bg_opa = LV_OPA_TRANSP;
   1c228:	f88d 5072 	strb.w	r5, [sp, #114]	; 0x72
            draw_dsc.pattern_opa = LV_OPA_TRANSP;
   1c22c:	f88d 50a8 	strb.w	r5, [sp, #168]	; 0xa8
            draw_dsc.shadow_opa = LV_OPA_TRANSP;
   1c230:	f88d 5098 	strb.w	r5, [sp, #152]	; 0x98
            lv_obj_init_draw_rect_dsc(img, LV_OBJ_PART_MAIN, &draw_dsc);
   1c234:	f7f9 ffaa 	bl	1618c <lv_obj_init_draw_rect_dsc>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
   1c238:	4629      	mov	r1, r5
   1c23a:	2207      	movs	r2, #7
   1c23c:	4620      	mov	r0, r4
   1c23e:	f7ed fae3 	bl	9808 <_lv_obj_get_style_int>
            zoom_final = (zoom_final * ext->zoom) >> 8;
   1c242:	8a73      	ldrh	r3, [r6, #18]
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
   1c244:	4629      	mov	r1, r5
   1c246:	fb00 f703 	mul.w	r7, r0, r3
   1c24a:	2206      	movs	r2, #6
   1c24c:	4620      	mov	r0, r4
   1c24e:	f7ed fadb 	bl	9808 <_lv_obj_get_style_int>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1c252:	8ae2      	ldrh	r2, [r4, #22]
   1c254:	8a61      	ldrh	r1, [r4, #18]
            angle_final += ext->angle;
   1c256:	89b3      	ldrh	r3, [r6, #12]
   1c258:	3201      	adds	r2, #1
   1c25a:	1a52      	subs	r2, r2, r1
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1c25c:	8aa1      	ldrh	r1, [r4, #20]
   1c25e:	4403      	add	r3, r0
   1c260:	8a20      	ldrh	r0, [r4, #16]
   1c262:	3101      	adds	r1, #1
   1c264:	1a09      	subs	r1, r1, r0
                                             angle_final, zoom_final, &ext->pivot);
   1c266:	360e      	adds	r6, #14
            _lv_img_buf_get_transformed_area(&bg_coords, lv_area_get_width(&img->coords), lv_area_get_height(&img->coords),
   1c268:	f3c7 270f 	ubfx	r7, r7, #8, #16
   1c26c:	a80f      	add	r0, sp, #60	; 0x3c
   1c26e:	9601      	str	r6, [sp, #4]
   1c270:	9700      	str	r7, [sp, #0]
   1c272:	b21b      	sxth	r3, r3
   1c274:	b212      	sxth	r2, r2
   1c276:	b209      	sxth	r1, r1
   1c278:	f7fe fb60 	bl	1a93c <_lv_img_buf_get_transformed_area>
            bg_coords.x1 += img->coords.x1;
   1c27c:	f9b4 2010 	ldrsh.w	r2, [r4, #16]
   1c280:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
            bg_coords.y1 += img->coords.y1;
   1c284:	f8bd 103e 	ldrh.w	r1, [sp, #62]	; 0x3e
            bg_coords.x1 += img->coords.x1;
   1c288:	4413      	add	r3, r2
   1c28a:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
            bg_coords.y1 += img->coords.y1;
   1c28e:	f9b4 3012 	ldrsh.w	r3, [r4, #18]
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1c292:	4620      	mov	r0, r4
   1c294:	4419      	add	r1, r3
   1c296:	f8ad 103e 	strh.w	r1, [sp, #62]	; 0x3e
            bg_coords.x2 += img->coords.x1;
   1c29a:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
   1c29e:	440a      	add	r2, r1
   1c2a0:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
            bg_coords.y2 += img->coords.y1;
   1c2a4:	f8bd 2042 	ldrh.w	r2, [sp, #66]	; 0x42
   1c2a8:	4629      	mov	r1, r5
   1c2aa:	4413      	add	r3, r2
   1c2ac:	2212      	movs	r2, #18
   1c2ae:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
   1c2b2:	f7ed faa9 	bl	9808 <_lv_obj_get_style_int>
            bg_coords.x1 -= lv_obj_get_style_pad_left(img, LV_IMG_PART_MAIN);
   1c2b6:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1c2ba:	4629      	mov	r1, r5
   1c2bc:	1a1b      	subs	r3, r3, r0
   1c2be:	2213      	movs	r2, #19
   1c2c0:	4620      	mov	r0, r4
   1c2c2:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
   1c2c6:	f7ed fa9f 	bl	9808 <_lv_obj_get_style_int>
            bg_coords.x2 += lv_obj_get_style_pad_right(img, LV_IMG_PART_MAIN);
   1c2ca:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1c2ce:	4629      	mov	r1, r5
   1c2d0:	4418      	add	r0, r3
   1c2d2:	f8ad 0040 	strh.w	r0, [sp, #64]	; 0x40
   1c2d6:	2210      	movs	r2, #16
   1c2d8:	4620      	mov	r0, r4
   1c2da:	f7ed fa95 	bl	9808 <_lv_obj_get_style_int>
            bg_coords.y1 -= lv_obj_get_style_pad_top(img, LV_IMG_PART_MAIN);
   1c2de:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   1c2e2:	4629      	mov	r1, r5
   1c2e4:	1a1b      	subs	r3, r3, r0
   1c2e6:	2211      	movs	r2, #17
   1c2e8:	4620      	mov	r0, r4
   1c2ea:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
   1c2ee:	f7ed fa8b 	bl	9808 <_lv_obj_get_style_int>
            bg_coords.y2 += lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
   1c2f2:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
            lv_draw_rect(&img->coords, clip_area, &draw_dsc);
   1c2f6:	4641      	mov	r1, r8
            bg_coords.y2 += lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
   1c2f8:	4418      	add	r0, r3
   1c2fa:	f8ad 0042 	strh.w	r0, [sp, #66]	; 0x42
            lv_draw_rect(&img->coords, clip_area, &draw_dsc);
   1c2fe:	aa18      	add	r2, sp, #96	; 0x60
   1c300:	f104 0010 	add.w	r0, r4, #16
   1c304:	f7fc fe77 	bl	18ff6 <lv_draw_rect>
   1c308:	e599      	b.n	1be3e <lv_img_design+0x84>
        if(lv_obj_get_style_clip_corner(img, LV_IMG_PART_MAIN)) return LV_DESIGN_RES_MASKED;
   1c30a:	2503      	movs	r5, #3
   1c30c:	e597      	b.n	1be3e <lv_img_design+0x84>

0001c30e <lv_img_get_auto_size>:
{
   1c30e:	b508      	push	{r3, lr}
    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
   1c310:	f7f9 ff14 	bl	1613c <lv_obj_get_ext_attr>
    return ext->auto_size == 0 ? false : true;
   1c314:	7d00      	ldrb	r0, [r0, #20]
}
   1c316:	f3c0 0080 	ubfx	r0, r0, #2, #1
   1c31a:	bd08      	pop	{r3, pc}

0001c31c <lv_img_set_src>:
{
   1c31c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1c320:	4606      	mov	r6, r0
   1c322:	b087      	sub	sp, #28
    lv_img_src_t src_type = lv_img_src_get_type(src_img);
   1c324:	4608      	mov	r0, r1
{
   1c326:	460f      	mov	r7, r1
    lv_img_src_t src_type = lv_img_src_get_type(src_img);
   1c328:	f7fc f90b 	bl	18542 <lv_img_src_get_type>
   1c32c:	4605      	mov	r5, r0
    lv_img_ext_t * ext    = lv_obj_get_ext_attr(img);
   1c32e:	4630      	mov	r0, r6
   1c330:	f7f9 ff04 	bl	1613c <lv_obj_get_ext_attr>
    if(src_type == LV_IMG_SRC_UNKNOWN) {
   1c334:	2d03      	cmp	r5, #3
    lv_img_ext_t * ext    = lv_obj_get_ext_attr(img);
   1c336:	4604      	mov	r4, r0
    if(src_type == LV_IMG_SRC_UNKNOWN) {
   1c338:	d111      	bne.n	1c35e <lv_img_set_src+0x42>
        if(ext->src_type == LV_IMG_SRC_SYMBOL || ext->src_type == LV_IMG_SRC_FILE) {
   1c33a:	7d03      	ldrb	r3, [r0, #20]
   1c33c:	f003 0303 	and.w	r3, r3, #3
   1c340:	3b01      	subs	r3, #1
   1c342:	2b01      	cmp	r3, #1
   1c344:	d802      	bhi.n	1c34c <lv_img_set_src+0x30>
            lv_mem_free(ext->src);
   1c346:	6800      	ldr	r0, [r0, #0]
   1c348:	f7f0 fbba 	bl	cac0 <lv_mem_free>
        ext->src      = NULL;
   1c34c:	2300      	movs	r3, #0
   1c34e:	6023      	str	r3, [r4, #0]
        ext->src_type = LV_IMG_SRC_UNKNOWN;
   1c350:	7d23      	ldrb	r3, [r4, #20]
   1c352:	f043 0303 	orr.w	r3, r3, #3
   1c356:	7523      	strb	r3, [r4, #20]
}
   1c358:	b007      	add	sp, #28
   1c35a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    lv_img_decoder_get_info(src_img, &header);
   1c35e:	4638      	mov	r0, r7
   1c360:	a904      	add	r1, sp, #16
   1c362:	f7f0 f851 	bl	c408 <lv_img_decoder_get_info>
    if(src_type == LV_IMG_SRC_VARIABLE) {
   1c366:	2d00      	cmp	r5, #0
   1c368:	d13d      	bne.n	1c3e6 <lv_img_set_src+0xca>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
   1c36a:	7d23      	ldrb	r3, [r4, #20]
   1c36c:	f003 0303 	and.w	r3, r3, #3
   1c370:	3b01      	subs	r3, #1
   1c372:	2b01      	cmp	r3, #1
   1c374:	d802      	bhi.n	1c37c <lv_img_set_src+0x60>
            lv_mem_free(ext->src);
   1c376:	6820      	ldr	r0, [r4, #0]
   1c378:	f7f0 fba2 	bl	cac0 <lv_mem_free>
        ext->src = src_img;
   1c37c:	6027      	str	r7, [r4, #0]
    ext->w        = header.w;
   1c37e:	9a04      	ldr	r2, [sp, #16]
    ext->cf       = header.cf;
   1c380:	f89d 0010 	ldrb.w	r0, [sp, #16]
    ext->w        = header.w;
   1c384:	f3c2 238a 	ubfx	r3, r2, #10, #11
   1c388:	8123      	strh	r3, [r4, #8]
    ext->h        = header.h;
   1c38a:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    ext->cf       = header.cf;
   1c38e:	f3c0 0004 	ubfx	r0, r0, #0, #5
    ext->h        = header.h;
   1c392:	f3c3 114a 	ubfx	r1, r3, #5, #11
   1c396:	8161      	strh	r1, [r4, #10]
    ext->src_type = src_type;
   1c398:	7d21      	ldrb	r1, [r4, #20]
   1c39a:	f005 0503 	and.w	r5, r5, #3
   1c39e:	ea45 05c0 	orr.w	r5, r5, r0, lsl #3
   1c3a2:	f001 0104 	and.w	r1, r1, #4
   1c3a6:	430d      	orrs	r5, r1
    ext->pivot.x = header.w / 2;
   1c3a8:	f3c2 22c9 	ubfx	r2, r2, #11, #10
    ext->pivot.y = header.h / 2;
   1c3ac:	f3c3 1389 	ubfx	r3, r3, #6, #10
    if(lv_img_get_auto_size(img) != false) {
   1c3b0:	4630      	mov	r0, r6
    ext->src_type = src_type;
   1c3b2:	7525      	strb	r5, [r4, #20]
    ext->pivot.x = header.w / 2;
   1c3b4:	81e2      	strh	r2, [r4, #14]
    ext->pivot.y = header.h / 2;
   1c3b6:	8223      	strh	r3, [r4, #16]
    if(lv_img_get_auto_size(img) != false) {
   1c3b8:	f7ff ffa9 	bl	1c30e <lv_img_get_auto_size>
   1c3bc:	b130      	cbz	r0, 1c3cc <lv_img_set_src+0xb0>
        lv_obj_set_size(img, ext->w, ext->h);
   1c3be:	4630      	mov	r0, r6
   1c3c0:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
   1c3c4:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
   1c3c8:	f7f9 fae8 	bl	1599c <lv_obj_set_size>
    if(ext->angle || ext->zoom != LV_IMG_ZOOM_NONE) lv_obj_refresh_ext_draw_pad(img);
   1c3cc:	89a3      	ldrh	r3, [r4, #12]
   1c3ce:	b91b      	cbnz	r3, 1c3d8 <lv_img_set_src+0xbc>
   1c3d0:	8a63      	ldrh	r3, [r4, #18]
   1c3d2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1c3d6:	d002      	beq.n	1c3de <lv_img_set_src+0xc2>
   1c3d8:	4630      	mov	r0, r6
   1c3da:	f7f9 f9af 	bl	1573c <lv_obj_refresh_ext_draw_pad>
    lv_obj_invalidate(img);
   1c3de:	4630      	mov	r0, r6
   1c3e0:	f7f9 fa1e 	bl	15820 <lv_obj_invalidate>
   1c3e4:	e7b8      	b.n	1c358 <lv_img_set_src+0x3c>
    else if(src_type == LV_IMG_SRC_FILE || src_type == LV_IMG_SRC_SYMBOL) {
   1c3e6:	1e6b      	subs	r3, r5, #1
   1c3e8:	b2db      	uxtb	r3, r3
   1c3ea:	2b01      	cmp	r3, #1
   1c3ec:	d81f      	bhi.n	1c42e <lv_img_set_src+0x112>
        if(ext->src != src_img) {
   1c3ee:	f8d4 8000 	ldr.w	r8, [r4]
   1c3f2:	45b8      	cmp	r8, r7
   1c3f4:	d01b      	beq.n	1c42e <lv_img_set_src+0x112>
            if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
   1c3f6:	7d23      	ldrb	r3, [r4, #20]
            char * new_str = lv_mem_alloc(strlen(src_img) + 1);
   1c3f8:	4638      	mov	r0, r7
            if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
   1c3fa:	f003 0303 	and.w	r3, r3, #3
   1c3fe:	3b01      	subs	r3, #1
            const void * old_src = NULL;
   1c400:	2b01      	cmp	r3, #1
   1c402:	bf88      	it	hi
   1c404:	f04f 0800 	movhi.w	r8, #0
            char * new_str = lv_mem_alloc(strlen(src_img) + 1);
   1c408:	f7e4 f82c 	bl	464 <strlen>
   1c40c:	3001      	adds	r0, #1
   1c40e:	f7f0 fb43 	bl	ca98 <lv_mem_alloc>
            if(new_str == NULL) return;
   1c412:	4681      	mov	r9, r0
   1c414:	2800      	cmp	r0, #0
   1c416:	d09f      	beq.n	1c358 <lv_img_set_src+0x3c>
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   1c418:	4639      	mov	r1, r7
   1c41a:	f001 fab7 	bl	1d98c <strcpy>
            ext->src = new_str;
   1c41e:	f8c4 9000 	str.w	r9, [r4]
            if(old_src) lv_mem_free(old_src);
   1c422:	f1b8 0f00 	cmp.w	r8, #0
   1c426:	d002      	beq.n	1c42e <lv_img_set_src+0x112>
   1c428:	4640      	mov	r0, r8
   1c42a:	f7f0 fb49 	bl	cac0 <lv_mem_free>
    if(src_type == LV_IMG_SRC_SYMBOL) {
   1c42e:	2d02      	cmp	r5, #2
   1c430:	d1a5      	bne.n	1c37e <lv_img_set_src+0x62>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   1c432:	f248 028e 	movw	r2, #32910	; 0x808e
   1c436:	2100      	movs	r1, #0
   1c438:	4630      	mov	r0, r6
   1c43a:	f7ed fc3b 	bl	9cb4 <_lv_obj_get_style_ptr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   1c43e:	f248 0280 	movw	r2, #32896	; 0x8080
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
   1c442:	4680      	mov	r8, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   1c444:	2100      	movs	r1, #0
   1c446:	4630      	mov	r0, r6
   1c448:	f7ed f9de 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   1c44c:	f248 0281 	movw	r2, #32897	; 0x8081
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
   1c450:	4681      	mov	r9, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
   1c452:	2100      	movs	r1, #0
   1c454:	4630      	mov	r0, r6
   1c456:	f7ed f9d7 	bl	9808 <_lv_obj_get_style_int>
        _lv_txt_get_size(&size, src_img, font, letter_space, line_space,
   1c45a:	f647 4318 	movw	r3, #31768	; 0x7c18
   1c45e:	2200      	movs	r2, #0
   1c460:	9000      	str	r0, [sp, #0]
   1c462:	e9cd 3201 	strd	r3, r2, [sp, #4]
   1c466:	4639      	mov	r1, r7
   1c468:	464b      	mov	r3, r9
   1c46a:	4642      	mov	r2, r8
   1c46c:	a805      	add	r0, sp, #20
   1c46e:	f7ff f857 	bl	1b520 <_lv_txt_get_size>
        header.w = size.x;
   1c472:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   1c476:	f3c3 020a 	ubfx	r2, r3, #0, #11
   1c47a:	f9bd 3016 	ldrsh.w	r3, [sp, #22]
   1c47e:	055b      	lsls	r3, r3, #21
   1c480:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
   1c484:	9a04      	ldr	r2, [sp, #16]
   1c486:	f3c2 0209 	ubfx	r2, r2, #0, #10
   1c48a:	4313      	orrs	r3, r2
   1c48c:	9304      	str	r3, [sp, #16]
   1c48e:	e776      	b.n	1c37e <lv_img_set_src+0x62>

0001c490 <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
   1c490:	b510      	push	{r4, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c492:	f7f9 fe53 	bl	1613c <lv_obj_get_ext_attr>
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
   1c496:	7cc3      	ldrb	r3, [r0, #19]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c498:	4604      	mov	r4, r0
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
   1c49a:	07db      	lsls	r3, r3, #31
   1c49c:	d503      	bpl.n	1c4a6 <lv_label_dot_tmp_free+0x16>
   1c49e:	6840      	ldr	r0, [r0, #4]
   1c4a0:	b108      	cbz	r0, 1c4a6 <lv_label_dot_tmp_free+0x16>
        lv_mem_free(ext->dot.tmp_ptr);
   1c4a2:	f7f0 fb0d 	bl	cac0 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
   1c4a6:	7ce3      	ldrb	r3, [r4, #19]
   1c4a8:	f36f 0300 	bfc	r3, #0, #1
   1c4ac:	74e3      	strb	r3, [r4, #19]
    ext->dot.tmp_ptr   = NULL;
   1c4ae:	2300      	movs	r3, #0
   1c4b0:	6063      	str	r3, [r4, #4]
}
   1c4b2:	bd10      	pop	{r4, pc}

0001c4b4 <lv_label_set_offset_y>:
{
   1c4b4:	b538      	push	{r3, r4, r5, lr}
   1c4b6:	4604      	mov	r4, r0
   1c4b8:	460d      	mov	r5, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c4ba:	f7f9 fe3f 	bl	1613c <lv_obj_get_ext_attr>
    ext->offset.y        = y;
   1c4be:	8205      	strh	r5, [r0, #16]
    lv_obj_invalidate(label);
   1c4c0:	4620      	mov	r0, r4
}
   1c4c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label);
   1c4c6:	f7f9 b9ab 	b.w	15820 <lv_obj_invalidate>

0001c4ca <lv_label_set_offset_x>:
{
   1c4ca:	b538      	push	{r3, r4, r5, lr}
   1c4cc:	4604      	mov	r4, r0
   1c4ce:	460d      	mov	r5, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c4d0:	f7f9 fe34 	bl	1613c <lv_obj_get_ext_attr>
    ext->offset.x        = x;
   1c4d4:	81c5      	strh	r5, [r0, #14]
    lv_obj_invalidate(label);
   1c4d6:	4620      	mov	r0, r4
}
   1c4d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label);
   1c4dc:	f7f9 b9a0 	b.w	15820 <lv_obj_invalidate>

0001c4e0 <_lv_memcpy>:
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1c4e0:	f001 ba3f 	b.w	1d962 <memcpy>

0001c4e4 <lv_label_set_dot_tmp>:
{
   1c4e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c4e6:	4615      	mov	r5, r2
   1c4e8:	4607      	mov	r7, r0
   1c4ea:	460e      	mov	r6, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c4ec:	f7f9 fe26 	bl	1613c <lv_obj_get_ext_attr>
   1c4f0:	4604      	mov	r4, r0
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
   1c4f2:	4638      	mov	r0, r7
   1c4f4:	f7ff ffcc 	bl	1c490 <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
   1c4f8:	2d04      	cmp	r5, #4
   1c4fa:	d911      	bls.n	1c520 <lv_label_set_dot_tmp+0x3c>
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
   1c4fc:	1c68      	adds	r0, r5, #1
   1c4fe:	f7f0 facb 	bl	ca98 <lv_mem_alloc>
   1c502:	6060      	str	r0, [r4, #4]
        if(ext->dot.tmp_ptr == NULL) {
   1c504:	b158      	cbz	r0, 1c51e <lv_label_set_dot_tmp+0x3a>
        _lv_memcpy(ext->dot.tmp_ptr, data, len);
   1c506:	462a      	mov	r2, r5
   1c508:	4631      	mov	r1, r6
   1c50a:	f7ff ffe9 	bl	1c4e0 <_lv_memcpy>
        ext->dot.tmp_ptr[len] = '\0';
   1c50e:	2200      	movs	r2, #0
   1c510:	6863      	ldr	r3, [r4, #4]
   1c512:	555a      	strb	r2, [r3, r5]
        ext->dot_tmp_alloc    = true;
   1c514:	7ce3      	ldrb	r3, [r4, #19]
   1c516:	f043 0301 	orr.w	r3, r3, #1
   1c51a:	74e3      	strb	r3, [r4, #19]
    return true;
   1c51c:	2001      	movs	r0, #1
}
   1c51e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ext->dot_tmp_alloc = false;
   1c520:	7ce3      	ldrb	r3, [r4, #19]
        _lv_memcpy(ext->dot.tmp, data, len);
   1c522:	462a      	mov	r2, r5
        ext->dot_tmp_alloc = false;
   1c524:	f36f 0300 	bfc	r3, #0, #1
        _lv_memcpy(ext->dot.tmp, data, len);
   1c528:	4631      	mov	r1, r6
        ext->dot_tmp_alloc = false;
   1c52a:	74e3      	strb	r3, [r4, #19]
        _lv_memcpy(ext->dot.tmp, data, len);
   1c52c:	1d20      	adds	r0, r4, #4
   1c52e:	f7ff ffd7 	bl	1c4e0 <_lv_memcpy>
   1c532:	e7f3      	b.n	1c51c <lv_label_set_dot_tmp+0x38>

0001c534 <get_txt_coords>:

static void get_txt_coords(const lv_obj_t * label, lv_area_t * area)
{
   1c534:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c538:	4605      	mov	r5, r0
   1c53a:	460c      	mov	r4, r1
    lv_obj_get_coords(label, area);
   1c53c:	f7f9 fa9d 	bl	15a7a <lv_obj_get_coords>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1c540:	2212      	movs	r2, #18
   1c542:	2100      	movs	r1, #0
   1c544:	4628      	mov	r0, r5
   1c546:	f7ed f95f 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1c54a:	2213      	movs	r2, #19
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
   1c54c:	4607      	mov	r7, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1c54e:	2100      	movs	r1, #0
   1c550:	4628      	mov	r0, r5
   1c552:	f7ed f959 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1c556:	2210      	movs	r2, #16
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
   1c558:	4680      	mov	r8, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
   1c55a:	2100      	movs	r1, #0
   1c55c:	4628      	mov	r0, r5
   1c55e:	f7ed f953 	bl	9808 <_lv_obj_get_style_int>
   1c562:	4606      	mov	r6, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
   1c564:	2211      	movs	r2, #17
   1c566:	2100      	movs	r1, #0
   1c568:	4628      	mov	r0, r5
   1c56a:	f7ed f94d 	bl	9808 <_lv_obj_get_style_int>

    lv_coord_t left   = lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
    lv_coord_t right  = lv_obj_get_style_pad_right(label, LV_LABEL_PART_MAIN);
    lv_coord_t top    = lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN);
    lv_coord_t bottom = lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
    area->x1 += left;
   1c56e:	8823      	ldrh	r3, [r4, #0]
    area->x2 -= right;
   1c570:	88a2      	ldrh	r2, [r4, #4]
    area->x1 += left;
   1c572:	441f      	add	r7, r3
    area->y1 += top;
   1c574:	8863      	ldrh	r3, [r4, #2]
    area->x2 -= right;
   1c576:	eba2 0208 	sub.w	r2, r2, r8
    area->y1 += top;
   1c57a:	441e      	add	r6, r3
    area->y2 -= bottom;
   1c57c:	88e3      	ldrh	r3, [r4, #6]
    area->x1 += left;
   1c57e:	8027      	strh	r7, [r4, #0]
    area->y2 -= bottom;
   1c580:	1a1b      	subs	r3, r3, r0
    area->x2 -= right;
   1c582:	80a2      	strh	r2, [r4, #4]
    area->y1 += top;
   1c584:	8066      	strh	r6, [r4, #2]
    area->y2 -= bottom;
   1c586:	80e3      	strh	r3, [r4, #6]
}
   1c588:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001c58c <lv_label_set_align>:
{
   1c58c:	b538      	push	{r3, r4, r5, lr}
   1c58e:	460c      	mov	r4, r1
   1c590:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c592:	f7f9 fdd3 	bl	1613c <lv_obj_get_ext_attr>
    if(ext->align == align) return;
   1c596:	7c83      	ldrb	r3, [r0, #18]
   1c598:	f3c3 1201 	ubfx	r2, r3, #4, #2
   1c59c:	42a2      	cmp	r2, r4
   1c59e:	d007      	beq.n	1c5b0 <lv_label_set_align+0x24>
    ext->align = align;
   1c5a0:	f364 1305 	bfi	r3, r4, #4, #2
   1c5a4:	7483      	strb	r3, [r0, #18]
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
   1c5a6:	4628      	mov	r0, r5
}
   1c5a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
   1c5ac:	f7f9 b938 	b.w	15820 <lv_obj_invalidate>
}
   1c5b0:	bd38      	pop	{r3, r4, r5, pc}

0001c5b2 <lv_label_get_text>:
{
   1c5b2:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c5b4:	f7f9 fdc2 	bl	1613c <lv_obj_get_ext_attr>
}
   1c5b8:	6800      	ldr	r0, [r0, #0]
   1c5ba:	bd08      	pop	{r3, pc}

0001c5bc <lv_label_get_long_mode>:
{
   1c5bc:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c5be:	f7f9 fdbd 	bl	1613c <lv_obj_get_ext_attr>
    return ext->long_mode;
   1c5c2:	7c80      	ldrb	r0, [r0, #18]
}
   1c5c4:	f000 0007 	and.w	r0, r0, #7
   1c5c8:	bd08      	pop	{r3, pc}

0001c5ca <lv_label_get_align>:
{
   1c5ca:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c5cc:	f7f9 fdb6 	bl	1613c <lv_obj_get_ext_attr>
    lv_label_align_t align = ext->align;
   1c5d0:	7c80      	ldrb	r0, [r0, #18]
   1c5d2:	f3c0 1001 	ubfx	r0, r0, #4, #2
    if(align == LV_LABEL_ALIGN_AUTO) {
   1c5d6:	2803      	cmp	r0, #3
}
   1c5d8:	bf08      	it	eq
   1c5da:	2000      	moveq	r0, #0
   1c5dc:	bd08      	pop	{r3, pc}

0001c5de <lv_label_design>:
{
   1c5de:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if(mode == LV_DESIGN_COVER_CHK)
   1c5e2:	2a02      	cmp	r2, #2
{
   1c5e4:	4607      	mov	r7, r0
   1c5e6:	4689      	mov	r9, r1
   1c5e8:	4616      	mov	r6, r2
   1c5ea:	b0af      	sub	sp, #188	; 0xbc
    if(mode == LV_DESIGN_COVER_CHK)
   1c5ec:	f000 80f2 	beq.w	1c7d4 <lv_label_design+0x1f6>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
   1c5f0:	2a00      	cmp	r2, #0
   1c5f2:	f040 80f8 	bne.w	1c7e6 <lv_label_design+0x208>
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c5f6:	f7f9 fda1 	bl	1613c <lv_obj_get_ext_attr>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c5fa:	2204      	movs	r2, #4
   1c5fc:	4631      	mov	r1, r6
   1c5fe:	4604      	mov	r4, r0
   1c600:	4638      	mov	r0, r7
   1c602:	f7ed f901 	bl	9808 <_lv_obj_get_style_int>
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1c606:	2205      	movs	r2, #5
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
   1c608:	4680      	mov	r8, r0
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
   1c60a:	4631      	mov	r1, r6
   1c60c:	4638      	mov	r0, r7
   1c60e:	f7ed f8fb 	bl	9808 <_lv_obj_get_style_int>
   1c612:	4605      	mov	r5, r0
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
   1c614:	2208      	movs	r2, #8
   1c616:	f107 0110 	add.w	r1, r7, #16
   1c61a:	a805      	add	r0, sp, #20
   1c61c:	f7ff ff60 	bl	1c4e0 <_lv_memcpy>
        bg_coords.x1 -= w;
   1c620:	f8bd 3014 	ldrh.w	r3, [sp, #20]
        bg_coords.x2 += w;
   1c624:	f8bd 0018 	ldrh.w	r0, [sp, #24]
        bg_coords.x1 -= w;
   1c628:	eba3 0308 	sub.w	r3, r3, r8
   1c62c:	f8ad 3014 	strh.w	r3, [sp, #20]
        bg_coords.x2 += w;
   1c630:	4480      	add	r8, r0
        bg_coords.y1 -= h;
   1c632:	f8bd 3016 	ldrh.w	r3, [sp, #22]
        bg_coords.y2 += h;
   1c636:	f8bd 001a 	ldrh.w	r0, [sp, #26]
        bg_coords.y1 -= h;
   1c63a:	1b5b      	subs	r3, r3, r5
        bg_coords.y2 += h;
   1c63c:	4405      	add	r5, r0
        lv_draw_rect_dsc_init(&draw_rect_dsc);
   1c63e:	a814      	add	r0, sp, #80	; 0x50
        bg_coords.y1 -= h;
   1c640:	f8ad 3016 	strh.w	r3, [sp, #22]
        bg_coords.x2 += w;
   1c644:	f8ad 8018 	strh.w	r8, [sp, #24]
        bg_coords.y2 += h;
   1c648:	f8ad 501a 	strh.w	r5, [sp, #26]
        lv_draw_rect_dsc_init(&draw_rect_dsc);
   1c64c:	f7ef fc66 	bl	bf1c <lv_draw_rect_dsc_init>
        lv_obj_init_draw_rect_dsc(label, LV_LABEL_PART_MAIN, &draw_rect_dsc);
   1c650:	4631      	mov	r1, r6
   1c652:	4638      	mov	r0, r7
   1c654:	aa14      	add	r2, sp, #80	; 0x50
   1c656:	f7f9 fd99 	bl	1618c <lv_obj_init_draw_rect_dsc>
        lv_draw_rect(&bg_coords, clip_area, &draw_rect_dsc);
   1c65a:	aa14      	add	r2, sp, #80	; 0x50
   1c65c:	4649      	mov	r1, r9
   1c65e:	a805      	add	r0, sp, #20
   1c660:	f7fc fcc9 	bl	18ff6 <lv_draw_rect>
        get_txt_coords(label, &txt_coords);
   1c664:	4638      	mov	r0, r7
   1c666:	a907      	add	r1, sp, #28
   1c668:	f7ff ff64 	bl	1c534 <get_txt_coords>
        bool is_common = _lv_area_intersect(&txt_clip, clip_area, &txt_coords);
   1c66c:	4649      	mov	r1, r9
   1c66e:	aa07      	add	r2, sp, #28
   1c670:	a809      	add	r0, sp, #36	; 0x24
   1c672:	f7fe fb13 	bl	1ac9c <_lv_area_intersect>
        if(!is_common) return LV_DESIGN_RES_OK;
   1c676:	2800      	cmp	r0, #0
   1c678:	f000 80ac 	beq.w	1c7d4 <lv_label_design+0x1f6>
        lv_label_align_t align = lv_label_get_align(label);
   1c67c:	4638      	mov	r0, r7
   1c67e:	f7ff ffa4 	bl	1c5ca <lv_label_get_align>
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
   1c682:	7ca3      	ldrb	r3, [r4, #18]
   1c684:	f3c3 1580 	ubfx	r5, r3, #6, #1
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
   1c688:	061a      	lsls	r2, r3, #24
   1c68a:	bf48      	it	mi
   1c68c:	f045 0502 	orrmi.w	r5, r5, #2
        if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
   1c690:	075b      	lsls	r3, r3, #29
   1c692:	bf08      	it	eq
   1c694:	f045 0510 	orreq.w	r5, r5, #16
        if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
   1c698:	2801      	cmp	r0, #1
   1c69a:	f040 809f 	bne.w	1c7dc <lv_label_design+0x1fe>
   1c69e:	f045 0504 	orr.w	r5, r5, #4
        lv_draw_label_dsc_init(&label_draw_dsc);
   1c6a2:	a80b      	add	r0, sp, #44	; 0x2c
   1c6a4:	f7ee fabe 	bl	ac24 <lv_draw_label_dsc_init>
        label_draw_dsc.sel_start = lv_label_get_text_sel_start(label);
   1c6a8:	f64f 73ff 	movw	r3, #65535	; 0xffff
        label_draw_dsc.sel_end = lv_label_get_text_sel_end(label);
   1c6ac:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
        label_draw_dsc.ofs_x = ext->offset.x;
   1c6b0:	89e3      	ldrh	r3, [r4, #14]
        lv_obj_init_draw_label_dsc(label, LV_LABEL_PART_MAIN, &label_draw_dsc);
   1c6b2:	aa0b      	add	r2, sp, #44	; 0x2c
        label_draw_dsc.ofs_x = ext->offset.x;
   1c6b4:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
        label_draw_dsc.ofs_y = ext->offset.y;
   1c6b8:	8a23      	ldrh	r3, [r4, #16]
        lv_obj_init_draw_label_dsc(label, LV_LABEL_PART_MAIN, &label_draw_dsc);
   1c6ba:	2100      	movs	r1, #0
   1c6bc:	4638      	mov	r0, r7
        label_draw_dsc.ofs_y = ext->offset.y;
   1c6be:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
        label_draw_dsc.flag = flag;
   1c6c2:	f88d 504d 	strb.w	r5, [sp, #77]	; 0x4d
        lv_obj_init_draw_label_dsc(label, LV_LABEL_PART_MAIN, &label_draw_dsc);
   1c6c6:	f7f9 ff0e 	bl	164e6 <lv_obj_init_draw_label_dsc>
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
   1c6ca:	7ca3      	ldrb	r3, [r4, #18]
   1c6cc:	f003 0207 	and.w	r2, r3, #7
   1c6d0:	3a03      	subs	r2, #3
   1c6d2:	2a01      	cmp	r2, #1
   1c6d4:	d824      	bhi.n	1c720 <lv_label_design+0x142>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
   1c6d6:	f003 0330 	and.w	r3, r3, #48	; 0x30
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
   1c6da:	2b10      	cmp	r3, #16
   1c6dc:	d001      	beq.n	1c6e2 <lv_label_design+0x104>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
   1c6de:	2b20      	cmp	r3, #32
   1c6e0:	d11e      	bne.n	1c720 <lv_label_design+0x142>
            _lv_txt_get_size(&size, ext->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,
   1c6e2:	f647 4318 	movw	r3, #31768	; 0x7c18
   1c6e6:	9301      	str	r3, [sp, #4]
   1c6e8:	f9bd 303a 	ldrsh.w	r3, [sp, #58]	; 0x3a
   1c6ec:	9502      	str	r5, [sp, #8]
   1c6ee:	9300      	str	r3, [sp, #0]
   1c6f0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1c6f2:	f9bd 303c 	ldrsh.w	r3, [sp, #60]	; 0x3c
   1c6f6:	6821      	ldr	r1, [r4, #0]
   1c6f8:	a804      	add	r0, sp, #16
   1c6fa:	f7fe ff11 	bl	1b520 <_lv_txt_get_size>
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
   1c6fe:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   1c702:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   1c706:	3301      	adds	r3, #1
   1c708:	1a9b      	subs	r3, r3, r2
            if(size.x > lv_area_get_width(&txt_coords)) {
   1c70a:	f9bd 2010 	ldrsh.w	r2, [sp, #16]
   1c70e:	b21b      	sxth	r3, r3
   1c710:	429a      	cmp	r2, r3
                label_draw_dsc.flag &= ~LV_TXT_FLAG_CENTER;
   1c712:	bfc2      	ittt	gt
   1c714:	f89d 304d 	ldrbgt.w	r3, [sp, #77]	; 0x4d
   1c718:	f023 030c 	bicgt.w	r3, r3, #12
   1c71c:	f88d 304d 	strbgt.w	r3, [sp, #77]	; 0x4d
        lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   1c720:	2700      	movs	r7, #0
   1c722:	9700      	str	r7, [sp, #0]
   1c724:	6823      	ldr	r3, [r4, #0]
   1c726:	aa0b      	add	r2, sp, #44	; 0x2c
   1c728:	a909      	add	r1, sp, #36	; 0x24
   1c72a:	a807      	add	r0, sp, #28
   1c72c:	f7ee fa92 	bl	ac54 <lv_draw_label>
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
   1c730:	7ca3      	ldrb	r3, [r4, #18]
   1c732:	f003 0307 	and.w	r3, r3, #7
   1c736:	2b04      	cmp	r3, #4
   1c738:	d14c      	bne.n	1c7d4 <lv_label_design+0x1f6>
            _lv_txt_get_size(&size, ext->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,
   1c73a:	f647 4318 	movw	r3, #31768	; 0x7c18
   1c73e:	9301      	str	r3, [sp, #4]
   1c740:	f9bd 303a 	ldrsh.w	r3, [sp, #58]	; 0x3a
   1c744:	9502      	str	r5, [sp, #8]
   1c746:	9300      	str	r3, [sp, #0]
   1c748:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1c74a:	f9bd 303c 	ldrsh.w	r3, [sp, #60]	; 0x3c
   1c74e:	6821      	ldr	r1, [r4, #0]
   1c750:	a804      	add	r0, sp, #16
   1c752:	f7fe fee5 	bl	1b520 <_lv_txt_get_size>
   1c756:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   1c75a:	f8bd 101c 	ldrh.w	r1, [sp, #28]
   1c75e:	3201      	adds	r2, #1
            if(size.x > lv_area_get_width(&txt_coords)) {
   1c760:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
   1c764:	1a52      	subs	r2, r2, r1
   1c766:	b212      	sxth	r2, r2
   1c768:	4293      	cmp	r3, r2
   1c76a:	dd16      	ble.n	1c79a <lv_label_design+0x1bc>
                                       lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   1c76c:	2220      	movs	r2, #32
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   1c76e:	89e5      	ldrh	r5, [r4, #14]
                                       lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   1c770:	4611      	mov	r1, r2
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   1c772:	442b      	add	r3, r5
                                       lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   1c774:	980d      	ldr	r0, [sp, #52]	; 0x34
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   1c776:	b21d      	sxth	r5, r3
                                       lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
   1c778:	f7fe ff59 	bl	1b62e <lv_font_get_glyph_width>
                label_draw_dsc.ofs_y = ext->offset.y;
   1c77c:	8a23      	ldrh	r3, [r4, #16]
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   1c77e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   1c782:	9700      	str	r7, [sp, #0]
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   1c784:	4405      	add	r5, r0
                label_draw_dsc.ofs_y = ext->offset.y;
   1c786:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   1c78a:	aa0b      	add	r2, sp, #44	; 0x2c
   1c78c:	6823      	ldr	r3, [r4, #0]
   1c78e:	a909      	add	r1, sp, #36	; 0x24
   1c790:	a807      	add	r0, sp, #28
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
   1c792:	f8ad 5048 	strh.w	r5, [sp, #72]	; 0x48
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   1c796:	f7ee fa5d 	bl	ac54 <lv_draw_label>
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
   1c79a:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
   1c79e:	f8bd 101e 	ldrh.w	r1, [sp, #30]
   1c7a2:	3301      	adds	r3, #1
            if(size.y > lv_area_get_height(&txt_coords)) {
   1c7a4:	f9bd 2012 	ldrsh.w	r2, [sp, #18]
   1c7a8:	1a5b      	subs	r3, r3, r1
   1c7aa:	b21b      	sxth	r3, r3
   1c7ac:	429a      	cmp	r2, r3
   1c7ae:	dd11      	ble.n	1c7d4 <lv_label_design+0x1f6>
                label_draw_dsc.ofs_x = ext->offset.x;
   1c7b0:	89e3      	ldrh	r3, [r4, #14]
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   1c7b2:	a909      	add	r1, sp, #36	; 0x24
                label_draw_dsc.ofs_x = ext->offset.x;
   1c7b4:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
                label_draw_dsc.ofs_y = ext->offset.y + size.y + lv_font_get_line_height(label_draw_dsc.font);
   1c7b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   1c7ba:	a807      	add	r0, sp, #28
                label_draw_dsc.ofs_y = ext->offset.y + size.y + lv_font_get_line_height(label_draw_dsc.font);
   1c7bc:	891b      	ldrh	r3, [r3, #8]
   1c7be:	441a      	add	r2, r3
   1c7c0:	8a23      	ldrh	r3, [r4, #16]
   1c7c2:	441a      	add	r2, r3
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   1c7c4:	2300      	movs	r3, #0
   1c7c6:	9300      	str	r3, [sp, #0]
                label_draw_dsc.ofs_y = ext->offset.y + size.y + lv_font_get_line_height(label_draw_dsc.font);
   1c7c8:	f8ad 204a 	strh.w	r2, [sp, #74]	; 0x4a
                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
   1c7cc:	6823      	ldr	r3, [r4, #0]
   1c7ce:	aa0b      	add	r2, sp, #44	; 0x2c
   1c7d0:	f7ee fa40 	bl	ac54 <lv_draw_label>
}
   1c7d4:	4630      	mov	r0, r6
   1c7d6:	b02f      	add	sp, #188	; 0xbc
   1c7d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
   1c7dc:	2802      	cmp	r0, #2
   1c7de:	bf08      	it	eq
   1c7e0:	f045 0508 	orreq.w	r5, r5, #8
   1c7e4:	e75d      	b.n	1c6a2 <lv_label_design+0xc4>
    return LV_DESIGN_RES_OK;
   1c7e6:	2600      	movs	r6, #0
   1c7e8:	e7f4      	b.n	1c7d4 <lv_label_design+0x1f6>

0001c7ea <lv_label_get_recolor>:
{
   1c7ea:	b508      	push	{r3, lr}
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c7ec:	f7f9 fca6 	bl	1613c <lv_obj_get_ext_attr>
    return ext->recolor == 0 ? false : true;
   1c7f0:	7c80      	ldrb	r0, [r0, #18]
}
   1c7f2:	f3c0 1080 	ubfx	r0, r0, #6, #1
   1c7f6:	bd08      	pop	{r3, pc}

0001c7f8 <lv_label_set_text>:
{
   1c7f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c7fc:	4607      	mov	r7, r0
   1c7fe:	460d      	mov	r5, r1
    lv_obj_invalidate(label);
   1c800:	f7f9 f80e 	bl	15820 <lv_obj_invalidate>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c804:	4638      	mov	r0, r7
   1c806:	f7f9 fc99 	bl	1613c <lv_obj_get_ext_attr>
   1c80a:	4604      	mov	r4, r0
    if(text == NULL) {
   1c80c:	b925      	cbnz	r5, 1c818 <lv_label_set_text+0x20>
        lv_label_refr_text(label);
   1c80e:	4638      	mov	r0, r7
}
   1c810:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        lv_label_refr_text(label);
   1c814:	f7f2 bd7a 	b.w	f30c <lv_label_refr_text>
    if(ext->text == text && ext->static_txt == 0) {
   1c818:	6806      	ldr	r6, [r0, #0]
   1c81a:	42ae      	cmp	r6, r5
   1c81c:	d10e      	bne.n	1c83c <lv_label_set_text+0x44>
   1c81e:	7c83      	ldrb	r3, [r0, #18]
   1c820:	071b      	lsls	r3, r3, #28
   1c822:	d415      	bmi.n	1c850 <lv_label_set_text+0x58>
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
   1c824:	4630      	mov	r0, r6
   1c826:	f7e3 fe1d 	bl	464 <strlen>
   1c82a:	1c41      	adds	r1, r0, #1
   1c82c:	4630      	mov	r0, r6
   1c82e:	f7fe fdfd 	bl	1b42c <lv_mem_realloc>
   1c832:	6020      	str	r0, [r4, #0]
        if(ext->text == NULL) return;
   1c834:	2800      	cmp	r0, #0
   1c836:	d1ea      	bne.n	1c80e <lv_label_set_text+0x16>
}
   1c838:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(ext->text != NULL && ext->static_txt == 0) {
   1c83c:	b146      	cbz	r6, 1c850 <lv_label_set_text+0x58>
   1c83e:	7c83      	ldrb	r3, [r0, #18]
   1c840:	f013 0808 	ands.w	r8, r3, #8
   1c844:	d104      	bne.n	1c850 <lv_label_set_text+0x58>
            lv_mem_free(ext->text);
   1c846:	4630      	mov	r0, r6
   1c848:	f7f0 f93a 	bl	cac0 <lv_mem_free>
            ext->text = NULL;
   1c84c:	f8c4 8000 	str.w	r8, [r4]
        size_t len = strlen(text) + 1;
   1c850:	4628      	mov	r0, r5
   1c852:	f7e3 fe07 	bl	464 <strlen>
        ext->text = lv_mem_alloc(len);
   1c856:	3001      	adds	r0, #1
   1c858:	f7f0 f91e 	bl	ca98 <lv_mem_alloc>
   1c85c:	6020      	str	r0, [r4, #0]
        if(ext->text == NULL) return;
   1c85e:	2800      	cmp	r0, #0
   1c860:	d0ea      	beq.n	1c838 <lv_label_set_text+0x40>
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   1c862:	4629      	mov	r1, r5
   1c864:	f001 f892 	bl	1d98c <strcpy>
        ext->static_txt = 0;
   1c868:	7ca3      	ldrb	r3, [r4, #18]
   1c86a:	f36f 03c3 	bfc	r3, #3, #1
   1c86e:	74a3      	strb	r3, [r4, #18]
   1c870:	e7cd      	b.n	1c80e <lv_label_set_text+0x16>

0001c872 <lv_label_set_text_static>:
{
   1c872:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c874:	4607      	mov	r7, r0
   1c876:	460d      	mov	r5, r1
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c878:	f7f9 fc60 	bl	1613c <lv_obj_get_ext_attr>
    if(ext->static_txt == 0 && ext->text != NULL) {
   1c87c:	7c83      	ldrb	r3, [r0, #18]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c87e:	4604      	mov	r4, r0
    if(ext->static_txt == 0 && ext->text != NULL) {
   1c880:	f013 0608 	ands.w	r6, r3, #8
   1c884:	d104      	bne.n	1c890 <lv_label_set_text_static+0x1e>
   1c886:	6800      	ldr	r0, [r0, #0]
   1c888:	b110      	cbz	r0, 1c890 <lv_label_set_text_static+0x1e>
        lv_mem_free(ext->text);
   1c88a:	f7f0 f919 	bl	cac0 <lv_mem_free>
        ext->text = NULL;
   1c88e:	6026      	str	r6, [r4, #0]
    if(text != NULL) {
   1c890:	b125      	cbz	r5, 1c89c <lv_label_set_text_static+0x2a>
        ext->static_txt = 1;
   1c892:	7ca3      	ldrb	r3, [r4, #18]
        ext->text       = (char *)text;
   1c894:	6025      	str	r5, [r4, #0]
        ext->static_txt = 1;
   1c896:	f043 0308 	orr.w	r3, r3, #8
   1c89a:	74a3      	strb	r3, [r4, #18]
    lv_label_refr_text(label);
   1c89c:	4638      	mov	r0, r7
}
   1c89e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    lv_label_refr_text(label);
   1c8a2:	f7f2 bd33 	b.w	f30c <lv_label_refr_text>

0001c8a6 <lv_label_set_recolor>:
{
   1c8a6:	b538      	push	{r3, r4, r5, lr}
   1c8a8:	460c      	mov	r4, r1
   1c8aa:	4605      	mov	r5, r0
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
   1c8ac:	f7f9 fc46 	bl	1613c <lv_obj_get_ext_attr>
    if(ext->recolor == en) return;
   1c8b0:	7c83      	ldrb	r3, [r0, #18]
   1c8b2:	f3c3 1280 	ubfx	r2, r3, #6, #1
   1c8b6:	42a2      	cmp	r2, r4
   1c8b8:	d007      	beq.n	1c8ca <lv_label_set_recolor+0x24>
    ext->recolor = en == false ? 0 : 1;
   1c8ba:	f364 1386 	bfi	r3, r4, #6, #1
   1c8be:	7483      	strb	r3, [r0, #18]
    lv_label_refr_text(label); /*Refresh the text because the potential color codes in text needs to
   1c8c0:	4628      	mov	r0, r5
}
   1c8c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    lv_label_refr_text(label); /*Refresh the text because the potential color codes in text needs to
   1c8c6:	f7f2 bd21 	b.w	f30c <lv_label_refr_text>
}
   1c8ca:	bd38      	pop	{r3, r4, r5, pc}

0001c8cc <metal_io_phys>:
 * @return	METAL_BAD_PHYS if offset is out of range, or physical address
 *		of offset.
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
   1c8cc:	b430      	push	{r4, r5}
	if (!io->ops.offset_to_phys) {
   1c8ce:	6b04      	ldr	r4, [r0, #48]	; 0x30
{
   1c8d0:	460b      	mov	r3, r1
	if (!io->ops.offset_to_phys) {
   1c8d2:	b984      	cbnz	r4, 1c8f6 <metal_io_phys+0x2a>
		unsigned long page = (io->page_shift >=
   1c8d4:	68c1      	ldr	r1, [r0, #12]
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap && offset < io->size
   1c8d6:	6845      	ldr	r5, [r0, #4]
				     0 : offset >> io->page_shift);
   1c8d8:	291f      	cmp	r1, #31
   1c8da:	bf98      	it	ls
   1c8dc:	fa23 f401 	lsrls.w	r4, r3, r1
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
   1c8e0:	b165      	cbz	r5, 1c8fc <metal_io_phys+0x30>
		return (io->physmap && offset < io->size
   1c8e2:	6881      	ldr	r1, [r0, #8]
   1c8e4:	428b      	cmp	r3, r1
   1c8e6:	d209      	bcs.n	1c8fc <metal_io_phys+0x30>
			? io->physmap[page] + (offset & io->page_mask)
   1c8e8:	6900      	ldr	r0, [r0, #16]
   1c8ea:	4003      	ands	r3, r0
			: METAL_BAD_PHYS);
   1c8ec:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   1c8f0:	4418      	add	r0, r3
	}

	return io->ops.offset_to_phys(io, offset);
}
   1c8f2:	bc30      	pop	{r4, r5}
   1c8f4:	4770      	bx	lr
	return io->ops.offset_to_phys(io, offset);
   1c8f6:	4623      	mov	r3, r4
}
   1c8f8:	bc30      	pop	{r4, r5}
	return io->ops.offset_to_phys(io, offset);
   1c8fa:	4718      	bx	r3
			: METAL_BAD_PHYS);
   1c8fc:	f04f 30ff 	mov.w	r0, #4294967295
   1c900:	e7f7      	b.n	1c8f2 <metal_io_phys+0x26>

0001c902 <virtqueue_create>:
{
   1c902:	b570      	push	{r4, r5, r6, lr}
   1c904:	9c06      	ldr	r4, [sp, #24]
		vq->vq_queue_index = id;
   1c906:	8121      	strh	r1, [r4, #8]
		vq->callback = callback;
   1c908:	9904      	ldr	r1, [sp, #16]
		vq->vq_name = name;
   1c90a:	e9c4 0200 	strd	r0, r2, [r4]
		vq->vq_nentries = ring->num_descs;
   1c90e:	891a      	ldrh	r2, [r3, #8]
		vq->callback = callback;
   1c910:	60e1      	str	r1, [r4, #12]
		vq->notify = notify;
   1c912:	9905      	ldr	r1, [sp, #20]
{
	vr->num = num;
	vr->desc = (struct vring_desc *)p;
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
	vr->used = (struct vring_used *)
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
   1c914:	1c96      	adds	r6, r2, #2
   1c916:	6121      	str	r1, [r4, #16]
		vq_ring_init(vq, ring->vaddr, ring->align);
   1c918:	e9d3 1500 	ldrd	r1, r5, [r3]
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
   1c91c:	eb01 1302 	add.w	r3, r1, r2, lsl #4
   1c920:	61e3      	str	r3, [r4, #28]
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
   1c922:	eb03 0346 	add.w	r3, r3, r6, lsl #1
	      align - 1) & ~(align - 1));
   1c926:	1c6e      	adds	r6, r5, #1
   1c928:	4433      	add	r3, r6
   1c92a:	426d      	negs	r5, r5
   1c92c:	402b      	ands	r3, r5
	vr->used = (struct vring_used *)
   1c92e:	6223      	str	r3, [r4, #32]
	vr = &vq->vq_ring;

	vring_init(vr, size, ring_mem, alignment);

#ifndef VIRTIO_SLAVE_ONLY
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
   1c930:	6983      	ldr	r3, [r0, #24]
	vr->desc = (struct vring_desc *)p;
   1c932:	e9c4 2105 	strd	r2, r1, [r4, #20]
		vq->vq_nentries = ring->num_descs;
   1c936:	8162      	strh	r2, [r4, #10]
		vq->vq_free_cnt = vq->vq_nentries;
   1c938:	84a2      	strh	r2, [r4, #36]	; 0x24
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
   1c93a:	b96b      	cbnz	r3, 1c958 <virtqueue_create+0x56>
		int i;

		for (i = 0; i < size - 1; i++)
   1c93c:	3a01      	subs	r2, #1
   1c93e:	4293      	cmp	r3, r2
   1c940:	eb01 1003 	add.w	r0, r1, r3, lsl #4
   1c944:	db0a      	blt.n	1c95c <virtqueue_create+0x5a>
			vr->desc[i].next = i + 1;
		vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
   1c946:	2300      	movs	r3, #0
   1c948:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   1c94c:	eb01 1202 	add.w	r2, r1, r2, lsl #4
   1c950:	7393      	strb	r3, [r2, #14]
   1c952:	f06f 037f 	mvn.w	r3, #127	; 0x7f
   1c956:	73d3      	strb	r3, [r2, #15]
}
   1c958:	2000      	movs	r0, #0
   1c95a:	bd70      	pop	{r4, r5, r6, pc}
			vr->desc[i].next = i + 1;
   1c95c:	3301      	adds	r3, #1
   1c95e:	81c3      	strh	r3, [r0, #14]
		for (i = 0; i < size - 1; i++)
   1c960:	e7ed      	b.n	1c93e <virtqueue_create+0x3c>

0001c962 <virtqueue_add_buffer>:
{
   1c962:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
   1c966:	2700      	movs	r7, #0
		head_idx = vq->vq_desc_head_idx;
   1c968:	f8b0 b02c 	ldrh.w	fp, [r0, #44]	; 0x2c
{
   1c96c:	4604      	mov	r4, r0
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
   1c96e:	465d      	mov	r5, fp
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
   1c970:	46ba      	mov	sl, r7
{
   1c972:	b085      	sub	sp, #20
	needed = readable + writable;
   1c974:	18d6      	adds	r6, r2, r3
{
   1c976:	4691      	mov	r9, r2
		dxp->cookie = cookie;
   1c978:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   1c97a:	eb00 03cb 	add.w	r3, r0, fp, lsl #3
   1c97e:	635a      	str	r2, [r3, #52]	; 0x34
		dxp->ndescs = needed;
   1c980:	871e      	strh	r6, [r3, #56]	; 0x38
		if (i < needed - 1)
   1c982:	1e72      	subs	r2, r6, #1
		idx = vq_ring_add_buffer(vq, vq->vq_ring.desc, head_idx,
   1c984:	6983      	ldr	r3, [r0, #24]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
   1c986:	f101 0804 	add.w	r8, r1, #4
		if (i < needed - 1)
   1c98a:	9201      	str	r2, [sp, #4]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
   1c98c:	42be      	cmp	r6, r7
   1c98e:	dc19      	bgt.n	1c9c4 <virtqueue_add_buffer+0x62>
		vq->vq_free_cnt -= needed;
   1c990:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
	 * it usable to the host. The chain is made available now rather than
	 * deferring to virtqueue_notify() in the hopes that if the host is
	 * currently running on another CPU, we can keep it processing the new
	 * descriptor.
	 */
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
   1c992:	8962      	ldrh	r2, [r4, #10]
		vq->vq_free_cnt -= needed;
   1c994:	1b9e      	subs	r6, r3, r6
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
   1c996:	69e3      	ldr	r3, [r4, #28]
		vq->vq_desc_head_idx = idx;
   1c998:	85a5      	strh	r5, [r4, #44]	; 0x2c
		vq->vq_free_cnt -= needed;
   1c99a:	84a6      	strh	r6, [r4, #36]	; 0x24
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
   1c99c:	1e51      	subs	r1, r2, #1
   1c99e:	885a      	ldrh	r2, [r3, #2]
}
   1c9a0:	2000      	movs	r0, #0
	vq->vq_ring.avail->ring[avail_idx] = desc_idx;
   1c9a2:	400a      	ands	r2, r1
   1c9a4:	eb03 0342 	add.w	r3, r3, r2, lsl #1
   1c9a8:	f8a3 b004 	strh.w	fp, [r3, #4]

	atomic_thread_fence(memory_order_seq_cst);
   1c9ac:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.avail->idx++;
   1c9b0:	69e2      	ldr	r2, [r4, #28]
   1c9b2:	8853      	ldrh	r3, [r2, #2]
   1c9b4:	3301      	adds	r3, #1
   1c9b6:	8053      	strh	r3, [r2, #2]

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
   1c9b8:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   1c9ba:	3301      	adds	r3, #1
   1c9bc:	84e3      	strh	r3, [r4, #38]	; 0x26
}
   1c9be:	b005      	add	sp, #20
   1c9c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
   1c9c4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
		dp = &desc[idx];
   1c9c6:	012a      	lsls	r2, r5, #4
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
   1c9c8:	f858 1c04 	ldr.w	r1, [r8, #-4]
   1c9cc:	eb03 1505 	add.w	r5, r3, r5, lsl #4
   1c9d0:	9302      	str	r3, [sp, #8]
   1c9d2:	6803      	ldr	r3, [r0, #0]
   1c9d4:	9203      	str	r2, [sp, #12]
   1c9d6:	1ac9      	subs	r1, r1, r3
 *		physical address.
 */
static inline metal_phys_addr_t
metal_io_virt_to_phys(struct metal_io_region *io, void *virt)
{
	return metal_io_phys(io, metal_io_virt_to_offset(io, virt));
   1c9d8:	6883      	ldr	r3, [r0, #8]
   1c9da:	f108 0808 	add.w	r8, r8, #8
   1c9de:	4299      	cmp	r1, r3
   1c9e0:	bf28      	it	cs
   1c9e2:	f04f 31ff 	movcs.w	r1, #4294967295
   1c9e6:	f7ff ff71 	bl	1c8cc <metal_io_phys>
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
   1c9ea:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
   1c9ee:	5098      	str	r0, [r3, r2]
		dp->len = buf_list[i].len;
   1c9f0:	f858 2c08 	ldr.w	r2, [r8, #-8]
			dp->flags |= VRING_DESC_F_NEXT;
   1c9f4:	f885 a00d 	strb.w	sl, [r5, #13]
		dp->len = buf_list[i].len;
   1c9f8:	60aa      	str	r2, [r5, #8]
		if (i < needed - 1)
   1c9fa:	9a01      	ldr	r2, [sp, #4]
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
   1c9fc:	f8c5 a004 	str.w	sl, [r5, #4]
		if (i < needed - 1)
   1ca00:	4297      	cmp	r7, r2
			dp->flags |= VRING_DESC_F_NEXT;
   1ca02:	bfb6      	itet	lt
   1ca04:	2201      	movlt	r2, #1
		dp->flags = 0;
   1ca06:	f885 a00c 	strbge.w	sl, [r5, #12]
			dp->flags |= VRING_DESC_F_NEXT;
   1ca0a:	732a      	strblt	r2, [r5, #12]
		if (i >= readable)
   1ca0c:	45b9      	cmp	r9, r7
			dp->flags |= VRING_DESC_F_WRITE;
   1ca0e:	bfd8      	it	le
   1ca10:	89aa      	ldrhle	r2, [r5, #12]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
   1ca12:	f107 0701 	add.w	r7, r7, #1
			dp->flags |= VRING_DESC_F_WRITE;
   1ca16:	bfdc      	itt	le
   1ca18:	f042 0202 	orrle.w	r2, r2, #2
   1ca1c:	81aa      	strhle	r2, [r5, #12]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
   1ca1e:	89ed      	ldrh	r5, [r5, #14]
   1ca20:	e7b4      	b.n	1c98c <virtqueue_add_buffer+0x2a>

0001ca22 <virtqueue_get_buffer>:
{
   1ca22:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!vq || vq->vq_used_cons_idx == vq->vq_ring.used->idx)
   1ca24:	b350      	cbz	r0, 1ca7c <virtqueue_get_buffer+0x5a>
   1ca26:	6a05      	ldr	r5, [r0, #32]
   1ca28:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
   1ca2a:	886c      	ldrh	r4, [r5, #2]
   1ca2c:	429c      	cmp	r4, r3
   1ca2e:	d030      	beq.n	1ca92 <virtqueue_get_buffer+0x70>
	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
   1ca30:	1c5c      	adds	r4, r3, #1
   1ca32:	85c4      	strh	r4, [r0, #46]	; 0x2e
   1ca34:	8944      	ldrh	r4, [r0, #10]
	atomic_thread_fence(memory_order_seq_cst);
   1ca36:	f3bf 8f5b 	dmb	ish
	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
   1ca3a:	3c01      	subs	r4, #1
   1ca3c:	401c      	ands	r4, r3
	desc_idx = (uint16_t)uep->id;
   1ca3e:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
   1ca42:	686b      	ldr	r3, [r5, #4]
   1ca44:	b29e      	uxth	r6, r3
	if (len)
   1ca46:	b109      	cbz	r1, 1ca4c <virtqueue_get_buffer+0x2a>
		*len = uep->len;
   1ca48:	68ad      	ldr	r5, [r5, #8]
   1ca4a:	600d      	str	r5, [r1, #0]
	dp = &vq->vq_ring.desc[desc_idx];
   1ca4c:	f8d0 c018 	ldr.w	ip, [r0, #24]
   1ca50:	b29b      	uxth	r3, r3
   1ca52:	eb0c 1103 	add.w	r1, ip, r3, lsl #4
	vq->vq_free_cnt += dxp->ndescs;
   1ca56:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   1ca5a:	8f1d      	ldrh	r5, [r3, #56]	; 0x38
   1ca5c:	8c87      	ldrh	r7, [r0, #36]	; 0x24
   1ca5e:	442f      	add	r7, r5
	dxp->ndescs--;
   1ca60:	3d01      	subs	r5, #1
	vq->vq_free_cnt += dxp->ndescs;
   1ca62:	8487      	strh	r7, [r0, #36]	; 0x24
	dxp->ndescs--;
   1ca64:	871d      	strh	r5, [r3, #56]	; 0x38
	if ((dp->flags & VRING_DESC_F_INDIRECT) == 0) {
   1ca66:	898d      	ldrh	r5, [r1, #12]
   1ca68:	076f      	lsls	r7, r5, #29
   1ca6a:	d50e      	bpl.n	1ca8a <virtqueue_get_buffer+0x68>
	dp->next = vq->vq_desc_head_idx;
   1ca6c:	8d85      	ldrh	r5, [r0, #44]	; 0x2c
   1ca6e:	81cd      	strh	r5, [r1, #14]
	vq->vq_descx[desc_idx].cookie = NULL;
   1ca70:	2100      	movs	r1, #0
	vq->vq_desc_head_idx = desc_idx;
   1ca72:	8586      	strh	r6, [r0, #44]	; 0x2c
	cookie = vq->vq_descx[desc_idx].cookie;
   1ca74:	6b58      	ldr	r0, [r3, #52]	; 0x34
	vq->vq_descx[desc_idx].cookie = NULL;
   1ca76:	6359      	str	r1, [r3, #52]	; 0x34
	if (idx)
   1ca78:	b102      	cbz	r2, 1ca7c <virtqueue_get_buffer+0x5a>
		*idx = used_idx;
   1ca7a:	8014      	strh	r4, [r2, #0]
}
   1ca7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			dxp->ndescs--;
   1ca7e:	8f1d      	ldrh	r5, [r3, #56]	; 0x38
			dp = &vq->vq_ring.desc[dp->next];
   1ca80:	89c9      	ldrh	r1, [r1, #14]
			dxp->ndescs--;
   1ca82:	3d01      	subs	r5, #1
			dp = &vq->vq_ring.desc[dp->next];
   1ca84:	eb0c 1101 	add.w	r1, ip, r1, lsl #4
			dxp->ndescs--;
   1ca88:	871d      	strh	r5, [r3, #56]	; 0x38
		while (dp->flags & VRING_DESC_F_NEXT) {
   1ca8a:	898d      	ldrh	r5, [r1, #12]
   1ca8c:	07ed      	lsls	r5, r5, #31
   1ca8e:	d4f6      	bmi.n	1ca7e <virtqueue_get_buffer+0x5c>
   1ca90:	e7ec      	b.n	1ca6c <virtqueue_get_buffer+0x4a>
		return NULL;
   1ca92:	2000      	movs	r0, #0
   1ca94:	e7f2      	b.n	1ca7c <virtqueue_get_buffer+0x5a>

0001ca96 <virtqueue_get_available_buffer>:
{
   1ca96:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	atomic_thread_fence(memory_order_seq_cst);
   1ca9a:	f3bf 8f5b 	dmb	ish
{
   1ca9e:	4617      	mov	r7, r2
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
   1caa0:	69c2      	ldr	r2, [r0, #28]
{
   1caa2:	460e      	mov	r6, r1
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
   1caa4:	8853      	ldrh	r3, [r2, #2]
   1caa6:	8e01      	ldrh	r1, [r0, #48]	; 0x30
{
   1caa8:	4605      	mov	r5, r0
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
   1caaa:	428b      	cmp	r3, r1
   1caac:	d046      	beq.n	1cb3c <virtqueue_get_available_buffer+0xa6>
	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
   1caae:	1c4b      	adds	r3, r1, #1
   1cab0:	8603      	strh	r3, [r0, #48]	; 0x30
   1cab2:	8943      	ldrh	r3, [r0, #10]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
   1cab4:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
   1cab8:	3b01      	subs	r3, #1
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
   1caba:	400b      	ands	r3, r1
   1cabc:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   1cac0:	889a      	ldrh	r2, [r3, #4]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
   1cac2:	6983      	ldr	r3, [r0, #24]
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
   1cac4:	b291      	uxth	r1, r2
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
   1cac6:	eb03 1301 	add.w	r3, r3, r1, lsl #4
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
   1caca:	8032      	strh	r2, [r6, #0]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
   1cacc:	f8d3 9000 	ldr.w	r9, [r3]
	if (!io->ops.phys_to_offset) {
   1cad0:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
   1cad4:	bb5b      	cbnz	r3, 1cb2e <virtqueue_get_available_buffer+0x98>
			(io->page_mask == (metal_phys_addr_t)(-1) ?
   1cad6:	f8d8 4010 	ldr.w	r4, [r8, #16]
			phys - io->physmap[0] :  phys & io->page_mask);
   1cada:	1c62      	adds	r2, r4, #1
   1cadc:	bf09      	itett	eq
   1cade:	f8d8 3004 	ldreq.w	r3, [r8, #4]
   1cae2:	ea09 0404 	andne.w	r4, r9, r4
   1cae6:	681c      	ldreq	r4, [r3, #0]
   1cae8:	eba9 0404 	subeq.w	r4, r9, r4
			if (metal_io_phys(io, offset) == phys)
   1caec:	4621      	mov	r1, r4
   1caee:	4640      	mov	r0, r8
   1caf0:	f7ff feec 	bl	1c8cc <metal_io_phys>
   1caf4:	4581      	cmp	r9, r0
   1caf6:	d009      	beq.n	1cb0c <virtqueue_get_available_buffer+0x76>
			offset += io->page_mask + 1;
   1caf8:	f8d8 3010 	ldr.w	r3, [r8, #16]
   1cafc:	3301      	adds	r3, #1
   1cafe:	441c      	add	r4, r3
		} while (offset < io->size);
   1cb00:	f8d8 3008 	ldr.w	r3, [r8, #8]
   1cb04:	429c      	cmp	r4, r3
   1cb06:	d3f1      	bcc.n	1caec <virtqueue_get_available_buffer+0x56>
		return METAL_BAD_OFFSET;
   1cb08:	f04f 34ff 	mov.w	r4, #4294967295
	return (io->virt != METAL_BAD_VA && offset < io->size
   1cb0c:	f8d8 0000 	ldr.w	r0, [r8]
		: NULL);
   1cb10:	1c43      	adds	r3, r0, #1
   1cb12:	d011      	beq.n	1cb38 <virtqueue_get_available_buffer+0xa2>
	return (io->virt != METAL_BAD_VA && offset < io->size
   1cb14:	f8d8 3008 	ldr.w	r3, [r8, #8]
   1cb18:	42a3      	cmp	r3, r4
   1cb1a:	d90d      	bls.n	1cb38 <virtqueue_get_available_buffer+0xa2>
		: NULL);
   1cb1c:	4420      	add	r0, r4
	*len = vq->vq_ring.desc[*avail_idx].len;
   1cb1e:	8832      	ldrh	r2, [r6, #0]
   1cb20:	69ab      	ldr	r3, [r5, #24]
   1cb22:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   1cb26:	689b      	ldr	r3, [r3, #8]
   1cb28:	603b      	str	r3, [r7, #0]
}
   1cb2a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return (*io->ops.phys_to_offset)(io, phys);
   1cb2e:	4649      	mov	r1, r9
   1cb30:	4640      	mov	r0, r8
   1cb32:	4798      	blx	r3
   1cb34:	4604      	mov	r4, r0
   1cb36:	e7e9      	b.n	1cb0c <virtqueue_get_available_buffer+0x76>
		: NULL);
   1cb38:	2000      	movs	r0, #0
   1cb3a:	e7f0      	b.n	1cb1e <virtqueue_get_available_buffer+0x88>
		return NULL;
   1cb3c:	2000      	movs	r0, #0
   1cb3e:	e7f4      	b.n	1cb2a <virtqueue_get_available_buffer+0x94>

0001cb40 <virtqueue_disable_cb>:
{
   1cb40:	b530      	push	{r4, r5, lr}
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
   1cb42:	2500      	movs	r5, #0
   1cb44:	6802      	ldr	r2, [r0, #0]
   1cb46:	6993      	ldr	r3, [r2, #24]
   1cb48:	6912      	ldr	r2, [r2, #16]
   1cb4a:	f002 5400 	and.w	r4, r2, #536870912	; 0x20000000
   1cb4e:	ea54 0205 	orrs.w	r2, r4, r5
   1cb52:	d014      	beq.n	1cb7e <virtqueue_disable_cb+0x3e>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
   1cb54:	b94b      	cbnz	r3, 1cb6a <virtqueue_disable_cb+0x2a>
			vring_used_event(&vq->vq_ring) =
   1cb56:	69c2      	ldr	r2, [r0, #28]
   1cb58:	6941      	ldr	r1, [r0, #20]
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
   1cb5a:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
   1cb5c:	8940      	ldrh	r0, [r0, #10]
			vring_used_event(&vq->vq_ring) =
   1cb5e:	eb02 0241 	add.w	r2, r2, r1, lsl #1
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
   1cb62:	1a1b      	subs	r3, r3, r0
			vring_avail_event(&vq->vq_ring) =
   1cb64:	3b01      	subs	r3, #1
   1cb66:	8093      	strh	r3, [r2, #4]
}
   1cb68:	bd30      	pop	{r4, r5, pc}
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
   1cb6a:	2b01      	cmp	r3, #1
   1cb6c:	d1fc      	bne.n	1cb68 <virtqueue_disable_cb+0x28>
			vring_avail_event(&vq->vq_ring) =
   1cb6e:	6a02      	ldr	r2, [r0, #32]
   1cb70:	6941      	ldr	r1, [r0, #20]
			    vq->vq_available_idx - vq->vq_nentries - 1;
   1cb72:	8e03      	ldrh	r3, [r0, #48]	; 0x30
   1cb74:	8940      	ldrh	r0, [r0, #10]
			vring_avail_event(&vq->vq_ring) =
   1cb76:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
			    vq->vq_available_idx - vq->vq_nentries - 1;
   1cb7a:	1a1b      	subs	r3, r3, r0
   1cb7c:	e7f2      	b.n	1cb64 <virtqueue_disable_cb+0x24>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
   1cb7e:	b92b      	cbnz	r3, 1cb8c <virtqueue_disable_cb+0x4c>
			vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
   1cb80:	69c2      	ldr	r2, [r0, #28]
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
   1cb82:	8813      	ldrh	r3, [r2, #0]
   1cb84:	f043 0301 	orr.w	r3, r3, #1
   1cb88:	8013      	strh	r3, [r2, #0]
}
   1cb8a:	e7ed      	b.n	1cb68 <virtqueue_disable_cb+0x28>
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
   1cb8c:	2b01      	cmp	r3, #1
   1cb8e:	d1eb      	bne.n	1cb68 <virtqueue_disable_cb+0x28>
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
   1cb90:	6a02      	ldr	r2, [r0, #32]
   1cb92:	e7f6      	b.n	1cb82 <virtqueue_disable_cb+0x42>

0001cb94 <virtqueue_kick>:
{
   1cb94:	b510      	push	{r4, lr}
	atomic_thread_fence(memory_order_seq_cst);
   1cb96:	f3bf 8f5b 	dmb	ish
 */
static int vq_ring_must_notify(struct virtqueue *vq)
{
	uint16_t new_idx, prev_idx, event_idx;

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
   1cb9a:	2300      	movs	r3, #0
   1cb9c:	6801      	ldr	r1, [r0, #0]
{
   1cb9e:	4604      	mov	r4, r0
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
   1cba0:	6908      	ldr	r0, [r1, #16]
   1cba2:	f000 5200 	and.w	r2, r0, #536870912	; 0x20000000
   1cba6:	4313      	orrs	r3, r2
   1cba8:	698b      	ldr	r3, [r1, #24]
   1cbaa:	d020      	beq.n	1cbee <virtqueue_kick+0x5a>
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
   1cbac:	b9b3      	cbnz	r3, 1cbdc <virtqueue_kick+0x48>
			new_idx = vq->vq_ring.avail->idx;
   1cbae:	69e3      	ldr	r3, [r4, #28]
			prev_idx = new_idx - vq->vq_queued_cnt;
			event_idx = vring_avail_event(&vq->vq_ring);
   1cbb0:	6961      	ldr	r1, [r4, #20]
			new_idx = vq->vq_ring.avail->idx;
   1cbb2:	885a      	ldrh	r2, [r3, #2]
			event_idx = vring_avail_event(&vq->vq_ring);
   1cbb4:	6a23      	ldr	r3, [r4, #32]
   1cbb6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
			new_idx = vq->vq_ring.used->idx;
			prev_idx = new_idx - vq->vq_queued_cnt;
			event_idx = vring_used_event(&vq->vq_ring);
   1cbba:	889b      	ldrh	r3, [r3, #4]
 * event?
 */
static inline int
vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
	return (uint16_t)(new_idx - event_idx - 1) <
   1cbbc:	1ad2      	subs	r2, r2, r3
   1cbbe:	3a01      	subs	r2, #1
   1cbc0:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   1cbc2:	b292      	uxth	r2, r2
   1cbc4:	4293      	cmp	r3, r2
   1cbc6:	bf94      	ite	ls
   1cbc8:	2300      	movls	r3, #0
   1cbca:	2301      	movhi	r3, #1
	if (vq_ring_must_notify(vq))
   1cbcc:	b11b      	cbz	r3, 1cbd6 <virtqueue_kick+0x42>
 * vq_ring_notify
 *
 */
static void vq_ring_notify(struct virtqueue *vq)
{
	if (vq->notify)
   1cbce:	6923      	ldr	r3, [r4, #16]
   1cbd0:	b10b      	cbz	r3, 1cbd6 <virtqueue_kick+0x42>
		vq->notify(vq);
   1cbd2:	4620      	mov	r0, r4
   1cbd4:	4798      	blx	r3
	vq->vq_queued_cnt = 0;
   1cbd6:	2300      	movs	r3, #0
   1cbd8:	84e3      	strh	r3, [r4, #38]	; 0x26
}
   1cbda:	bd10      	pop	{r4, pc}
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
   1cbdc:	2b01      	cmp	r3, #1
   1cbde:	d1fa      	bne.n	1cbd6 <virtqueue_kick+0x42>
			new_idx = vq->vq_ring.used->idx;
   1cbe0:	6a23      	ldr	r3, [r4, #32]
			event_idx = vring_used_event(&vq->vq_ring);
   1cbe2:	6961      	ldr	r1, [r4, #20]
			new_idx = vq->vq_ring.used->idx;
   1cbe4:	885a      	ldrh	r2, [r3, #2]
			event_idx = vring_used_event(&vq->vq_ring);
   1cbe6:	69e3      	ldr	r3, [r4, #28]
   1cbe8:	eb03 0341 	add.w	r3, r3, r1, lsl #1
   1cbec:	e7e5      	b.n	1cbba <virtqueue_kick+0x26>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
   1cbee:	b92b      	cbnz	r3, 1cbfc <virtqueue_kick+0x68>
			return (vq->vq_ring.used->flags &
   1cbf0:	6a23      	ldr	r3, [r4, #32]
			return (vq->vq_ring.avail->flags &
   1cbf2:	881b      	ldrh	r3, [r3, #0]
				VRING_AVAIL_F_NO_INTERRUPT) == 0;
   1cbf4:	43db      	mvns	r3, r3
   1cbf6:	f003 0301 	and.w	r3, r3, #1
   1cbfa:	e7e7      	b.n	1cbcc <virtqueue_kick+0x38>
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
   1cbfc:	2b01      	cmp	r3, #1
   1cbfe:	d1ea      	bne.n	1cbd6 <virtqueue_kick+0x42>
			return (vq->vq_ring.avail->flags &
   1cc00:	69e3      	ldr	r3, [r4, #28]
   1cc02:	e7f6      	b.n	1cbf2 <virtqueue_kick+0x5e>

0001cc04 <virtqueue_get_desc_size>:
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
   1cc04:	69c2      	ldr	r2, [r0, #28]
   1cc06:	8e01      	ldrh	r1, [r0, #48]	; 0x30
   1cc08:	8853      	ldrh	r3, [r2, #2]
   1cc0a:	428b      	cmp	r3, r1
   1cc0c:	d00a      	beq.n	1cc24 <virtqueue_get_desc_size+0x20>
	head_idx = vq->vq_available_idx & (vq->vq_nentries - 1);
   1cc0e:	8943      	ldrh	r3, [r0, #10]
   1cc10:	3b01      	subs	r3, #1
	avail_idx = vq->vq_ring.avail->ring[head_idx];
   1cc12:	400b      	ands	r3, r1
   1cc14:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	len = vq->vq_ring.desc[avail_idx].len;
   1cc18:	889a      	ldrh	r2, [r3, #4]
   1cc1a:	6983      	ldr	r3, [r0, #24]
   1cc1c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   1cc20:	6898      	ldr	r0, [r3, #8]
	return len;
   1cc22:	4770      	bx	lr
		return 0;
   1cc24:	2000      	movs	r0, #0
}
   1cc26:	4770      	bx	lr

0001cc28 <virtqueue_notification>:
	atomic_thread_fence(memory_order_seq_cst);
   1cc28:	f3bf 8f5b 	dmb	ish
	if (vq->callback)
   1cc2c:	68c3      	ldr	r3, [r0, #12]
   1cc2e:	b103      	cbz	r3, 1cc32 <virtqueue_notification+0xa>
		vq->callback(vq);
   1cc30:	4718      	bx	r3
}
   1cc32:	4770      	bx	lr

0001cc34 <__metal_mutex_acquire>:
	return z_impl_k_sem_take(sem, timeout);
   1cc34:	f04f 32ff 	mov.w	r2, #4294967295
   1cc38:	f04f 33ff 	mov.w	r3, #4294967295
   1cc3c:	f7f4 b8d0 	b.w	10de0 <z_impl_k_sem_take>

0001cc40 <rpmsg_unregister_endpoint>:
{
   1cc40:	b570      	push	{r4, r5, r6, lr}
   1cc42:	4604      	mov	r4, r0
	struct rpmsg_device *rdev = ept->rdev;
   1cc44:	6a05      	ldr	r5, [r0, #32]
	metal_mutex_acquire(&rdev->lock);
   1cc46:	f105 0658 	add.w	r6, r5, #88	; 0x58
   1cc4a:	4630      	mov	r0, r6
   1cc4c:	f7ff fff2 	bl	1cc34 <__metal_mutex_acquire>
	if (ept->addr != RPMSG_ADDR_ANY)
   1cc50:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1cc52:	1c5a      	adds	r2, r3, #1
   1cc54:	d010      	beq.n	1cc78 <rpmsg_unregister_endpoint+0x38>
	addr -= RPMSG_RESERVED_ADDRESSES;
   1cc56:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
	if (addr >= 0 && addr < size)
   1cc5a:	2b7f      	cmp	r3, #127	; 0x7f
   1cc5c:	d80c      	bhi.n	1cc78 <rpmsg_unregister_endpoint+0x38>
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
   1cc5e:	2201      	movs	r2, #1
	bitmap[bit / METAL_BITS_PER_ULONG] &=
   1cc60:	0959      	lsrs	r1, r3, #5
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
   1cc62:	3548      	adds	r5, #72	; 0x48
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
   1cc64:	f003 031f 	and.w	r3, r3, #31
   1cc68:	fa02 f303 	lsl.w	r3, r2, r3
	bitmap[bit / METAL_BITS_PER_ULONG] &=
   1cc6c:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
   1cc70:	ea22 0203 	bic.w	r2, r2, r3
   1cc74:	f845 2021 	str.w	r2, [r5, r1, lsl #2]
	metal_list_del(&ept->node);
   1cc78:	f104 0334 	add.w	r3, r4, #52	; 0x34
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
	node->next->prev = node->prev;
   1cc7c:	e9d4 120d 	ldrd	r1, r2, [r4, #52]	; 0x34
   1cc80:	604a      	str	r2, [r1, #4]
	node->prev->next = node->next;
   1cc82:	6011      	str	r1, [r2, #0]
	node->prev = node;
	node->next = node;
   1cc84:	e9c4 330d 	strd	r3, r3, [r4, #52]	; 0x34
	ept->rdev = NULL;
   1cc88:	2300      	movs	r3, #0
   1cc8a:	6223      	str	r3, [r4, #32]
	z_impl_k_sem_give(sem);
   1cc8c:	4630      	mov	r0, r6
}
   1cc8e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1cc92:	f7f4 b87f 	b.w	10d94 <z_impl_k_sem_give>

0001cc96 <rpmsg_send_ns_message>:
{
   1cc96:	b530      	push	{r4, r5, lr}
	ns_msg.addr = ept->addr;
   1cc98:	6a45      	ldr	r5, [r0, #36]	; 0x24
{
   1cc9a:	b08d      	sub	sp, #52	; 0x34
   1cc9c:	4604      	mov	r4, r0
	ns_msg.flags = flags;
   1cc9e:	910b      	str	r1, [sp, #44]	; 0x2c
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
   1cca0:	2220      	movs	r2, #32
   1cca2:	4601      	mov	r1, r0
   1cca4:	a802      	add	r0, sp, #8
	ns_msg.addr = ept->addr;
   1cca6:	950a      	str	r5, [sp, #40]	; 0x28
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
   1cca8:	f000 fe8a 	bl	1d9c0 <strncpy>
	ret = rpmsg_send_offchannel_raw(ept, ept->addr,
   1ccac:	2328      	movs	r3, #40	; 0x28
   1ccae:	2201      	movs	r2, #1
   1ccb0:	4629      	mov	r1, r5
   1ccb2:	e9cd 3200 	strd	r3, r2, [sp]
   1ccb6:	4620      	mov	r0, r4
   1ccb8:	2235      	movs	r2, #53	; 0x35
   1ccba:	ab02      	add	r3, sp, #8
   1ccbc:	f7f2 ff2a 	bl	fb14 <rpmsg_send_offchannel_raw>
}
   1ccc0:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   1ccc4:	b00d      	add	sp, #52	; 0x34
   1ccc6:	bd30      	pop	{r4, r5, pc}

0001ccc8 <rpmsg_get_endpoint>:
{
   1ccc8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1cccc:	4680      	mov	r8, r0
   1ccce:	4689      	mov	r9, r1
   1ccd0:	4615      	mov	r5, r2
   1ccd2:	461e      	mov	r6, r3
	metal_list_for_each(&rdev->endpoints, node) {
   1ccd4:	6807      	ldr	r7, [r0, #0]
   1ccd6:	45b8      	cmp	r8, r7
   1ccd8:	d101      	bne.n	1ccde <rpmsg_get_endpoint+0x16>
	return NULL;
   1ccda:	2400      	movs	r4, #0
   1ccdc:	e021      	b.n	1cd22 <rpmsg_get_endpoint+0x5a>
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
   1ccde:	1c69      	adds	r1, r5, #1
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
   1cce0:	f1a7 0434 	sub.w	r4, r7, #52	; 0x34
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
   1cce4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1cce6:	d006      	beq.n	1ccf6 <rpmsg_get_endpoint+0x2e>
   1cce8:	429d      	cmp	r5, r3
		if (addr == ept->addr && dest_addr == ept->dest_addr)
   1ccea:	d01a      	beq.n	1cd22 <rpmsg_get_endpoint+0x5a>
		if (name)
   1ccec:	f1b9 0f00 	cmp.w	r9, #0
   1ccf0:	d106      	bne.n	1cd00 <rpmsg_get_endpoint+0x38>
	metal_list_for_each(&rdev->endpoints, node) {
   1ccf2:	683f      	ldr	r7, [r7, #0]
   1ccf4:	e7ef      	b.n	1ccd6 <rpmsg_get_endpoint+0xe>
		if (addr == ept->addr && dest_addr == ept->dest_addr)
   1ccf6:	3301      	adds	r3, #1
   1ccf8:	d1f8      	bne.n	1ccec <rpmsg_get_endpoint+0x24>
   1ccfa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1ccfc:	42b3      	cmp	r3, r6
   1ccfe:	e7f4      	b.n	1ccea <rpmsg_get_endpoint+0x22>
			name_match = !strncmp(ept->name, name,
   1cd00:	2220      	movs	r2, #32
   1cd02:	4649      	mov	r1, r9
   1cd04:	4620      	mov	r0, r4
   1cd06:	f000 fe49 	bl	1d99c <strncmp>
		if (!name || !name_match)
   1cd0a:	2800      	cmp	r0, #0
   1cd0c:	d1f1      	bne.n	1ccf2 <rpmsg_get_endpoint+0x2a>
		if (dest_addr != RPMSG_ADDR_ANY && ept->dest_addr == dest_addr)
   1cd0e:	1c72      	adds	r2, r6, #1
   1cd10:	d002      	beq.n	1cd18 <rpmsg_get_endpoint+0x50>
   1cd12:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1cd14:	42b3      	cmp	r3, r6
   1cd16:	d004      	beq.n	1cd22 <rpmsg_get_endpoint+0x5a>
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
   1cd18:	1c6b      	adds	r3, r5, #1
   1cd1a:	d1ea      	bne.n	1ccf2 <rpmsg_get_endpoint+0x2a>
   1cd1c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1cd1e:	3301      	adds	r3, #1
   1cd20:	d1e7      	bne.n	1ccf2 <rpmsg_get_endpoint+0x2a>
}
   1cd22:	4620      	mov	r0, r4
   1cd24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001cd28 <rpmsg_register_endpoint>:
	new_node->prev = node->prev;
   1cd28:	6842      	ldr	r2, [r0, #4]
	metal_list_add_tail(&rdev->endpoints, &ept->node);
   1cd2a:	f101 0334 	add.w	r3, r1, #52	; 0x34
	new_node->next = node;
   1cd2e:	e9c1 020d 	strd	r0, r2, [r1, #52]	; 0x34
	ept->rdev = rdev;
   1cd32:	6208      	str	r0, [r1, #32]
	new_node->next->prev = new_node;
   1cd34:	6043      	str	r3, [r0, #4]
	new_node->prev->next = new_node;
   1cd36:	6b8a      	ldr	r2, [r1, #56]	; 0x38
   1cd38:	6013      	str	r3, [r2, #0]
}
   1cd3a:	4770      	bx	lr

0001cd3c <rpmsg_destroy_ept>:
 *
 * @param ept - pointer to endpoint to destroy
 *
 */
void rpmsg_destroy_ept(struct rpmsg_endpoint *ept)
{
   1cd3c:	b510      	push	{r4, lr}
	struct rpmsg_device *rdev;

	if (!ept)
   1cd3e:	4604      	mov	r4, r0
   1cd40:	b190      	cbz	r0, 1cd68 <rpmsg_destroy_ept+0x2c>
		return;

	rdev = ept->rdev;
   1cd42:	6a03      	ldr	r3, [r0, #32]
	if (!rdev)
   1cd44:	b183      	cbz	r3, 1cd68 <rpmsg_destroy_ept+0x2c>
		return;

	if (ept->name[0] && rdev->support_ns &&
   1cd46:	7802      	ldrb	r2, [r0, #0]
   1cd48:	b14a      	cbz	r2, 1cd5e <rpmsg_destroy_ept+0x22>
   1cd4a:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   1cd4e:	b133      	cbz	r3, 1cd5e <rpmsg_destroy_ept+0x22>
   1cd50:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1cd52:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   1cd56:	d302      	bcc.n	1cd5e <rpmsg_destroy_ept+0x22>
	    ept->addr >= RPMSG_RESERVED_ADDRESSES)
		(void)rpmsg_send_ns_message(ept, RPMSG_NS_DESTROY);
   1cd58:	2101      	movs	r1, #1
   1cd5a:	f7ff ff9c 	bl	1cc96 <rpmsg_send_ns_message>
	rpmsg_unregister_endpoint(ept);
   1cd5e:	4620      	mov	r0, r4
}
   1cd60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rpmsg_unregister_endpoint(ept);
   1cd64:	f7ff bf6c 	b.w	1cc40 <rpmsg_unregister_endpoint>
}
   1cd68:	bd10      	pop	{r4, pc}

0001cd6a <rpmsg_virtio_tx_callback>:
}
   1cd6a:	4770      	bx	lr

0001cd6c <k_sem_give>:
   1cd6c:	f7f4 b812 	b.w	10d94 <z_impl_k_sem_give>

0001cd70 <rpmsg_virtio_get_rx_buffer>:
{
   1cd70:	b430      	push	{r4, r5}
	return rvdev->vdev->role;
   1cd72:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
   1cd74:	4613      	mov	r3, r2
   1cd76:	69ad      	ldr	r5, [r5, #24]
	if (role == RPMSG_MASTER) {
   1cd78:	b925      	cbnz	r5, 1cd84 <rpmsg_virtio_get_rx_buffer+0x14>
}
   1cd7a:	bc30      	pop	{r4, r5}
		data = virtqueue_get_buffer(rvdev->rvq, len, idx);
   1cd7c:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
   1cd80:	f7ff be4f 	b.w	1ca22 <virtqueue_get_buffer>
	if (role == RPMSG_REMOTE) {
   1cd84:	2d01      	cmp	r5, #1
   1cd86:	d106      	bne.n	1cd96 <rpmsg_virtio_get_rx_buffer+0x26>
}
   1cd88:	bc30      	pop	{r4, r5}
		    virtqueue_get_available_buffer(rvdev->rvq, idx, len);
   1cd8a:	460a      	mov	r2, r1
   1cd8c:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
   1cd90:	4619      	mov	r1, r3
   1cd92:	f7ff be80 	b.w	1ca96 <virtqueue_get_available_buffer>
}
   1cd96:	2000      	movs	r0, #0
   1cd98:	bc30      	pop	{r4, r5}
   1cd9a:	4770      	bx	lr

0001cd9c <__metal_mutex_acquire>:
	return z_impl_k_sem_take(sem, timeout);
   1cd9c:	f04f 32ff 	mov.w	r2, #4294967295
   1cda0:	f04f 33ff 	mov.w	r3, #4294967295
   1cda4:	f7f4 b81c 	b.w	10de0 <z_impl_k_sem_take>

0001cda8 <rpmsg_virtio_ns_callback>:
{
   1cda8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (len != sizeof(*ns_msg))
   1cdac:	2a28      	cmp	r2, #40	; 0x28
{
   1cdae:	4680      	mov	r8, r0
   1cdb0:	460e      	mov	r6, r1
   1cdb2:	b089      	sub	sp, #36	; 0x24
	if (len != sizeof(*ns_msg))
   1cdb4:	d12b      	bne.n	1ce0e <rpmsg_virtio_ns_callback+0x66>
	struct rpmsg_device *rdev = ept->rdev;
   1cdb6:	6a05      	ldr	r5, [r0, #32]
	metal_io_block_read(io,
   1cdb8:	2320      	movs	r3, #32
	struct metal_io_region *io = rvdev->shbuf_io;
   1cdba:	f8d5 0088 	ldr.w	r0, [r5, #136]	; 0x88
	metal_io_block_read(io,
   1cdbe:	466a      	mov	r2, sp
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
   1cdc0:	6801      	ldr	r1, [r0, #0]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
   1cdc2:	6884      	ldr	r4, [r0, #8]
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
   1cdc4:	1a71      	subs	r1, r6, r1
   1cdc6:	42a1      	cmp	r1, r4
   1cdc8:	bf28      	it	cs
   1cdca:	f04f 31ff 	movcs.w	r1, #4294967295
   1cdce:	f7f8 fb31 	bl	15434 <metal_io_block_read>
	metal_mutex_acquire(&rdev->lock);
   1cdd2:	f105 0758 	add.w	r7, r5, #88	; 0x58
	dest = ns_msg->addr;
   1cdd6:	f8d6 9020 	ldr.w	r9, [r6, #32]
   1cdda:	4638      	mov	r0, r7
   1cddc:	f7ff ffde 	bl	1cd9c <__metal_mutex_acquire>
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
   1cde0:	464b      	mov	r3, r9
   1cde2:	f04f 32ff 	mov.w	r2, #4294967295
   1cde6:	4669      	mov	r1, sp
   1cde8:	4628      	mov	r0, r5
   1cdea:	f7ff ff6d 	bl	1ccc8 <rpmsg_get_endpoint>
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
   1cdee:	6a73      	ldr	r3, [r6, #36]	; 0x24
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
   1cdf0:	4604      	mov	r4, r0
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
   1cdf2:	07db      	lsls	r3, r3, #31
   1cdf4:	d50f      	bpl.n	1ce16 <rpmsg_virtio_ns_callback+0x6e>
		if (_ept)
   1cdf6:	b110      	cbz	r0, 1cdfe <rpmsg_virtio_ns_callback+0x56>
			_ept->dest_addr = RPMSG_ADDR_ANY;
   1cdf8:	f04f 33ff 	mov.w	r3, #4294967295
   1cdfc:	6283      	str	r3, [r0, #40]	; 0x28
   1cdfe:	4638      	mov	r0, r7
   1ce00:	f7ff ffb4 	bl	1cd6c <k_sem_give>
		if (_ept && _ept->ns_unbind_cb)
   1ce04:	b11c      	cbz	r4, 1ce0e <rpmsg_virtio_ns_callback+0x66>
   1ce06:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1ce08:	b10b      	cbz	r3, 1ce0e <rpmsg_virtio_ns_callback+0x66>
			_ept->ns_unbind_cb(ept);
   1ce0a:	4640      	mov	r0, r8
   1ce0c:	4798      	blx	r3
}
   1ce0e:	2000      	movs	r0, #0
   1ce10:	b009      	add	sp, #36	; 0x24
   1ce12:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (!_ept) {
   1ce16:	b950      	cbnz	r0, 1ce2e <rpmsg_virtio_ns_callback+0x86>
   1ce18:	4638      	mov	r0, r7
   1ce1a:	f7ff ffa7 	bl	1cd6c <k_sem_give>
			if (rdev->ns_bind_cb)
   1ce1e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
   1ce20:	2b00      	cmp	r3, #0
   1ce22:	d0f4      	beq.n	1ce0e <rpmsg_virtio_ns_callback+0x66>
				rdev->ns_bind_cb(rdev, name, dest);
   1ce24:	464a      	mov	r2, r9
   1ce26:	4669      	mov	r1, sp
   1ce28:	4628      	mov	r0, r5
   1ce2a:	4798      	blx	r3
   1ce2c:	e7ef      	b.n	1ce0e <rpmsg_virtio_ns_callback+0x66>
			_ept->dest_addr = dest;
   1ce2e:	f8c0 9028 	str.w	r9, [r0, #40]	; 0x28
   1ce32:	4638      	mov	r0, r7
   1ce34:	f7ff ff9a 	bl	1cd6c <k_sem_give>
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
	__metal_mutex_release(mutex);
}
   1ce38:	e7e9      	b.n	1ce0e <rpmsg_virtio_ns_callback+0x66>

0001ce3a <rpmsg_virtio_rx_callback>:
{
   1ce3a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct rpmsg_virtio_device *rvdev = vdev->priv;
   1ce3e:	6803      	ldr	r3, [r0, #0]
{
   1ce40:	b086      	sub	sp, #24
	struct rpmsg_virtio_device *rvdev = vdev->priv;
   1ce42:	6a5e      	ldr	r6, [r3, #36]	; 0x24
	metal_mutex_acquire(&rdev->lock);
   1ce44:	f106 0758 	add.w	r7, r6, #88	; 0x58
	__metal_mutex_acquire(mutex);
   1ce48:	4638      	mov	r0, r7
   1ce4a:	f7ff ffa7 	bl	1cd9c <__metal_mutex_acquire>
	rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
   1ce4e:	4630      	mov	r0, r6
   1ce50:	f10d 020a 	add.w	r2, sp, #10
   1ce54:	a903      	add	r1, sp, #12
   1ce56:	f7ff ff8b 	bl	1cd70 <rpmsg_virtio_get_rx_buffer>
   1ce5a:	4604      	mov	r4, r0
   1ce5c:	4638      	mov	r0, r7
   1ce5e:	f7ff ff85 	bl	1cd6c <k_sem_give>
	while (rp_hdr) {
   1ce62:	b914      	cbnz	r4, 1ce6a <rpmsg_virtio_rx_callback+0x30>
}
   1ce64:	b006      	add	sp, #24
   1ce66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ce6a:	4638      	mov	r0, r7
   1ce6c:	f7ff ff96 	bl	1cd9c <__metal_mutex_acquire>
			     struct rpmsg_endpoint *ept);

static inline struct rpmsg_endpoint *
rpmsg_get_ept_from_addr(struct rpmsg_device *rdev, uint32_t addr)
{
	return rpmsg_get_endpoint(rdev, NULL, addr, RPMSG_ADDR_ANY);
   1ce70:	f04f 33ff 	mov.w	r3, #4294967295
   1ce74:	2100      	movs	r1, #0
   1ce76:	4630      	mov	r0, r6
   1ce78:	6862      	ldr	r2, [r4, #4]
   1ce7a:	f7ff ff25 	bl	1ccc8 <rpmsg_get_endpoint>
   1ce7e:	4605      	mov	r5, r0
   1ce80:	4638      	mov	r0, r7
   1ce82:	f7ff ff73 	bl	1cd6c <k_sem_give>
		if (ept) {
   1ce86:	b185      	cbz	r5, 1ceaa <rpmsg_virtio_rx_callback+0x70>
			if (ept->dest_addr == RPMSG_ADDR_ANY) {
   1ce88:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   1ce8a:	6823      	ldr	r3, [r4, #0]
   1ce8c:	3201      	adds	r2, #1
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
   1ce8e:	6be9      	ldr	r1, [r5, #60]	; 0x3c
				ept->dest_addr = rp_hdr->src;
   1ce90:	bf08      	it	eq
   1ce92:	62ab      	streq	r3, [r5, #40]	; 0x28
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
   1ce94:	89a2      	ldrh	r2, [r4, #12]
   1ce96:	9100      	str	r1, [sp, #0]
   1ce98:	4628      	mov	r0, r5
   1ce9a:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
   1ce9e:	f104 0110 	add.w	r1, r4, #16
   1cea2:	47c0      	blx	r8
			RPMSG_ASSERT(status >= 0,
   1cea4:	2800      	cmp	r0, #0
   1cea6:	da00      	bge.n	1ceaa <rpmsg_virtio_rx_callback+0x70>
   1cea8:	e7fe      	b.n	1cea8 <rpmsg_virtio_rx_callback+0x6e>
   1ceaa:	4638      	mov	r0, r7
   1ceac:	f7ff ff76 	bl	1cd9c <__metal_mutex_acquire>
   1ceb0:	6ff2      	ldr	r2, [r6, #124]	; 0x7c
		rpmsg_virtio_return_buffer(rvdev, rp_hdr, len, idx);
   1ceb2:	9b03      	ldr	r3, [sp, #12]
   1ceb4:	6992      	ldr	r2, [r2, #24]
	if (role == RPMSG_MASTER) {
   1ceb6:	b9b2      	cbnz	r2, 1cee6 <rpmsg_virtio_rx_callback+0xac>
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
   1ceb8:	9400      	str	r4, [sp, #0]
		vqbuf.len = len;
   1ceba:	e9cd 4304 	strd	r4, r3, [sp, #16]
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
   1cebe:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
   1cec2:	2301      	movs	r3, #1
   1cec4:	a904      	add	r1, sp, #16
   1cec6:	f7ff fd4c 	bl	1c962 <virtqueue_add_buffer>
		rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
   1ceca:	4630      	mov	r0, r6
   1cecc:	f10d 020a 	add.w	r2, sp, #10
   1ced0:	a903      	add	r1, sp, #12
   1ced2:	f7ff ff4d 	bl	1cd70 <rpmsg_virtio_get_rx_buffer>
		if (!rp_hdr) {
   1ced6:	4604      	mov	r4, r0
   1ced8:	2800      	cmp	r0, #0
   1ceda:	d1bf      	bne.n	1ce5c <rpmsg_virtio_rx_callback+0x22>
			virtqueue_kick(rvdev->rvq);
   1cedc:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
   1cee0:	f7ff fe58 	bl	1cb94 <virtqueue_kick>
   1cee4:	e7ba      	b.n	1ce5c <rpmsg_virtio_rx_callback+0x22>
	if (role == RPMSG_REMOTE) {
   1cee6:	2a01      	cmp	r2, #1
   1cee8:	d1ef      	bne.n	1ceca <rpmsg_virtio_rx_callback+0x90>
		virtqueue_add_consumed_buffer(rvdev->rvq, idx, len);
   1ceea:	461a      	mov	r2, r3
   1ceec:	f8bd 100a 	ldrh.w	r1, [sp, #10]
   1cef0:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
   1cef4:	f7f2 fdf2 	bl	fadc <virtqueue_add_consumed_buffer>
   1cef8:	e7e7      	b.n	1ceca <rpmsg_virtio_rx_callback+0x90>

0001cefa <rpmsg_virtio_shm_pool_get_buffer>:
{
   1cefa:	4603      	mov	r3, r0
	if (shpool->avail < size)
   1cefc:	6842      	ldr	r2, [r0, #4]
{
   1cefe:	b510      	push	{r4, lr}
	if (shpool->avail < size)
   1cf00:	428a      	cmp	r2, r1
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
   1cf02:	bf29      	itett	cs
   1cf04:	6880      	ldrcs	r0, [r0, #8]
		return NULL;
   1cf06:	2000      	movcc	r0, #0
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
   1cf08:	1a84      	subcs	r4, r0, r2
   1cf0a:	6818      	ldrcs	r0, [r3, #0]
	shpool->avail -= size;
   1cf0c:	bf22      	ittt	cs
   1cf0e:	1a52      	subcs	r2, r2, r1
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
   1cf10:	1900      	addcs	r0, r0, r4
	shpool->avail -= size;
   1cf12:	605a      	strcs	r2, [r3, #4]
}
   1cf14:	bd10      	pop	{r4, pc}

0001cf16 <rpmsg_virtio_init_shm_pool>:
	if (!shpool)
   1cf16:	b110      	cbz	r0, 1cf1e <rpmsg_virtio_init_shm_pool+0x8>
	shpool->avail = size;
   1cf18:	e9c0 2201 	strd	r2, r2, [r0, #4]
	shpool->base = shb;
   1cf1c:	6001      	str	r1, [r0, #0]
}
   1cf1e:	4770      	bx	lr

0001cf20 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   1cf20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1cf22:	4605      	mov	r5, r0
   1cf24:	460e      	mov	r6, r1
	__asm__ volatile(
   1cf26:	f04f 0320 	mov.w	r3, #32
   1cf2a:	f3ef 8711 	mrs	r7, BASEPRI
   1cf2e:	f383 8811 	msr	BASEPRI, r3
   1cf32:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   1cf36:	f7f3 ff27 	bl	10d88 <z_impl_k_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	z_coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   1cf3a:	4631      	mov	r1, r6
   1cf3c:	4604      	mov	r4, r0
   1cf3e:	4628      	mov	r0, r5
   1cf40:	f7f8 f9dd 	bl	152fe <k_sys_fatal_error_handler>
	__asm__ volatile(
   1cf44:	f387 8811 	msr	BASEPRI, r7
   1cf48:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   1cf4c:	4620      	mov	r0, r4
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
   1cf4e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1cf52:	f7e5 be57 	b.w	2c04 <z_impl_k_thread_abort>

0001cf56 <z_pm_save_idle_exit>:
	z_clock_idle_exit();
   1cf56:	f7f5 bbf7 	b.w	12748 <z_clock_idle_exit>

0001cf5a <k_heap_init>:
{
   1cf5a:	b410      	push	{r4}
   1cf5c:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   1cf60:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   1cf64:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   1cf66:	f7f5 b80c 	b.w	11f82 <sys_heap_init>

0001cf6a <k_heap_aligned_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   1cf6a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1cf6e:	b087      	sub	sp, #28
   1cf70:	4604      	mov	r4, r0
   1cf72:	460e      	mov	r6, r1
	int64_t now, end = z_timeout_end_calc(timeout);
   1cf74:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
{
   1cf78:	4617      	mov	r7, r2
	int64_t now, end = z_timeout_end_calc(timeout);
   1cf7a:	f000 fb16 	bl	1d5aa <z_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   1cf7e:	f104 0914 	add.w	r9, r4, #20
	int64_t now, end = z_timeout_end_calc(timeout);
   1cf82:	4605      	mov	r5, r0
   1cf84:	4688      	mov	r8, r1
	__asm__ volatile(
   1cf86:	f04f 0320 	mov.w	r3, #32
   1cf8a:	f3ef 8b11 	mrs	fp, BASEPRI
   1cf8e:	f383 8811 	msr	BASEPRI, r3
   1cf92:	f3bf 8f6f 	isb	sy
		now = z_tick_get();
		if ((ret != NULL) || ((end - now) <= 0)) {
			break;
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   1cf96:	f104 0a0c 	add.w	sl, r4, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   1cf9a:	463a      	mov	r2, r7
   1cf9c:	4631      	mov	r1, r6
   1cf9e:	4620      	mov	r0, r4
   1cfa0:	f7f4 ff92 	bl	11ec8 <sys_heap_aligned_alloc>
   1cfa4:	9005      	str	r0, [sp, #20]
		now = z_tick_get();
   1cfa6:	f7f4 f9ff 	bl	113a8 <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
   1cfaa:	9b05      	ldr	r3, [sp, #20]
   1cfac:	b13b      	cbz	r3, 1cfbe <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   1cfae:	f38b 8811 	msr	BASEPRI, fp
   1cfb2:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
   1cfb6:	4618      	mov	r0, r3
   1cfb8:	b007      	add	sp, #28
   1cfba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((ret != NULL) || ((end - now) <= 0)) {
   1cfbe:	1a2a      	subs	r2, r5, r0
   1cfc0:	9202      	str	r2, [sp, #8]
   1cfc2:	eb68 0201 	sbc.w	r2, r8, r1
   1cfc6:	9203      	str	r2, [sp, #12]
   1cfc8:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   1cfcc:	2901      	cmp	r1, #1
   1cfce:	f172 0200 	sbcs.w	r2, r2, #0
   1cfd2:	dbec      	blt.n	1cfae <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   1cfd4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1cfd8:	4659      	mov	r1, fp
   1cfda:	e9cd 2300 	strd	r2, r3, [sp]
   1cfde:	4648      	mov	r0, r9
   1cfe0:	4652      	mov	r2, sl
   1cfe2:	f7f3 fdc3 	bl	10b6c <z_pend_curr>
	__asm__ volatile(
   1cfe6:	f04f 0320 	mov.w	r3, #32
   1cfea:	f3ef 8b11 	mrs	fp, BASEPRI
   1cfee:	f383 8811 	msr	BASEPRI, r3
   1cff2:	f3bf 8f6f 	isb	sy
   1cff6:	e7d0      	b.n	1cf9a <k_heap_aligned_alloc+0x30>

0001cff8 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   1cff8:	b538      	push	{r3, r4, r5, lr}
   1cffa:	4604      	mov	r4, r0
   1cffc:	f04f 0320 	mov.w	r3, #32
   1d000:	f3ef 8511 	mrs	r5, BASEPRI
   1d004:	f383 8811 	msr	BASEPRI, r3
   1d008:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   1d00c:	f7f4 ff0f 	bl	11e2e <sys_heap_free>

	if (z_unpend_all(&h->wait_q) != 0) {
   1d010:	f104 000c 	add.w	r0, r4, #12
   1d014:	f000 f9e8 	bl	1d3e8 <z_unpend_all>
   1d018:	b130      	cbz	r0, 1d028 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   1d01a:	4629      	mov	r1, r5
   1d01c:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   1d020:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   1d024:	f7f3 bb5a 	b.w	106dc <z_reschedule>
	__asm__ volatile(
   1d028:	f385 8811 	msr	BASEPRI, r5
   1d02c:	f3bf 8f6f 	isb	sy
}
   1d030:	bd38      	pop	{r3, r4, r5, pc}

0001d032 <k_mem_slab_init>:
{
   1d032:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   1d034:	2400      	movs	r4, #0
   1d036:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   1d038:	ea41 0402 	orr.w	r4, r1, r2
   1d03c:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   1d040:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   1d044:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   1d046:	d10c      	bne.n	1d062 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   1d048:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   1d04a:	42a3      	cmp	r3, r4
   1d04c:	d103      	bne.n	1d056 <k_mem_slab_init+0x24>
   1d04e:	e9c0 0000 	strd	r0, r0, [r0]
}
   1d052:	2000      	movs	r0, #0
}
   1d054:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   1d056:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   1d058:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   1d05a:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   1d05c:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   1d05e:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   1d060:	e7f3      	b.n	1d04a <k_mem_slab_init+0x18>
		return -EINVAL;
   1d062:	f06f 0015 	mvn.w	r0, #21
	return rc;
   1d066:	e7f5      	b.n	1d054 <k_mem_slab_init+0x22>

0001d068 <z_impl_k_mutex_init>:
{
   1d068:	4603      	mov	r3, r0
	mutex->owner = NULL;
   1d06a:	2000      	movs	r0, #0
   1d06c:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   1d070:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   1d074:	4770      	bx	lr

0001d076 <queue_insert>:
{
   1d076:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1d07a:	4699      	mov	r9, r3
   1d07c:	4604      	mov	r4, r0
   1d07e:	460d      	mov	r5, r1
   1d080:	4690      	mov	r8, r2
   1d082:	f89d 3020 	ldrb.w	r3, [sp, #32]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1d086:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   1d08a:	f04f 0220 	mov.w	r2, #32
   1d08e:	f3ef 8711 	mrs	r7, BASEPRI
   1d092:	f382 8811 	msr	BASEPRI, r2
   1d096:	f3bf 8f6f 	isb	sy
	if (is_append) {
   1d09a:	b103      	cbz	r3, 1d09e <queue_insert+0x28>
		prev = sys_sflist_peek_tail(&queue->data_q);
   1d09c:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   1d09e:	4630      	mov	r0, r6
   1d0a0:	f000 f97d 	bl	1d39e <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   1d0a4:	b160      	cbz	r0, 1d0c0 <queue_insert+0x4a>
   1d0a6:	2400      	movs	r4, #0
   1d0a8:	f8c0 8014 	str.w	r8, [r0, #20]
   1d0ac:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80
	z_ready_thread(thread);
   1d0b0:	f000 f91a 	bl	1d2e8 <z_ready_thread>
	z_reschedule(&queue->lock, key);
   1d0b4:	4630      	mov	r0, r6
   1d0b6:	4639      	mov	r1, r7
   1d0b8:	f7f3 fb10 	bl	106dc <z_reschedule>
	return 0;
   1d0bc:	2000      	movs	r0, #0
   1d0be:	e00c      	b.n	1d0da <queue_insert+0x64>
	if (alloc) {
   1d0c0:	f1b9 0f00 	cmp.w	r9, #0
   1d0c4:	d01b      	beq.n	1d0fe <queue_insert+0x88>
	return z_thread_aligned_alloc(0, size);
   1d0c6:	2108      	movs	r1, #8
   1d0c8:	f7f4 fa96 	bl	115f8 <z_thread_aligned_alloc>
		if (anode == NULL) {
   1d0cc:	b938      	cbnz	r0, 1d0de <queue_insert+0x68>
	__asm__ volatile(
   1d0ce:	f387 8811 	msr	BASEPRI, r7
   1d0d2:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   1d0d6:	f06f 000b 	mvn.w	r0, #11
}
   1d0da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   1d0de:	2301      	movs	r3, #1
		anode->data = data;
   1d0e0:	f8c0 8004 	str.w	r8, [r0, #4]
   1d0e4:	6003      	str	r3, [r0, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   1d0e6:	6803      	ldr	r3, [r0, #0]
   1d0e8:	f003 0203 	and.w	r2, r3, #3
   1d0ec:	b95d      	cbnz	r5, 1d106 <queue_insert+0x90>
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d0ee:	6823      	ldr	r3, [r4, #0]
   1d0f0:	4313      	orrs	r3, r2
   1d0f2:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   1d0f4:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   1d0f6:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   1d0f8:	b973      	cbnz	r3, 1d118 <queue_insert+0xa2>
	list->tail = node;
   1d0fa:	6060      	str	r0, [r4, #4]
}
   1d0fc:	e00c      	b.n	1d118 <queue_insert+0xa2>
}
   1d0fe:	4640      	mov	r0, r8
	node->next_and_flags = flags;
   1d100:	f8c8 9000 	str.w	r9, [r8]
}
   1d104:	e7ef      	b.n	1d0e6 <queue_insert+0x70>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1d106:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   1d108:	f033 0303 	bics.w	r3, r3, #3
   1d10c:	d110      	bne.n	1d130 <queue_insert+0xba>
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d10e:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   1d110:	6862      	ldr	r2, [r4, #4]
   1d112:	b93a      	cbnz	r2, 1d124 <queue_insert+0xae>
	list->head = node;
   1d114:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   1d118:	2104      	movs	r1, #4
   1d11a:	f104 0010 	add.w	r0, r4, #16
   1d11e:	f000 fbdb 	bl	1d8d8 <z_handle_obj_poll_events>
   1d122:	e7c7      	b.n	1d0b4 <queue_insert+0x3e>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d124:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d126:	f003 0303 	and.w	r3, r3, #3
   1d12a:	4303      	orrs	r3, r0
   1d12c:	6013      	str	r3, [r2, #0]
   1d12e:	e7e4      	b.n	1d0fa <queue_insert+0x84>
   1d130:	4313      	orrs	r3, r2
   1d132:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d134:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d136:	f003 0303 	and.w	r3, r3, #3
   1d13a:	4303      	orrs	r3, r0
   1d13c:	602b      	str	r3, [r5, #0]
}
   1d13e:	e7eb      	b.n	1d118 <queue_insert+0xa2>

0001d140 <z_queue_node_peek>:
{
   1d140:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   1d142:	4604      	mov	r4, r0
   1d144:	b130      	cbz	r0, 1d154 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d146:	6802      	ldr	r2, [r0, #0]
   1d148:	0793      	lsls	r3, r2, #30
   1d14a:	d003      	beq.n	1d154 <z_queue_node_peek+0x14>
		ret = anode->data;
   1d14c:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   1d14e:	b109      	cbz	r1, 1d154 <z_queue_node_peek+0x14>
			k_free(anode);
   1d150:	f000 fbee 	bl	1d930 <k_free>
}
   1d154:	4620      	mov	r0, r4
   1d156:	bd10      	pop	{r4, pc}

0001d158 <z_impl_k_queue_init>:
	list->head = NULL;
   1d158:	2300      	movs	r3, #0
	list->tail = NULL;
   1d15a:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dlist_init(&w->waitq);
   1d15e:	f100 0308 	add.w	r3, r0, #8
   1d162:	e9c0 3302 	strd	r3, r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   1d166:	f100 0310 	add.w	r3, r0, #16
   1d16a:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
   1d16e:	4770      	bx	lr

0001d170 <k_queue_append>:
	(void)queue_insert(queue, NULL, data, false, true);
   1d170:	2301      	movs	r3, #1
{
   1d172:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
   1d174:	9300      	str	r3, [sp, #0]
   1d176:	2300      	movs	r3, #0
{
   1d178:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   1d17a:	4619      	mov	r1, r3
   1d17c:	f7ff ff7b 	bl	1d076 <queue_insert>
}
   1d180:	b003      	add	sp, #12
   1d182:	f85d fb04 	ldr.w	pc, [sp], #4

0001d186 <k_queue_prepend>:
	(void)queue_insert(queue, NULL, data, false, false);
   1d186:	2300      	movs	r3, #0
{
   1d188:	b507      	push	{r0, r1, r2, lr}
   1d18a:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, false);
   1d18c:	9300      	str	r3, [sp, #0]
   1d18e:	4619      	mov	r1, r3
   1d190:	f7ff ff71 	bl	1d076 <queue_insert>
}
   1d194:	b003      	add	sp, #12
   1d196:	f85d fb04 	ldr.w	pc, [sp], #4

0001d19a <k_queue_append_list>:
{
   1d19a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1d19e:	4605      	mov	r5, r0
   1d1a0:	4616      	mov	r6, r2
	CHECKIF(head == NULL || tail == NULL) {
   1d1a2:	460c      	mov	r4, r1
   1d1a4:	b391      	cbz	r1, 1d20c <k_queue_append_list+0x72>
   1d1a6:	b38a      	cbz	r2, 1d20c <k_queue_append_list+0x72>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1d1a8:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
   1d1ac:	f04f 0320 	mov.w	r3, #32
   1d1b0:	f3ef 8811 	mrs	r8, BASEPRI
   1d1b4:	f383 8811 	msr	BASEPRI, r3
   1d1b8:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
   1d1bc:	4638      	mov	r0, r7
   1d1be:	f000 f8ee 	bl	1d39e <z_unpend_first_thread>
   1d1c2:	f04f 0900 	mov.w	r9, #0
	while ((head != NULL) && (thread != NULL)) {
   1d1c6:	b920      	cbnz	r0, 1d1d2 <k_queue_append_list+0x38>
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   1d1c8:	686b      	ldr	r3, [r5, #4]
   1d1ca:	b9cb      	cbnz	r3, 1d200 <k_queue_append_list+0x66>
	list->head = node;
   1d1cc:	602c      	str	r4, [r5, #0]
	list->tail = node;
   1d1ce:	606e      	str	r6, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   1d1d0:	e00a      	b.n	1d1e8 <k_queue_append_list+0x4e>
	thread->base.swap_data = data;
   1d1d2:	6144      	str	r4, [r0, #20]
   1d1d4:	f8c0 9080 	str.w	r9, [r0, #128]	; 0x80
	z_ready_thread(thread);
   1d1d8:	f000 f886 	bl	1d2e8 <z_ready_thread>
		head = *(void **)head;
   1d1dc:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
   1d1de:	4638      	mov	r0, r7
   1d1e0:	f000 f8dd 	bl	1d39e <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
   1d1e4:	2c00      	cmp	r4, #0
   1d1e6:	d1ee      	bne.n	1d1c6 <k_queue_append_list+0x2c>
	z_handle_obj_poll_events(&queue->poll_events, state);
   1d1e8:	2104      	movs	r1, #4
   1d1ea:	f105 0010 	add.w	r0, r5, #16
   1d1ee:	f000 fb73 	bl	1d8d8 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   1d1f2:	4638      	mov	r0, r7
   1d1f4:	4641      	mov	r1, r8
   1d1f6:	f7f3 fa71 	bl	106dc <z_reschedule>
	return 0;
   1d1fa:	2000      	movs	r0, #0
}
   1d1fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d200:	6819      	ldr	r1, [r3, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d202:	f001 0103 	and.w	r1, r1, #3
   1d206:	430c      	orrs	r4, r1
   1d208:	601c      	str	r4, [r3, #0]
}
   1d20a:	e7e0      	b.n	1d1ce <k_queue_append_list+0x34>
		return -EINVAL;
   1d20c:	f06f 0015 	mvn.w	r0, #21
   1d210:	e7f4      	b.n	1d1fc <k_queue_append_list+0x62>

0001d212 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   1d212:	f990 000e 	ldrsb.w	r0, [r0, #14]
   1d216:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   1d21a:	4298      	cmp	r0, r3
   1d21c:	bfac      	ite	ge
   1d21e:	2000      	movge	r0, #0
   1d220:	2001      	movlt	r0, #1
   1d222:	4770      	bx	lr

0001d224 <z_find_first_thread_to_unpend>:
{
   1d224:	b510      	push	{r4, lr}
   1d226:	f04f 0320 	mov.w	r3, #32
   1d22a:	f3ef 8411 	mrs	r4, BASEPRI
   1d22e:	f383 8811 	msr	BASEPRI, r3
   1d232:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   1d236:	f000 f84d 	bl	1d2d4 <z_priq_dumb_best>
	__asm__ volatile(
   1d23a:	f384 8811 	msr	BASEPRI, r4
   1d23e:	f3bf 8f6f 	isb	sy
}
   1d242:	bd10      	pop	{r4, pc}

0001d244 <z_unpend_thread_no_timeout>:
{
   1d244:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d246:	f04f 0320 	mov.w	r3, #32
   1d24a:	f3ef 8411 	mrs	r4, BASEPRI
   1d24e:	f383 8811 	msr	BASEPRI, r3
   1d252:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   1d256:	f000 f81b 	bl	1d290 <unpend_thread_no_timeout>
	__asm__ volatile(
   1d25a:	f384 8811 	msr	BASEPRI, r4
   1d25e:	f3bf 8f6f 	isb	sy
}
   1d262:	bd10      	pop	{r4, pc}

0001d264 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1d264:	4603      	mov	r3, r0
   1d266:	b920      	cbnz	r0, 1d272 <z_reschedule_irqlock+0xe>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1d268:	f3ef 8205 	mrs	r2, IPSR
   1d26c:	b90a      	cbnz	r2, 1d272 <z_reschedule_irqlock+0xe>
   1d26e:	f7e5 ba79 	b.w	2764 <arch_swap>
   1d272:	f383 8811 	msr	BASEPRI, r3
   1d276:	f3bf 8f6f 	isb	sy
}
   1d27a:	4770      	bx	lr

0001d27c <z_reschedule_unlocked>:
	__asm__ volatile(
   1d27c:	f04f 0320 	mov.w	r3, #32
   1d280:	f3ef 8011 	mrs	r0, BASEPRI
   1d284:	f383 8811 	msr	BASEPRI, r3
   1d288:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   1d28c:	f7ff bfea 	b.w	1d264 <z_reschedule_irqlock>

0001d290 <unpend_thread_no_timeout>:
{
   1d290:	4601      	mov	r1, r0
   1d292:	b508      	push	{r3, lr}
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1d294:	6880      	ldr	r0, [r0, #8]
   1d296:	f7f3 fa47 	bl	10728 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1d29a:	7b4b      	ldrb	r3, [r1, #13]
   1d29c:	f023 0302 	bic.w	r3, r3, #2
   1d2a0:	734b      	strb	r3, [r1, #13]
	thread->base.pended_on = NULL;
   1d2a2:	2300      	movs	r3, #0
   1d2a4:	608b      	str	r3, [r1, #8]
}
   1d2a6:	bd08      	pop	{r3, pc}

0001d2a8 <z_unpend_thread>:
{
   1d2a8:	b538      	push	{r3, r4, r5, lr}
   1d2aa:	4604      	mov	r4, r0
   1d2ac:	f04f 0320 	mov.w	r3, #32
   1d2b0:	f3ef 8511 	mrs	r5, BASEPRI
   1d2b4:	f383 8811 	msr	BASEPRI, r3
   1d2b8:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   1d2bc:	f7ff ffe8 	bl	1d290 <unpend_thread_no_timeout>
	__asm__ volatile(
   1d2c0:	f385 8811 	msr	BASEPRI, r5
   1d2c4:	f3bf 8f6f 	isb	sy
	return z_abort_timeout(&thread->base.timeout);
   1d2c8:	f104 0018 	add.w	r0, r4, #24
}
   1d2cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1d2d0:	f000 b925 	b.w	1d51e <z_abort_timeout>

0001d2d4 <z_priq_dumb_best>:
{
   1d2d4:	4603      	mov	r3, r0
	return list->head == list;
   1d2d6:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1d2d8:	4283      	cmp	r3, r0
   1d2da:	d003      	beq.n	1d2e4 <z_priq_dumb_best+0x10>
	if (n != NULL) {
   1d2dc:	2800      	cmp	r0, #0
   1d2de:	bf38      	it	cc
   1d2e0:	2000      	movcc	r0, #0
   1d2e2:	4770      	bx	lr
	struct k_thread *thread = NULL;
   1d2e4:	2000      	movs	r0, #0
}
   1d2e6:	4770      	bx	lr

0001d2e8 <z_ready_thread>:
{
   1d2e8:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d2ea:	f04f 0320 	mov.w	r3, #32
   1d2ee:	f3ef 8411 	mrs	r4, BASEPRI
   1d2f2:	f383 8811 	msr	BASEPRI, r3
   1d2f6:	f3bf 8f6f 	isb	sy
		ready_thread(thread);
   1d2fa:	f7f3 fa6f 	bl	107dc <ready_thread>
	__asm__ volatile(
   1d2fe:	f384 8811 	msr	BASEPRI, r4
   1d302:	f3bf 8f6f 	isb	sy
}
   1d306:	bd10      	pop	{r4, pc}

0001d308 <z_thread_timeout>:
{
   1d308:	b570      	push	{r4, r5, r6, lr}
   1d30a:	4604      	mov	r4, r0
	__asm__ volatile(
   1d30c:	f04f 0320 	mov.w	r3, #32
   1d310:	f3ef 8611 	mrs	r6, BASEPRI
   1d314:	f383 8811 	msr	BASEPRI, r3
   1d318:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
   1d31c:	f850 3c10 	ldr.w	r3, [r0, #-16]
		struct k_thread *thread = CONTAINER_OF(timeout,
   1d320:	f1a0 0518 	sub.w	r5, r0, #24
		if (thread->base.pended_on != NULL) {
   1d324:	b113      	cbz	r3, 1d32c <z_thread_timeout+0x24>
			unpend_thread_no_timeout(thread);
   1d326:	4628      	mov	r0, r5
   1d328:	f7ff ffb2 	bl	1d290 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   1d32c:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
		ready_thread(thread);
   1d330:	4628      	mov	r0, r5
   1d332:	f023 0314 	bic.w	r3, r3, #20
   1d336:	f804 3c0b 	strb.w	r3, [r4, #-11]
   1d33a:	f7f3 fa4f 	bl	107dc <ready_thread>
	__asm__ volatile(
   1d33e:	f386 8811 	msr	BASEPRI, r6
   1d342:	f3bf 8f6f 	isb	sy
}
   1d346:	bd70      	pop	{r4, r5, r6, pc}

0001d348 <add_to_waitq_locked>:
{
   1d348:	b538      	push	{r3, r4, r5, lr}
   1d34a:	4604      	mov	r4, r0
   1d34c:	460d      	mov	r5, r1
	unready_thread(thread);
   1d34e:	f7f3 fbcd 	bl	10aec <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   1d352:	7b63      	ldrb	r3, [r4, #13]
   1d354:	f043 0302 	orr.w	r3, r3, #2
   1d358:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   1d35a:	b1c5      	cbz	r5, 1d38e <add_to_waitq_locked+0x46>
	return list->head == list;
   1d35c:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   1d35e:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1d360:	429d      	cmp	r5, r3
   1d362:	bf08      	it	eq
   1d364:	2300      	moveq	r3, #0
   1d366:	2b00      	cmp	r3, #0
   1d368:	bf38      	it	cc
   1d36a:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1d36c:	b183      	cbz	r3, 1d390 <add_to_waitq_locked+0x48>
	if (thread_1->base.prio < thread_2->base.prio) {
   1d36e:	f994 100e 	ldrsb.w	r1, [r4, #14]
   1d372:	f993 200e 	ldrsb.w	r2, [r3, #14]
   1d376:	4291      	cmp	r1, r2
   1d378:	db04      	blt.n	1d384 <add_to_waitq_locked+0x3c>
	return (node == list->tail) ? NULL : node->next;
   1d37a:	686a      	ldr	r2, [r5, #4]
   1d37c:	429a      	cmp	r2, r3
   1d37e:	d007      	beq.n	1d390 <add_to_waitq_locked+0x48>
   1d380:	681b      	ldr	r3, [r3, #0]
   1d382:	e7f3      	b.n	1d36c <add_to_waitq_locked+0x24>
	node->prev = successor->prev;
   1d384:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1d386:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   1d38a:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   1d38c:	605c      	str	r4, [r3, #4]
}
   1d38e:	bd38      	pop	{r3, r4, r5, pc}
	node->prev = list->tail;
   1d390:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   1d392:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   1d394:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   1d396:	686b      	ldr	r3, [r5, #4]
   1d398:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1d39a:	606c      	str	r4, [r5, #4]
   1d39c:	e7f7      	b.n	1d38e <add_to_waitq_locked+0x46>

0001d39e <z_unpend_first_thread>:
{
   1d39e:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   1d3a0:	f04f 0320 	mov.w	r3, #32
   1d3a4:	f3ef 8211 	mrs	r2, BASEPRI
   1d3a8:	f383 8811 	msr	BASEPRI, r3
   1d3ac:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   1d3b0:	f7ff ff90 	bl	1d2d4 <z_priq_dumb_best>
   1d3b4:	4604      	mov	r4, r0
	__asm__ volatile(
   1d3b6:	f382 8811 	msr	BASEPRI, r2
   1d3ba:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   1d3be:	b188      	cbz	r0, 1d3e4 <z_unpend_first_thread+0x46>
	__asm__ volatile(
   1d3c0:	f04f 0320 	mov.w	r3, #32
   1d3c4:	f3ef 8511 	mrs	r5, BASEPRI
   1d3c8:	f383 8811 	msr	BASEPRI, r3
   1d3cc:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   1d3d0:	f7ff ff5e 	bl	1d290 <unpend_thread_no_timeout>
	__asm__ volatile(
   1d3d4:	f385 8811 	msr	BASEPRI, r5
   1d3d8:	f3bf 8f6f 	isb	sy
   1d3dc:	f104 0018 	add.w	r0, r4, #24
   1d3e0:	f000 f89d 	bl	1d51e <z_abort_timeout>
}
   1d3e4:	4620      	mov	r0, r4
   1d3e6:	bd38      	pop	{r3, r4, r5, pc}

0001d3e8 <z_unpend_all>:
{
   1d3e8:	b538      	push	{r3, r4, r5, lr}
   1d3ea:	4605      	mov	r5, r0
	int need_sched = 0;
   1d3ec:	2000      	movs	r0, #0
	return list->head == list;
   1d3ee:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1d3f0:	42a5      	cmp	r5, r4
   1d3f2:	d000      	beq.n	1d3f6 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   1d3f4:	b904      	cbnz	r4, 1d3f8 <z_unpend_all+0x10>
}
   1d3f6:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   1d3f8:	4620      	mov	r0, r4
   1d3fa:	f7ff ff55 	bl	1d2a8 <z_unpend_thread>
		z_ready_thread(thread);
   1d3fe:	4620      	mov	r0, r4
   1d400:	f7ff ff72 	bl	1d2e8 <z_ready_thread>
		need_sched = 1;
   1d404:	2001      	movs	r0, #1
   1d406:	e7f2      	b.n	1d3ee <z_unpend_all+0x6>

0001d408 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   1d408:	b15a      	cbz	r2, 1d422 <z_impl_k_sem_init+0x1a>
   1d40a:	428a      	cmp	r2, r1
   1d40c:	d309      	bcc.n	1d422 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   1d40e:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   1d412:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   1d416:	e9c0 0000 	strd	r0, r0, [r0]
   1d41a:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   1d41e:	2000      	movs	r0, #0
   1d420:	4770      	bx	lr
		return -EINVAL;
   1d422:	f06f 0015 	mvn.w	r0, #21
}
   1d426:	4770      	bx	lr

0001d428 <k_is_in_isr>:
   1d428:	f3ef 8005 	mrs	r0, IPSR
}
   1d42c:	3800      	subs	r0, #0
   1d42e:	bf18      	it	ne
   1d430:	2001      	movne	r0, #1
   1d432:	4770      	bx	lr

0001d434 <z_impl_k_busy_wait>:
	if (usec_to_wait == 0) {
   1d434:	b108      	cbz	r0, 1d43a <z_impl_k_busy_wait+0x6>
	arch_busy_wait(usec_to_wait);
   1d436:	f7e4 ba2f 	b.w	1898 <arch_busy_wait>
}
   1d43a:	4770      	bx	lr

0001d43c <z_impl_k_thread_name_set>:
}
   1d43c:	f06f 0057 	mvn.w	r0, #87	; 0x57
   1d440:	4770      	bx	lr

0001d442 <k_work_submit_to_queue>:
{
   1d442:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1d444:	f101 0308 	add.w	r3, r1, #8
   1d448:	e8d3 2fef 	ldaex	r2, [r3]
   1d44c:	f042 0c01 	orr.w	ip, r2, #1
   1d450:	e8c3 cfee 	stlex	lr, ip, [r3]
   1d454:	f1be 0f00 	cmp.w	lr, #0
   1d458:	d1f6      	bne.n	1d448 <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   1d45a:	07d3      	lsls	r3, r2, #31
   1d45c:	d403      	bmi.n	1d466 <k_work_submit_to_queue+0x24>
}
   1d45e:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   1d462:	f7ff be85 	b.w	1d170 <k_queue_append>
}
   1d466:	f85d fb04 	ldr.w	pc, [sp], #4

0001d46a <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   1d46a:	f1a0 0110 	sub.w	r1, r0, #16
   1d46e:	6980      	ldr	r0, [r0, #24]
   1d470:	f7ff bfe7 	b.w	1d442 <k_work_submit_to_queue>

0001d474 <work_cancel>:
{
   1d474:	b570      	push	{r4, r5, r6, lr}
   1d476:	4604      	mov	r4, r0
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   1d478:	f100 0508 	add.w	r5, r0, #8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1d47c:	e8d5 3faf 	lda	r3, [r5]
	if (k_work_pending(&work->work)) {
   1d480:	07db      	lsls	r3, r3, #31
   1d482:	d52f      	bpl.n	1d4e4 <work_cancel+0x70>
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   1d484:	2100      	movs	r1, #0
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   1d486:	6a82      	ldr	r2, [r0, #40]	; 0x28
   1d488:	6813      	ldr	r3, [r2, #0]
   1d48a:	b913      	cbnz	r3, 1d492 <work_cancel+0x1e>
			return -EINVAL;
   1d48c:	f06f 0015 	mvn.w	r0, #21
}
   1d490:	bd70      	pop	{r4, r5, r6, pc}
   1d492:	429c      	cmp	r4, r3
   1d494:	d121      	bne.n	1d4da <work_cancel+0x66>
Z_GENLIST_REMOVE(sflist, sfnode)
   1d496:	6823      	ldr	r3, [r4, #0]
   1d498:	6856      	ldr	r6, [r2, #4]
   1d49a:	f023 0003 	bic.w	r0, r3, #3
   1d49e:	b991      	cbnz	r1, 1d4c6 <work_cancel+0x52>
   1d4a0:	42b4      	cmp	r4, r6
	list->head = node;
   1d4a2:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   1d4a4:	d100      	bne.n	1d4a8 <work_cancel+0x34>
	list->tail = node;
   1d4a6:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d4a8:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d4aa:	f003 0303 	and.w	r3, r3, #3
   1d4ae:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   1d4b0:	2000      	movs	r0, #0
   1d4b2:	62a0      	str	r0, [r4, #40]	; 0x28
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1d4b4:	e8d5 3fef 	ldaex	r3, [r5]
   1d4b8:	f023 0301 	bic.w	r3, r3, #1
   1d4bc:	e8c5 3fe2 	stlex	r2, r3, [r5]
   1d4c0:	2a00      	cmp	r2, #0
   1d4c2:	d0e5      	beq.n	1d490 <work_cancel+0x1c>
   1d4c4:	e7f6      	b.n	1d4b4 <work_cancel+0x40>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d4c6:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   1d4c8:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d4ca:	f003 0303 	and.w	r3, r3, #3
   1d4ce:	ea43 0300 	orr.w	r3, r3, r0
   1d4d2:	600b      	str	r3, [r1, #0]
	list->tail = node;
   1d4d4:	bf08      	it	eq
   1d4d6:	6051      	streq	r1, [r2, #4]
}
   1d4d8:	e7e6      	b.n	1d4a8 <work_cancel+0x34>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1d4da:	6818      	ldr	r0, [r3, #0]
   1d4dc:	4619      	mov	r1, r3
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   1d4de:	f020 0303 	bic.w	r3, r0, #3
   1d4e2:	e7d2      	b.n	1d48a <work_cancel+0x16>
		int err = z_abort_timeout(&work->timeout);
   1d4e4:	3010      	adds	r0, #16
   1d4e6:	f000 f81a 	bl	1d51e <z_abort_timeout>
		if (err) {
   1d4ea:	2800      	cmp	r0, #0
   1d4ec:	d0e0      	beq.n	1d4b0 <work_cancel+0x3c>
			return -EALREADY;
   1d4ee:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1d4f2:	e7cd      	b.n	1d490 <work_cancel+0x1c>

0001d4f4 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
   1d4f4:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d4f6:	f04f 0220 	mov.w	r2, #32
   1d4fa:	f3ef 8411 	mrs	r4, BASEPRI
   1d4fe:	f382 8811 	msr	BASEPRI, r2
   1d502:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = -EINVAL;

	if (work->work_q != NULL) {
   1d506:	6a83      	ldr	r3, [r0, #40]	; 0x28
   1d508:	b133      	cbz	r3, 1d518 <k_delayed_work_cancel+0x24>
		ret = work_cancel(work);
   1d50a:	f7ff ffb3 	bl	1d474 <work_cancel>
	__asm__ volatile(
   1d50e:	f384 8811 	msr	BASEPRI, r4
   1d512:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&lock, key);
	return ret;
}
   1d516:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   1d518:	f06f 0015 	mvn.w	r0, #21
   1d51c:	e7f7      	b.n	1d50e <k_delayed_work_cancel+0x1a>

0001d51e <z_abort_timeout>:
{
   1d51e:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d520:	f04f 0220 	mov.w	r2, #32
   1d524:	f3ef 8411 	mrs	r4, BASEPRI
   1d528:	f382 8811 	msr	BASEPRI, r2
   1d52c:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   1d530:	6803      	ldr	r3, [r0, #0]
   1d532:	b13b      	cbz	r3, 1d544 <z_abort_timeout+0x26>
			remove_timeout(to);
   1d534:	f7f3 fdfa 	bl	1112c <remove_timeout>
			ret = 0;
   1d538:	2000      	movs	r0, #0
	__asm__ volatile(
   1d53a:	f384 8811 	msr	BASEPRI, r4
   1d53e:	f3bf 8f6f 	isb	sy
}
   1d542:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   1d544:	f06f 0015 	mvn.w	r0, #21
   1d548:	e7f7      	b.n	1d53a <z_abort_timeout+0x1c>

0001d54a <z_get_next_timeout_expiry>:
{
   1d54a:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d54c:	f04f 0320 	mov.w	r3, #32
   1d550:	f3ef 8411 	mrs	r4, BASEPRI
   1d554:	f383 8811 	msr	BASEPRI, r3
   1d558:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   1d55c:	f7f3 fe00 	bl	11160 <next_timeout>
	__asm__ volatile(
   1d560:	f384 8811 	msr	BASEPRI, r4
   1d564:	f3bf 8f6f 	isb	sy
}
   1d568:	bd10      	pop	{r4, pc}

0001d56a <z_set_timeout_expiry>:
{
   1d56a:	b570      	push	{r4, r5, r6, lr}
   1d56c:	4604      	mov	r4, r0
   1d56e:	460d      	mov	r5, r1
	__asm__ volatile(
   1d570:	f04f 0320 	mov.w	r3, #32
   1d574:	f3ef 8611 	mrs	r6, BASEPRI
   1d578:	f383 8811 	msr	BASEPRI, r3
   1d57c:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   1d580:	f7f3 fdee 	bl	11160 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   1d584:	2801      	cmp	r0, #1
   1d586:	dd05      	ble.n	1d594 <z_set_timeout_expiry+0x2a>
   1d588:	42a0      	cmp	r0, r4
   1d58a:	dd03      	ble.n	1d594 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, is_idle);
   1d58c:	4629      	mov	r1, r5
   1d58e:	4620      	mov	r0, r4
   1d590:	f7e4 fdb0 	bl	20f4 <z_clock_set_timeout>
	__asm__ volatile(
   1d594:	f386 8811 	msr	BASEPRI, r6
   1d598:	f3bf 8f6f 	isb	sy
}
   1d59c:	bd70      	pop	{r4, r5, r6, pc}

0001d59e <z_tick_get_32>:

uint32_t z_tick_get_32(void)
{
   1d59e:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)z_tick_get();
   1d5a0:	f7f3 ff02 	bl	113a8 <z_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   1d5a4:	bd08      	pop	{r3, pc}

0001d5a6 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
   1d5a6:	f7f3 beff 	b.w	113a8 <z_tick_get>

0001d5aa <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t z_timeout_end_calc(k_timeout_t timeout)
{
   1d5aa:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1d5ac:	1c4b      	adds	r3, r1, #1
   1d5ae:	bf08      	it	eq
   1d5b0:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
   1d5b4:	4604      	mov	r4, r0
   1d5b6:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1d5b8:	d013      	beq.n	1d5e2 <z_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1d5ba:	ea54 0105 	orrs.w	r1, r4, r5
   1d5be:	d103      	bne.n	1d5c8 <z_timeout_end_calc+0x1e>

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
		return Z_TICK_ABS(dt);
	}
	return z_tick_get() + MAX(1, dt);
}
   1d5c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return z_tick_get();
   1d5c4:	f7f3 bef0 	b.w	113a8 <z_tick_get>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   1d5c8:	f06f 0101 	mvn.w	r1, #1
   1d5cc:	1a0a      	subs	r2, r1, r0
   1d5ce:	f04f 31ff 	mov.w	r1, #4294967295
   1d5d2:	eb61 0305 	sbc.w	r3, r1, r5
   1d5d6:	2a00      	cmp	r2, #0
   1d5d8:	f173 0100 	sbcs.w	r1, r3, #0
   1d5dc:	db02      	blt.n	1d5e4 <z_timeout_end_calc+0x3a>
		return Z_TICK_ABS(dt);
   1d5de:	4610      	mov	r0, r2
   1d5e0:	4619      	mov	r1, r3
}
   1d5e2:	bd38      	pop	{r3, r4, r5, pc}
	return z_tick_get() + MAX(1, dt);
   1d5e4:	f7f3 fee0 	bl	113a8 <z_tick_get>
   1d5e8:	2c01      	cmp	r4, #1
   1d5ea:	f175 0300 	sbcs.w	r3, r5, #0
   1d5ee:	bfbc      	itt	lt
   1d5f0:	2401      	movlt	r4, #1
   1d5f2:	2500      	movlt	r5, #0
   1d5f4:	1820      	adds	r0, r4, r0
   1d5f6:	eb45 0101 	adc.w	r1, r5, r1
   1d5fa:	e7f2      	b.n	1d5e2 <z_timeout_end_calc+0x38>

0001d5fc <k_timer_init>:
	timer->status = 0U;
   1d5fc:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   1d5fe:	e9c0 1208 	strd	r1, r2, [r0, #32]
   1d602:	f100 0218 	add.w	r2, r0, #24
   1d606:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
   1d60a:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   1d60e:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
   1d610:	6343      	str	r3, [r0, #52]	; 0x34
}
   1d612:	4770      	bx	lr

0001d614 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   1d614:	b510      	push	{r4, lr}
   1d616:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   1d618:	f7ff ff81 	bl	1d51e <z_abort_timeout>

	if (inactive) {
   1d61c:	b9d8      	cbnz	r0, 1d656 <z_impl_k_timer_stop+0x42>
		return;
	}

	if (timer->stop_fn != NULL) {
   1d61e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1d620:	b10b      	cbz	r3, 1d626 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   1d622:	4620      	mov	r0, r4
   1d624:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   1d626:	f104 0018 	add.w	r0, r4, #24
   1d62a:	2100      	movs	r1, #0
   1d62c:	f7ff fdfa 	bl	1d224 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   1d630:	4604      	mov	r4, r0
   1d632:	b180      	cbz	r0, 1d656 <z_impl_k_timer_stop+0x42>
		z_unpend_thread_no_timeout(thread);
   1d634:	f7ff fe06 	bl	1d244 <z_unpend_thread_no_timeout>
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
   1d638:	4620      	mov	r0, r4
   1d63a:	f7ff fe55 	bl	1d2e8 <z_ready_thread>
	__asm__ volatile(
   1d63e:	f04f 0320 	mov.w	r3, #32
   1d642:	f3ef 8011 	mrs	r0, BASEPRI
   1d646:	f383 8811 	msr	BASEPRI, r3
   1d64a:	f3bf 8f6f 	isb	sy
		z_reschedule_unlocked();
	}
}
   1d64e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   1d652:	f7ff be07 	b.w	1d264 <z_reschedule_irqlock>
   1d656:	bd10      	pop	{r4, pc}

0001d658 <clear_event_registrations>:
	while (num_events--) {
   1d658:	2314      	movs	r3, #20
{
   1d65a:	b530      	push	{r4, r5, lr}
	event->poller = NULL;
   1d65c:	2400      	movs	r4, #0
   1d65e:	fb03 0101 	mla	r1, r3, r1, r0
	while (num_events--) {
   1d662:	4281      	cmp	r1, r0
   1d664:	d100      	bne.n	1d668 <clear_event_registrations+0x10>
}
   1d666:	bd30      	pop	{r4, r5, pc}
	switch (event->type) {
   1d668:	f811 3c07 	ldrb.w	r3, [r1, #-7]
	event->poller = NULL;
   1d66c:	f841 4c0c 	str.w	r4, [r1, #-12]
	switch (event->type) {
   1d670:	f003 030f 	and.w	r3, r3, #15
   1d674:	2b02      	cmp	r3, #2
   1d676:	d80a      	bhi.n	1d68e <clear_event_registrations+0x36>
   1d678:	b15b      	cbz	r3, 1d692 <clear_event_registrations+0x3a>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   1d67a:	f851 3c14 	ldr.w	r3, [r1, #-20]
   1d67e:	b143      	cbz	r3, 1d692 <clear_event_registrations+0x3a>
	node->prev->next = node->next;
   1d680:	f851 5c10 	ldr.w	r5, [r1, #-16]
   1d684:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
   1d686:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   1d688:	e941 4405 	strd	r4, r4, [r1, #-20]
}
   1d68c:	e001      	b.n	1d692 <clear_event_registrations+0x3a>
	switch (event->type) {
   1d68e:	2b04      	cmp	r3, #4
   1d690:	d0f3      	beq.n	1d67a <clear_event_registrations+0x22>
	__asm__ volatile(
   1d692:	f382 8811 	msr	BASEPRI, r2
   1d696:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   1d69a:	f04f 0320 	mov.w	r3, #32
   1d69e:	f3ef 8211 	mrs	r2, BASEPRI
   1d6a2:	f383 8811 	msr	BASEPRI, r3
   1d6a6:	f3bf 8f6f 	isb	sy
   1d6aa:	3914      	subs	r1, #20
   1d6ac:	e7d9      	b.n	1d662 <clear_event_registrations+0xa>

0001d6ae <k_work_submit_to_queue>:
{
   1d6ae:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1d6b0:	f101 0308 	add.w	r3, r1, #8
   1d6b4:	e8d3 2fef 	ldaex	r2, [r3]
   1d6b8:	f042 0c01 	orr.w	ip, r2, #1
   1d6bc:	e8c3 cfee 	stlex	lr, ip, [r3]
   1d6c0:	f1be 0f00 	cmp.w	lr, #0
   1d6c4:	d1f6      	bne.n	1d6b4 <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   1d6c6:	07d3      	lsls	r3, r2, #31
   1d6c8:	d403      	bmi.n	1d6d2 <k_work_submit_to_queue+0x24>
}
   1d6ca:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   1d6ce:	f7ff bd4f 	b.w	1d170 <k_queue_append>
}
   1d6d2:	f85d fb04 	ldr.w	pc, [sp], #4

0001d6d6 <signal_poll_event>:
{
   1d6d6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct z_poller *poller = event->poller;
   1d6da:	6884      	ldr	r4, [r0, #8]
{
   1d6dc:	4605      	mov	r5, r0
   1d6de:	460e      	mov	r6, r1
	if (poller) {
   1d6e0:	b144      	cbz	r4, 1d6f4 <signal_poll_event+0x1e>
		if (poller->mode == MODE_POLL) {
   1d6e2:	7863      	ldrb	r3, [r4, #1]
   1d6e4:	2b01      	cmp	r3, #1
   1d6e6:	d138      	bne.n	1d75a <signal_poll_event+0x84>
	if (!z_is_thread_pending(thread)) {
   1d6e8:	f814 3c57 	ldrb.w	r3, [r4, #-87]
   1d6ec:	f013 0302 	ands.w	r3, r3, #2
   1d6f0:	d10a      	bne.n	1d708 <signal_poll_event+0x32>
		poller->is_polling = false;
   1d6f2:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
   1d6f4:	2000      	movs	r0, #0
	event->state |= state;
   1d6f6:	68eb      	ldr	r3, [r5, #12]
	event->poller = NULL;
   1d6f8:	60a8      	str	r0, [r5, #8]
	event->state |= state;
   1d6fa:	f3c3 3104 	ubfx	r1, r3, #12, #5
   1d6fe:	430e      	orrs	r6, r1
   1d700:	f366 3310 	bfi	r3, r6, #12, #5
   1d704:	60eb      	str	r3, [r5, #12]
	return retcode;
   1d706:	e00d      	b.n	1d724 <signal_poll_event+0x4e>
	if (z_is_thread_timeout_expired(thread)) {
   1d708:	f04f 31ff 	mov.w	r1, #4294967295
   1d70c:	e954 230f 	ldrd	r2, r3, [r4, #-60]	; 0x3c
   1d710:	f06f 0001 	mvn.w	r0, #1
   1d714:	428b      	cmp	r3, r1
   1d716:	bf08      	it	eq
   1d718:	4282      	cmpeq	r2, r0
   1d71a:	d105      	bne.n	1d728 <signal_poll_event+0x52>
		poller->is_polling = false;
   1d71c:	2300      	movs	r3, #0
		return -EAGAIN;
   1d71e:	f06f 000a 	mvn.w	r0, #10
		poller->is_polling = false;
   1d722:	7023      	strb	r3, [r4, #0]
}
   1d724:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   1d728:	f1a4 0864 	sub.w	r8, r4, #100	; 0x64
	z_unpend_thread(thread);
   1d72c:	4640      	mov	r0, r8
   1d72e:	f7ff fdbb 	bl	1d2a8 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   1d732:	2e08      	cmp	r6, #8
   1d734:	bf0c      	ite	eq
   1d736:	f06f 0303 	mvneq.w	r3, #3
   1d73a:	2300      	movne	r3, #0
   1d73c:	61e3      	str	r3, [r4, #28]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   1d73e:	f814 3c57 	ldrb.w	r3, [r4, #-87]
   1d742:	06db      	lsls	r3, r3, #27
   1d744:	d102      	bne.n	1d74c <signal_poll_event+0x76>
	if (!z_is_thread_ready(thread)) {
   1d746:	f854 7c4c 	ldr.w	r7, [r4, #-76]
   1d74a:	b10f      	cbz	r7, 1d750 <signal_poll_event+0x7a>
		poller->is_polling = false;
   1d74c:	2300      	movs	r3, #0
   1d74e:	e7d0      	b.n	1d6f2 <signal_poll_event+0x1c>
	z_ready_thread(thread);
   1d750:	4640      	mov	r0, r8
   1d752:	f7ff fdc9 	bl	1d2e8 <z_ready_thread>
		poller->is_polling = false;
   1d756:	7027      	strb	r7, [r4, #0]
		if (retcode < 0) {
   1d758:	e7cc      	b.n	1d6f4 <signal_poll_event+0x1e>
		} else if (poller->mode == MODE_TRIGGERED) {
   1d75a:	2b02      	cmp	r3, #2
   1d75c:	d1f6      	bne.n	1d74c <signal_poll_event+0x76>
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
   1d75e:	7823      	ldrb	r3, [r4, #0]
   1d760:	2b00      	cmp	r3, #0
   1d762:	d0c7      	beq.n	1d6f4 <signal_poll_event+0x1e>
   1d764:	f854 7c04 	ldr.w	r7, [r4, #-4]
   1d768:	2f00      	cmp	r7, #0
   1d76a:	d0f4      	beq.n	1d756 <signal_poll_event+0x80>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
		twork->poll_result = 0;
   1d76c:	f04f 0800 	mov.w	r8, #0
		z_abort_timeout(&twork->timeout);
   1d770:	f1a4 0910 	sub.w	r9, r4, #16
   1d774:	f104 0010 	add.w	r0, r4, #16
   1d778:	f7ff fed1 	bl	1d51e <z_abort_timeout>
		k_work_submit_to_queue(work_q, &twork->work);
   1d77c:	4649      	mov	r1, r9
   1d77e:	4638      	mov	r0, r7
		twork->poll_result = 0;
   1d780:	f8c4 8028 	str.w	r8, [r4, #40]	; 0x28
		k_work_submit_to_queue(work_q, &twork->work);
   1d784:	f7ff ff93 	bl	1d6ae <k_work_submit_to_queue>
		poller->is_polling = false;
   1d788:	f884 8000 	strb.w	r8, [r4]
		if (retcode < 0) {
   1d78c:	e7b2      	b.n	1d6f4 <signal_poll_event+0x1e>

0001d78e <add_event>:
{
   1d78e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d790:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   1d792:	e9d0 2300 	ldrd	r2, r3, [r0]
   1d796:	4290      	cmp	r0, r2
   1d798:	4604      	mov	r4, r0
   1d79a:	460d      	mov	r5, r1
   1d79c:	d106      	bne.n	1d7ac <add_event+0x1e>
	node->prev = list->tail;
   1d79e:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   1d7a0:	602c      	str	r4, [r5, #0]
	node->prev = list->tail;
   1d7a2:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   1d7a4:	6863      	ldr	r3, [r4, #4]
   1d7a6:	601d      	str	r5, [r3, #0]
	list->tail = node;
   1d7a8:	6065      	str	r5, [r4, #4]
}
   1d7aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   1d7ac:	2b00      	cmp	r3, #0
   1d7ae:	d0f6      	beq.n	1d79e <add_event+0x10>
	    z_is_t1_higher_prio_than_t2(poller_thread(pending->poller),
   1d7b0:	6898      	ldr	r0, [r3, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   1d7b2:	b100      	cbz	r0, 1d7b6 <add_event+0x28>
   1d7b4:	3864      	subs	r0, #100	; 0x64
   1d7b6:	b107      	cbz	r7, 1d7ba <add_event+0x2c>
   1d7b8:	3f64      	subs	r7, #100	; 0x64
	    z_is_t1_higher_prio_than_t2(poller_thread(pending->poller),
   1d7ba:	4639      	mov	r1, r7
   1d7bc:	f7ff fd29 	bl	1d212 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   1d7c0:	2800      	cmp	r0, #0
   1d7c2:	d1ec      	bne.n	1d79e <add_event+0x10>
	return list->head == list;
   1d7c4:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1d7c6:	42b4      	cmp	r4, r6
   1d7c8:	d0e9      	beq.n	1d79e <add_event+0x10>
   1d7ca:	2e00      	cmp	r6, #0
   1d7cc:	bf38      	it	cc
   1d7ce:	2600      	movcc	r6, #0
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   1d7d0:	2e00      	cmp	r6, #0
   1d7d2:	d0e4      	beq.n	1d79e <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller_thread(poller),
   1d7d4:	68b1      	ldr	r1, [r6, #8]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   1d7d6:	b101      	cbz	r1, 1d7da <add_event+0x4c>
   1d7d8:	3964      	subs	r1, #100	; 0x64
		if (z_is_t1_higher_prio_than_t2(poller_thread(poller),
   1d7da:	4638      	mov	r0, r7
   1d7dc:	f7ff fd19 	bl	1d212 <z_is_t1_higher_prio_than_t2>
   1d7e0:	b128      	cbz	r0, 1d7ee <add_event+0x60>
	node->prev = successor->prev;
   1d7e2:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   1d7e4:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   1d7e8:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   1d7ea:	6075      	str	r5, [r6, #4]
			return;
   1d7ec:	e7dd      	b.n	1d7aa <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   1d7ee:	6863      	ldr	r3, [r4, #4]
   1d7f0:	42b3      	cmp	r3, r6
   1d7f2:	d0d4      	beq.n	1d79e <add_event+0x10>
   1d7f4:	6836      	ldr	r6, [r6, #0]
   1d7f6:	e7eb      	b.n	1d7d0 <add_event+0x42>

0001d7f8 <register_events>:
{
   1d7f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   1d7fc:	f04f 0a00 	mov.w	sl, #0
{
   1d800:	460e      	mov	r6, r1
   1d802:	4614      	mov	r4, r2
   1d804:	461f      	mov	r7, r3
   1d806:	4683      	mov	fp, r0
	int events_registered = 0;
   1d808:	4655      	mov	r5, sl
	event->poller = NULL;
   1d80a:	46d0      	mov	r8, sl
	for (int ii = 0; ii < num_events; ii++) {
   1d80c:	45b2      	cmp	sl, r6
   1d80e:	db02      	blt.n	1d816 <register_events+0x1e>
}
   1d810:	4628      	mov	r0, r5
   1d812:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d816:	f04f 0320 	mov.w	r3, #32
   1d81a:	f3ef 8911 	mrs	r9, BASEPRI
   1d81e:	f383 8811 	msr	BASEPRI, r3
   1d822:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   1d826:	f89b 200d 	ldrb.w	r2, [fp, #13]
   1d82a:	f002 020f 	and.w	r2, r2, #15
   1d82e:	2a02      	cmp	r2, #2
   1d830:	d006      	beq.n	1d840 <register_events+0x48>
   1d832:	2a04      	cmp	r2, #4
   1d834:	d008      	beq.n	1d848 <register_events+0x50>
   1d836:	2a01      	cmp	r2, #1
   1d838:	d120      	bne.n	1d87c <register_events+0x84>
		if (event->signal->signaled != 0U) {
   1d83a:	f8db 3010 	ldr.w	r3, [fp, #16]
   1d83e:	e001      	b.n	1d844 <register_events+0x4c>
		if (k_sem_count_get(event->sem) > 0U) {
   1d840:	f8db 3010 	ldr.w	r3, [fp, #16]
		if (event->signal->signaled != 0U) {
   1d844:	689b      	ldr	r3, [r3, #8]
   1d846:	e002      	b.n	1d84e <register_events+0x56>
		if (!k_queue_is_empty(event->queue)) {
   1d848:	f8db 3010 	ldr.w	r3, [fp, #16]
   1d84c:	681b      	ldr	r3, [r3, #0]
		if (event->signal->signaled != 0U) {
   1d84e:	b1ab      	cbz	r3, 1d87c <register_events+0x84>
	event->state |= state;
   1d850:	f8db 300c 	ldr.w	r3, [fp, #12]
	event->poller = NULL;
   1d854:	f8cb 8008 	str.w	r8, [fp, #8]
	event->state |= state;
   1d858:	f3c3 3104 	ubfx	r1, r3, #12, #5
   1d85c:	430a      	orrs	r2, r1
   1d85e:	f362 3310 	bfi	r3, r2, #12, #5
   1d862:	f8cb 300c 	str.w	r3, [fp, #12]
			poller->is_polling = false;
   1d866:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
   1d86a:	f389 8811 	msr	BASEPRI, r9
   1d86e:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   1d872:	f10a 0a01 	add.w	sl, sl, #1
   1d876:	f10b 0b14 	add.w	fp, fp, #20
   1d87a:	e7c7      	b.n	1d80c <register_events+0x14>
		} else if (!just_check && poller->is_polling) {
   1d87c:	2f00      	cmp	r7, #0
   1d87e:	d1f4      	bne.n	1d86a <register_events+0x72>
   1d880:	7823      	ldrb	r3, [r4, #0]
   1d882:	2b00      	cmp	r3, #0
   1d884:	d0f1      	beq.n	1d86a <register_events+0x72>
	switch (event->type) {
   1d886:	f89b 300d 	ldrb.w	r3, [fp, #13]
   1d88a:	f003 030f 	and.w	r3, r3, #15
   1d88e:	2b02      	cmp	r3, #2
   1d890:	d008      	beq.n	1d8a4 <register_events+0xac>
   1d892:	2b04      	cmp	r3, #4
   1d894:	d006      	beq.n	1d8a4 <register_events+0xac>
   1d896:	2b01      	cmp	r3, #1
   1d898:	d10b      	bne.n	1d8b2 <register_events+0xba>
		add_event(&event->signal->poll_events, event, poller);
   1d89a:	4622      	mov	r2, r4
   1d89c:	4659      	mov	r1, fp
   1d89e:	f8db 0010 	ldr.w	r0, [fp, #16]
   1d8a2:	e004      	b.n	1d8ae <register_events+0xb6>
		add_event(&event->queue->poll_events, event, poller);
   1d8a4:	4622      	mov	r2, r4
   1d8a6:	4659      	mov	r1, fp
   1d8a8:	f8db 0010 	ldr.w	r0, [fp, #16]
   1d8ac:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
   1d8ae:	f7ff ff6e 	bl	1d78e <add_event>
	event->poller = poller;
   1d8b2:	f8cb 4008 	str.w	r4, [fp, #8]
			events_registered += 1;
   1d8b6:	3501      	adds	r5, #1
   1d8b8:	e7d7      	b.n	1d86a <register_events+0x72>

0001d8ba <k_poll_event_init>:
{
   1d8ba:	b510      	push	{r4, lr}
	event->poller = NULL;
   1d8bc:	2400      	movs	r4, #0
	event->type = type;
   1d8be:	0452      	lsls	r2, r2, #17
   1d8c0:	0209      	lsls	r1, r1, #8
   1d8c2:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
   1d8c6:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
   1d8ca:	430a      	orrs	r2, r1
   1d8cc:	7b01      	ldrb	r1, [r0, #12]
	event->poller = NULL;
   1d8ce:	6084      	str	r4, [r0, #8]
	event->type = type;
   1d8d0:	430a      	orrs	r2, r1
	event->obj = obj;
   1d8d2:	e9c0 2303 	strd	r2, r3, [r0, #12]
}
   1d8d6:	bd10      	pop	{r4, pc}

0001d8d8 <z_handle_obj_poll_events>:
{
   1d8d8:	4603      	mov	r3, r0
	return list->head == list;
   1d8da:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   1d8dc:	4283      	cmp	r3, r0
   1d8de:	d008      	beq.n	1d8f2 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   1d8e0:	e9d0 3200 	ldrd	r3, r2, [r0]
   1d8e4:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1d8e6:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1d8e8:	2300      	movs	r3, #0
	node->prev = NULL;
   1d8ea:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
   1d8ee:	f7ff bef2 	b.w	1d6d6 <signal_poll_event>
}
   1d8f2:	4770      	bx	lr

0001d8f4 <z_heap_aligned_alloc>:
	size_t excess = MAX(sizeof(struct k_heap *), align);
   1d8f4:	2904      	cmp	r1, #4
{
   1d8f6:	e92d 4373 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, lr}
	size_t excess = MAX(sizeof(struct k_heap *), align);
   1d8fa:	460d      	mov	r5, r1
   1d8fc:	bf38      	it	cc
   1d8fe:	2504      	movcc	r5, #4
	return c < a;
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	size_t c = a + b;
   1d900:	18aa      	adds	r2, r5, r2
{
   1d902:	4606      	mov	r6, r0
   1d904:	d209      	bcs.n	1d91a <z_heap_aligned_alloc+0x26>
	mem = k_heap_aligned_alloc(heap, align, size, K_NO_WAIT);
   1d906:	f04f 0800 	mov.w	r8, #0
   1d90a:	f04f 0900 	mov.w	r9, #0
   1d90e:	e9cd 8900 	strd	r8, r9, [sp]
   1d912:	f7ff fb2a 	bl	1cf6a <k_heap_aligned_alloc>
	if (mem == NULL) {
   1d916:	4604      	mov	r4, r0
   1d918:	b918      	cbnz	r0, 1d922 <z_heap_aligned_alloc+0x2e>
		return NULL;
   1d91a:	2000      	movs	r0, #0
}
   1d91c:	b002      	add	sp, #8
   1d91e:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
__ssp_bos_icheck3(memset, void *, int)
   1d922:	462a      	mov	r2, r5
   1d924:	21ff      	movs	r1, #255	; 0xff
   1d926:	f000 f829 	bl	1d97c <memset>
	*heap_ref = heap;
   1d92a:	6026      	str	r6, [r4, #0]
	return mem + excess;
   1d92c:	1960      	adds	r0, r4, r5
   1d92e:	e7f5      	b.n	1d91c <z_heap_aligned_alloc+0x28>

0001d930 <k_free>:
	if (ptr != NULL) {
   1d930:	b138      	cbz	r0, 1d942 <k_free+0x12>
		for (heap_ref = &((struct k_heap **)ptr)[-1];
   1d932:	1f03      	subs	r3, r0, #4
   1d934:	4619      	mov	r1, r3
			*heap_ref == (struct k_heap *)-1; --heap_ref) {
   1d936:	f853 0904 	ldr.w	r0, [r3], #-4
		for (heap_ref = &((struct k_heap **)ptr)[-1];
   1d93a:	1c42      	adds	r2, r0, #1
   1d93c:	d0fa      	beq.n	1d934 <k_free+0x4>
		k_heap_free(*heap_ref, ptr);
   1d93e:	f7ff bb5b 	b.w	1cff8 <k_heap_free>
}
   1d942:	4770      	bx	lr

0001d944 <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
   1d944:	4770      	bx	lr

0001d946 <memcmp>:
   1d946:	b530      	push	{r4, r5, lr}
   1d948:	3901      	subs	r1, #1
   1d94a:	2400      	movs	r4, #0
   1d94c:	42a2      	cmp	r2, r4
   1d94e:	d101      	bne.n	1d954 <memcmp+0xe>
   1d950:	2000      	movs	r0, #0
   1d952:	e005      	b.n	1d960 <memcmp+0x1a>
   1d954:	5d03      	ldrb	r3, [r0, r4]
   1d956:	3401      	adds	r4, #1
   1d958:	5d0d      	ldrb	r5, [r1, r4]
   1d95a:	42ab      	cmp	r3, r5
   1d95c:	d0f6      	beq.n	1d94c <memcmp+0x6>
   1d95e:	1b58      	subs	r0, r3, r5
   1d960:	bd30      	pop	{r4, r5, pc}

0001d962 <memcpy>:
   1d962:	440a      	add	r2, r1
   1d964:	1e43      	subs	r3, r0, #1
   1d966:	4291      	cmp	r1, r2
   1d968:	d100      	bne.n	1d96c <memcpy+0xa>
   1d96a:	4770      	bx	lr
   1d96c:	b510      	push	{r4, lr}
   1d96e:	f811 4b01 	ldrb.w	r4, [r1], #1
   1d972:	4291      	cmp	r1, r2
   1d974:	f803 4f01 	strb.w	r4, [r3, #1]!
   1d978:	d1f9      	bne.n	1d96e <memcpy+0xc>
   1d97a:	bd10      	pop	{r4, pc}

0001d97c <memset>:
   1d97c:	4402      	add	r2, r0
   1d97e:	4603      	mov	r3, r0
   1d980:	4293      	cmp	r3, r2
   1d982:	d100      	bne.n	1d986 <memset+0xa>
   1d984:	4770      	bx	lr
   1d986:	f803 1b01 	strb.w	r1, [r3], #1
   1d98a:	e7f9      	b.n	1d980 <memset+0x4>

0001d98c <strcpy>:
   1d98c:	4603      	mov	r3, r0
   1d98e:	f811 2b01 	ldrb.w	r2, [r1], #1
   1d992:	f803 2b01 	strb.w	r2, [r3], #1
   1d996:	2a00      	cmp	r2, #0
   1d998:	d1f9      	bne.n	1d98e <strcpy+0x2>
   1d99a:	4770      	bx	lr

0001d99c <strncmp>:
   1d99c:	b510      	push	{r4, lr}
   1d99e:	b16a      	cbz	r2, 1d9bc <strncmp+0x20>
   1d9a0:	3901      	subs	r1, #1
   1d9a2:	1884      	adds	r4, r0, r2
   1d9a4:	f810 3b01 	ldrb.w	r3, [r0], #1
   1d9a8:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   1d9ac:	4293      	cmp	r3, r2
   1d9ae:	d103      	bne.n	1d9b8 <strncmp+0x1c>
   1d9b0:	42a0      	cmp	r0, r4
   1d9b2:	d001      	beq.n	1d9b8 <strncmp+0x1c>
   1d9b4:	2b00      	cmp	r3, #0
   1d9b6:	d1f5      	bne.n	1d9a4 <strncmp+0x8>
   1d9b8:	1a98      	subs	r0, r3, r2
   1d9ba:	bd10      	pop	{r4, pc}
   1d9bc:	4610      	mov	r0, r2
   1d9be:	e7fc      	b.n	1d9ba <strncmp+0x1e>

0001d9c0 <strncpy>:
   1d9c0:	3901      	subs	r1, #1
   1d9c2:	4603      	mov	r3, r0
   1d9c4:	b510      	push	{r4, lr}
   1d9c6:	b132      	cbz	r2, 1d9d6 <strncpy+0x16>
   1d9c8:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   1d9cc:	3a01      	subs	r2, #1
   1d9ce:	f803 4b01 	strb.w	r4, [r3], #1
   1d9d2:	2c00      	cmp	r4, #0
   1d9d4:	d1f7      	bne.n	1d9c6 <strncpy+0x6>
   1d9d6:	441a      	add	r2, r3
   1d9d8:	2100      	movs	r1, #0
   1d9da:	4293      	cmp	r3, r2
   1d9dc:	d100      	bne.n	1d9e0 <strncpy+0x20>
   1d9de:	bd10      	pop	{r4, pc}
   1d9e0:	f803 1b01 	strb.w	r1, [r3], #1
   1d9e4:	e7f9      	b.n	1d9da <strncpy+0x1a>

0001d9e6 <strnlen>:
   1d9e6:	4602      	mov	r2, r0
   1d9e8:	4401      	add	r1, r0
   1d9ea:	b510      	push	{r4, lr}
   1d9ec:	428a      	cmp	r2, r1
   1d9ee:	4613      	mov	r3, r2
   1d9f0:	d101      	bne.n	1d9f6 <strnlen+0x10>
   1d9f2:	1a18      	subs	r0, r3, r0
   1d9f4:	bd10      	pop	{r4, pc}
   1d9f6:	781c      	ldrb	r4, [r3, #0]
   1d9f8:	3201      	adds	r2, #1
   1d9fa:	2c00      	cmp	r4, #0
   1d9fc:	d1f6      	bne.n	1d9ec <strnlen+0x6>
   1d9fe:	e7f8      	b.n	1d9f2 <strnlen+0xc>
